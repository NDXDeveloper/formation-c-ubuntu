üîù Retour au [Sommaire](/SOMMAIRE.md)

# 15.2.3 Backtrace et Analyse de la Pile

## Introduction

Imaginez que vous √™tes perdu dans un labyrinthe complexe de couloirs (votre programme). Vous savez que vous √™tes dans une pi√®ce sp√©cifique (une fonction), mais comment √™tes-vous arriv√© l√† ? Par quel chemin ? Quelles portes avez-vous travers√©es ?

Le **backtrace** (trace arri√®re) est exactement cela : il vous montre **le chemin complet** que votre programme a emprunt√© pour arriver √† son √©tat actuel. C'est l'un des outils les plus puissants de GDB pour comprendre le **contexte d'ex√©cution**.

Dans cette section, nous allons apprendre √† :
- Comprendre ce qu'est la pile d'appels (call stack)
- Utiliser la commande `backtrace` pour voir le chemin d'ex√©cution
- Naviguer entre les diff√©rents niveaux de la pile
- Inspecter les variables √† chaque niveau

---

## 1. Comprendre la Pile d'Appels (Call Stack)

### Qu'est-ce que la Pile d'Appels ?

Quand votre programme s'ex√©cute, chaque fois qu'une fonction appelle une autre fonction, le programme doit **se souvenir** :
- D'o√π il vient (quelle ligne l'a appel√©e)
- Quelles sont les variables locales
- O√π retourner une fois la fonction termin√©e

Toutes ces informations sont stock√©es dans une structure de donn√©es appel√©e **la pile** (stack). C'est une pile au sens litt√©ral : comme une pile d'assiettes, on empile des informations au-dessus, et on d√©pile depuis le sommet.

### Analogie : Une Pile de Livres

Imaginez que vous lisez un livre :
1. Vous √™tes √† la page 50 du **livre A** (fonction `main`)
2. Le texte dit "voir le livre B, page 10"
3. Vous **mettez un marque-page** √† la page 50 du livre A
4. Vous ouvrez le **livre B** √† la page 10 (fonction `calculer`)
5. Le livre B dit "voir le livre C, page 5"
6. Vous **mettez un marque-page** √† la page 10 du livre B
7. Vous ouvrez le **livre C** √† la page 5 (fonction `multiplier`)

Votre pile de livres ressemble √† :
```
[Livre C, page 5]  ‚Üê Sommet (o√π vous √™tes maintenant)
[Livre B, page 10] ‚Üê Marque-page
[Livre A, page 50] ‚Üê Base (d'o√π vous √™tes parti)
```

Quand vous finissez le livre C, vous le **retirez de la pile** et revenez au livre B. C'est exactement comme cela que fonctionne la pile d'appels en C !

### Repr√©sentation en C

Prenons un exemple de code :

```c
#include <stdio.h>

int multiplier(int a, int b) {
    return a * b;
}

int calculer(int x) {
    int y = 10;
    int resultat = multiplier(x, y);
    return resultat;
}

int main() {
    int valeur = 5;
    int final = calculer(valeur);
    printf("R√©sultat : %d\n", final);
    return 0;
}
```

Quand le programme s'ex√©cute, la pile √©volue ainsi :

**√âtape 1** : Le programme commence dans `main()`
```
[main]
```

**√âtape 2** : `main()` appelle `calculer(5)`
```
[calculer]  ‚Üê Sommet (ex√©cution actuelle)
[main]      ‚Üê Appelant
```

**√âtape 3** : `calculer()` appelle `multiplier(5, 10)`
```
[multiplier]  ‚Üê Sommet (ex√©cution actuelle)
[calculer]    ‚Üê Appelant
[main]        ‚Üê Appelant originel
```

**√âtape 4** : `multiplier()` se termine et retourne
```
[calculer]  ‚Üê De retour ici
[main]
```

**√âtape 5** : `calculer()` se termine et retourne
```
[main]  ‚Üê De retour ici
```

### Pourquoi c'est Important ?

Quand un bug se produit (comme un segmentation fault), comprendre **comment le programme est arriv√© l√†** est crucial. Le backtrace vous montre exactement cette s√©quence d'appels.

---

## 2. La Commande `backtrace`

### Syntaxe de Base

La commande la plus simple est :

```gdb
backtrace
```

Ou son raccourci :

```gdb
bt
```

Cette commande affiche **toute la pile d'appels**, du point actuel jusqu'√† `main()`.

### Exemple Concret

Reprenons notre programme et lan√ßons-le dans GDB :

```c
#include <stdio.h>

int multiplier(int a, int b) {
    return a * b;  // Ligne 4
}

int calculer(int x) {
    int y = 10;
    int resultat = multiplier(x, y);  // Ligne 9
    return resultat;
}

int main() {
    int valeur = 5;
    int final = calculer(valeur);  // Ligne 14
    printf("R√©sultat : %d\n", final);
    return 0;
}
```

Dans GDB :

```gdb
(gdb) break multiplier
Breakpoint 1 at 0x1129: file exemple.c, line 4.

(gdb) run
Starting program: ./exemple

Breakpoint 1, multiplier (a=5, b=10) at exemple.c:4
4           return a * b;

(gdb) backtrace
#0  multiplier (a=5, b=10) at exemple.c:4
#1  0x0000555555555152 in calculer (x=5) at exemple.c:9
#2  0x000055555555516c in main () at exemple.c:14
```

### Interpr√©ter le Backtrace

Analysons cette sortie ligne par ligne :

```
#0  multiplier (a=5, b=10) at exemple.c:4
```

- **#0** : Num√©ro de frame (niveau 0 = sommet de la pile)
- **multiplier** : Nom de la fonction
- **(a=5, b=10)** : Valeurs des param√®tres
- **exemple.c:4** : Fichier et ligne

```
#1  0x0000555555555152 in calculer (x=5) at exemple.c:9
```

- **#1** : Frame 1 (appelant de multiplier)
- **calculer (x=5)** : Fonction appelante avec son param√®tre
- **exemple.c:9** : La ligne qui a appel√© `multiplier()`

```
#2  0x000055555555516c in main () at exemple.c:14
```

- **#2** : Frame 2 (base de la pile)
- **main ()** : La fonction principale
- **exemple.c:14** : La ligne qui a appel√© `calculer()`

**√Ä lire de bas en haut** : Le programme a commenc√© dans `main()` (frame #2), qui a appel√© `calculer()` (frame #1), qui a appel√© `multiplier()` (frame #0, o√π nous sommes maintenant).

### Options de Backtrace

#### Backtrace Complet (`bt full`)

Pour voir **toutes les variables locales** √† chaque niveau :

```gdb
(gdb) bt full
#0  multiplier (a=5, b=10) at exemple.c:4
        (pas de variables locales ici)
#1  0x0000555555555152 in calculer (x=5) at exemple.c:9
        y = 10
        resultat = 0
#2  0x000055555555516c in main () at exemple.c:14
        valeur = 5
        final = 0
```

Ceci est **extr√™mement utile** pour comprendre l'√©tat complet du programme √† chaque niveau.

#### Backtrace Limit√©

Pour voir seulement les N premiers niveaux :

```gdb
bt 3      # Les 3 premiers niveaux
bt -3     # Les 3 derniers niveaux
```

Utile quand la pile est tr√®s profonde (r√©cursion, frameworks complexes).

---

## 3. Naviguer dans la Pile avec `frame`

### Qu'est-ce qu'un Frame ?

Un **frame** (cadre) est un niveau de la pile d'appels. Chaque frame correspond √† un appel de fonction. Le frame actif (celui o√π GDB est arr√™t√©) est le frame #0.

### Changer de Frame

Pour **se d√©placer** dans la pile et inspecter diff√©rents niveaux, utilisez la commande `frame` :

```gdb
frame <num√©ro>
```

Ou les raccourcis :
- `up` : Monter d'un niveau (vers l'appelant)
- `down` : Descendre d'un niveau (vers l'appel√©)

### Exemple Pratique

Reprenons notre backtrace :

```gdb
(gdb) bt
#0  multiplier (a=5, b=10) at exemple.c:4
#1  0x0000555555555152 in calculer (x=5) at exemple.c:9
#2  0x000055555555516c in main () at exemple.c:14

(gdb) frame 1
#1  0x0000555555555152 in calculer (x=5) at exemple.c:9
9           int resultat = multiplier(x, y);

(gdb) print x
$1 = 5

(gdb) print y
$2 = 10
```

Nous sommes maintenant dans le **contexte de `calculer()`**. Nous pouvons voir ses variables locales (`x`, `y`) !

### Naviguer avec `up` et `down`

```gdb
(gdb) bt
#0  multiplier (a=5, b=10) at exemple.c:4
#1  calculer (x=5) at exemple.c:9
#2  main () at exemple.c:14

(gdb) up
#1  calculer (x=5) at exemple.c:9
9           int resultat = multiplier(x, y);

(gdb) up
#2  main () at exemple.c:14
14          int final = calculer(valeur);

(gdb) down
#1  calculer (x=5) at exemple.c:9

(gdb) down
#0  multiplier (a=5, b=10) at exemple.c:4
```

C'est comme **remonter et descendre** l'historique des appels de fonctions.

### Voir le Frame Actuel

Pour savoir o√π vous √™tes :

```gdb
frame
# Ou
info frame
```

Ceci affiche des informations d√©taill√©es sur le frame actuel :

```gdb
(gdb) info frame
Stack level 0, frame at 0x7fffffffddc0:
 rip = 0x555555555129 in multiplier (exemple.c:4); saved rip = 0x555555555152
 called by frame at 0x7fffffffddf0
 source language c.
 Arglist at 0x7fffffffddb0, args: a=5, b=10
 Locals at 0x7fffffffddb0, Previous frame's sp is 0x7fffffffddc0
```

---

## 4. Inspecter les Variables dans Diff√©rents Frames

### Pourquoi C'est Important ?

Souvent, un bug dans une fonction est caus√© par des **mauvaises valeurs** pass√©es par la fonction appelante. Le backtrace vous permet de **remonter la cha√Æne** pour trouver o√π les valeurs sont devenues incorrectes.

### Exemple : D√©bogage de Valeurs Incorrectes

Imaginons ce programme avec un bug subtil :

```c
#include <stdio.h>

int diviser(int a, int b) {
    return a / b;  // Bug si b == 0
}

int calculer_moyenne(int somme, int nombre) {
    return diviser(somme, nombre);
}

int main() {
    int total = 100;
    int count = 0;  // Bug : devrait √™tre > 0
    int moyenne = calculer_moyenne(total, count);
    printf("Moyenne : %d\n", moyenne);
    return 0;
}
```

Quand nous ex√©cutons ce programme, il crash avec une erreur de division par z√©ro (sur certains syst√®mes) ou donne un r√©sultat bizarre.

Dans GDB :

```gdb
(gdb) run
Program received signal SIGFPE, Arithmetic exception.
0x0000555555555129 in diviser (a=100, b=0) at bug.c:4
4           return a / b;

(gdb) bt
#0  0x0000555555555129 in diviser (a=100, b=0) at bug.c:4
#1  0x0000555555555145 in calculer_moyenne (somme=100, nombre=0) at bug.c:8
#2  0x000055555555516a in main () at bug.c:14
```

Le backtrace montre clairement :
- **Frame #0** : Nous sommes dans `diviser()` avec `b=0` (cause imm√©diate)
- **Frame #1** : `calculer_moyenne()` a pass√© `nombre=0` √† `diviser()`
- **Frame #2** : `main()` a pass√© `count=0` √† `calculer_moyenne()`

Remontons la cha√Æne :

```gdb
(gdb) frame 2
#2  0x000055555555516a in main () at bug.c:14
14          int moyenne = calculer_moyenne(total, count);

(gdb) print count
$1 = 0

(gdb) print total
$2 = 100
```

**Aha !** Le bug est dans `main()` : `count` est initialis√© √† 0 au lieu d'une valeur positive. Sans le backtrace, on aurait peut-√™tre pens√© que le bug √©tait dans `diviser()`, alors qu'en r√©alit√©, c'est l'appelant qui passe une mauvaise valeur.

### Inspecter les Param√®tres de Fonction

Vous pouvez voir les param√®tres √† n'importe quel niveau :

```gdb
(gdb) bt
#0  fonction_c (x=10) at test.c:10
#1  fonction_b (y=20) at test.c:6
#2  fonction_a (z=30) at test.c:2

(gdb) frame 2
(gdb) print z
$1 = 30

(gdb) frame 1
(gdb) print y
$2 = 20

(gdb) frame 0
(gdb) print x
$3 = 10
```

### Commande `info args` et `info locals`

Raccourcis pratiques pour voir rapidement les informations d'un frame :

```gdb
# Voir tous les arguments de la fonction actuelle
info args

# Voir toutes les variables locales
info locals

# Voir tout (arguments + locales)
info args
info locals
```

Exemple :

```gdb
(gdb) frame 1
#1  calculer (x=5) at exemple.c:9

(gdb) info args
x = 5

(gdb) info locals
y = 10
resultat = 0
```

---

## 5. Backtrace dans les Situations R√©elles

### Cas 1 : Segmentation Fault

Les segfaults sont l'utilisation la plus courante du backtrace :

```c
#include <stdio.h>
#include <string.h>

void traiter_chaine(char *str) {
    strcat(str, " - Trait√©");  // Bug si str est NULL
}

void initialiser(char *data) {
    traiter_chaine(data);
}

int main() {
    char *texte = NULL;  // Bug : pointeur non initialis√©
    initialiser(texte);
    return 0;
}
```

Dans GDB :

```gdb
(gdb) run
Program received signal SIGSEGV, Segmentation fault.
0x00007ffff7e8b5b7 in strcat () from /lib/x86_64-linux-gnu/libc.so.6

(gdb) bt
#0  0x00007ffff7e8b5b7 in strcat () from /lib/x86_64-linux-gnu/libc.so.6
#1  0x0000555555555149 in traiter_chaine (str=0x0) at segfault.c:5
#2  0x0000555555555162 in initialiser (data=0x0) at segfault.c:9
#3  0x0000555555555177 in main () at segfault.c:14
```

Le backtrace nous dit :
- Le crash s'est produit dans `strcat()` (biblioth√®que standard)
- `traiter_chaine()` a appel√© `strcat()` avec `str=0x0` (NULL)
- `initialiser()` a pass√© `data=0x0` √† `traiter_chaine()`
- `main()` a pass√© `texte=NULL` √† `initialiser()`

**La vraie source du bug** : `main()` initialise `texte` √† NULL !

### Cas 2 : R√©cursion Infinie

La r√©cursion infinie remplit la pile jusqu'√† la d√©border (stack overflow) :

```c
#include <stdio.h>

int factorielle(int n) {
    // Bug : pas de condition d'arr√™t pour n < 0
    if (n == 0) return 1;
    return n * factorielle(n - 1);
}

int main() {
    int resultat = factorielle(-5);  // R√©cursion infinie !
    printf("R√©sultat : %d\n", resultat);
    return 0;
}
```

Dans GDB :

```gdb
(gdb) run
Program received signal SIGSEGV, Segmentation fault.
0x0000555555555129 in factorielle (n=-262885) at recursion.c:5

(gdb) bt
#0  0x0000555555555129 in factorielle (n=-262885) at recursion.c:5
#1  0x000055555555514c in factorielle (n=-262884) at recursion.c:6
#2  0x000055555555514c in factorielle (n=-262883) at recursion.c:6
#3  0x000055555555514c in factorielle (n=-262882) at recursion.c:6
... (des milliers de lignes) ...
#8185  0x000055555555514c in factorielle (n=-5) at recursion.c:6
#8186  0x0000555555555167 in main () at recursion.c:10
```

Le backtrace montre des **milliers d'appels** √† `factorielle()` avec des valeurs n√©gatives de plus en plus grandes en valeur absolue. C'est la signature d'une r√©cursion infinie !

Utilisez `bt 20` pour voir les premiers niveaux seulement :

```gdb
(gdb) bt 20
```

Ou `bt -10` pour voir les derniers (proches de `main()`) :

```gdb
(gdb) bt -10
#8177  factorielle (n=-5)
#8178  factorielle (n=-6)
#8179  factorielle (n=-7)
#8180  factorielle (n=-8)
#8181  factorielle (n=-9)
#8182  factorielle (n=-10)
#8183  factorielle (n=-5)
#8184  factorielle (n=-5)
#8185  factorielle (n=-5)
#8186  main () at recursion.c:10
```

### Cas 3 : Programmes Multi-thread√©s

Dans un programme avec plusieurs threads, chaque thread a sa **propre pile**. GDB peut montrer le backtrace de chaque thread :

```gdb
# Voir tous les threads
info threads

# Changer de thread
thread 2

# Voir le backtrace du thread actuel
bt

# Voir le backtrace de tous les threads
thread apply all bt
```

Exemple de sortie :

```gdb
(gdb) thread apply all bt

Thread 3 (Thread 0x7ffff6fff700 (LWP 12345)):
#0  pthread_cond_wait () from /lib/x86_64-linux-gnu/libpthread.so.0
#1  0x0000555555555234 in worker_thread (arg=0x0) at threads.c:15

Thread 2 (Thread 0x7ffff77ff700 (LWP 12344)):
#0  __GI___libc_read () from /lib/x86_64-linux-gnu/libc.so.6
#1  0x0000555555555198 in lire_fichier () at threads.c:25

Thread 1 (Thread 0x7ffff7fe0740 (LWP 12343)):
#0  0x0000555555555167 in main () at threads.c:40
```

---

## 6. Techniques Avanc√©es de Backtrace

### Backtrace apr√®s un Crash (Core Dump)

Si votre programme a crash√© et g√©n√©r√© un **core dump**, vous pouvez charger ce fichier dans GDB pour voir le backtrace du crash :

```bash
# Activer les core dumps (si d√©sactiv√©s)
ulimit -c unlimited

# Lancer le programme (qui crash)
./programme
Segmentation fault (core dumped)

# Charger le core dump dans GDB
gdb ./programme core
```

Dans GDB :

```gdb
(gdb) bt
#0  0x00007ffff7e8b5b7 in strcat ()
#1  0x0000555555555149 in traiter_chaine (str=0x0)
#2  0x0000555555555162 in initialiser (data=0x0)
#3  0x0000555555555177 in main ()
```

C'est comme faire une **autopsie** du crash. Vous pouvez analyser ce qui s'est pass√© **apr√®s coup**, sans avoir √† relancer le programme.

### Frame avec Adresse M√©moire

Si vous connaissez l'adresse d'un frame, vous pouvez y acc√©der directement :

```gdb
frame 0x7fffffffddc0
```

Ceci est rarement utilis√© en d√©bogage normal, mais peut √™tre utile pour du reverse engineering ou du d√©bogage kernel.

### Comprendre les Adresses dans le Backtrace

Chaque ligne du backtrace contient une adresse hexad√©cimale :

```
#1  0x0000555555555152 in calculer (x=5) at exemple.c:9
    ^^^^^^^^^^^^^^^^^^
    Adresse de retour
```

Cette adresse est **l'endroit o√π le programme retournera** quand la fonction se termine. C'est l'instruction **juste apr√®s** l'appel de fonction.

Pour les d√©butants, ces adresses ne sont pas tr√®s utiles. Mais si vous n'avez **pas de symboles de d√©bogage** (compil√© sans `-g`), vous verrez seulement ces adresses :

```gdb
(gdb) bt
#0  0x0000555555555129 in ?? ()
#1  0x0000555555555152 in ?? ()
#2  0x000055555555516c in ?? ()
```

Les `??` signifient que GDB ne peut pas r√©soudre les noms de fonctions. **Solution** : Recompilez avec `-g`.

---

## 7. Commandes Utiles Compl√©mentaires

### `where` : Alias de `backtrace`

```gdb
where
```

C'est exactement la m√™me chose que `bt`. Utilisez celui que vous pr√©f√©rez.

### `select-frame` : Changer de Frame sans Affichage

```gdb
select-frame 2
```

Comme `frame 2`, mais ne r√©affiche pas le code source. Utile dans les scripts GDB.

### `info stack` : Informations sur la Pile

```gdb
info stack
```

Similaire √† `bt`, mais peut donner des informations suppl√©mentaires selon la configuration.

---

## 8. Strat√©gies de D√©bogage avec Backtrace

### Strat√©gie 1 : "Bottom-Up" (De bas en haut)

Quand vous avez un crash :
1. Regardez o√π le crash s'est produit (frame #0)
2. V√©rifiez les valeurs des variables locales
3. Montez d'un niveau (`up`) pour voir qui a appel√© cette fonction
4. V√©rifiez les param√®tres pass√©s
5. Continuez √† monter jusqu'√† trouver la **source** du probl√®me

```gdb
(gdb) bt
(gdb) frame 0       # Le crash
(gdb) print var
(gdb) up            # Qui a appel√© ?
(gdb) info args     # Quels param√®tres ?
(gdb) up            # Qui a appel√© l'appelant ?
```

### Strat√©gie 2 : "Top-Down" (De haut en bas)

Quand vous voulez comprendre le flux d'ex√©cution :
1. Commencez par `main()` (frame le plus haut)
2. Descendez niveau par niveau
3. Observez comment les donn√©es sont transform√©es

```gdb
(gdb) bt
(gdb) frame 5       # main() ou d√©but
(gdb) print input
(gdb) down
(gdb) print transformed_data
(gdb) down
```

### Strat√©gie 3 : Chercher le Point de Divergence

Dans un bug o√π une valeur devient incorrecte :
1. Utilisez `bt full` pour voir toutes les variables
2. Parcourez les frames pour trouver **o√π** la valeur passe de correcte √† incorrecte
3. C'est l√† que se trouve le bug

```gdb
(gdb) bt full
# Cherchez visuellement o√π une variable a une valeur bizarre
```

### Strat√©gie 4 : Combiner avec Watchpoints

```gdb
(gdb) break fonction_suspecte
(gdb) run
(gdb) watch ma_variable
(gdb) continue
# Le watchpoint s'active
(gdb) bt
# Voyez qui a modifi√© la variable
```

---

## 9. Limitations et Pi√®ges Communs

### Limitation 1 : Optimisation du Compilateur

Avec `-O2` ou `-O3`, le compilateur peut **optimiser** des fonctions :
- **Inlining** : Les petites fonctions sont ins√©r√©es directement dans l'appelant
- **Tail call optimization** : Les appels en fin de fonction sont optimis√©s

R√©sultat : Le backtrace peut √™tre **incomplet** ou montrer des choses bizarres.

**Solution** : Pour d√©boguer, compilez avec `-O0` (pas d'optimisation) :

```bash
gcc -g -O0 -o programme programme.c
```

### Limitation 2 : Pas de Symboles de D√©bogage

Sans `-g`, vous obtenez :

```gdb
(gdb) bt
#0  0x555555555129 in ?? ()
#1  0x555555555152 in ?? ()
```

**Solution** : Recompilez avec `-g` :

```bash
gcc -g -o programme programme.c
```

### Limitation 3 : Code Assembleur ou Biblioth√®ques

Si le crash est dans une biblioth√®que sans symboles :

```gdb
#0  0x00007ffff7e8b5b7 in strcat () from /lib/x86_64-linux-gnu/libc.so.6
```

Vous ne pouvez pas voir le code source de `strcat()`, mais vous pouvez voir **qui l'a appel√©** (frame #1).

### Pi√®ge : Confusion entre Frame et Ligne

Un frame ne correspond **pas** √† une ligne de code, mais √† un **appel de fonction**. Une fonction peut avoir beaucoup de lignes, mais un seul frame.

---

## 10. Cas Pratique Complet

### Le Probl√®me

Vous avez ce programme qui crash :

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char* dupliquer_chaine(char *src) {
    char *dest = malloc(strlen(src));  // Bug : pas de +1 pour '\0'
    strcpy(dest, src);
    return dest;
}

char* formater_message(char *nom) {
    char *message = dupliquer_chaine(nom);
    strcat(message, " : Bienvenue !");  // Bug : pas assez d'espace allou√©
    return message;
}

int main() {
    char *utilisateur = "Alice";
    char *msg = formater_message(utilisateur);
    printf("%s\n", msg);
    free(msg);
    return 0;
}
```

### Session de D√©bogage

```gdb
(gdb) run
Program received signal SIGSEGV, Segmentation fault.
0x00007ffff7e8c123 in strcat () from /lib/x86_64-linux-gnu/libc.so.6

(gdb) bt
#0  0x00007ffff7e8c123 in strcat () from /lib/x86_64-linux-gnu/libc.so.6
#1  0x0000555555555198 in formater_message (nom=0x555555556004 "Alice") at bug.c:13
#2  0x00005555555551bc in main () at bug.c:18

(gdb) frame 1
#1  0x0000555555555198 in formater_message (nom=0x555555556004 "Alice") at bug.c:13
13          strcat(message, " : Bienvenue !");

(gdb) print message
$1 = 0x5555555592a0 "Alice"

(gdb) print strlen(message)
$2 = 5

(gdb) print strlen(" : Bienvenue !")
$3 = 14
```

**Analyse** :
- `message` contient "Alice" (5 caract√®res + '\0' = 6 octets)
- On essaie d'ajouter " : Bienvenue !" (14 caract√®res + '\0')
- Total n√©cessaire : 5 + 14 + 1 = 20 octets
- Espace allou√© : Seulement 5 octets (bug dans `dupliquer_chaine()`)

Remontons encore :

```gdb
(gdb) up
#2  0x00005555555551bc in main () at bug.c:18
18          char *msg = formater_message(utilisateur);

(gdb) print utilisateur
$4 = 0x555555556004 "Alice"
```

Maintenant, regardons `dupliquer_chaine()` :

```gdb
(gdb) list dupliquer_chaine
5       char* dupliquer_chaine(char *src) {
6           char *dest = malloc(strlen(src));  // Bug ici !
7           strcpy(dest, src);
8           return dest;
9       }
```

**Le bug** : `malloc(strlen(src))` devrait √™tre `malloc(strlen(src) + 1)` pour inclure le caract√®re nul de fin de cha√Æne.

Sans le backtrace, on aurait pu penser que le bug √©tait dans `strcat()`. Gr√¢ce au backtrace, nous avons **remont√© la cha√Æne causale** jusqu'√† la vraie source du probl√®me.

---

## 11. R√©sum√© des Commandes

### Commandes de Backtrace

| Commande | Action |
|----------|--------|
| `backtrace` ou `bt` | Affiche toute la pile d'appels |
| `bt full` | Affiche la pile avec toutes les variables |
| `bt 10` | Affiche les 10 premiers niveaux |
| `bt -5` | Affiche les 5 derniers niveaux |
| `where` | Alias de `backtrace` |

### Commandes de Navigation

| Commande | Action |
|----------|--------|
| `frame N` | Aller au frame num√©ro N |
| `up` | Monter d'un frame (vers l'appelant) |
| `down` | Descendre d'un frame (vers l'appel√©) |
| `info frame` | Informations d√©taill√©es sur le frame actuel |

### Commandes d'Inspection

| Commande | Action |
|----------|--------|
| `info args` | Affiche les arguments de la fonction |
| `info locals` | Affiche les variables locales |
| `print variable` | Affiche la valeur d'une variable |

### Commandes Multi-thread

| Commande | Action |
|----------|--------|
| `info threads` | Liste tous les threads |
| `thread N` | Changer de thread |
| `thread apply all bt` | Backtrace de tous les threads |

---

## 12. Conseils Pratiques

### Conseil 1 : Utilisez `bt full` en Premier

Quand vous d√©boguez un crash, commencez **toujours** par :

```gdb
bt full
```

Cela vous donne une **vue compl√®te** de l'√©tat du programme. Vous pouvez souvent trouver le bug juste en lisant cette sortie.

### Conseil 2 : Notez les Frames Int√©ressants

Si la pile est profonde, notez les num√©ros de frames qui semblent suspects :

```
Frame #0 : Le crash (dans strcat)
Frame #3 : Valeur bizarre pour le param√®tre
Frame #7 : Origine possible dans main
```

Puis explorez ces frames sp√©cifiquement.

### Conseil 3 : Combinez avec `list`

Apr√®s avoir chang√© de frame, utilisez `list` pour voir le code source :

```gdb
(gdb) frame 3
(gdb) list
```

Cela vous donne le **contexte visuel** de l'appel.

### Conseil 4 : Utilisez TUI Mode

En mode TUI, le backtrace reste visible tout en voyant le code :

```gdb
(gdb) tui enable
(gdb) layout split
(gdb) bt
```

### Conseil 5 : Sauvegardez les Backtraces

Pour les bugs complexes, sauvegardez le backtrace dans un fichier :

```gdb
(gdb) set logging file backtrace.txt
(gdb) set logging on
(gdb) bt full
(gdb) set logging off
```

---

## Conclusion

Le backtrace est l'une des fonctionnalit√©s les plus puissantes de GDB. Il vous permet de :
- **Comprendre le chemin d'ex√©cution** du programme
- **Identifier la source r√©elle** d'un bug, pas seulement le sympt√¥me
- **Remonter la cha√Æne causale** des valeurs incorrectes
- **D√©boguer des crashes** complexes dans de gros programmes

Avec la pratique, lire et interpr√©ter un backtrace devient une **seconde nature**. C'est souvent la **premi√®re chose** que vous ferez lors d'un d√©bogage : lancer le programme, attendre le crash, et taper `bt full`.

### R√©capitulatif Mental

Quand votre programme crash :
1. **`run`** ‚Üí Lancer le programme
2. **`bt full`** ‚Üí Voir le chemin complet avec toutes les variables
3. **`frame N`** ‚Üí Explorer les frames suspects
4. **`print variable`** ‚Üí Inspecter les valeurs
5. **`up/down`** ‚Üí Naviguer pour comprendre le flux

C'est votre nouveau r√©flexe de d√©bogage !

---

## Prochaines √âtapes

Maintenant que vous ma√Ætrisez le backtrace, vous √™tes pr√™t pour :
- **15.2.4 Inspection des variables** : Techniques avanc√©es pour examiner les structures complexes
- **15.3 GDB avanc√©** : Core dumps, debugging distant, reverse debugging
- **15.4 Valgrind** : D√©tection de fuites m√©moire et bugs subtils

Le backtrace, combin√© aux breakpoints et au stepping, forme le **trio fondamental** du d√©bogage en C. Ma√Ætrisez ces trois comp√©tences, et vous pourrez r√©soudre n'importe quel bug !

---

**üí° Astuce finale :** La comp√©tence la plus pr√©cieuse n'est pas de savoir utiliser `bt`, mais de savoir **interpr√©ter** ce que le backtrace vous dit. Avec l'exp√©rience, vous apprendrez √† **reconna√Ætre les patterns** (r√©cursion infinie, pointeur NULL, buffer overflow) juste en regardant la pile d'appels. C'est comme apprendre √† lire des empreintes pour un d√©tective !

‚è≠Ô∏è [Inspection des variables](/15-debogage-et-qualite/02.4-inspection-variables.md)
