ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 21.2.2 BPF Maps

## Introduction

Si les **programmes BPF** sont les acteurs qui exÃ©cutent la logique, les **BPF Maps** sont la **mÃ©moire partagÃ©e** qui leur permet de stocker, de partager et de communiquer des donnÃ©es. Sans les maps, les programmes BPF seraient aveugles et amnÃ©siques - ils ne pourraient ni se souvenir d'Ã©vÃ©nements passÃ©s, ni communiquer avec l'espace utilisateur.

Dans cette section, nous allons explorer en profondeur ce que sont les BPF Maps, comment elles fonctionnent, et comment les utiliser efficacement.

---

## ğŸ¯ Qu'est-ce qu'une BPF Map ?

### DÃ©finition Simple

Une **BPF Map** est une **structure de donnÃ©es gÃ©nÃ©rique** qui :
- Stocke des paires **clÃ©-valeur** (dans la plupart des cas)
- RÃ©side dans le **noyau Linux**
- Est accessible depuis les **programmes BPF** (dans le noyau)
- Est accessible depuis l'**espace utilisateur** (via des syscalls)
- Persiste tant qu'elle est rÃ©fÃ©rencÃ©e (survit au programme qui l'a crÃ©Ã©e)

### Analogie : Le Tableau d'Affichage

Imaginez un **tableau d'affichage** dans un bureau :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         TABLEAU D'AFFICHAGE (BPF MAP)           â”‚
â”‚                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  PID 1234 â†’ 150 appels open()           â”‚    â”‚
â”‚  â”‚  PID 5678 â†’ 42 appels open()            â”‚    â”‚
â”‚  â”‚  PID 9012 â†’ 201 appels open()           â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                 â”‚
â”‚         â–²                         â–²             â”‚
â”‚         â”‚                         â”‚             â”‚
â”‚    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”             â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚    â”‚ Programmeâ”‚             â”‚ Programme   â”‚     â”‚
â”‚    â”‚   BPF    â”‚             â”‚ Utilisateur â”‚     â”‚
â”‚    â”‚ (kernel) â”‚             â”‚ (userspace) â”‚     â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                                                 â”‚
â”‚  Les deux peuvent lire et Ã©crire !              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

- Les **programmes BPF** (dans le noyau) peuvent **lire et Ã©crire** sur le tableau
- Les **programmes utilisateur** peuvent aussi **lire et Ã©crire** sur le tableau
- Tout le monde voit les **mÃªmes donnÃ©es**
- Le tableau **persiste** mÃªme quand un programme se termine

---

## ğŸ¤” Pourquoi les BPF Maps Sont Essentielles ?

### ProblÃ¨me 1 : Communication Kernel â†” Userspace

Sans les maps, un programme BPF ne pourrait pas transmettre d'informations Ã  l'espace utilisateur :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       ESPACE UTILISATEUR                 â”‚
â”‚                                          â”‚
â”‚   "Je voudrais les statistiques          â”‚
â”‚    de mon programme BPF..."              â”‚
â”‚                                          â”‚
â”‚   âŒ Impossible sans BPF Maps            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       NOYAU LINUX                        â”‚
â”‚                                          â”‚
â”‚  Programme BPF collecte des donnÃ©es      â”‚
â”‚  mais ne peut pas les transmettre...     â”‚
â”‚                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Avec les BPF Maps** :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       ESPACE UTILISATEUR                 â”‚
â”‚                                          â”‚
â”‚   Programme lit les stats via map        â”‚
â”‚   â†“                                      â”‚
â””â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚ bpf_map_lookup_elem()
â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    â”‚
â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚  â”‚    BPF MAP         â”‚  â† Pont de comm. â”‚
â”‚  â”‚  PID â†’ Compteur    â”‚                  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”‚           â–²                              â”‚
â”‚  Programme BPF Ã©crit dans la map         â”‚
â”‚                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ProblÃ¨me 2 : MÃ©moire Persistante

Les variables locales d'un programme BPF disparaissent aprÃ¨s chaque exÃ©cution :

```c
SEC("tracepoint/syscalls/sys_enter_open")
int trace_open(void *ctx)
{
    int counter = 0;  // âŒ Cette variable est rÃ©initialisÃ©e Ã  chaque appel !
    counter++;

    // counter vaut toujours 1, jamais 2, 3, 4...
    return 0;
}
```

**Avec une BPF Map** :

```c
// Map pour stocker un compteur persistant
struct {
    __uint(type, BPF_MAP_TYPE_ARRAY);
    __uint(max_entries, 1);
    __type(key, __u32);
    __type(value, __u64);
} counter_map SEC(".maps");

SEC("tracepoint/syscalls/sys_enter_open")
int trace_open(void *ctx)
{
    __u32 key = 0;
    __u64 *counter = bpf_map_lookup_elem(&counter_map, &key);

    if (counter) {
        __sync_fetch_and_add(counter, 1);  // âœ… IncrÃ©mente le compteur persistant
    }

    return 0;
}
```

### ProblÃ¨me 3 : Partage de DonnÃ©es Entre Programmes BPF

Plusieurs programmes BPF peuvent partager la mÃªme map :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          NOYAU LINUX                         â”‚
â”‚                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                           â”‚
â”‚  â”‚Programme BPF 1â”‚ â”€â”€â”                       â”‚
â”‚  â”‚ (tracepoint)  â”‚   â”‚                       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚                       â”‚
â”‚                      â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”œâ”€â–¶â”‚   BPF MAP        â”‚ â”‚
â”‚  â”‚Programme BPF 2â”‚   â”‚  â”‚  (partagÃ©e)      â”‚ â”‚
â”‚  â”‚   (kprobe)    â”‚ â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                           â”‚
â”‚                                              â”‚
â”‚  Tous les programmes voient les mÃªmes        â”‚
â”‚  donnÃ©es et peuvent se coordonner !          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“¦ Types de BPF Maps

Il existe **plus de 30 types** de BPF Maps, chacun optimisÃ© pour un cas d'usage spÃ©cifique. Voici les plus importants :

### Vue d'Ensemble

| Type | Structure | Cas d'usage | Performance |
|------|-----------|-------------|-------------|
| **HASH** | Table de hachage | Associations clÃ©-valeur flexibles | Lookup O(1) moyen |
| **ARRAY** | Tableau indexÃ© | AccÃ¨s par index, compteurs | Lookup O(1) garanti |
| **PERCPU_HASH** | Hash par CPU | Stats par CPU, pas de locks | TrÃ¨s rapide |
| **PERCPU_ARRAY** | Array par CPU | Compteurs par CPU | TrÃ¨s rapide |
| **RINGBUF** | Ring buffer | Streaming d'Ã©vÃ©nements | Efficace |
| **PERF_EVENT_ARRAY** | Array d'Ã©vÃ©nements | Envoi d'Ã©vÃ©nements (legacy) | Efficace |
| **LRU_HASH** | Hash avec LRU | Cache auto-nettoyant | Pratique |
| **STACK / QUEUE** | Pile / File | LIFO / FIFO | SpÃ©cialisÃ© |
| **PROG_ARRAY** | Array de programmes | Tail calls | Technique |

Explorons les plus couramment utilisÃ©s en dÃ©tail.

---

## 1ï¸âƒ£ BPF_MAP_TYPE_HASH

### Description

La **Hash Map** est comme un **dictionnaire** : vous stockez des paires clÃ©-valeur oÃ¹ la clÃ© peut Ãªtre n'importe quelle structure.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      HASH MAP                      â”‚
â”‚                                    â”‚
â”‚  ClÃ© (PID) â†’ Valeur (Stats)        â”‚
â”‚                                    â”‚
â”‚  1234 â†’ {count: 10, bytes: 5000}   â”‚
â”‚  5678 â†’ {count: 5, bytes: 1200}    â”‚
â”‚  9012 â†’ {count: 20, bytes: 8500}   â”‚
â”‚  ...                               â”‚
â”‚                                    â”‚
â”‚  Max entries: configurable         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### DÃ©claration

```c
// Structure pour les valeurs
struct process_stats {
    __u64 count;
    __u64 total_bytes;
};

// DÃ©claration de la map
struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 10240);        // Maximum 10240 entrÃ©es
    __type(key, __u32);                 // ClÃ© = PID (entier 32 bits)
    __type(value, struct process_stats); // Valeur = structure stats
} process_map SEC(".maps");
```

### OpÃ©rations

```c
// 1. LOOKUP (chercher)
__u32 pid = 1234;
struct process_stats *stats = bpf_map_lookup_elem(&process_map, &pid);
if (stats) {
    // stats pointe vers les donnÃ©es dans la map
    bpf_printk("Count: %llu\n", stats->count);
}

// 2. UPDATE (crÃ©er ou mettre Ã  jour)
struct process_stats new_stats = {
    .count = 1,
    .total_bytes = 4096,
};
bpf_map_update_elem(&process_map, &pid, &new_stats, BPF_ANY);
// BPF_ANY = crÃ©er si n'existe pas, sinon mettre Ã  jour

// 3. DELETE (supprimer)
bpf_map_delete_elem(&process_map, &pid);
```

### Flags pour Update

```c
// BPF_ANY : crÃ©er si n'existe pas, sinon mettre Ã  jour
bpf_map_update_elem(&map, &key, &value, BPF_ANY);

// BPF_NOEXIST : crÃ©er uniquement si n'existe pas (Ã©choue sinon)
bpf_map_update_elem(&map, &key, &value, BPF_NOEXIST);

// BPF_EXIST : mettre Ã  jour uniquement si existe dÃ©jÃ  (Ã©choue sinon)
bpf_map_update_elem(&map, &key, &value, BPF_EXIST);
```

### Exemple Complet

```c
SEC("tracepoint/syscalls/sys_exit_read")
int trace_read(struct trace_event_raw_sys_exit *ctx)
{
    __u32 pid = bpf_get_current_pid_tgid() >> 32;
    long bytes_read = ctx->ret;

    if (bytes_read < 0)
        return 0;

    // Chercher les stats existantes
    struct process_stats *stats = bpf_map_lookup_elem(&process_map, &pid);

    if (stats) {
        // Mise Ã  jour atomique
        __sync_fetch_and_add(&stats->count, 1);
        __sync_fetch_and_add(&stats->total_bytes, bytes_read);
    } else {
        // CrÃ©er une nouvelle entrÃ©e
        struct process_stats new_stats = {
            .count = 1,
            .total_bytes = bytes_read,
        };
        bpf_map_update_elem(&process_map, &pid, &new_stats, BPF_NOEXIST);
    }

    return 0;
}
```

### Quand Utiliser

âœ… **Bon pour** :
- Associations clÃ©-valeur dynamiques (nombre de clÃ©s inconnu)
- Tracking par PID, IP, etc.
- Compteurs par entitÃ©

âŒ **Pas idÃ©al pour** :
- AccÃ¨s trÃ¨s frÃ©quents (prÃ©fÃ©rer ARRAY)
- DonnÃ©es par CPU (prÃ©fÃ©rer PERCPU_HASH)

---

## 2ï¸âƒ£ BPF_MAP_TYPE_ARRAY

### Description

L'**Array Map** est comme un **tableau classique** : accÃ¨s direct par index, trÃ¨s rapide.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      ARRAY MAP                     â”‚
â”‚                                    â”‚
â”‚  Index â†’ Valeur                    â”‚
â”‚                                    â”‚
â”‚  [0] â†’ 42                          â”‚
â”‚  [1] â†’ 100                         â”‚
â”‚  [2] â†’ 255                         â”‚
â”‚  [3] â†’ 0                           â”‚
â”‚  ...                               â”‚
â”‚                                    â”‚
â”‚  Taille fixe : dÃ©finie Ã  la        â”‚
â”‚  crÃ©ation (max_entries)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### CaractÃ©ristiques

- **Taille fixe** : DÃ©finie Ã  la crÃ©ation
- **Indices contigus** : 0, 1, 2, 3, ..., max_entries-1
- **Pas de suppression** : On ne peut pas supprimer une entrÃ©e (seulement la modifier)
- **Performance maximale** : Lookup O(1) garanti (pas de hash)

### DÃ©claration

```c
struct {
    __uint(type, BPF_MAP_TYPE_ARRAY);
    __uint(max_entries, 256);  // 256 entrÃ©es (indices 0-255)
    __type(key, __u32);        // ClÃ© = index (toujours u32)
    __type(value, __u64);      // Valeur = entier 64 bits
} array_map SEC(".maps");
```

### Exemple : Compteurs de Syscalls

```c
// Map pour compter les syscalls (index = numÃ©ro de syscall)
struct {
    __uint(type, BPF_MAP_TYPE_ARRAY);
    __uint(max_entries, 512);  // Linux a ~400 syscalls
    __type(key, __u32);
    __type(value, __u64);
} syscall_counts SEC(".maps");

SEC("tracepoint/raw_syscalls/sys_enter")
int count_syscalls(struct trace_event_raw_sys_enter *ctx)
{
    __u32 syscall_id = ctx->id;

    // Limiter Ã  512 (sÃ©curitÃ©)
    if (syscall_id >= 512)
        return 0;

    // IncrÃ©menter le compteur
    __u64 *count = bpf_map_lookup_elem(&syscall_counts, &syscall_id);
    if (count) {
        __sync_fetch_and_add(count, 1);
    }

    return 0;
}
```

### Quand Utiliser

âœ… **Bon pour** :
- Compteurs globaux (ex: par type d'Ã©vÃ©nement)
- Indices connus Ã  l'avance (ex: CPU ID, syscall number)
- Performance maximale requise
- Configuration globale

âŒ **Pas idÃ©al pour** :
- ClÃ©s arbitraires (prÃ©fÃ©rer HASH)
- Besoin de supprimer des entrÃ©es

---

## 3ï¸âƒ£ BPF_MAP_TYPE_PERCPU_HASH et PERCPU_ARRAY

### Description

Les maps **per-CPU** maintiennent une **copie des donnÃ©es par cÅ“ur CPU**. Cela Ã©vite les contentions et les locks.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            PERCPU HASH MAP                   â”‚
â”‚                                              â”‚
â”‚  CPU 0          CPU 1          CPU 2         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ PID  â”‚      â”‚ PID  â”‚      â”‚ PID  â”‚        â”‚
â”‚  â”‚ 1234 â”‚      â”‚ 5678 â”‚      â”‚ 1234 â”‚        â”‚
â”‚  â”‚ â†’ 10 â”‚      â”‚ â†’ 5  â”‚      â”‚ â†’ 20 â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚                                              â”‚
â”‚  Chaque CPU a sa propre copie !              â”‚
â”‚  Pas de contention = ultra rapide            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Avantages

- âœ… **ZÃ©ro contention** : Pas besoin de locks/atomics
- âœ… **Performance maximale** : Chaque CPU travaille indÃ©pendamment
- âœ… **IdÃ©al pour statistiques** : AgrÃ©gation en userspace

### DÃ©claration

```c
struct {
    __uint(type, BPF_MAP_TYPE_PERCPU_HASH);
    __uint(max_entries, 10240);
    __type(key, __u32);
    __type(value, __u64);
} percpu_stats SEC(".maps");
```

### Exemple : Compteur de Paquets par CPU

```c
SEC("xdp")
int count_packets(struct xdp_md *ctx)
{
    __u32 key = 0;  // Une seule clÃ©

    // Lookup sans lock - chaque CPU a sa copie !
    __u64 *count = bpf_map_lookup_elem(&percpu_stats, &key);
    if (count) {
        (*count)++;  // Pas besoin d'atomic !
    }

    return XDP_PASS;
}
```

### Lecture Depuis Userspace

En userspace, vous recevez **un tableau de valeurs** (une par CPU) :

```c
// Userspace code
__u32 key = 0;
__u64 values[nr_cpus];  // Tableau pour tous les CPUs

// RÃ©cupÃ¨re les valeurs de tous les CPUs
bpf_map_lookup_elem(map_fd, &key, values);

// AgrÃ©ger
__u64 total = 0;
for (int i = 0; i < nr_cpus; i++) {
    total += values[i];
}
printf("Total packets: %llu\n", total);
```

### Quand Utiliser

âœ… **Bon pour** :
- Compteurs haute frÃ©quence
- Statistiques de performance
- Tout ce qui nÃ©cessite des updates atomiques frÃ©quentes

âŒ **Pas idÃ©al pour** :
- Grandes structures (mÃ©moire Ã— nombre de CPUs)
- DonnÃ©es qui doivent Ãªtre cohÃ©rentes entre CPUs

---

## 4ï¸âƒ£ BPF_MAP_TYPE_RINGBUF (Ring Buffer)

### Description

Le **Ring Buffer** est une structure circulaire optimisÃ©e pour **streamer des Ã©vÃ©nements** du kernel vers l'espace utilisateur.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          RING BUFFER (circulaire)           â”‚
â”‚                                             â”‚
â”‚     â”Œâ”€â”€â†’ [Event 5] [Event 6] [Event 7]      â”‚
â”‚     â”‚                              â”‚        â”‚
â”‚     â”‚    Producer (BPF)            â”‚        â”‚
â”‚     â”‚    Ã©crit ici â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚     â”‚                                       â”‚
â”‚     â””â”€â”€ Consumer (Userspace)                â”‚
â”‚         lit ici                             â”‚
â”‚                                             â”‚
â”‚  â€¢ Efficace (zero-copy possible)            â”‚
â”‚  â€¢ Pas de perte d'Ã©vÃ©nements (backpressure) â”‚
â”‚  â€¢ Ordre prÃ©servÃ©                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### DÃ©claration

```c
struct {
    __uint(type, BPF_MAP_TYPE_RINGBUF);
    __uint(max_entries, 256 * 1024);  // 256 KB
} events SEC(".maps");
```

### Exemple : Streamer des Ã‰vÃ©nements

```c
// Structure d'Ã©vÃ©nement
struct event {
    __u32 pid;
    __u32 uid;
    char comm[16];
    char filename[256];
};

SEC("tracepoint/syscalls/sys_enter_open")
int trace_open(struct trace_event_raw_sys_enter *ctx)
{
    // RÃ©server de l'espace dans le ring buffer
    struct event *e = bpf_ringbuf_reserve(&events, sizeof(*e), 0);
    if (!e)
        return 0;  // Buffer plein

    // Remplir l'Ã©vÃ©nement
    e->pid = bpf_get_current_pid_tgid() >> 32;
    e->uid = bpf_get_current_uid_gid() & 0xFFFFFFFF;
    bpf_get_current_comm(&e->comm, sizeof(e->comm));
    bpf_probe_read_user_str(&e->filename, sizeof(e->filename),
                            (void *)ctx->args[0]);

    // Soumettre l'Ã©vÃ©nement (rend visible pour userspace)
    bpf_ringbuf_submit(e, 0);

    return 0;
}
```

### Lecture Depuis Userspace (avec libbpf)

```c
// Callback appelÃ© pour chaque Ã©vÃ©nement
static int handle_event(void *ctx, void *data, size_t data_sz)
{
    struct event *e = data;
    printf("PID %d (%s) opened %s\n", e->pid, e->comm, e->filename);
    return 0;
}

// Setup du ring buffer
struct ring_buffer *rb = ring_buffer__new(bpf_map__fd(skel->maps.events),
                                           handle_event, NULL, NULL);

// Polling (boucle infinie)
while (running) {
    ring_buffer__poll(rb, 100 /* timeout ms */);
}
```

### Avantages vs PERF_EVENT_ARRAY

| Aspect | RINGBUF | PERF_EVENT_ARRAY (legacy) |
|--------|---------|---------------------------|
| **MÃ©moire** | Globale (partagÃ©e) | Par CPU |
| **Ordre** | PrÃ©servÃ© globalement | Seulement par CPU |
| **ComplexitÃ©** | Plus simple | Plus complexe |
| **Performance** | LÃ©gÃ¨rement meilleur | TrÃ¨s bon |
| **Recommandation** | âœ… Utiliser en prioritÃ© | âš ï¸ Legacy |

### Quand Utiliser

âœ… **Bon pour** :
- Streaming d'Ã©vÃ©nements vers userspace
- Logs structurÃ©s
- Traces d'exÃ©cution
- Audit events

âŒ **Pas idÃ©al pour** :
- Statistiques simples (prÃ©fÃ©rer HASH/ARRAY)
- Communication bidirectionnelle

---

## 5ï¸âƒ£ BPF_MAP_TYPE_LRU_HASH

### Description

Comme une **HASH Map**, mais avec **Ã©viction automatique LRU** (Least Recently Used). Quand la map est pleine, l'entrÃ©e la moins rÃ©cemment utilisÃ©e est supprimÃ©e automatiquement.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         LRU HASH MAP (max 3 entrÃ©es)       â”‚
â”‚                                            â”‚
â”‚  Ã‰tat initial :                            â”‚
â”‚  [A: 10] [B: 20] [C: 30]                   â”‚
â”‚                                            â”‚
â”‚  Insertion de D (map pleine) :             â”‚
â”‚  A est le moins rÃ©cent â†’ supprimÃ©          â”‚
â”‚  [B: 20] [C: 30] [D: 40]                   â”‚
â”‚                                            â”‚
â”‚  AccÃ¨s Ã  B (devient plus rÃ©cent) :         â”‚
â”‚  [C: 30] [D: 40] [B: 20]                   â”‚
â”‚                                            â”‚
â”‚  Auto-nettoyage = pas de gestion manuelle! â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### DÃ©claration

```c
struct {
    __uint(type, BPF_MAP_TYPE_LRU_HASH);
    __uint(max_entries, 10000);
    __type(key, __u32);
    __type(value, __u64);
} lru_cache SEC(".maps");
```

### Exemple : Cache d'IP

```c
// Cache des connexions rÃ©centes
struct connection_info {
    __u64 packets;
    __u64 bytes;
    __u64 last_seen;
};

struct {
    __uint(type, BPF_MAP_TYPE_LRU_HASH);
    __uint(max_entries, 10000);  // Top 10000 connexions
    __type(key, __u32);           // IP address
    __type(value, struct connection_info);
} connection_cache SEC(".maps");

SEC("xdp")
int track_connections(struct xdp_md *ctx)
{
    // Parser l'IP source
    __u32 src_ip = parse_ip(ctx);  // Fonction helper custom

    struct connection_info *info = bpf_map_lookup_elem(&connection_cache, &src_ip);

    if (info) {
        info->packets++;
        info->bytes += (ctx->data_end - ctx->data);
        info->last_seen = bpf_ktime_get_ns();
    } else {
        struct connection_info new_info = {
            .packets = 1,
            .bytes = (ctx->data_end - ctx->data),
            .last_seen = bpf_ktime_get_ns(),
        };
        bpf_map_update_elem(&connection_cache, &src_ip, &new_info, BPF_ANY);
        // Si la map est pleine, l'IP la moins rÃ©cente est auto-supprimÃ©e !
    }

    return XDP_PASS;
}
```

### Quand Utiliser

âœ… **Bon pour** :
- Caches avec taille limitÃ©e
- Top-N tracking (ex: top 10000 IPs)
- Ã‰viter la gestion manuelle de l'Ã©viction

âŒ **Pas idÃ©al pour** :
- DonnÃ©es qui doivent toutes Ãªtre gardÃ©es
- ContrÃ´le prÃ©cis de l'Ã©viction

---

## 6ï¸âƒ£ BPF_MAP_TYPE_STACK et QUEUE

### Description

**STACK** (pile LIFO) et **QUEUE** (file FIFO) sont des structures spÃ©cialisÃ©es.

```
STACK (LIFO - Last In First Out)        QUEUE (FIFO - First In First Out)

  push(3)                                 enqueue(1)
  push(2)      â”Œâ”€â”€â”€â”                     enqueue(2)     â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
  push(1) â”€â”€â”€â–¶ â”‚ 1 â”‚ â—€â”€â”€ pop()          enqueue(3) â”€â”€â”€â–¶ â”‚ 1 â”‚ 2 â”‚ 3 â”‚
               â”œâ”€â”€â”€â”¤                                    â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”¬â”€â”˜
               â”‚ 2 â”‚                                              â”‚
               â”œâ”€â”€â”€â”¤                                         dequeue()
               â”‚ 3 â”‚                                              â–¼
               â””â”€â”€â”€â”˜                                           retourne 1
```

### DÃ©claration

```c
// Stack
struct {
    __uint(type, BPF_MAP_TYPE_STACK);
    __uint(max_entries, 100);
    __type(value, __u32);  // Pas de clÃ© !
} my_stack SEC(".maps");

// Queue
struct {
    __uint(type, BPF_MAP_TYPE_QUEUE);
    __uint(max_entries, 100);
    __type(value, __u32);
} my_queue SEC(".maps");
```

### OpÃ©rations

```c
// STACK
__u32 value = 42;
bpf_map_push_elem(&my_stack, &value, 0);  // Push

__u32 popped;
bpf_map_pop_elem(&my_stack, &popped);     // Pop

// QUEUE
bpf_map_push_elem(&my_queue, &value, 0);  // Enqueue
bpf_map_pop_elem(&my_queue, &popped);     // Dequeue
```

### Quand Utiliser

âœ… **Bon pour** :
- ImplÃ©mentation d'algorithmes spÃ©cifiques
- Task queues
- Historique limitÃ© (FIFO)

âŒ **Rarement utilisÃ©** dans la pratique (RINGBUF prÃ©fÃ©rÃ© pour le streaming)

---

## 7ï¸âƒ£ BPF_MAP_TYPE_PROG_ARRAY (Tail Calls)

### Description

La **PROG_ARRAY** stocke des **programmes BPF** et permet les **tail calls** (appeler un autre programme BPF depuis un programme BPF).

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       Programme BPF Principal          â”‚
â”‚                                        â”‚
â”‚   if (condition_A) {                   â”‚
â”‚       bpf_tail_call(ctx, &progs, 0);   â”‚
â”‚   } else if (condition_B) {            â”‚
â”‚       bpf_tail_call(ctx, &progs, 1);   â”‚
â”‚   }                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       PROG_ARRAY Map                   â”‚
â”‚                                        â”‚
â”‚   [0] â†’ Programme BPF pour cas A       â”‚
â”‚   [1] â†’ Programme BPF pour cas B       â”‚
â”‚   [2] â†’ Programme BPF pour cas C       â”‚
â”‚   ...                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### DÃ©claration

```c
struct {
    __uint(type, BPF_MAP_TYPE_PROG_ARRAY);
    __uint(max_entries, 10);  // Max 10 programmes
    __type(key, __u32);       // Index du programme
    __type(value, __u32);     // FD du programme (gÃ©rÃ© par loader)
} prog_array SEC(".maps");
```

### Exemple : Router XDP

```c
SEC("xdp")
int xdp_router(struct xdp_md *ctx)
{
    // Parser le paquet
    __u16 eth_proto = parse_eth_type(ctx);

    // Router vers le bon handler
    if (eth_proto == ETH_P_IP) {
        bpf_tail_call(ctx, &prog_array, 0);  // IPv4 handler
    } else if (eth_proto == ETH_P_IPV6) {
        bpf_tail_call(ctx, &prog_array, 1);  // IPv6 handler
    }

    // Fallback si tail call Ã©choue
    return XDP_PASS;
}

SEC("xdp")
int handle_ipv4(struct xdp_md *ctx)
{
    // Logique IPv4
    return XDP_PASS;
}

SEC("xdp")
int handle_ipv6(struct xdp_md *ctx)
{
    // Logique IPv6
    return XDP_PASS;
}
```

### Important : Tail Call ne Retourne Jamais

Un tail call **remplace** le programme courant - il ne retourne **jamais** au programme appelant :

```c
bpf_tail_call(ctx, &prog_array, 0);
// Cette ligne ne sera JAMAIS exÃ©cutÃ©e si le tail call rÃ©ussit !
bpf_printk("Ceci ne s'affichera jamais\n");
```

### Quand Utiliser

âœ… **Bon pour** :
- Contourner la limite de taille (diviser un gros programme)
- Routing logique (diffÃ©rents chemins de traitement)
- Modularisation du code

âŒ **Complexe** : Ã€ utiliser seulement si nÃ©cessaire

---

## ğŸ”„ OpÃ©rations Communes sur les Maps

### Depuis les Programmes BPF (Kernel)

```c
// 1. Lookup (chercher)
void *value = bpf_map_lookup_elem(map, &key);
if (value) {
    // Utiliser value
}

// 2. Update (crÃ©er/modifier)
bpf_map_update_elem(map, &key, &value, BPF_ANY);

// 3. Delete (supprimer)
bpf_map_delete_elem(map, &key);

// 4. Atomics (pour modifications thread-safe)
__sync_fetch_and_add(&value, 1);      // IncrÃ©menter
__sync_fetch_and_sub(&value, 1);      // DÃ©crÃ©menter
__sync_lock_test_and_set(&value, 42); // Set atomique
```

### Depuis l'Espace Utilisateur

```c
#include <bpf/bpf.h>

// 1. Obtenir le FD de la map
int map_fd = bpf_map__fd(skel->maps.my_map);

// 2. Lookup
__u32 key = 1234;
__u64 value;
int ret = bpf_map_lookup_elem(map_fd, &key, &value);
if (ret == 0) {
    printf("Value: %llu\n", value);
}

// 3. Update
value = 9999;
bpf_map_update_elem(map_fd, &key, &value, BPF_ANY);

// 4. Delete
bpf_map_delete_elem(map_fd, &key);

// 5. ItÃ©rer sur toutes les entrÃ©es
__u32 next_key, key = 0;
while (bpf_map_get_next_key(map_fd, &key, &next_key) == 0) {
    __u64 value;
    bpf_map_lookup_elem(map_fd, &next_key, &value);
    printf("Key: %u, Value: %llu\n", next_key, value);
    key = next_key;
}
```

---

## ğŸ“Š Exemple Complet : Monitoring de Latence

Voici un exemple complet combinant plusieurs types de maps :

```c
#include <linux/bpf.h>
#include <bpf/bpf_helpers.h>

// Structure pour stocker le dÃ©but d'une opÃ©ration
struct start_info {
    __u64 start_ts;  // Timestamp de dÃ©but
};

// Structure pour les statistiques de latence
struct latency_stats {
    __u64 count;
    __u64 total_ns;
    __u64 min_ns;
    __u64 max_ns;
};

// Map 1 : Stocke les timestamps de dÃ©but (HASH)
struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 10240);
    __type(key, __u32);  // PID
    __type(value, struct start_info);
} start_map SEC(".maps");

// Map 2 : Statistiques par syscall (ARRAY)
struct {
    __uint(type, BPF_MAP_TYPE_ARRAY);
    __uint(max_entries, 512);
    __type(key, __u32);  // Syscall number
    __type(value, struct latency_stats);
} stats_map SEC(".maps");

// Map 3 : Events ring buffer
struct {
    __uint(type, BPF_MAP_TYPE_RINGBUF);
    __uint(max_entries, 256 * 1024);
} events SEC(".maps");

// Structure d'Ã©vÃ©nement pour le ring buffer
struct event {
    __u32 pid;
    __u32 syscall_id;
    __u64 duration_ns;
    char comm[16];
};

// Tracepoint : EntrÃ©e dans un syscall
SEC("tracepoint/raw_syscalls/sys_enter")
int trace_enter(struct trace_event_raw_sys_enter *ctx)
{
    __u32 pid = bpf_get_current_pid_tgid() >> 32;

    // Stocker le timestamp de dÃ©but
    struct start_info info = {
        .start_ts = bpf_ktime_get_ns(),
    };
    bpf_map_update_elem(&start_map, &pid, &info, BPF_ANY);

    return 0;
}

// Tracepoint : Sortie d'un syscall
SEC("tracepoint/raw_syscalls/sys_exit")
int trace_exit(struct trace_event_raw_sys_exit *ctx)
{
    __u32 pid = bpf_get_current_pid_tgid() >> 32;
    __u32 syscall_id = ctx->id;

    // RÃ©cupÃ©rer le timestamp de dÃ©but
    struct start_info *info = bpf_map_lookup_elem(&start_map, &pid);
    if (!info)
        return 0;

    // Calculer la durÃ©e
    __u64 duration_ns = bpf_ktime_get_ns() - info->start_ts;

    // Mettre Ã  jour les statistiques
    if (syscall_id < 512) {
        struct latency_stats *stats = bpf_map_lookup_elem(&stats_map, &syscall_id);
        if (stats) {
            __sync_fetch_and_add(&stats->count, 1);
            __sync_fetch_and_add(&stats->total_ns, duration_ns);

            // Min/Max (attention : race possible, mais acceptable)
            if (duration_ns < stats->min_ns || stats->min_ns == 0)
                stats->min_ns = duration_ns;
            if (duration_ns > stats->max_ns)
                stats->max_ns = duration_ns;
        }
    }

    // Envoyer un Ã©vÃ©nement si latence > 1ms
    if (duration_ns > 1000000) {  // 1ms
        struct event *e = bpf_ringbuf_reserve(&events, sizeof(*e), 0);
        if (e) {
            e->pid = pid;
            e->syscall_id = syscall_id;
            e->duration_ns = duration_ns;
            bpf_get_current_comm(&e->comm, sizeof(e->comm));
            bpf_ringbuf_submit(e, 0);
        }
    }

    // Nettoyer
    bpf_map_delete_elem(&start_map, &pid);

    return 0;
}

char LICENSE[] SEC("license") = "GPL";
```

**Ce programme** :
1. Utilise une **HASH map** pour stocker les timestamps de dÃ©but
2. Utilise une **ARRAY map** pour les statistiques par syscall
3. Utilise un **RINGBUF** pour streamer les Ã©vÃ©nements avec haute latence
4. Combine les trois pour un monitoring complet

---

## ğŸ¯ Choix du Bon Type de Map

### Arbre de DÃ©cision

```
Avez-vous besoin de streamer des Ã©vÃ©nements ?
  â”‚
  â”œâ”€ OUI â”€â”€â–¶ BPF_MAP_TYPE_RINGBUF
  â”‚
  â””â”€ NON
      â”‚
      ClÃ©s dynamiques ou statiques ?
      â”‚
      â”œâ”€ DYNAMIQUES (ex: PID, IP)
      â”‚   â”‚
      â”‚   Besoin d'Ã©viction automatique ?
      â”‚   â”‚
      â”‚   â”œâ”€ OUI â”€â”€â–¶ BPF_MAP_TYPE_LRU_HASH
      â”‚   â”‚
      â”‚   â””â”€ NON
      â”‚       â”‚
      â”‚       Updates trÃ¨s frÃ©quents ?
      â”‚       â”‚
      â”‚       â”œâ”€ OUI â”€â”€â–¶ BPF_MAP_TYPE_PERCPU_HASH
      â”‚       â”‚
      â”‚       â””â”€ NON â”€â”€â–¶ BPF_MAP_TYPE_HASH
      â”‚
      â””â”€ STATIQUES (ex: CPU ID, syscall#)
          â”‚
          Updates trÃ¨s frÃ©quents ?
          â”‚
          â”œâ”€ OUI â”€â”€â–¶ BPF_MAP_TYPE_PERCPU_ARRAY
          â”‚
          â””â”€ NON â”€â”€â–¶ BPF_MAP_TYPE_ARRAY
```

### Tableau RÃ©capitulatif

| Cas d'usage | Type recommandÃ© |
|-------------|----------------|
| Compteur par PID | PERCPU_HASH ou HASH |
| Compteur par type d'Ã©vÃ©nement | PERCPU_ARRAY ou ARRAY |
| Top-N tracking | LRU_HASH |
| Streaming d'Ã©vÃ©nements | RINGBUF |
| Cache avec taille limitÃ©e | LRU_HASH |
| Configuration globale | ARRAY |
| Tail calls | PROG_ARRAY |

---

## âš ï¸ PiÃ¨ges Courants et Bonnes Pratiques

### 1. Toujours VÃ©rifier le Retour de Lookup

```c
// âŒ DANGEREUX
__u64 *value = bpf_map_lookup_elem(&map, &key);
*value = 42;  // CRASH si value == NULL !

// âœ… CORRECT
__u64 *value = bpf_map_lookup_elem(&map, &key);
if (value) {
    *value = 42;
}
```

### 2. Attention Ã  la Taille des Maps

```c
// âŒ Trop petit
struct {
    __uint(max_entries, 10);  // Seulement 10 PIDs ?
} process_map SEC(".maps");

// âœ… Dimensionnement appropriÃ©
struct {
    __uint(max_entries, 10240);  // ~10K processus
} process_map SEC(".maps");
```

**CoÃ»t mÃ©moire** :
- Hash : ~32 bytes + sizeof(key) + sizeof(value) par entrÃ©e
- Array : sizeof(value) Ã— max_entries
- PerCPU : (coÃ»t) Ã— nombre de CPUs

### 3. Utiliser des Atomics pour les Updates

```c
// âŒ Race condition possible
__u64 *count = bpf_map_lookup_elem(&map, &key);
if (count) {
    *count = *count + 1;  // Non atomique !
}

// âœ… Atomique
__u64 *count = bpf_map_lookup_elem(&map, &key);
if (count) {
    __sync_fetch_and_add(count, 1);  // Atomique
}
```

### 4. Nettoyer les EntrÃ©es Temporaires

```c
// Stocker des infos temporaires
bpf_map_update_elem(&temp_map, &pid, &info, BPF_ANY);

// ... traitement ...

// âœ… IMPORTANT : Nettoyer aprÃ¨s usage
bpf_map_delete_elem(&temp_map, &pid);
```

Sans nettoyage, la map se remplit et les nouvelles entrÃ©es Ã©chouent !

### 5. Limiter la Pile (Stack)

```c
// âŒ Trop gros pour la pile (512 bytes max)
char buffer[4096];

// âœ… Utiliser une per-CPU array
struct {
    __uint(type, BPF_MAP_TYPE_PERCPU_ARRAY);
    __uint(max_entries, 1);
    __type(key, __u32);
    __type(value, char[4096]);
} buffer_map SEC(".maps");

__u32 key = 0;
char *buffer = bpf_map_lookup_elem(&buffer_map, &key);
if (buffer) {
    // Utiliser buffer
}
```

---

## ğŸ“ RÃ©sumÃ©

Les **BPF Maps** sont essentielles pour :
- **Stocker des donnÃ©es** persistantes
- **Communiquer** entre kernel et userspace
- **Partager** des informations entre programmes BPF
- CrÃ©er des **structures de donnÃ©es complexes**

**Types principaux** :
- **HASH** : ClÃ©-valeur dynamique
- **ARRAY** : Indices fixes, performance max
- **PERCPU_*** : Copie par CPU, zÃ©ro contention
- **RINGBUF** : Streaming d'Ã©vÃ©nements
- **LRU_HASH** : Cache auto-nettoyant
- **PROG_ARRAY** : Tail calls

**Bonnes pratiques** :
- âœ… Toujours vÃ©rifier les pointeurs NULL
- âœ… Dimensionner correctement (max_entries)
- âœ… Utiliser atomics pour les updates
- âœ… Nettoyer les entrÃ©es temporaires
- âœ… Utiliser des maps pour grandes structures (pas la pile)

---

## ğŸ¯ Prochaine Ã‰tape

Maintenant que vous maÃ®trisez les programmes BPF et les BPF Maps, explorons le **vÃ©rificateur eBPF** - le gardien qui garantit que tout ce code est sÃ»r.

**ğŸ‘‰ Prochaine section : 21.2.3 Le Verifier**

Le vÃ©rificateur :
- Analyse statique du bytecode
- Garantit la sÃ©curitÃ© (pas de crash possible)
- VÃ©rifie la terminaison (pas de boucles infinies)
- Valide tous les accÃ¨s mÃ©moire

**Ã€ bientÃ´t !** ğŸš€

---

## ğŸ“š RÃ©fÃ©rences

### Documentation Officielle
- [BPF Map Types](https://www.kernel.org/doc/html/latest/bpf/maps.html)
- [libbpf API - Maps](https://libbpf.readthedocs.io/en/latest/api.html)

### Exemples
- [libbpf-bootstrap examples](https://github.com/libbpf/libbpf-bootstrap)
- [BCC tools](https://github.com/iovisor/bcc/tree/master/tools) - Utilisation intensive des maps

### Articles
- [BPF ring buffer](https://nakryiko.com/posts/bpf-ringbuf/)
- [BPF maps: a deep dive](https://www.grant.pizza/blog/bpf-maps/)

â­ï¸ [Le verifier](/21-introduction-ebpf/02.3-verifier.md)
