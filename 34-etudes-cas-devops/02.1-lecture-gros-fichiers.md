ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 34.2.1 Lecture efficace de gros fichiers

## Introduction

Lorsqu'on dÃ©veloppe un parser de logs ou tout outil devant traiter de gros fichiers (logs systÃ¨me, fichiers de donnÃ©es, exports CSV volumineux), la performance de lecture devient cruciale. Un fichier de log de production peut facilement atteindre plusieurs gigaoctets, voire tÃ©raoctets. Une approche naÃ¯ve peut prendre des heures lÃ  oÃ¹ une approche optimisÃ©e prend quelques minutes.

Dans cette section, nous allons explorer les diffÃ©rentes techniques de lecture de fichiers en C, de la plus simple Ã  la plus performante, et comprendre quand utiliser chaque approche.

---

## 1. Approches de lecture : Vue d'ensemble

### 1.1 Les diffÃ©rentes mÃ©thodes

Il existe plusieurs faÃ§ons de lire un fichier en C, chacune avec ses avantages et inconvÃ©nients :

| MÃ©thode | Performance | ComplexitÃ© | Usage |
|---------|-------------|------------|-------|
| `fgetc()` | â­ TrÃ¨s lente | Facile | Petits fichiers, analyse caractÃ¨re par caractÃ¨re |
| `fgets()` | â­â­ Lente | Facile | Fichiers texte ligne par ligne |
| `fread()` avec buffer | â­â­â­â­ Rapide | Moyenne | Fichiers binaires, gros volumes |
| `read()` (appel systÃ¨me) | â­â­â­â­ Rapide | Moyenne | ContrÃ´le fin, fichiers volumineux |
| `mmap()` | â­â­â­â­â­ TrÃ¨s rapide | Complexe | TrÃ¨s gros fichiers, accÃ¨s alÃ©atoire |

### 1.2 Facteurs de performance

**Ce qui ralentit la lecture :**
- Trop d'appels systÃ¨me (chaque appel a un coÃ»t)
- Buffers trop petits (trop d'opÃ©rations I/O)
- Buffers trop grands (gaspillage mÃ©moire)
- Copies de donnÃ©es inutiles
- Allocations mÃ©moire rÃ©pÃ©tÃ©es

**Ce qui accÃ©lÃ¨re la lecture :**
- Buffers de taille optimale (4KB - 64KB gÃ©nÃ©ralement)
- RÃ©utilisation des buffers
- Lecture sÃ©quentielle plutÃ´t qu'alÃ©atoire
- Moins d'appels systÃ¨me
- Memory mapping pour trÃ¨s gros fichiers

---

## 2. Approche naÃ¯ve : CaractÃ¨re par caractÃ¨re

### 2.1 Lecture avec fgetc()

```c
#include <stdio.h>
#include <time.h>

void lire_fgetc(const char *chemin) {
    FILE *fp = fopen(chemin, "r");
    if (fp == NULL) {
        perror("fopen");
        return;
    }

    clock_t debut = clock();

    int caractere;
    long long compteur = 0;

    // Lire caractÃ¨re par caractÃ¨re
    while ((caractere = fgetc(fp)) != EOF) {
        compteur++;
        // Traitement du caractÃ¨re...
    }

    clock_t fin = clock();
    double temps = (double)(fin - debut) / CLOCKS_PER_SEC;

    printf("CaractÃ¨res lus: %lld\n", compteur);
    printf("Temps: %.3f secondes\n", temps);

    fclose(fp);
}
```

**Analyse :**
- âŒ **TrÃ¨s lent** : Un appel de fonction par caractÃ¨re
- âŒ **Inefficace** : Le buffering interne de stdio ne compense pas complÃ¨tement
- âœ… **Simple** : Code facile Ã  comprendre
- ğŸ“Š **Performance** : ~10-20 MB/s

**Quand l'utiliser :** Jamais pour de gros fichiers !

---

## 3. Approche basique : Ligne par ligne

### 3.1 Lecture avec fgets()

```c
#include <stdio.h>
#include <string.h>
#include <time.h>

#define MAX_LINE_LENGTH 4096

void lire_fgets(const char *chemin) {
    FILE *fp = fopen(chemin, "r");
    if (fp == NULL) {
        perror("fopen");
        return;
    }

    clock_t debut = clock();

    char ligne[MAX_LINE_LENGTH];
    long long nb_lignes = 0;

    // Lire ligne par ligne
    while (fgets(ligne, sizeof(ligne), fp) != NULL) {
        nb_lignes++;

        // Traitement de la ligne...
        // Par exemple: chercher un pattern
    }

    clock_t fin = clock();
    double temps = (double)(fin - debut) / CLOCKS_PER_SEC;

    printf("Lignes lues: %lld\n", nb_lignes);
    printf("Temps: %.3f secondes\n", temps);

    fclose(fp);
}
```

**Analyse :**
- âš ï¸ **Lent** : Encore beaucoup d'appels de fonction
- âš ï¸ **Limitation** : Taille de ligne maximale fixe
- âœ… **Pratique** : Parfait pour fichiers texte ligne par ligne
- ğŸ“Š **Performance** : ~50-100 MB/s

**ProblÃ¨me des lignes trop longues :**
```c
// Si une ligne dÃ©passe MAX_LINE_LENGTH, elle est tronquÃ©e
// Solution: vÃ©rifier si la ligne se termine par '\n'

while (fgets(ligne, sizeof(ligne), fp) != NULL) {
    size_t len = strlen(ligne);

    // Ligne complÃ¨te (se termine par \n)
    if (len > 0 && ligne[len-1] == '\n') {
        // Traiter la ligne complÃ¨te
    } else {
        // Ligne trop longue, continuer la lecture
        // ou gÃ©rer l'erreur
    }
}
```

### 3.2 Version amÃ©liorÃ©e avec getline() (GNU)

```c
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>

void lire_getline(const char *chemin) {
    FILE *fp = fopen(chemin, "r");
    if (fp == NULL) {
        perror("fopen");
        return;
    }

    char *ligne = NULL;
    size_t len = 0;
    ssize_t lu;
    long long nb_lignes = 0;

    // getline() alloue/rÃ©alloue automatiquement le buffer
    while ((lu = getline(&ligne, &len, fp)) != -1) {
        nb_lignes++;

        // Traitement de la ligne (longueur dans 'lu')
        // ligne[lu-1] est le '\n' (si prÃ©sent)
    }

    free(ligne);  // Important: libÃ©rer le buffer
    fclose(fp);

    printf("Lignes lues: %lld\n", nb_lignes);
}
```

**Avantages de getline() :**
- âœ… Pas de limite de taille de ligne
- âœ… RÃ©utilise et agrandi le buffer automatiquement
- âœ… Plus rapide que fgets()
- âš ï¸ Extension GNU (pas POSIX standard)

---

## 4. Approche performante : Lecture par blocs

### 4.1 Avec fread() (bibliothÃ¨que standard)

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define BUFFER_SIZE (64 * 1024)  // 64 KB

void lire_fread(const char *chemin) {
    FILE *fp = fopen(chemin, "rb");  // "rb" pour binaire
    if (fp == NULL) {
        perror("fopen");
        return;
    }

    clock_t debut = clock();

    char *buffer = malloc(BUFFER_SIZE);
    if (buffer == NULL) {
        fclose(fp);
        return;
    }

    size_t octets_lus;
    long long total_octets = 0;

    // Lire par blocs de 64 KB
    while ((octets_lus = fread(buffer, 1, BUFFER_SIZE, fp)) > 0) {
        total_octets += octets_lus;

        // Traiter le buffer
        // for (size_t i = 0; i < octets_lus; i++) {
        //     traiter(buffer[i]);
        // }
    }

    clock_t fin = clock();
    double temps = (double)(fin - debut) / CLOCKS_PER_SEC;

    printf("Octets lus: %lld\n", total_octets);
    printf("Temps: %.3f secondes\n", temps);
    printf("DÃ©bit: %.2f MB/s\n", (total_octets / (1024.0 * 1024.0)) / temps);

    free(buffer);
    fclose(fp);
}
```

**Analyse :**
- âœ… **Rapide** : Moins d'appels de fonction
- âœ… **Efficace** : Lecture par gros blocs
- âœ… **ContrÃ´lable** : Taille de buffer ajustable
- ğŸ“Š **Performance** : ~200-500 MB/s

### 4.2 Traitement ligne par ligne avec buffer

Pour traiter un fichier texte ligne par ligne efficacement :

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define BUFFER_SIZE (64 * 1024)

typedef void (*LineCallback)(const char *ligne, size_t longueur, void *user_data);

void traiter_fichier_par_lignes(const char *chemin,
                                 LineCallback callback,
                                 void *user_data) {
    FILE *fp = fopen(chemin, "r");
    if (fp == NULL) {
        perror("fopen");
        return;
    }

    char *buffer = malloc(BUFFER_SIZE);
    char *ligne_buffer = malloc(BUFFER_SIZE);
    size_t ligne_len = 0;

    if (buffer == NULL || ligne_buffer == NULL) {
        free(buffer);
        free(ligne_buffer);
        fclose(fp);
        return;
    }

    size_t octets_lus;

    while ((octets_lus = fread(buffer, 1, BUFFER_SIZE, fp)) > 0) {
        for (size_t i = 0; i < octets_lus; i++) {
            char c = buffer[i];

            if (c == '\n') {
                // Ligne complÃ¨te trouvÃ©e
                ligne_buffer[ligne_len] = '\0';
                callback(ligne_buffer, ligne_len, user_data);
                ligne_len = 0;
            } else {
                // Ajouter le caractÃ¨re Ã  la ligne courante
                if (ligne_len < BUFFER_SIZE - 1) {
                    ligne_buffer[ligne_len++] = c;
                }
            }
        }
    }

    // Traiter la derniÃ¨re ligne si elle ne se termine pas par \n
    if (ligne_len > 0) {
        ligne_buffer[ligne_len] = '\0';
        callback(ligne_buffer, ligne_len, user_data);
    }

    free(buffer);
    free(ligne_buffer);
    fclose(fp);
}

// Fonction callback d'exemple
void traiter_ligne(const char *ligne, size_t longueur, void *user_data) {
    long long *compteur = (long long *)user_data;
    (*compteur)++;

    // Traiter la ligne...
}

// Utilisation
int main() {
    long long nb_lignes = 0;
    traiter_fichier_par_lignes("gros_fichier.log", traiter_ligne, &nb_lignes);
    printf("Lignes traitÃ©es: %lld\n", nb_lignes);
    return 0;
}
```

**Avantages :**
- âœ… Performance de fread() + traitement ligne par ligne
- âœ… Pas de limite de taille de ligne
- âœ… Architecture callback flexible

---

## 5. Approche systÃ¨me : read() direct

### 5.1 Utilisation de l'appel systÃ¨me read()

```c
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <time.h>

#define BUFFER_SIZE (64 * 1024)

void lire_read_syscall(const char *chemin) {
    int fd = open(chemin, O_RDONLY);
    if (fd == -1) {
        perror("open");
        return;
    }

    clock_t debut = clock();

    char *buffer = malloc(BUFFER_SIZE);
    if (buffer == NULL) {
        close(fd);
        return;
    }

    ssize_t octets_lus;
    long long total_octets = 0;

    // Lire par blocs
    while ((octets_lus = read(fd, buffer, BUFFER_SIZE)) > 0) {
        total_octets += octets_lus;

        // Traiter le buffer
    }

    if (octets_lus == -1) {
        perror("read");
    }

    clock_t fin = clock();
    double temps = (double)(fin - debut) / CLOCKS_PER_SEC;

    printf("Octets lus: %lld\n", total_octets);
    printf("Temps: %.3f secondes\n", temps);
    printf("DÃ©bit: %.2f MB/s\n", (total_octets / (1024.0 * 1024.0)) / temps);

    free(buffer);
    close(fd);
}
```

**DiffÃ©rences avec fread() :**
- Pas de buffering supplÃ©mentaire (plus de contrÃ´le)
- LÃ©gÃ¨rement plus rapide dans certains cas
- Plus flexible pour les options (O_DIRECT, etc.)

### 5.2 Options avancÃ©es

```c
#include <fcntl.h>

// O_DIRECT: bypass du cache du systÃ¨me de fichiers
// Attention: nÃ©cessite un alignement mÃ©moire spÃ©cifique
int fd = open(chemin, O_RDONLY | O_DIRECT);

// posix_fadvise: donner des hints au kernel
#include <fcntl.h>

int fd = open(chemin, O_RDONLY);
posix_fadvise(fd, 0, 0, POSIX_FADV_SEQUENTIAL);  // Lecture sÃ©quentielle
// ou
posix_fadvise(fd, 0, 0, POSIX_FADV_WILLNEED);    // PrÃ©-charger en cache
```

---

## 6. Approche optimale : Memory Mapping (mmap)

### 6.1 Principe du memory mapping

Le memory mapping permet de "mapper" un fichier directement dans la mÃ©moire virtuelle du processus. Au lieu de lire explicitement, on accÃ¨de au fichier comme Ã  un tableau en mÃ©moire.

**Avantages :**
- âœ… TrÃ¨s rapide (pas de copies)
- âœ… Le kernel gÃ¨re le chargement (paging)
- âœ… Partage de mÃ©moire entre processus possible
- âœ… AccÃ¨s alÃ©atoire efficace

**InconvÃ©nients :**
- âš ï¸ Plus complexe
- âš ï¸ LimitÃ© par l'espace d'adressage (sur 32 bits)
- âš ï¸ Gestion des erreurs plus dÃ©licate

### 6.2 ImplÃ©mentation basique

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <time.h>

void lire_mmap(const char *chemin) {
    // Ouvrir le fichier
    int fd = open(chemin, O_RDONLY);
    if (fd == -1) {
        perror("open");
        return;
    }

    // Obtenir la taille du fichier
    struct stat sb;
    if (fstat(fd, &sb) == -1) {
        perror("fstat");
        close(fd);
        return;
    }

    size_t taille = sb.st_size;

    clock_t debut = clock();

    // Mapper le fichier en mÃ©moire
    char *data = mmap(NULL, taille, PROT_READ, MAP_PRIVATE, fd, 0);
    if (data == MAP_FAILED) {
        perror("mmap");
        close(fd);
        return;
    }

    // Conseiller au kernel sur l'accÃ¨s
    madvise(data, taille, MADV_SEQUENTIAL);

    // Traiter les donnÃ©es (accÃ¨s comme un tableau)
    long long compteur = 0;
    for (size_t i = 0; i < taille; i++) {
        if (data[i] == '\n') {
            compteur++;
        }
    }

    clock_t fin = clock();
    double temps = (double)(fin - debut) / CLOCKS_PER_SEC;

    printf("Lignes: %lld\n", compteur);
    printf("Temps: %.3f secondes\n", temps);
    printf("DÃ©bit: %.2f MB/s\n", (taille / (1024.0 * 1024.0)) / temps);

    // Nettoyer
    munmap(data, taille);
    close(fd);
}
```

### 6.3 Traitement ligne par ligne avec mmap

```c
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void traiter_lignes_mmap(const char *chemin) {
    int fd = open(chemin, O_RDONLY);
    if (fd == -1) {
        perror("open");
        return;
    }

    struct stat sb;
    if (fstat(fd, &sb) == -1) {
        perror("fstat");
        close(fd);
        return;
    }

    size_t taille = sb.st_size;

    char *data = mmap(NULL, taille, PROT_READ, MAP_PRIVATE, fd, 0);
    if (data == MAP_FAILED) {
        perror("mmap");
        close(fd);
        return;
    }

    madvise(data, taille, MADV_SEQUENTIAL);

    // Traiter ligne par ligne
    const char *debut_ligne = data;
    const char *fin_fichier = data + taille;
    long long nb_lignes = 0;

    for (const char *p = data; p < fin_fichier; p++) {
        if (*p == '\n') {
            // Ligne trouvÃ©e
            size_t longueur = p - debut_ligne;

            // Traiter la ligne (debut_ligne, longueur)
            // Exemple: afficher les 10 premiÃ¨res lignes
            if (nb_lignes < 10) {
                printf("Ligne %lld (%zu octets): %.*s\n",
                       nb_lignes + 1, longueur, (int)longueur, debut_ligne);
            }

            nb_lignes++;
            debut_ligne = p + 1;  // Ligne suivante
        }
    }

    // DerniÃ¨re ligne si pas de \n final
    if (debut_ligne < fin_fichier) {
        nb_lignes++;
    }

    printf("Total lignes: %lld\n", nb_lignes);

    munmap(data, taille);
    close(fd);
}
```

### 6.4 Options de madvise()

```c
// Conseiller le kernel sur l'utilisation

// AccÃ¨s sÃ©quentiel (lecture de bout en bout)
madvise(data, taille, MADV_SEQUENTIAL);

// AccÃ¨s alÃ©atoire (sauts frÃ©quents)
madvise(data, taille, MADV_RANDOM);

// Besoin immÃ©diat (prÃ©-charger)
madvise(data, taille, MADV_WILLNEED);

// Plus besoin (libÃ©rer du cache)
madvise(data, taille, MADV_DONTNEED);
```

---

## 7. Comparaison de performances

### 7.1 Benchmark comparatif

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE (64 * 1024)

typedef struct {
    const char *nom;
    double temps;
    double debit;  // MB/s
} ResultatBenchmark;

// Benchmark fgetc()
double bench_fgetc(const char *chemin, size_t *taille_fichier) {
    FILE *fp = fopen(chemin, "r");
    if (!fp) return -1;

    clock_t debut = clock();

    long long compteur = 0;
    while (fgetc(fp) != EOF) compteur++;

    clock_t fin = clock();

    fseek(fp, 0, SEEK_END);
    *taille_fichier = ftell(fp);

    fclose(fp);
    return (double)(fin - debut) / CLOCKS_PER_SEC;
}

// Benchmark fgets()
double bench_fgets(const char *chemin, size_t *taille_fichier) {
    FILE *fp = fopen(chemin, "r");
    if (!fp) return -1;

    char ligne[4096];
    clock_t debut = clock();

    while (fgets(ligne, sizeof(ligne), fp) != NULL);

    clock_t fin = clock();

    fseek(fp, 0, SEEK_END);
    *taille_fichier = ftell(fp);

    fclose(fp);
    return (double)(fin - debut) / CLOCKS_PER_SEC;
}

// Benchmark fread()
double bench_fread(const char *chemin, size_t *taille_fichier) {
    FILE *fp = fopen(chemin, "rb");
    if (!fp) return -1;

    char *buffer = malloc(BUFFER_SIZE);
    clock_t debut = clock();

    while (fread(buffer, 1, BUFFER_SIZE, fp) > 0);

    clock_t fin = clock();

    fseek(fp, 0, SEEK_END);
    *taille_fichier = ftell(fp);

    free(buffer);
    fclose(fp);
    return (double)(fin - debut) / CLOCKS_PER_SEC;
}

// Benchmark mmap()
double bench_mmap(const char *chemin, size_t *taille_fichier) {
    int fd = open(chemin, O_RDONLY);
    if (fd == -1) return -1;

    struct stat sb;
    fstat(fd, &sb);
    *taille_fichier = sb.st_size;

    char *data = mmap(NULL, *taille_fichier, PROT_READ, MAP_PRIVATE, fd, 0);
    if (data == MAP_FAILED) {
        close(fd);
        return -1;
    }

    clock_t debut = clock();

    long long compteur = 0;
    for (size_t i = 0; i < *taille_fichier; i++) {
        if (data[i] == '\n') compteur++;
    }

    clock_t fin = clock();

    munmap(data, *taille_fichier);
    close(fd);
    return (double)(fin - debut) / CLOCKS_PER_SEC;
}

void afficher_resultats(ResultatBenchmark *resultats, int nb_resultats) {
    printf("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    printf("â•‘ MÃ©thode                â•‘ Temps (s)     â•‘ DÃ©bit (MB/s)  â•‘\n");
    printf("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n");

    for (int i = 0; i < nb_resultats; i++) {
        printf("â•‘ %-22s â•‘ %13.3f â•‘ %13.2f â•‘\n",
               resultats[i].nom,
               resultats[i].temps,
               resultats[i].debit);
    }

    printf("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "Usage: %s <fichier>\n", argv[0]);
        return 1;
    }

    const char *fichier = argv[1];
    size_t taille;

    ResultatBenchmark resultats[4];
    int idx = 0;

    // Benchmark fread() (plus pratique que fgetc qui est trop lent)
    printf("Test fread()...\n");
    double temps = bench_fread(fichier, &taille);
    if (temps > 0) {
        resultats[idx].nom = "fread() (64KB buffer)";
        resultats[idx].temps = temps;
        resultats[idx].debit = (taille / (1024.0 * 1024.0)) / temps;
        idx++;
    }

    // Benchmark fgets()
    printf("Test fgets()...\n");
    temps = bench_fgets(fichier, &taille);
    if (temps > 0) {
        resultats[idx].nom = "fgets() (ligne/ligne)";
        resultats[idx].temps = temps;
        resultats[idx].debit = (taille / (1024.0 * 1024.0)) / temps;
        idx++;
    }

    // Benchmark mmap()
    printf("Test mmap()...\n");
    temps = bench_mmap(fichier, &taille);
    if (temps > 0) {
        resultats[idx].nom = "mmap() + parcours";
        resultats[idx].temps = temps;
        resultats[idx].debit = (taille / (1024.0 * 1024.0)) / temps;
        idx++;
    }

    printf("\nRÃ©sultats pour %s (%.2f MB):\n\n",
           fichier, taille / (1024.0 * 1024.0));
    afficher_resultats(resultats, idx);

    return 0;
}
```

### 7.2 RÃ©sultats typiques

Pour un fichier de 500 MB sur un SSD moderne :

```
RÃ©sultats pour access.log (500.00 MB):

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ MÃ©thode                â•‘ Temps (s)     â•‘ DÃ©bit (MB/s)  â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ fread() (64KB buffer)  â•‘         0.450 â•‘      1111.11  â•‘
â•‘ fgets() (ligne/ligne)  â•‘         2.100 â•‘       238.10  â•‘
â•‘ mmap() + parcours      â•‘         0.280 â•‘      1785.71  â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

**Observations :**
- `mmap()` est ~6-7Ã— plus rapide que `fgets()`
- `fread()` avec gros buffer est ~5Ã— plus rapide que `fgets()`
- La diffÃ©rence s'accentue avec la taille du fichier

---

## 8. Optimisations avancÃ©es

### 8.1 PrÃ©chargement (prefetching)

```c
#include <sys/mman.h>

// Demander au kernel de prÃ©-charger les donnÃ©es
void precharger_fichier(const char *data, size_t taille) {
    // Conseiller le chargement immÃ©diat
    madvise((void*)data, taille, MADV_WILLNEED);

    // Ou forcer le chargement en touchant chaque page
    size_t page_size = sysconf(_SC_PAGESIZE);
    volatile char c;

    for (size_t i = 0; i < taille; i += page_size) {
        c = data[i];  // Toucher la page
    }
}
```

### 8.2 Lecture parallÃ¨le (multi-threading)

Pour de TRÃˆS gros fichiers, on peut diviser le travail :

```c
#include <pthread.h>
#include <sys/mman.h>

typedef struct {
    const char *data;
    size_t debut;
    size_t fin;
    long long resultat;
} ThreadData;

void *traiter_chunk(void *arg) {
    ThreadData *td = (ThreadData *)arg;

    td->resultat = 0;
    for (size_t i = td->debut; i < td->fin; i++) {
        if (td->data[i] == '\n') {
            td->resultat++;
        }
    }

    return NULL;
}

long long compter_lignes_parallele(const char *chemin, int nb_threads) {
    // Mapper le fichier
    int fd = open(chemin, O_RDONLY);
    struct stat sb;
    fstat(fd, &sb);
    size_t taille = sb.st_size;

    char *data = mmap(NULL, taille, PROT_READ, MAP_PRIVATE, fd, 0);
    madvise(data, taille, MADV_SEQUENTIAL);

    // CrÃ©er les threads
    pthread_t *threads = malloc(nb_threads * sizeof(pthread_t));
    ThreadData *thread_data = malloc(nb_threads * sizeof(ThreadData));

    size_t chunk_size = taille / nb_threads;

    for (int i = 0; i < nb_threads; i++) {
        thread_data[i].data = data;
        thread_data[i].debut = i * chunk_size;
        thread_data[i].fin = (i == nb_threads - 1) ? taille : (i + 1) * chunk_size;
        thread_data[i].resultat = 0;

        pthread_create(&threads[i], NULL, traiter_chunk, &thread_data[i]);
    }

    // Attendre et collecter les rÃ©sultats
    long long total = 0;
    for (int i = 0; i < nb_threads; i++) {
        pthread_join(threads[i], NULL);
        total += thread_data[i].resultat;
    }

    free(threads);
    free(thread_data);
    munmap(data, taille);
    close(fd);

    return total;
}
```

### 8.3 Traitement SIMD (vectorisation)

Pour du traitement trÃ¨s intensif, on peut utiliser les instructions SIMD :

```c
#include <immintrin.h>  // AVX2

// Compter les '\n' avec AVX2 (traite 32 octets Ã  la fois)
long long compter_newlines_simd(const char *data, size_t taille) {
    long long compteur = 0;
    const __m256i newline = _mm256_set1_epi8('\n');

    size_t i = 0;

    // Traiter par blocs de 32 octets
    for (; i + 32 <= taille; i += 32) {
        __m256i chunk = _mm256_loadu_si256((const __m256i*)(data + i));
        __m256i cmp = _mm256_cmpeq_epi8(chunk, newline);
        int mask = _mm256_movemask_epi8(cmp);
        compteur += __builtin_popcount(mask);
    }

    // Traiter les octets restants
    for (; i < taille; i++) {
        if (data[i] == '\n') compteur++;
    }

    return compteur;
}

// Compiler avec: gcc -mavx2 -O3 programme.c
```

---

## 9. Choix de la mÃ©thode selon le contexte

### 9.1 Arbre de dÃ©cision

```
Quel est votre besoin ?
â”‚
â”œâ”€ Petit fichier (<1 MB)
â”‚  â””â”€> Utiliser fgets() (simple et suffisant)
â”‚
â”œâ”€ Fichier moyen (1-100 MB)
â”‚  â”œâ”€ Traitement ligne par ligne ?
â”‚  â”‚  â””â”€> fread() avec buffer + parsing manuel
â”‚  â””â”€ Traitement brut ?
â”‚     â””â”€> fread() avec gros buffer
â”‚
â”œâ”€ Gros fichier (100 MB - 1 GB)
â”‚  â”œâ”€ AccÃ¨s sÃ©quentiel ?
â”‚  â”‚  â””â”€> mmap() avec MADV_SEQUENTIAL
â”‚  â””â”€ AccÃ¨s alÃ©atoire ?
â”‚     â””â”€> mmap() avec MADV_RANDOM
â”‚
â””â”€ TrÃ¨s gros fichier (>1 GB)
   â”œâ”€ Tient en mÃ©moire ?
   â”‚  â””â”€> mmap() + traitement parallÃ¨le
   â””â”€ Ne tient pas en mÃ©moire ?
      â””â”€> fread() en streaming (traiter et jeter)
```

### 9.2 Tableau rÃ©capitulatif

| ScÃ©nario | MÃ©thode recommandÃ©e | Raison |
|----------|---------------------|--------|
| Log systÃ¨me (lignes) | fread() + parsing manuel | Bon compromis performance/complexitÃ© |
| CSV volumineux | mmap() | AccÃ¨s rapide, possibilitÃ© de parallÃ©liser |
| Fichier binaire | fread() ou read() | ContrÃ´le prÃ©cis des donnÃ©es |
| Analyse texte simple | getline() (GNU) | Simple, pas de limite de ligne |
| TrÃ¨s gros logs | mmap() + multi-thread | Performance maximale |
| Fichier distant/lent | fread() avec gros buffer | Minimise les I/O |

---

## 10. Bonnes pratiques

### 10.1 Gestion des erreurs

```c
// Toujours vÃ©rifier les retours
FILE *fp = fopen(chemin, "r");
if (fp == NULL) {
    fprintf(stderr, "Erreur ouverture %s: %s\n", chemin, strerror(errno));
    return -1;
}

// Avec mmap(), vÃ©rifier MAP_FAILED
char *data = mmap(NULL, taille, PROT_READ, MAP_PRIVATE, fd, 0);
if (data == MAP_FAILED) {
    perror("mmap");
    close(fd);
    return -1;
}
```

### 10.2 LibÃ©ration des ressources

```c
// TOUJOURS nettoyer
void traiter_fichier(const char *chemin) {
    FILE *fp = fopen(chemin, "r");
    char *buffer = malloc(BUFFER_SIZE);

    if (fp == NULL || buffer == NULL) {
        if (fp) fclose(fp);
        if (buffer) free(buffer);
        return;
    }

    // Traitement...

    // Nettoyage garanti
    free(buffer);
    fclose(fp);
}
```

### 10.3 Taille de buffer optimale

```c
// RÃ¨gles gÃ©nÃ©rales pour la taille de buffer

// Disque dur traditionnel (HDD)
#define BUFFER_SIZE_HDD (128 * 1024)  // 128 KB

// SSD
#define BUFFER_SIZE_SSD (64 * 1024)   // 64 KB

// DÃ©tection automatique
size_t obtenir_taille_buffer_optimale() {
    // Utiliser la taille de page systÃ¨me
    long page_size = sysconf(_SC_PAGESIZE);

    // Multiple de la taille de page (typiquement 4KB)
    return page_size * 16;  // 64 KB sur la plupart des systÃ¨mes
}
```

### 10.4 Monitoring de la progression

Pour de gros fichiers, informer l'utilisateur :

```c
void lire_avec_progression(const char *chemin) {
    int fd = open(chemin, O_RDONLY);
    struct stat sb;
    fstat(fd, &sb);
    size_t taille_totale = sb.st_size;

    char *buffer = malloc(BUFFER_SIZE);
    ssize_t lu;
    size_t total_lu = 0;
    int dernier_pourcent = -1;

    while ((lu = read(fd, buffer, BUFFER_SIZE)) > 0) {
        total_lu += lu;

        // Afficher progression
        int pourcent = (total_lu * 100) / taille_totale;
        if (pourcent != dernier_pourcent && pourcent % 10 == 0) {
            printf("\rProgression: %d%%", pourcent);
            fflush(stdout);
            dernier_pourcent = pourcent;
        }

        // Traiter buffer...
    }

    printf("\rProgression: 100%%\n");

    free(buffer);
    close(fd);
}
```

---

## 11. RÃ©capitulatif

### Points clÃ©s Ã  retenir

- âœ… **fgets()** : Simple mais lent, ok pour petits fichiers
- âœ… **fread()** : Bon compromis performance/simplicitÃ©
- âœ… **read()** : Plus de contrÃ´le, lÃ©gÃ¨rement plus rapide
- âœ… **mmap()** : Optimal pour gros fichiers en lecture
- âœ… **Taille de buffer** : 64 KB est un bon dÃ©faut
- âœ… **VÃ©rifier les erreurs** : Toujours tester les retours
- âœ… **LibÃ©rer les ressources** : Ne jamais oublier free()/close()/munmap()

### Performances typiques (SSD moderne)

| MÃ©thode | DÃ©bit approximatif |
|---------|-------------------|
| fgetc() | 10-20 MB/s |
| fgets() | 50-100 MB/s |
| fread() (64KB) | 200-500 MB/s |
| read() (64KB) | 250-600 MB/s |
| mmap() | 500-2000 MB/s |

---

## Conclusion

La lecture efficace de gros fichiers en C repose sur quelques principes simples :

1. **Minimiser les appels systÃ¨me** : Lire par gros blocs plutÃ´t que caractÃ¨re par caractÃ¨re
2. **Utiliser des buffers adaptÃ©s** : 64 KB est souvent optimal
3. **Exploiter mmap()** : Pour les trÃ¨s gros fichiers et l'accÃ¨s alÃ©atoire
4. **Donner des hints au kernel** : posix_fadvise(), madvise()
5. **ParallÃ©liser si nÃ©cessaire** : Multi-threading pour fichiers Ã©normes

Le choix de la mÃ©thode dÃ©pend de votre cas d'usage, mais `fread()` avec un buffer de 64 KB est un excellent point de dÃ©part qui fonctionne bien dans la majoritÃ© des situations. Pour des besoins de performance maximale, `mmap()` est imbattable.

Dans la section suivante (34.2.2), nous verrons comment utiliser ces techniques pour implÃ©menter un parser de logs performant avec support des expressions rÃ©guliÃ¨res.

â­ï¸ [Expressions rÃ©guliÃ¨res](/34-etudes-cas-devops/02.2-expressions-regulieres.md)
