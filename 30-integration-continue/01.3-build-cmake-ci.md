üîù Retour au [Sommaire](/SOMMAIRE.md)

# 30.1.3 Build avec CMake en CI

## Introduction

**CMake** est le syst√®me de build moderne et standard pour les projets C/C++. Dans un pipeline CI/CD, CMake joue un r√¥le crucial en permettant de compiler votre projet de mani√®re **portable**, **reproductible** et **automatis√©e** sur diff√©rentes plateformes.

Cette section vous montre comment int√©grer CMake dans vos workflows GitHub Actions pour construire vos projets C de mani√®re professionnelle.

---

## Pourquoi CMake en CI ?

### Avantages de CMake dans l'int√©gration continue

1. **Portabilit√©** : Le m√™me `CMakeLists.txt` fonctionne sur Linux, macOS et Windows
2. **Configuration unifi√©e** : Une seule source de v√©rit√© pour la structure de build
3. **Gestion des d√©pendances** : CMake peut d√©tecter et configurer les biblioth√®ques
4. **Build types** : Facile de basculer entre Debug et Release
5. **Out-of-source builds** : Compilation sans polluer le code source
6. **Int√©gration native** : Support natif des tests (CTest), sanitizers, etc.

### Alternative √† Make traditionnel

Plut√¥t que d'√©crire des `Makefile` sp√©cifiques √† chaque plateforme, CMake g√©n√®re automatiquement les fichiers de build appropri√©s.

---

## Pr√©requis : Structure d'un projet CMake

Avant de mettre en place le CI, votre projet doit avoir un fichier `CMakeLists.txt` √† sa racine :

```
mon-projet/
‚îú‚îÄ‚îÄ CMakeLists.txt       ‚Üê Fichier de configuration CMake
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.c
‚îÇ   ‚îî‚îÄ‚îÄ utils.c
‚îú‚îÄ‚îÄ include/
‚îÇ   ‚îî‚îÄ‚îÄ utils.h
‚îî‚îÄ‚îÄ tests/
    ‚îî‚îÄ‚îÄ test_utils.c
```

**Exemple minimal de `CMakeLists.txt` :**

```cmake
cmake_minimum_required(VERSION 3.10)  
project(MonProjet C)  

# D√©finir le standard C
set(CMAKE_C_STANDARD 17)  
set(CMAKE_C_STANDARD_REQUIRED ON)  

# Ajouter l'ex√©cutable
add_executable(mon_app
    src/main.c
    src/utils.c
)

# Inclure les headers
target_include_directories(mon_app PRIVATE include)
```

---

## Les 3 √©tapes fondamentales du build CMake

Un build CMake se d√©roule toujours en trois phases :

### 1. Configuration (cmake)

```bash
cmake -B build -S .
```

- **Analyse** le `CMakeLists.txt`
- **D√©tecte** le compilateur et les biblioth√®ques
- **G√©n√®re** les fichiers de build (Makefiles, Ninja, etc.)
- `-B build` : R√©pertoire de build (build directory)
- `-S .` : R√©pertoire source (o√π se trouve CMakeLists.txt)

### 2. Compilation (cmake --build)

```bash
cmake --build build
```

- **Compile** le projet
- **Utilise** le syst√®me de build g√©n√©r√© (Make, Ninja, etc.)
- `build` : Le r√©pertoire cr√©√© √† l'√©tape pr√©c√©dente

### 3. Installation (cmake --install) [Optionnel]

```bash
cmake --install build --prefix /usr/local
```

- **Installe** les binaires, biblioth√®ques et headers
- `--prefix` : Destination de l'installation

---

## Workflow de base : Build CMake simple

Voici un workflow GitHub Actions minimal pour compiler un projet CMake :

```yaml
name: CMake Build

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout du code
      uses: actions/checkout@v4

    - name: Installer CMake
      run: |
        sudo apt-get update
        sudo apt-get install -y cmake

    - name: Configurer le projet
      run: cmake -B build -S .

    - name: Compiler le projet
      run: cmake --build build

    - name: Lancer l'ex√©cutable
      run: ./build/mon_app
```

**Explication des √©tapes :**

1. `checkout@v4` : R√©cup√®re votre code source
2. Installation de CMake (sur Ubuntu latest, CMake est d√©j√† install√©)
3. Configuration avec `cmake -B build -S .`
4. Compilation avec `cmake --build build`
5. Ex√©cution du binaire g√©n√©r√©

---

## Options de configuration CMake importantes

### Build Type (Debug vs Release)

```yaml
- name: Configurer en mode Release
  run: cmake -B build -DCMAKE_BUILD_TYPE=Release
```

**Les types de build courants :**

- `Debug` : Symboles de d√©bogage, pas d'optimisation (-g -O0)
- `Release` : Optimisations maximales, pas de symboles (-O3 -DNDEBUG)
- `RelWithDebInfo` : Optimisations + symboles de d√©bogage (-O2 -g)
- `MinSizeRel` : Optimisation pour la taille (-Os)

### Sp√©cifier le compilateur

```yaml
- name: Configurer avec GCC-12
  run: |
    cmake -B build \
      -DCMAKE_C_COMPILER=gcc-12 \
      -DCMAKE_BUILD_TYPE=Release
```

### Verbosit√© du build

```yaml
- name: Compiler avec logs verbeux
  run: cmake --build build --verbose
```

Utile pour d√©boguer les probl√®mes de compilation en CI.

### Parall√©lisation

```yaml
- name: Compiler en parall√®le
  run: cmake --build build -j$(nproc)
```

- `-j$(nproc)` : Utilise tous les c≈ìurs CPU disponibles
- Sur GitHub Actions (Linux) : g√©n√©ralement 2 c≈ìurs

---

## Workflow avec Build Type en matrice

Tester votre projet en Debug et Release :

```yaml
name: CMake Build Multi-Config

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        build-type: [Debug, Release]

    steps:
    - uses: actions/checkout@v4

    - name: Configurer CMake (${{ matrix.build-type }})
      run: |
        cmake -B build \
          -DCMAKE_BUILD_TYPE=${{ matrix.build-type }}

    - name: Compiler
      run: cmake --build build --config ${{ matrix.build-type }}

    - name: Afficher les informations de build
      run: |
        echo "Build type: ${{ matrix.build-type }}"
        ls -lh build/
```

---

## Workflow complet : Multi-plateformes avec CMake

Voici un workflow robuste qui compile sur Linux, macOS et Windows :

```yaml
name: CMake Multi-Plateformes

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    name: ${{ matrix.os }} - ${{ matrix.build-type }}
    runs-on: ${{ matrix.os }}

    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        build-type: [Debug, Release]

    steps:
    - name: Checkout du code
      uses: actions/checkout@v4

    - name: Installer CMake (Windows)
      if: runner.os == 'Windows'
      uses: lukka/get-cmake@latest

    - name: Configurer CMake
      run: |
        cmake -B build \
          -DCMAKE_BUILD_TYPE=${{ matrix.build-type }}

    - name: Compiler
      run: cmake --build build --config ${{ matrix.build-type }}

    - name: Lister les fichiers g√©n√©r√©s
      shell: bash
      run: |
        echo "Contenu du r√©pertoire build:"
        ls -R build/
```

**Points cl√©s :**

- `shell: bash` : Force l'utilisation de bash m√™me sur Windows (pour la compatibilit√©)
- `lukka/get-cmake@latest` : Action qui installe CMake sur Windows
- Le m√™me workflow fonctionne sur 3 OS diff√©rents !

---

## Gestion des tests avec CTest

Si votre `CMakeLists.txt` d√©finit des tests avec `enable_testing()` et `add_test()`, vous pouvez les lancer en CI :

**Dans votre `CMakeLists.txt` :**

```cmake
enable_testing()

add_executable(test_utils tests/test_utils.c)  
add_test(NAME test_utils COMMAND test_utils)  
```

**Dans votre workflow :**

```yaml
- name: Configurer avec tests
  run: cmake -B build -DCMAKE_BUILD_TYPE=Debug

- name: Compiler
  run: cmake --build build

- name: Lancer les tests
  run: |
    cd build
    ctest --output-on-failure --verbose
```

**Options CTest utiles :**

- `--output-on-failure` : Affiche la sortie uniquement si un test √©choue
- `--verbose` : Mode verbeux
- `-j4` : Parall√©lise les tests

---

## Installation et packaging

Pour cr√©er un artifact installable :

```yaml
- name: Configurer CMake
  run: cmake -B build -DCMAKE_INSTALL_PREFIX=/usr/local

- name: Compiler
  run: cmake --build build

- name: Installer
  run: cmake --install build --prefix install_dir

- name: Uploader l'artifact
  uses: actions/upload-artifact@v4
  with:
    name: mon-app-${{ matrix.os }}
    path: install_dir/
```

Cela cr√©e un artifact t√©l√©chargeable depuis l'interface GitHub Actions.

---

## Caching des builds CMake

Pour acc√©l√©rer vos builds, vous pouvez mettre en cache les fichiers g√©n√©r√©s par CMake :

```yaml
- name: Cache CMake build
  uses: actions/cache@v4
  with:
    path: |
      build/
      ~/.cache/ccache
    key: ${{ runner.os }}-cmake-${{ hashFiles('**/CMakeLists.txt') }}
    restore-keys: |
      ${{ runner.os }}-cmake-

- name: Configurer CMake
  run: cmake -B build

- name: Compiler
  run: cmake --build build
```

**Explications :**

- `path: build/` : Met en cache le r√©pertoire de build
- `key:` : Cl√© unique bas√©e sur l'OS et le hash de CMakeLists.txt
- Si `CMakeLists.txt` change, le cache est invalid√©
- Les builds suivants sont **beaucoup plus rapides** !

---

## Workflow complet avec matrice avanc√©e

Voici un exemple r√©aliste combinant plusieurs dimensions :

```yaml
name: CI CMake Complet

on:
  push:
    branches: [ main, develop ]
  pull_request:

jobs:
  build-and-test:
    name: ${{ matrix.os }} - ${{ matrix.compiler }} - ${{ matrix.build-type }}
    runs-on: ${{ matrix.os }}

    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-22.04, ubuntu-24.04]
        compiler: [gcc, clang]
        compiler-version: [12, 13]
        build-type: [Debug, Release]

        exclude:
          # Clang 13 pas disponible sur Ubuntu 24.04
          - os: ubuntu-24.04
            compiler: clang
            compiler-version: 13

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Installer le compilateur
      run: |
        sudo apt-get update
        if [ "${{ matrix.compiler }}" = "gcc" ]; then
          sudo apt-get install -y gcc-${{ matrix.compiler-version }}
          echo "CC=gcc-${{ matrix.compiler-version }}" >> $GITHUB_ENV
        else
          sudo apt-get install -y clang-${{ matrix.compiler-version }}
          echo "CC=clang-${{ matrix.compiler-version }}" >> $GITHUB_ENV
        fi

    - name: Cache CMake
      uses: actions/cache@v4
      with:
        path: build/
        key: ${{ matrix.os }}-${{ matrix.compiler }}-${{ matrix.compiler-version }}-${{ matrix.build-type }}-${{ hashFiles('**/CMakeLists.txt') }}

    - name: Configurer CMake
      run: |
        cmake -B build \
          -DCMAKE_C_COMPILER=$CC \
          -DCMAKE_BUILD_TYPE=${{ matrix.build-type }} \
          -DCMAKE_EXPORT_COMPILE_COMMANDS=ON

    - name: Compiler
      run: cmake --build build -j$(nproc)

    - name: Lancer les tests
      run: |
        cd build
        ctest --output-on-failure

    - name: Uploader compile_commands.json (Debug only)
      if: matrix.build-type == 'Debug'
      uses: actions/upload-artifact@v4
      with:
        name: compile-commands-${{ matrix.os }}-${{ matrix.compiler }}
        path: build/compile_commands.json
```

**Ce workflow fait :**

- Teste sur 2 versions d'Ubuntu
- Avec GCC et Clang
- Versions 12 et 13
- En mode Debug et Release
- Met en cache les builds
- Lance les tests automatiquement
- Upload compile_commands.json pour l'analyse statique

---

## Options CMake avanc√©es pour la CI

### Export des commandes de compilation

```yaml
- name: Configurer avec export des commandes
  run: |
    cmake -B build \
      -DCMAKE_BUILD_TYPE=Debug \
      -DCMAKE_EXPORT_COMPILE_COMMANDS=ON
```

G√©n√®re `compile_commands.json`, utile pour :
- clang-tidy (analyse statique)
- IDE auto-completion
- Outils d'analyse de code

### Warnings as errors

```yaml
- name: Configurer avec warnings strictes
  run: |
    cmake -B build \
      -DCMAKE_C_FLAGS="-Wall -Wextra -Werror"
```

Force le build √† √©chouer si des warnings sont pr√©sents.

### Position Independent Code (pour biblioth√®ques)

```yaml
- name: Configurer avec PIC
  run: |
    cmake -B build \
      -DCMAKE_POSITION_INDEPENDENT_CODE=ON
```

N√©cessaire pour cr√©er des biblioth√®ques partag√©es (.so).

---

## Int√©gration avec les sanitizers

Combiner CMake avec AddressSanitizer :

```yaml
jobs:
  build-with-sanitizers:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        sanitizer: [address, undefined, thread]

    steps:
    - uses: actions/checkout@v4

    - name: Configurer avec ${{ matrix.sanitizer }} sanitizer
      run: |
        cmake -B build \
          -DCMAKE_BUILD_TYPE=Debug \
          -DCMAKE_C_FLAGS="-fsanitize=${{ matrix.sanitizer }} -fno-omit-frame-pointer"

    - name: Compiler
      run: cmake --build build

    - name: Lancer les tests
      run: |
        cd build
        ctest --output-on-failure
```

---

## Gestion des d√©pendances externes

### Avec find_package

Si votre projet utilise des biblioth√®ques externes :

```yaml
- name: Installer les d√©pendances
  run: |
    sudo apt-get update
    sudo apt-get install -y libssl-dev libcurl4-openssl-dev

- name: Configurer CMake
  run: cmake -B build
```

### Avec FetchContent (CMake 3.11+)

Si votre `CMakeLists.txt` utilise `FetchContent`, aucune √©tape suppl√©mentaire n'est n√©cessaire :

```cmake
include(FetchContent)  
FetchContent_Declare(  
  unity
  GIT_REPOSITORY https://github.com/ThrowTheSwitch/Unity.git
  GIT_TAG v2.5.2
)
FetchContent_MakeAvailable(unity)
```

CMake t√©l√©chargera automatiquement les d√©pendances !

---

## Debugging des builds CMake en CI

### Afficher la configuration d√©taill√©e

```yaml
- name: Configurer avec d√©tails
  run: cmake -B build --debug-output
```

### Logs de compilation verbeux

```yaml
- name: Compiler avec logs complets
  run: cmake --build build --verbose
```

### Afficher les variables CMake

```yaml
- name: Afficher les variables CMake
  run: |
    cd build
    cmake -LA
```

### En cas d'√©chec

1. V√©rifiez les logs de l'√©tape "Configurer CMake"
2. Recherchez les erreurs `CMake Error`
3. V√©rifiez que toutes les d√©pendances sont install√©es
4. Testez la m√™me commande localement

---

## Workflow avec g√©n√©ration de documentation

Si vous utilisez Doxygen :

```yaml
- name: Installer Doxygen
  run: sudo apt-get install -y doxygen graphviz

- name: Configurer CMake avec docs
  run: |
    cmake -B build \
      -DBUILD_DOCUMENTATION=ON

- name: G√©n√©rer la documentation
  run: cmake --build build --target doc

- name: Uploader la documentation
  uses: actions/upload-artifact@v4
  with:
    name: documentation
    path: build/docs/html/
```

---

## Comparaison : Make vs CMake en CI

### Avec Make traditionnel

```yaml
steps:
  - uses: actions/checkout@v4
  - name: Compiler
    run: make
  - name: Tester
    run: make test
```

**Probl√®mes :**
- Makefile sp√©cifique √† la plateforme
- Difficile √† maintenir pour multi-OS
- Configuration en dur

### Avec CMake

```yaml
steps:
  - uses: actions/checkout@v4
  - name: Configurer
    run: cmake -B build -DCMAKE_BUILD_TYPE=Release
  - name: Compiler
    run: cmake --build build
  - name: Tester
    run: ctest --test-dir build
```

**Avantages :**
- Portable sur Linux/macOS/Windows
- Configuration flexible
- Standard moderne

---

## Actions GitHub pr√™tes √† l'emploi

Pour simplifier votre workflow, vous pouvez utiliser des actions communautaires :

### lukka/run-cmake

```yaml
- name: Build avec run-cmake
  uses: lukka/run-cmake@v10
  with:
    configurePreset: 'default'
    buildPreset: 'default'
```

N√©cessite des CMakePresets.json (CMake 3.19+).

### jwlawson/actions-setup-cmake

```yaml
- name: Installer CMake sp√©cifique
  uses: jwlawson/actions-setup-cmake@v2
  with:
    cmake-version: '3.25.0'
```

Utile pour tester une version sp√©cifique de CMake.

---

## Bonnes pratiques CMake en CI

### 1. Out-of-source builds (toujours)

‚úÖ **Bon :**
```bash
cmake -B build -S .
```

‚ùå **Mauvais :**
```bash
cmake .
```

### 2. Sp√©cifiez le build type

```bash
cmake -B build -DCMAKE_BUILD_TYPE=Release
```

Sans cela, le build type est vide par d√©faut !

### 3. Utilisez --build au lieu de make

‚úÖ **Portable :**
```bash
cmake --build build
```

‚ùå **D√©pendant de la plateforme :**
```bash
cd build && make
```

### 4. Parall√©lisez la compilation

```bash
cmake --build build -j$(nproc)
```

### 5. Testez avec CTest, pas manuellement

‚úÖ **Bon :**
```bash
ctest --test-dir build
```

‚ùå **Mauvais :**
```bash
./build/test1
./build/test2
...
```

### 6. Versionnez votre version CMake minimale

Dans `CMakeLists.txt` :
```cmake
cmake_minimum_required(VERSION 3.10)
```

GitHub Actions installe g√©n√©ralement CMake 3.22+.

---

## Template de workflow complet

Voici un template pr√™t √† l'emploi que vous pouvez copier :

```yaml
name: CMake CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    name: Build-${{ matrix.os }}-${{ matrix.build-type }}
    runs-on: ${{ matrix.os }}

    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest]
        build-type: [Debug, Release]

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Cache
      uses: actions/cache@v4
      with:
        path: build/
        key: ${{ runner.os }}-${{ matrix.build-type }}-${{ hashFiles('**/CMakeLists.txt') }}

    - name: Configure
      run: cmake -B build -DCMAKE_BUILD_TYPE=${{ matrix.build-type }}

    - name: Build
      run: cmake --build build -j$(nproc)

    - name: Test
      run: ctest --test-dir build --output-on-failure
```

---

## R√©sum√©

**√âtapes essentielles d'un build CMake en CI :**

1. **Checkout** : `actions/checkout@v4`
2. **Configure** : `cmake -B build -DCMAKE_BUILD_TYPE=Release`
3. **Build** : `cmake --build build -j$(nproc)`
4. **Test** : `ctest --test-dir build --output-on-failure`

**Options importantes :**

- `-DCMAKE_BUILD_TYPE` : Debug, Release, RelWithDebInfo
- `-DCMAKE_C_COMPILER` : Sp√©cifier le compilateur
- `--verbose` : Logs d√©taill√©s
- `-j$(nproc)` : Compilation parall√®le

---

## Prochaines √©tapes

Maintenant que vous ma√Ætrisez CMake en CI, vous pouvez :

- Ajouter l'ex√©cution de **tests unitaires** automatiques
- Int√©grer des **sanitizers** (ASan, UBSan)
- Configurer **Valgrind** pour la d√©tection de fuites
- Mesurer la **couverture de code**
- Cr√©er des **artifacts** de release

Ces sujets sont couverts dans les sections suivantes du module.

---

## Ressources compl√©mentaires

- [Documentation CMake officielle](https://cmake.org/documentation/)
- [CMake Tutorial](https://cmake.org/cmake/help/latest/guide/tutorial/index.html)
- [Modern CMake](https://cliutils.gitlab.io/modern-cmake/)
- [Actions GitHub pour CMake](https://github.com/marketplace?query=cmake)

---

**üéØ Points cl√©s √† retenir :**

- ‚úÖ CMake suit 3 √©tapes : Configure ‚Üí Build ‚Üí Test
- ‚úÖ Utilisez toujours des out-of-source builds (`-B build`)
- ‚úÖ Sp√©cifiez le build type (`-DCMAKE_BUILD_TYPE`)
- ‚úÖ `cmake --build` est portable, `make` ne l'est pas
- ‚úÖ CTest int√®gre naturellement les tests dans le workflow
- ‚úÖ Le caching acc√©l√®re significativement les builds
- ‚úÖ CMake + matrices = portabilit√© multi-plateformes facile

‚è≠Ô∏è [Ex√©cution des tests unitaires](/30-integration-continue/01.4-execution-tests.md)
