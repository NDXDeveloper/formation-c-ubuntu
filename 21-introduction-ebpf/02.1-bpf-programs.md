ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 21.2.1 BPF Programs

## Introduction

Les **programmes BPF** (ou programmes eBPF) sont au cÅ“ur de la technologie eBPF. Ce sont les "acteurs" qui s'exÃ©cutent dans le noyau Linux pour observer, filtrer, modifier ou bloquer des Ã©vÃ©nements systÃ¨me. Dans cette section, nous allons dÃ©couvrir ce qu'est un programme BPF, comment il fonctionne, et comment vous pouvez en crÃ©er.

Imaginez un programme BPF comme un **garde intelligent** postÃ© Ã  diffÃ©rents points stratÃ©giques du systÃ¨me : il observe ce qui se passe, prend des dÃ©cisions, collecte des statistiques, et peut mÃªme modifier le comportement du systÃ¨me.

---

## ğŸ¯ Qu'est-ce qu'un Programme BPF ?

### DÃ©finition Simple

Un **programme BPF** est un petit programme Ã©crit en C (avec des restrictions) qui :
1. Est compilÃ© en **bytecode eBPF** (instructions de la machine virtuelle eBPF)
2. Est **vÃ©rifiÃ©** par le noyau pour garantir sa sÃ©curitÃ©
3. Est **compilÃ© en code machine natif** (via JIT)
4. S'exÃ©cute **dans le noyau Linux** en rÃ©ponse Ã  des Ã©vÃ©nements
5. Peut communiquer avec l'espace utilisateur via des **BPF Maps**

### Analogie : Le Garde de SÃ©curitÃ©

Imaginez un aÃ©roport (le systÃ¨me Linux) :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚             AÃ‰ROPORT (SystÃ¨me)              â”‚
â”‚                                             â”‚
â”‚  Porte A          Porte B          Porte C  â”‚
â”‚     â”‚                â”‚                â”‚     â”‚
â”‚     â–¼                â–¼                â–¼     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚Guardâ”‚         â”‚Guardâ”‚         â”‚Guardâ”‚    â”‚
â”‚  â”‚ BPF â”‚         â”‚ BPF â”‚         â”‚ BPF â”‚    â”‚
â”‚  â”‚  1  â”‚         â”‚  2  â”‚         â”‚  3  â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”˜    â”‚
â”‚     â”‚                â”‚                â”‚     â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                      â”‚                      â”‚
â”‚            Rapport au centre                â”‚
â”‚            (BPF Maps)                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

- **Garde 1** (Porte A) : VÃ©rifie les passeports â†’ Programme BPF qui trace les appels systÃ¨me
- **Garde 2** (Porte B) : Scanne les bagages â†’ Programme BPF qui filtre les paquets rÃ©seau
- **Garde 3** (Porte C) : ContrÃ´le les visas â†’ Programme BPF qui dÃ©tecte les comportements suspects

Chaque garde :
- Suit des **rÃ¨gles strictes** (vÃ©rificateur)
- Travaille **trÃ¨s rapidement** (JIT compilation)
- Rapporte au **centre de contrÃ´le** (BPF Maps)
- Peut **arrÃªter** quelqu'un si nÃ©cessaire (modifier le comportement)

---

## ğŸ“‹ Structure d'un Programme BPF

### Anatomie de Base

Voici la structure typique d'un programme BPF simple :

```c
#include <linux/bpf.h>
#include <bpf/bpf_helpers.h>

// DÃ©claration d'une BPF Map (pour stocker des donnÃ©es)
struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 1024);
    __type(key, __u32);
    __type(value, __u64);
} my_map SEC(".maps");

// Le programme BPF lui-mÃªme
SEC("tracepoint/syscalls/sys_enter_open")  
int trace_open(struct trace_event_raw_sys_enter *ctx)  
{
    __u32 pid = bpf_get_current_pid_tgid() >> 32;
    __u64 *count;

    // Chercher l'entrÃ©e dans la map
    count = bpf_map_lookup_elem(&my_map, &pid);

    if (count) {
        // IncrÃ©menter le compteur
        __sync_fetch_and_add(count, 1);
    } else {
        // CrÃ©er une nouvelle entrÃ©e
        __u64 init_val = 1;
        bpf_map_update_elem(&my_map, &pid, &init_val, BPF_ANY);
    }

    return 0;
}

char LICENSE[] SEC("license") = "GPL";
```

### DÃ©cortiquons ce Code

**1. Les Includes**
```c
#include <linux/bpf.h>        // DÃ©finitions eBPF de base
#include <bpf/bpf_helpers.h>  // Fonctions helper (bpf_get_current_pid_tgid, etc.)
```

**2. La Section Maps**
```c
struct {
    __uint(type, BPF_MAP_TYPE_HASH);  // Type : Table de hachage
    __uint(max_entries, 1024);         // Maximum 1024 entrÃ©es
    __type(key, __u32);                // ClÃ© = entier 32 bits (PID)
    __type(value, __u64);              // Valeur = entier 64 bits (compteur)
} my_map SEC(".maps");
```
Cette structure dÃ©finit une **BPF Map** (nous verrons cela en dÃ©tail dans la section 21.2.2).

**3. Le Point d'EntrÃ©e du Programme**
```c
SEC("tracepoint/syscalls/sys_enter_open")  
int trace_open(struct trace_event_raw_sys_enter *ctx)  
```
- `SEC("tracepoint/...")` : Indique **oÃ¹** le programme sera attachÃ©
- `ctx` : Contexte contenant les informations sur l'Ã©vÃ©nement

**4. La Logique**
```c
__u32 pid = bpf_get_current_pid_tgid() >> 32;  // RÃ©cupÃ¨re le PID
count = bpf_map_lookup_elem(&my_map, &pid);     // Cherche dans la map
// ... IncrÃ©mente ou crÃ©e l'entrÃ©e
```

**5. La Licence**
```c
char LICENSE[] SEC("license") = "GPL";
```
Obligatoire ! Indique que le code est GPL (requis pour utiliser certaines fonctions kernel).

---

## ğŸ£ Types de Programmes BPF et Points d'Attachement

Les programmes BPF peuvent Ãªtre attachÃ©s Ã  diffÃ©rents **hooks** (points d'accroche) dans le noyau. Chaque type de programme a un usage spÃ©cifique.

### Vue d'Ensemble

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    NOYAU LINUX                          â”‚
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚           POINTS D'ATTACHEMENT (Hooks)          â”‚    â”‚
â”‚  â”‚                                                 â”‚    â”‚
â”‚  â”‚  1. TRACEPOINTS                                 â”‚    â”‚
â”‚  â”‚     â€¢ Ã‰vÃ©nements kernel prÃ©dÃ©finis              â”‚    â”‚
â”‚  â”‚     â€¢ Stable API                                â”‚    â”‚
â”‚  â”‚                                                 â”‚    â”‚
â”‚  â”‚  2. KPROBES / KRETPROBES                        â”‚    â”‚
â”‚  â”‚     â€¢ N'importe quelle fonction kernel          â”‚    â”‚
â”‚  â”‚     â€¢ API instable (peut changer)               â”‚    â”‚
â”‚  â”‚                                                 â”‚    â”‚
â”‚  â”‚  3. UPROBES / URETPROBES                        â”‚    â”‚
â”‚  â”‚     â€¢ Fonctions en espace utilisateur           â”‚    â”‚
â”‚  â”‚     â€¢ Instrumentation d'applications            â”‚    â”‚
â”‚  â”‚                                                 â”‚    â”‚
â”‚  â”‚  4. XDP (eXpress Data Path)                     â”‚    â”‚
â”‚  â”‚     â€¢ Paquets rÃ©seau (trÃ¨s tÃ´t)                 â”‚    â”‚
â”‚  â”‚     â€¢ Performance maximale                      â”‚    â”‚
â”‚  â”‚                                                 â”‚    â”‚
â”‚  â”‚  5. TC (Traffic Control)                        â”‚    â”‚
â”‚  â”‚     â€¢ Paquets rÃ©seau (pile TCP/IP)              â”‚    â”‚
â”‚  â”‚     â€¢ Ingress et egress                         â”‚    â”‚
â”‚  â”‚                                                 â”‚    â”‚
â”‚  â”‚  6. SOCKET FILTERS                              â”‚    â”‚
â”‚  â”‚     â€¢ Filtrage de sockets                       â”‚    â”‚
â”‚  â”‚                                                 â”‚    â”‚
â”‚  â”‚  7. CGROUP                                      â”‚    â”‚
â”‚  â”‚     â€¢ Ã‰vÃ©nements liÃ©s aux cgroups               â”‚    â”‚
â”‚  â”‚     â€¢ ContrÃ´le de ressources                    â”‚    â”‚
â”‚  â”‚                                                 â”‚    â”‚
â”‚  â”‚  8. LSM (Linux Security Modules)                â”‚    â”‚
â”‚  â”‚     â€¢ SÃ©curitÃ© (depuis Linux 5.7)               â”‚    â”‚
â”‚  â”‚                                                 â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1. Tracepoints

Les **tracepoints** sont des points d'instrumentation statiques dans le noyau, placÃ©s par les dÃ©veloppeurs du kernel.

**CaractÃ©ristiques** :
- âœ… **API stable** : Ne changent pas entre versions du kernel
- âœ… **Bien documentÃ©s** : Chaque tracepoint a une structure dÃ©finie
- âœ… **Peu nombreux** : Seulement ~1000 tracepoints dans le kernel
- âœ… **Performance** : Overhead minimal

**Exemples de tracepoints** :
```bash
# Lister tous les tracepoints disponibles
$ sudo cat /sys/kernel/debug/tracing/available_events | head

# Exemples :
# syscalls:sys_enter_open   â†’ Appel systÃ¨me open()
# syscalls:sys_exit_read    â†’ Retour de l'appel read()
# sched:sched_process_exec  â†’ ExÃ©cution d'un nouveau processus
# net:netif_rx              â†’ RÃ©ception d'un paquet rÃ©seau
```

**Exemple de programme** :
```c
SEC("tracepoint/syscalls/sys_enter_write")  
int trace_write(struct trace_event_raw_sys_enter *ctx)  
{
    // RÃ©cupÃ¨re le file descriptor (1er argument)
    int fd = (int)ctx->args[0];

    if (fd == 1 || fd == 2) {  // stdout ou stderr
        bpf_trace_printk("Process writing to console\n");
    }

    return 0;
}
```

**Cas d'usage** :
- Tracer les appels systÃ¨me
- Surveiller la crÃ©ation de processus
- Observer les Ã©vÃ©nements rÃ©seau
- Monitoring du scheduler

---

### 2. Kprobes / Kretprobes

Les **kprobes** permettent d'attacher un programme BPF Ã  **n'importe quelle fonction du kernel**, mÃªme celles sans tracepoint.

**CaractÃ©ristiques** :
- âš ï¸ **API instable** : Les noms de fonctions peuvent changer
- âœ… **FlexibilitÃ© totale** : AccÃ¨s Ã  toutes les fonctions kernel
- âœ… **TrÃ¨s nombreux** : Des milliers de fonctions disponibles
- âš ï¸ **PortabilitÃ© rÃ©duite** : Code peut casser entre versions

**DiffÃ©rence kprobe vs kretprobe** :
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    Fonction Kernel                   â”‚
â”‚                                      â”‚
â”‚    int my_function(int arg)          â”‚
â”‚    {                                 â”‚
â”‚  â—„â”€â”€â”€ KPROBE (entrÃ©e)                â”‚
â”‚        // Code de la fonction        â”‚
â”‚        return result;                â”‚
â”‚  â—„â”€â”€â”€ KRETPROBE (sortie)             â”‚
â”‚    }                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Exemple de programme** :
```c
SEC("kprobe/tcp_connect")  
int BPF_KPROBE(trace_tcp_connect, struct sock *sk)  
{
    __u32 pid = bpf_get_current_pid_tgid() >> 32;
    bpf_trace_printk("PID %d opening TCP connection\n", pid);
    return 0;
}

SEC("kretprobe/tcp_connect")  
int BPF_KRETPROBE(trace_tcp_connect_ret, int ret)  
{
    bpf_trace_printk("TCP connect returned: %d\n", ret);
    return 0;
}
```

**Cas d'usage** :
- Instrumentation de fonctions spÃ©cifiques
- Debugging du kernel
- Mesure de latence de fonctions
- Analyse de comportement interne

---

### 3. Uprobes / Uretprobes

Les **uprobes** permettent d'instrumenter des fonctions dans les **applications en espace utilisateur**.

**CaractÃ©ristiques** :
- âœ… **Instrumentation sans modification** : Pas besoin de recompiler l'app
- âœ… **Tout langage** : C, C++, Go, Python, etc.
- âš ï¸ **Symboles nÃ©cessaires** : L'application doit avoir des symboles de debug
- âœ… **Dynamique** : Attacher/dÃ©tacher Ã  chaud

**Exemple** : Tracer les requÃªtes MySQL
```c
SEC("uprobe/usr/bin/mysqld:mysql_parse")  
int trace_mysql_query(struct pt_regs *ctx)  
{
    char query[256];

    // Lire l'argument (pointeur vers la requÃªte SQL)
    bpf_probe_read_user(&query, sizeof(query), (void *)PT_REGS_PARM2(ctx));

    bpf_trace_printk("SQL Query: %s\n", query);
    return 0;
}
```

**Cas d'usage** :
- Profiling d'applications
- Tracing de bibliothÃ¨ques (libc, OpenSSL)
- Debugging sans recompilation
- Analyse de performance

---

### 4. XDP (eXpress Data Path)

**XDP** est un type de programme BPF spÃ©cialisÃ© pour le traitement de paquets rÃ©seau **ultra-rapide**.

**CaractÃ©ristiques** :
- âš¡ **Performance extrÃªme** : 20-50 nanosecondes par paquet
- ğŸš€ **ExÃ©cution trÃ¨s tÃ´t** : Avant mÃªme la pile TCP/IP
- âœ… **Zero-copy** : Pas de copie de paquets
- ğŸ¯ **Actions simples** : PASS, DROP, REDIRECT, TX

**Position dans la pile rÃ©seau** :
```
Paquet rÃ©seau entrant
         â”‚
         â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   NIC   â”‚ (Carte rÃ©seau)
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
         â”‚
         â–¼
  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
  â•‘ Programme XDPâ•‘  â—„â”€â”€â”€ ICI ! (avant tout traitement)
  â•‘   (eBPF)     â•‘
  â•šâ•â•â•â•â•â•â•¤â•â•â•â•â•â•â•â•
         â”‚
    DÃ©cision ?
         â”‚
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
    â”‚         â”‚
    â–¼         â–¼
  DROP      PASS
            â”‚
            â–¼
       Pile TCP/IP
       (iptables, etc.)
```

**Actions XDP** :
- `XDP_PASS` : Laisse passer le paquet (traitement normal)
- `XDP_DROP` : Rejette le paquet (ex: DDoS protection)
- `XDP_TX` : Renvoie le paquet sur la mÃªme interface
- `XDP_REDIRECT` : Redirige vers une autre interface
- `XDP_ABORTED` : Erreur (paquet rejetÃ© + log)

**Exemple** : Filtrage anti-DDoS simple
```c
SEC("xdp")  
int xdp_filter(struct xdp_md *ctx)  
{
    void *data_end = (void *)(long)ctx->data_end;
    void *data = (void *)(long)ctx->data;

    struct ethhdr *eth = data;

    // VÃ©rifier qu'on a assez de donnÃ©es
    if ((void *)(eth + 1) > data_end)
        return XDP_PASS;

    // Bloquer tous les paquets non-IPv4
    if (eth->h_proto != bpf_htons(ETH_P_IP))
        return XDP_DROP;

    struct iphdr *ip = (void *)(eth + 1);
    if ((void *)(ip + 1) > data_end)
        return XDP_PASS;

    // Bloquer une IP spÃ©cifique (exemple: 192.168.1.100)
    if (ip->saddr == bpf_htonl(0xC0A80164))  // 192.168.1.100 en hex
        return XDP_DROP;

    return XDP_PASS;
}
```

**Cas d'usage** :
- Protection DDoS
- Load balancing L4
- Filtrage de paquets haute performance
- Firewall ultra-rapide

**Performance** :
- **iptables** : ~1-10 Âµs par paquet
- **XDP** : ~0.02-0.05 Âµs par paquet
- **Gain** : 200-500x plus rapide !

---

### 5. Traffic Control (TC)

Les programmes **TC** s'exÃ©cutent au niveau de la pile **Traffic Control** de Linux, aprÃ¨s le traitement XDP.

**CaractÃ©ristiques** :
- âœ… **Plus de contexte** : AccÃ¨s Ã  la pile rÃ©seau complÃ¨te
- âœ… **Ingress et Egress** : Paquets entrants et sortants
- âœ… **Modification** : Peut modifier les paquets
- âš ï¸ **Moins rapide** : Plus lent que XDP (mais toujours trÃ¨s rapide)

**Position dans la pile** :
```
Paquet entrant (Ingress)
         â”‚
         â–¼
       XDP
         â”‚
         â–¼
  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•—
  â•‘ Programme  â•‘  â—„â”€â”€â”€ TC Ingress
  â•‘ TC Ingress â•‘
  â•šâ•â•â•â•â•â•¤â•â•â•â•â•â•â•
        â”‚
        â–¼
   Pile TCP/IP
   (Routing, etc.)
        â”‚
        â–¼
  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•—
  â•‘ Programme  â•‘  â—„â”€â”€â”€ TC Egress
  â•‘ TC Egress  â•‘
  â•šâ•â•â•â•â•â•¤â•â•â•â•â•â•â•
        â”‚
        â–¼
    Interface NIC
        â”‚
        â–¼
  Paquet sortant
```

**Exemple** : Limiter la bande passante
```c
SEC("tc")  
int tc_rate_limit(struct __sk_buff *skb)  
{
    // VÃ©rifier si la bande passante est dÃ©passÃ©e
    __u64 current_rate = get_current_rate();  // Fonction helper custom

    if (current_rate > MAX_BANDWIDTH) {
        return TC_ACT_SHOT;  // Rejeter le paquet
    }

    return TC_ACT_OK;  // Accepter le paquet
}
```

**Cas d'usage** :
- QoS (Quality of Service)
- Limitation de bande passante
- Modification de paquets
- Encapsulation/dÃ©capsulation (tunnels)

---

### 6. Socket Filters

Les programmes **socket filter** s'attachent Ã  des sockets individuels pour filtrer les paquets.

**CaractÃ©ristiques** :
- âœ… **Par socket** : Filtrage granulaire
- âœ… **Compatible BPF classique** : Ancien type de programme
- âœ… **UtilisÃ© par tcpdump/Wireshark**

**Exemple** :
```c
SEC("socket")  
int socket_filter(struct __sk_buff *skb)  
{
    // Filtrer uniquement les paquets TCP vers le port 80
    struct iphdr *ip = (void *)(long)skb->data;
    struct tcphdr *tcp = (void *)ip + sizeof(*ip);

    if (tcp->dest == bpf_htons(80)) {
        return 1;  // Accepter
    }

    return 0;  // Rejeter
}
```

---

### 7. Cgroup Programs

Les programmes **cgroup** permettent de contrÃ´ler le comportement des processus dans un cgroup.

**Types** :
- `BPF_CGROUP_INET_INGRESS` : Paquets entrants
- `BPF_CGROUP_INET_EGRESS` : Paquets sortants
- `BPF_CGROUP_SOCK_OPS` : OpÃ©rations sur sockets
- `BPF_CGROUP_DEVICE` : AccÃ¨s aux pÃ©riphÃ©riques
- `BPF_CGROUP_SYSCTL` : AccÃ¨s aux sysctls

**Cas d'usage** :
- SÃ©curitÃ© des containers
- Limitation de ressources
- Politiques rÃ©seau par container
- ContrÃ´le d'accÃ¨s aux devices

---

### 8. LSM (Linux Security Modules)

Depuis Linux 5.7, eBPF peut s'attacher aux **hooks LSM** pour la sÃ©curitÃ©.

**CaractÃ©ristiques** :
- âœ… **DÃ©cisions de sÃ©curitÃ©** : Autoriser/refuser des actions
- âœ… **Remplace les modules de sÃ©curitÃ©** : Alternative Ã  SELinux/AppArmor
- âœ… **GranularitÃ© fine** : ContrÃ´le prÃ©cis

**Exemple** : EmpÃªcher l'accÃ¨s Ã  un fichier
```c
SEC("lsm/file_open")  
int BPF_PROG(restrict_file_open, struct file *file)  
{
    char filename[256];
    bpf_d_path(&file->f_path, filename, sizeof(filename));

    // Bloquer l'accÃ¨s Ã  /etc/shadow
    if (bpf_strncmp(filename, "/etc/shadow", 11) == 0) {
        return -EPERM;  // Permission denied
    }

    return 0;  // Autoriser
}
```

---

## ğŸ”„ Cycle de Vie d'un Programme BPF

### 1. Ã‰criture et Compilation

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. Ã‰criture du code C                   â”‚
â”‚     (avec restrictions eBPF)             â”‚
â”‚                                          â”‚
â”‚     my_program.bpf.c                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  2. Compilation avec clang               â”‚
â”‚     $ clang -O2 -target bpf -c \         â”‚
â”‚       my_program.bpf.c -o my_program.o   â”‚
â”‚                                          â”‚
â”‚     â†’ GÃ©nÃ¨re du bytecode eBPF            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  3. Fichier objet ELF                    â”‚
â”‚     my_program.o                         â”‚
â”‚                                          â”‚
â”‚     Contient :                           â”‚
â”‚     â€¢ Bytecode eBPF                      â”‚
â”‚     â€¢ MÃ©tadonnÃ©es (sections, relocations)â”‚
â”‚     â€¢ DÃ©finitions de maps                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. Chargement dans le Noyau

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  4. Chargement via bpf() syscall         â”‚
â”‚     (depuis l'espace utilisateur)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         NOYAU LINUX                      â”‚
â”‚                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  5. VÃ‰RIFICATEUR                   â”‚  â”‚
â”‚  â”‚     â€¢ Analyse statique             â”‚  â”‚
â”‚  â”‚     â€¢ VÃ©rification sÃ©curitÃ©        â”‚  â”‚
â”‚  â”‚     â€¢ Garantie de terminaison      â”‚  â”‚
â”‚  â”‚                                    â”‚  â”‚
â”‚  â”‚     âœ“ SÃ»r ? â†’ Continue             â”‚  â”‚
â”‚  â”‚     âœ— Dangereux ? â†’ REJET          â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚             â”‚                            â”‚
â”‚             â–¼                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  6. JIT COMPILATION                â”‚  â”‚
â”‚  â”‚     Bytecode eBPF â†’ Code natif     â”‚  â”‚
â”‚  â”‚     (x86-64, ARM64, etc.)          â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚             â”‚                            â”‚
â”‚             â–¼                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  7. Programme chargÃ© en mÃ©moire    â”‚  â”‚
â”‚  â”‚     PrÃªt Ã  Ãªtre attachÃ©            â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3. Attachement Ã  un Hook

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  8. Attachement au point d'accroche      â”‚
â”‚                                          â”‚
â”‚     Exemple :                            â”‚
â”‚     â€¢ Tracepoint                         â”‚
â”‚     â€¢ Kprobe                             â”‚
â”‚     â€¢ XDP interface                      â”‚
â”‚     â€¢ Socket                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  9. ExÃ©cution automatique                â”‚
â”‚                                          â”‚
â”‚     Ã‰vÃ©nement â†’ Programme BPF dÃ©clenchÃ©  â”‚
â”‚                                          â”‚
â”‚     Le programme :                       â”‚
â”‚     â€¢ Inspecte l'Ã©vÃ©nement               â”‚
â”‚     â€¢ Prend des dÃ©cisions                â”‚
â”‚     â€¢ Stocke des donnÃ©es dans maps       â”‚
â”‚     â€¢ Retourne un code                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4. DÃ©tachement et Nettoyage

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  10. DÃ©tachement (quand plus nÃ©cessaire) â”‚
â”‚                                          â”‚
â”‚      â€¢ Programme dÃ©tachÃ© du hook         â”‚
â”‚      â€¢ Mais reste en mÃ©moire (rÃ©fÃ©rencÃ©) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  11. LibÃ©ration des ressources           â”‚
â”‚                                          â”‚
â”‚      Quand plus aucune rÃ©fÃ©rence :       â”‚
â”‚      â€¢ Programme supprimÃ©                â”‚
â”‚      â€¢ Maps supprimÃ©es (si non utilisÃ©es)â”‚
â”‚      â€¢ MÃ©moire libÃ©rÃ©e                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## âš ï¸ Restrictions et Contraintes

Les programmes BPF ont des **limitations strictes** pour garantir la sÃ©curitÃ©. Voici les principales :

### 1. Taille LimitÃ©e

```
Limite du vÃ©rificateur : ~1 million d'instructions
```

**Pourquoi ?** Pour garantir que la vÃ©rification se termine en temps raisonnable.

**Contournement** : Tail calls (appeler un autre programme BPF)

### 2. Pas de Boucles Non BornÃ©es

```c
// âŒ INTERDIT - Boucle potentiellement infinie
for (int i = 0; i < n; i++) {  // n pourrait Ãªtre Ã©norme
    do_something();
}

// âœ… AUTORISÃ‰ - Boucle bornÃ©e avec constante
#pragma unroll
for (int i = 0; i < 10; i++) {  // 10 est une constante
    do_something();
}

// âœ… AUTORISÃ‰ - Boucle vÃ©rifiable
for (int i = 0; i < 100 && i < len; i++) {  // Maximum garanti
    do_something();
}
```

**Depuis Linux 5.3** : Boucles bornÃ©es autorisÃ©es si le vÃ©rificateur peut prouver qu'elles se terminent.

### 3. Pas d'AccÃ¨s MÃ©moire Arbitraire

```c
// âŒ INTERDIT - Pointeur non vÃ©rifiÃ©
int *ptr = (int *)0x12345678;
*ptr = 42;  // Le vÃ©rificateur rejette ceci

// âœ… AUTORISÃ‰ - Pointeur validÃ©
int *ptr = bpf_map_lookup_elem(&my_map, &key);  
if (ptr) {  // VÃ©rification obligatoire !  
    *ptr = 42;  // OK aprÃ¨s vÃ©rification
}
```

### 4. Pile LimitÃ©e

```
Stack size : 512 bytes maximum
```

**ConsÃ©quences** :
- Pas de grosses variables locales
- Utiliser les maps pour les grandes structures

```c
// âŒ INTERDIT - Trop gros pour la pile
char buffer[4096];  // 4 KB > 512 bytes

// âœ… AUTORISÃ‰ - Via une map
struct {
    __uint(type, BPF_MAP_TYPE_PERCPU_ARRAY);
    __uint(max_entries, 1);
    __type(key, __u32);
    __type(value, char[4096]);
} buffer_map SEC(".maps");

// Utilisation :
__u32 key = 0;
char *buffer = bpf_map_lookup_elem(&buffer_map, &key);  
if (buffer) {  
    // Utiliser buffer
}
```

### 5. Fonctions Restreintes

Vous ne pouvez pas appeler n'importe quelle fonction. Seulement :
- **Helper functions** : Fonctions fournies par le kernel (prÃ©fixe `bpf_`)
- **Fonctions inline** : Votre propre code (marquÃ© `static __always_inline`)

```c
// âŒ INTERDIT - Fonction externe non inline
int my_function(int x) {
    return x * 2;
}

// âœ… AUTORISÃ‰ - Fonction inline
static __always_inline int my_function(int x) {
    return x * 2;
}

// âœ… AUTORISÃ‰ - Helper function
__u64 pid = bpf_get_current_pid_tgid();
```

### 6. Pas d'Allocation Dynamique

```c
// âŒ INTERDIT - malloc/calloc n'existent pas
void *ptr = malloc(1024);

// âœ… AUTORISÃ‰ - Utiliser une map
struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    // ...
} my_map SEC(".maps");

void *data = bpf_map_lookup_elem(&my_map, &key);
```

### 7. Pas de Locks/Mutex Traditionnels

```c
// âŒ INTERDIT - pthread_mutex, spinlock, etc.
pthread_mutex_lock(&mutex);

// âœ… AUTORISÃ‰ - Atomics
__sync_fetch_and_add(&counter, 1);

// âœ… AUTORISÃ‰ - Map spinlock (depuis Linux 5.1)
struct bpf_spin_lock lock;  
bpf_spin_lock(&lock);  
// Section critique
bpf_spin_unlock(&lock);
```

---

## ğŸ“ Exemple Complet CommentÃ©

Voici un programme BPF complet qui compte les octets lus par chaque processus :

```c
// SPDX-License-Identifier: GPL-2.0
#include <linux/bpf.h>
#include <bpf/bpf_helpers.h>

// Structure pour stocker les statistiques par processus
struct stats {
    __u64 count;        // Nombre d'appels read()
    __u64 total_bytes;  // Total d'octets lus
};

// Map : PID â†’ Stats
struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 10240);  // Max 10240 processus
    __type(key, __u32);           // ClÃ© = PID
    __type(value, struct stats);  // Valeur = statistiques
} read_stats SEC(".maps");

// Programme attachÃ© Ã  l'appel systÃ¨me read()
SEC("tracepoint/syscalls/sys_exit_read")  
int trace_read_exit(struct trace_event_raw_sys_exit *ctx)  
{
    // RÃ©cupÃ©rer le PID du processus actuel
    __u64 pid_tgid = bpf_get_current_pid_tgid();
    __u32 pid = pid_tgid >> 32;  // Les 32 bits de poids fort = PID

    // RÃ©cupÃ©rer la valeur de retour (nombre d'octets lus)
    long bytes_read = ctx->ret;

    // Ignorer les erreurs (ret < 0)
    if (bytes_read < 0)
        return 0;

    // Chercher les stats existantes
    struct stats *stat = bpf_map_lookup_elem(&read_stats, &pid);

    if (stat) {
        // Mettre Ã  jour les stats existantes
        __sync_fetch_and_add(&stat->count, 1);
        __sync_fetch_and_add(&stat->total_bytes, bytes_read);
    } else {
        // CrÃ©er une nouvelle entrÃ©e
        struct stats new_stat = {
            .count = 1,
            .total_bytes = bytes_read,
        };
        bpf_map_update_elem(&read_stats, &pid, &new_stat, BPF_ANY);
    }

    return 0;
}

// Licence GPL obligatoire
char LICENSE[] SEC("license") = "GPL";
```

**Ce que fait ce programme** :
1. S'attache au tracepoint `sys_exit_read` (quand read() retourne)
2. Extrait le PID et le nombre d'octets lus
3. Met Ã  jour ou crÃ©e les statistiques dans la map
4. Les stats sont accessibles depuis l'espace utilisateur

**Pour compiler** :
```bash
$ clang -O2 -target bpf -c trace_read.bpf.c -o trace_read.bpf.o
```

**Pour charger** (avec bpftool) :
```bash
# Charger le programme
$ sudo bpftool prog load trace_read.bpf.o /sys/fs/bpf/trace_read

# Attacher au tracepoint
$ sudo bpftool prog attach pinned /sys/fs/bpf/trace_read \
    tracepoint syscalls sys_exit_read

# Voir les stats (via bpftool map dump)
$ sudo bpftool map dump name read_stats
```

---

## ğŸ”§ Helper Functions Essentielles

Les programmes BPF peuvent appeler des **helper functions** fournies par le kernel. En voici quelques-unes parmi les plus utiles :

### Informations sur le Contexte

```c
// Obtenir le PID/TID actuel
__u64 pid_tgid = bpf_get_current_pid_tgid();
__u32 pid = pid_tgid >> 32;    // PID (processus)
__u32 tid = (__u32)pid_tgid;     // TID (thread) - 32 bits de poids faible

// Obtenir le nom du processus (comm)
char comm[16];  
bpf_get_current_comm(&comm, sizeof(comm));  
// comm contient maintenant "firefox", "bash", etc.

// Obtenir l'UID/GID actuel
__u64 uid_gid = bpf_get_current_uid_gid();
__u32 uid = uid_gid & 0xFFFFFFFF;
__u32 gid = uid_gid >> 32;
```

### Lecture de MÃ©moire

```c
// Lire depuis l'espace kernel (sÃ»r)
int ret = bpf_probe_read_kernel(&local_var, sizeof(local_var), kernel_ptr);

// Lire depuis l'espace utilisateur (sÃ»r)
int ret = bpf_probe_read_user(&local_var, sizeof(local_var), user_ptr);

// Lire une string utilisateur
char str[256];  
bpf_probe_read_user_str(&str, sizeof(str), user_string_ptr);  
```

### Debugging et Logging

```c
// Afficher dans le kernel log (via /sys/kernel/debug/tracing/trace_pipe)
bpf_trace_printk("Hello from eBPF! PID=%d\n", pid);

// Envoyer des Ã©vÃ©nements structurÃ©s (ring buffer)
struct event {
    __u32 pid;
    char comm[16];
};

struct event *e = bpf_ringbuf_reserve(&ringbuf, sizeof(*e), 0);  
if (e) {  
    e->pid = pid;
    bpf_get_current_comm(&e->comm, sizeof(e->comm));
    bpf_ringbuf_submit(e, 0);
}
```

### Temps et Timestamps

```c
// Obtenir le temps en nanosecondes (monotonic clock)
__u64 ts = bpf_ktime_get_ns();

// Calculer une latence
__u64 start = bpf_ktime_get_ns();
// ... opÃ©ration ...
__u64 duration = bpf_ktime_get_ns() - start;
```

### Manipulation de Maps

```c
// Lookup (chercher)
void *value = bpf_map_lookup_elem(&my_map, &key);

// Update (crÃ©er ou mettre Ã  jour)
bpf_map_update_elem(&my_map, &key, &value, BPF_ANY);

// Delete (supprimer)
bpf_map_delete_elem(&my_map, &key);

// Peek (ring buffer)
struct event *e = bpf_ringbuf_reserve(&ringbuf, size, 0);
```

---

## ğŸ“Š Tableau RÃ©capitulatif des Types de Programmes

| Type | Cas d'usage | Performance | StabilitÃ© API | PrivilÃ¨ges |
|------|-------------|-------------|---------------|------------|
| **Tracepoint** | Tracing stable | â­â­â­â­ | âœ… Stable | root |
| **Kprobe** | Tracing flexible | â­â­â­â­ | âš ï¸ Instable | root |
| **Uprobe** | Tracing userspace | â­â­â­ | âš ï¸ DÃ©pend de l'app | root |
| **XDP** | RÃ©seau ultra-rapide | â­â­â­â­â­ | âœ… Stable | root + CAP_NET_ADMIN |
| **TC** | QoS/Modification paquets | â­â­â­â­ | âœ… Stable | root + CAP_NET_ADMIN |
| **Socket Filter** | Filtrage par socket | â­â­â­â­ | âœ… Stable | root |
| **Cgroup** | ContrÃ´le containers | â­â­â­â­ | âœ… Stable | root |
| **LSM** | SÃ©curitÃ© | â­â­â­â­ | âœ… Stable | root + CAP_BPF |

---

## ğŸ’¡ Bonnes Pratiques

### 1. Toujours VÃ©rifier les Pointeurs

```c
// âŒ MAUVAIS
void *ptr = bpf_map_lookup_elem(&map, &key);
*ptr = 42;  // CRASH si ptr == NULL

// âœ… BON
void *ptr = bpf_map_lookup_elem(&map, &key);  
if (ptr) {  
    *ptr = 42;  // SÃ»r
}
```

### 2. Utiliser CO-RE pour la PortabilitÃ©

CO-RE (Compile Once - Run Everywhere) permet Ã  votre programme de fonctionner sur diffÃ©rentes versions du kernel.

```c
#include <vmlinux.h>  // GÃ©nÃ©rÃ© avec bpftool btf dump
#include <bpf/bpf_core_read.h>

// Lire un champ de structure de faÃ§on portable
struct task_struct *task = (void *)bpf_get_current_task();  
pid_t pid = BPF_CORE_READ(task, pid);  
```

### 3. Limiter l'Overhead

```c
// Filtrer tÃ´t pour Ã©viter du travail inutile
SEC("tracepoint/syscalls/sys_enter_open")  
int trace_open(struct trace_event_raw_sys_enter *ctx)  
{
    __u32 pid = bpf_get_current_pid_tgid() >> 32;

    // Filtrer : ignorer systemd (PID 1)
    if (pid == 1)
        return 0;  // Retour rapide

    // Le reste du code ne s'exÃ©cute que pour les autres processus
    // ...
}
```

### 4. Utiliser des Tail Calls pour les Programmes Longs

Si votre logique dÃ©passe la limite, divisez en plusieurs programmes :

```c
// Map pour les tail calls
struct {
    __uint(type, BPF_MAP_TYPE_PROG_ARRAY);
    __uint(max_entries, 2);
    __type(key, __u32);
    __type(value, __u32);
} prog_array SEC(".maps");

// Premier programme
SEC("xdp")  
int xdp_prog_1(struct xdp_md *ctx)  
{
    // Traitement partie 1
    // ...

    // Appeler le programme suivant
    bpf_tail_call(ctx, &prog_array, 1);

    return XDP_DROP;  // Fallback si tail call Ã©choue
}

// DeuxiÃ¨me programme
SEC("xdp")  
int xdp_prog_2(struct xdp_md *ctx)  
{
    // Traitement partie 2
    // ...
    return XDP_PASS;
}
```

---

## ğŸ“ RÃ©sumÃ©

Les **programmes BPF** sont le cÅ“ur d'eBPF. Voici les points clÃ©s Ã  retenir :

**Qu'est-ce qu'un programme BPF ?**
- Petit programme en C exÃ©cutÃ© dans le noyau
- VÃ©rifiÃ© pour garantir la sÃ©curitÃ©
- CompilÃ© en code natif (JIT)
- DÃ©clenchÃ© par des Ã©vÃ©nements

**Types principaux** :
- **Tracepoint** : Ã‰vÃ©nements kernel stables
- **Kprobe/Kretprobe** : N'importe quelle fonction kernel
- **Uprobe/Uretprobe** : Fonctions en espace utilisateur
- **XDP** : Paquets rÃ©seau ultra-rapides
- **TC** : Traffic control et QoS
- **Socket Filter** : Filtrage par socket
- **Cgroup** : ContrÃ´le des containers
- **LSM** : SÃ©curitÃ©

**Restrictions** :
- Taille limitÃ©e (~1M instructions)
- Pas de boucles infinies
- Pile limitÃ©e (512 bytes)
- Pas d'accÃ¨s mÃ©moire arbitraire
- Seulement les helper functions kernel

**Cycle de vie** :
1. Ã‰criture en C
2. Compilation en bytecode
3. VÃ©rification par le kernel
4. JIT compilation
5. Attachement Ã  un hook
6. ExÃ©cution automatique

---

## ğŸ¯ Prochaine Ã‰tape

Maintenant que vous comprenez les programmes BPF, nous allons explorer la deuxiÃ¨me piÃ¨ce essentielle : **les BPF Maps**.

**ğŸ‘‰ Prochaine section : 21.2.2 BPF Maps**

Les BPF Maps permettent :
- De stocker des donnÃ©es persistantes
- De communiquer entre kernel et userspace
- De partager des informations entre programmes BPF
- De crÃ©er des structures de donnÃ©es complexes

**Ã€ bientÃ´t !** ğŸš€

---

## ğŸ“š RÃ©fÃ©rences

### Documentation Officielle
- [BPF and XDP Reference Guide](https://docs.cilium.io/en/stable/bpf/)
- [Linux Kernel BPF Documentation](https://www.kernel.org/doc/html/latest/bpf/)
- [libbpf API Documentation](https://libbpf.readthedocs.io/)

### Tutoriels
- [BCC Python Developer Tutorial](https://github.com/iovisor/bcc/blob/master/docs/tutorial_bcc_python_developer.md)
- [XDP Tutorial](https://github.com/xdp-project/xdp-tutorial)

### Exemples de Code
- [libbpf-bootstrap](https://github.com/libbpf/libbpf-bootstrap) - Templates pour dÃ©marrer
- [BCC Tools](https://github.com/iovisor/bcc/tree/master/tools) - Outils de performance
- [Cilium eBPF Examples](https://github.com/cilium/ebpf/tree/master/examples)

â­ï¸ [BPF maps](/21-introduction-ebpf/02.2-bpf-maps.md)
