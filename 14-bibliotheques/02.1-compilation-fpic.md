ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 14.2.1 Compilation avec -fPIC

## Introduction

Lorsque vous crÃ©ez une **bibliothÃ¨que dynamique** (`.so`), vous devez compiler votre code d'une maniÃ¨re spÃ©ciale, diffÃ©rente d'un exÃ©cutable normal ou d'une bibliothÃ¨que statique. Cette compilation spÃ©ciale utilise l'option **`-fPIC`**.

Dans cette section, nous allons comprendre ce qu'est le **PIC** (Position Independent Code), pourquoi il est nÃ©cessaire pour les bibliothÃ¨ques partagÃ©es, et comment l'utiliser correctement.

---

## Qu'est-ce que `-fPIC` ?

### DÃ©finition

**`-fPIC`** signifie **"Position Independent Code"** (Code IndÃ©pendant de la Position).

C'est une option de compilation GCC qui gÃ©nÃ¨re du code machine capable de s'exÃ©cuter correctement **quelle que soit l'adresse mÃ©moire** oÃ¹ il est chargÃ©.

### Syntaxe de base

```bash
gcc -fPIC -c fichier.c -o fichier.o
```

**DÃ©composition :**
- `gcc` : Le compilateur
- `-fPIC` : Option pour gÃ©nÃ©rer du code indÃ©pendant de la position
- `-c` : Compile sans linker (gÃ©nÃ¨re un fichier objet)
- `fichier.c` : Votre code source
- `-o fichier.o` : Nom du fichier objet de sortie

---

## Pourquoi avons-nous besoin de `-fPIC` ?

### Le problÃ¨me de l'adressage mÃ©moire

Pour comprendre pourquoi `-fPIC` est nÃ©cessaire, il faut d'abord comprendre comment fonctionne la mÃ©moire.

#### Code normal (sans `-fPIC`)

Quand vous compilez un programme normal, le compilateur gÃ©nÃ¨re du code avec des **adresses absolues** :

```
Programme compilÃ© :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Adresse 0x00400000:     â”‚ â† Adresse fixe, dÃ©finie Ã  la compilation
â”‚   instruction 1         â”‚
â”‚   instruction 2         â”‚
â”‚   call 0x00401234       â”‚ â† Appel direct Ã  une adresse fixe
â”‚   ...                   â”‚
â”‚ Adresse 0x00401234:     â”‚
â”‚   fonction()            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Cela fonctionne bien pour un **exÃ©cutable** car :
- Il est toujours chargÃ© Ã  la mÃªme adresse en mÃ©moire
- Le systÃ¨me d'exploitation rÃ©serve un emplacement fixe

#### ProblÃ¨me avec les bibliothÃ¨ques partagÃ©es

Une bibliothÃ¨que dynamique (`.so`) peut Ãªtre :
- ChargÃ©e par **plusieurs programmes simultanÃ©ment**
- ChargÃ©e Ã  des **adresses mÃ©moire diffÃ©rentes** selon les programmes
- PartagÃ©e entre plusieurs processus

**Illustration du problÃ¨me :**

```
Programme A                     Programme B
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Code app     â”‚                â”‚ Code app     â”‚
â”‚ @0x00400000  â”‚                â”‚ @0x00400000  â”‚
â”‚              â”‚                â”‚              â”‚
â”‚ libmath.so   â”‚                â”‚ libmath.so   â”‚
â”‚ @0x7f100000  â”‚â—„â”€â”             â”‚ @0x7f200000  â”‚â—„â”€â”
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
                  â”‚                               â”‚
         MÃªme bibliothÃ¨que,              Adresses diffÃ©rentes !
         adresse diffÃ©rente
```

Si `libmath.so` est compilÃ©e avec des adresses fixes, elle ne fonctionnera qu'Ã  **une seule adresse**. Avec `-fPIC`, elle peut fonctionner **n'importe oÃ¹** en mÃ©moire.

---

## Comment fonctionne le code PIC ?

### Code sans `-fPIC` (adressage absolu)

```c
// fichier: math_utils.c
int global_counter = 0;

int increment() {
    global_counter++;
    return global_counter;
}
```

**Assembleur gÃ©nÃ©rÃ© (simplifiÃ©, sans `-fPIC`) :**
```asm
increment:
    mov    eax, [0x00601040]     ; Adresse absolue de global_counter
    add    eax, 1
    mov    [0x00601040], eax     ; Ã‰criture Ã  l'adresse absolue
    ret
```

âŒ **ProblÃ¨me :** L'adresse `0x00601040` est **codÃ©e en dur**. Si la bibliothÃ¨que est chargÃ©e ailleurs, elle Ã©crira au mauvais endroit !

### Code avec `-fPIC` (adressage relatif)

**Assembleur gÃ©nÃ©rÃ© (simplifiÃ©, avec `-fPIC`) :**
```asm
increment:
    mov    rax, [rip+offset]     ; Adresse RELATIVE au compteur programme
    add    rax, 1
    mov    [rip+offset], rax     ; Ã‰criture relative
    ret
```

âœ… **Solution :** Les adresses sont calculÃ©es **relativement** Ã  la position actuelle du code (`rip` = instruction pointer). Peu importe oÃ¹ la bibliothÃ¨que est chargÃ©e, les calculs restent corrects !

### MÃ©taphore

**Sans `-fPIC`** : "Allez au 123 rue de la RÃ©publique" (adresse absolue)
- Ne fonctionne que dans une ville spÃ©cifique

**Avec `-fPIC`** : "Allez 3 rues plus loin Ã  droite" (adresse relative)
- Fonctionne quel que soit votre point de dÃ©part

---

## Compilation d'une bibliothÃ¨que partagÃ©e : Workflow complet

### Ã‰tape 1 : CrÃ©er les fichiers source

**Fichier `math_utils.h`** (en-tÃªte) :
```c
#ifndef MATH_UTILS_H
#define MATH_UTILS_H

int addition(int a, int b);  
int multiplication(int a, int b);  

#endif
```

**Fichier `addition.c`** :
```c
#include "math_utils.h"

int addition(int a, int b) {
    return a + b;
}
```

**Fichier `multiplication.c`** :
```c
#include "math_utils.h"

int multiplication(int a, int b) {
    return a * b;
}
```

### Ã‰tape 2 : Compiler avec `-fPIC`

C'est l'Ã©tape cruciale : on compile chaque fichier source avec l'option `-fPIC` :

```bash
gcc -fPIC -c addition.c -o addition.o  
gcc -fPIC -c multiplication.c -o multiplication.o  
```

**RÃ©sultat :** Deux fichiers objets `addition.o` et `multiplication.o` contenant du **code indÃ©pendant de la position**.

### Ã‰tape 3 : CrÃ©er la bibliothÃ¨que partagÃ©e

On lie les fichiers objets pour crÃ©er la bibliothÃ¨que `.so` :

```bash
gcc -shared addition.o multiplication.o -o libmath_utils.so
```

**Options :**
- `-shared` : Indique au linker de crÃ©er une bibliothÃ¨que partagÃ©e
- `addition.o multiplication.o` : Les fichiers objets Ã  inclure
- `-o libmath_utils.so` : Nom de la bibliothÃ¨que (convention : `lib<nom>.so`)

### Workflow en un seul schÃ©ma

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ addition.c  â”‚   â”‚ multipli-   â”‚
â”‚             â”‚   â”‚ cation.c    â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚                 â”‚
       â”‚ gcc -fPIC -c    â”‚ gcc -fPIC -c
       â”‚                 â”‚
       â–¼                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ addition.o  â”‚   â”‚ multipli-   â”‚
â”‚ (PIC code)  â”‚   â”‚ cation.o    â”‚
â”‚             â”‚   â”‚ (PIC code)  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚                 â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â”‚ gcc -shared
                â”‚
                â–¼
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ libmath_     â”‚
         â”‚ utils.so     â”‚
         â”‚              â”‚
         â”‚ BibliothÃ¨que â”‚
         â”‚ partagÃ©e     â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Options de compilation dÃ©taillÃ©es

### `-fPIC` vs `-fpic` (minuscule)

GCC propose deux variantes :

| Option | Description | Usage |
|--------|-------------|-------|
| **`-fPIC`** | Position Independent Code (majuscule) | **RecommandÃ©** - Fonctionne toujours |
| `-fpic` | Position Independent Code (minuscule) | Optimisation plus agressive, peut Ã©chouer |

**DiffÃ©rence :**
- `-fpic` (minuscule) gÃ©nÃ¨re du code plus compact mais a des limitations sur certaines architectures
- `-fPIC` (majuscule) fonctionne dans tous les cas mais gÃ©nÃ¨re un code lÃ©gÃ¨rement plus volumineux

**Recommandation :** Utilisez **toujours `-fPIC`** (majuscule) sauf si vous optimisez pour une architecture spÃ©cifique.

### Flags de compilation recommandÃ©s

Pour une bibliothÃ¨que partagÃ©e de qualitÃ© production :

```bash
gcc -fPIC -Wall -Wextra -O2 -c fichier.c -o fichier.o
```

**Explication des options :**
- `-fPIC` : Code indÃ©pendant de la position
- `-Wall` : Active les avertissements courants
- `-Wextra` : Active encore plus d'avertissements
- `-O2` : Optimisation de niveau 2 (bon compromis vitesse/taille)

### Compilation en une seule ligne

On peut compiler et crÃ©er la bibliothÃ¨que en une seule commande :

```bash
gcc -fPIC -shared addition.c multiplication.c -o libmath_utils.so
```

Cette commande fait tout d'un coup :
1. Compile `addition.c` et `multiplication.c` avec `-fPIC`
2. CrÃ©e les fichiers objets en interne
3. Les lie en une bibliothÃ¨que partagÃ©e `libmath_utils.so`

**Avantage :** Rapide pour de petits projets  
**InconvÃ©nient :** Recompile tout Ã  chaque modification (pas de compilation incrÃ©mentale)  

---

## VÃ©rification du code PIC

### VÃ©rifier qu'un fichier objet est bien PIC

Vous pouvez vÃ©rifier si un fichier `.o` a Ã©tÃ© compilÃ© avec `-fPIC` :

```bash
readelf -h addition.o | grep Type
```

Sortie attendue :
```
Type:                              REL (Relocatable file)
```

Pour plus de dÃ©tails sur les relocations :

```bash
readelf -r addition.o
```

Vous verrez des entrÃ©es de type `R_X86_64_PC32` (relatif) au lieu de `R_X86_64_32` (absolu) si le code est bien PIC.

### VÃ©rifier qu'une bibliothÃ¨que `.so` est bien partagÃ©e

```bash
file libmath_utils.so
```

Sortie attendue :
```
libmath_utils.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, not stripped
```

Les mots clÃ©s importants : **"shared object"** et **"dynamically linked"**.

### Lister les symboles exportÃ©s

```bash
nm -D libmath_utils.so
```

Sortie exemple :
```
0000000000001149 T addition
0000000000001160 T multiplication
```

**LÃ©gende :**
- `T` : Symbole dans la section `.text` (code)
- Les adresses sont **relatives** (grÃ¢ce Ã  `-fPIC`)

---

## Que se passe-t-il sans `-fPIC` ?

### Tenter de crÃ©er une `.so` sans `-fPIC`

Si vous oubliez `-fPIC` :

```bash
# âŒ Compilation sans -fPIC
gcc -c addition.c -o addition.o  
gcc -c multiplication.c -o multiplication.o  

# Tentative de crÃ©ation de la bibliothÃ¨que partagÃ©e
gcc -shared addition.o multiplication.o -o libmath_utils.so
```

**RÃ©sultat possible (selon la plateforme) :**

#### Sur x86_64 (64 bits) :

Vous obtiendrez probablement une **erreur** :

```
/usr/bin/ld: addition.o: relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC
/usr/bin/ld: final link failed: Nonrepresentable section on output
collect2: error: ld returned 1 exit status
```

Le linker **refuse** car le code n'est pas indÃ©pendant de la position.

#### Sur i386 (32 bits) :

La compilation **peut rÃ©ussir** mais gÃ©nÃ¨re une bibliothÃ¨que avec des **"text relocations"** :

```bash
# La compilation rÃ©ussit mais...
gcc -shared addition.o multiplication.o -o libmath_utils.so

# VÃ©rification
readelf -d libmath_utils.so | grep TEXTREL
```

Si vous voyez `TEXTREL`, c'est mauvais :
- Performance dÃ©gradÃ©e
- IncompatibilitÃ© avec SELinux
- ProblÃ¨mes de sÃ©curitÃ©

**Conclusion :** `-fPIC` n'est pas optionnel, c'est **obligatoire** pour les bibliothÃ¨ques partagÃ©es modernes !

---

## Impact sur les performances

### Overhead du code PIC

Le code PIC a un **lÃ©ger coÃ»t en performance** :

**Raison :**
- Les adresses relatives nÃ©cessitent un calcul supplÃ©mentaire
- Utilise un registre supplÃ©mentaire (sur certaines architectures)
- Plus d'indirections pour accÃ©der aux donnÃ©es globales

**Ordre de grandeur :**
- Perte de performance : **2-5%** en moyenne
- Peut atteindre **10%** pour du code trÃ¨s intensif en accÃ¨s mÃ©moire

### Pourquoi c'est acceptable

Les avantages dÃ©passent largement le coÃ»t :

| Avantage | Justification |
|----------|---------------|
| **Partage mÃ©moire** | Une seule copie de la bibliothÃ¨que en RAM pour tous les processus |
| **SÃ©curitÃ©** | ASLR (Address Space Layout Randomization) |
| **FlexibilitÃ©** | Chargement dynamique, plugins |
| **Mise Ã  jour** | Remplacement facile des `.so` |

### Optimisations

Pour minimiser l'impact :

1. **Utilisez `-O2` ou `-O3`** lors de la compilation
   ```bash
   gcc -fPIC -O2 -c fichier.c -o fichier.o
   ```

2. **Minimisez les variables globales** (accÃ¨s plus coÃ»teux avec PIC)
   ```c
   // âŒ Moins efficace avec PIC
   int global_counter = 0;

   void increment() {
       global_counter++;  // AccÃ¨s global coÃ»teux
   }

   // âœ… Plus efficace
   void increment(int *counter) {
       (*counter)++;  // AccÃ¨s local via paramÃ¨tre
   }
   ```

3. **PrÃ©fÃ©rez les fonctions statiques locales**
   ```c
   // âœ… Fonction interne, peut Ãªtre optimisÃ©e
   static int helper() {
       return 42;
   }
   ```

---

## `-fPIC` et les bibliothÃ¨ques statiques

### Question frÃ©quente

**Faut-il compiler avec `-fPIC` pour une bibliothÃ¨que statique (`.a`) ?**

**RÃ©ponse courte :** Non, ce n'est pas nÃ©cessaire.

**Explication :**

Les bibliothÃ¨ques statiques (`.a`) sont **liÃ©es** dans l'exÃ©cutable ou la bibliothÃ¨que partagÃ©e finale. Le code est copiÃ© Ã  une position fixe dans le binaire final.

```
BibliothÃ¨que statique (.a) :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ libutils.a     â”‚
â”‚ (code normal)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ Linking statique
         â”‚ (copie du code)
         â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ programme   â”‚
  â”‚ exÃ©cutable  â”‚
  â”‚ (position   â”‚
  â”‚  fixe)      â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Exception : CrÃ©er une `.so` Ã  partir d'une `.a`

Si vous voulez crÃ©er une bibliothÃ¨que partagÃ©e (`.so`) qui **utilise** une bibliothÃ¨que statique (`.a`), alors les fichiers objets de la `.a` **doivent** avoir Ã©tÃ© compilÃ©s avec `-fPIC` :

```bash
# Compiler les sources avec -fPIC pour la .a
gcc -fPIC -c utils.c -o utils.o  
ar rcs libutils.a utils.o  

# Plus tard, crÃ©er une .so qui inclut cette .a
gcc -shared -fPIC main.c -L. -lutils -o libmain.so
```

**Astuce :** Pour une flexibilitÃ© maximale, compilez toujours vos bibliothÃ¨ques statiques avec `-fPIC`. Le coÃ»t est minime et vous permet de les rÃ©utiliser dans des `.so`.

---

## Plateformes et architectures

### DiffÃ©rences par architecture

Le besoin et l'implÃ©mentation de `-fPIC` varient selon l'architecture :

| Architecture | NÃ©cessitÃ© de `-fPIC` | Notes |
|--------------|---------------------|-------|
| **x86_64** (64-bit) | **Obligatoire** | Le linker refuse sans `-fPIC` |
| **i386** (32-bit) | RecommandÃ© | Peut fonctionner sans, mais TEXTREL |
| **ARM** | **Obligatoire** | Essentiel pour les systÃ¨mes embarquÃ©s |
| **PowerPC** | Obligatoire | Idem |

### Position Independent Executables (PIE)

Une extension de PIC pour les **exÃ©cutables** (pas seulement les bibliothÃ¨ques) :

```bash
gcc -fPIE -pie main.c -o programme
```

**Options :**
- `-fPIE` : Version PIC pour les exÃ©cutables (Ã©quivalent de `-fPIC`)
- `-pie` : CrÃ©e un exÃ©cutable PIE (au lieu de `-shared`)

**Avantage :** SÃ©curitÃ© accrue avec ASLR (Address Space Layout Randomization) - le programme peut Ãªtre chargÃ© Ã  une adresse alÃ©atoire Ã  chaque exÃ©cution.

---

## Exemple complet avec Makefile

### Structure du projet

```
mon_projet/
â”œâ”€â”€ include/
â”‚   â””â”€â”€ math_utils.h
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ addition.c
â”‚   â””â”€â”€ multiplication.c
â”œâ”€â”€ Makefile
â””â”€â”€ test.c
```

### Makefile optimisÃ©

```makefile
# Variables
CC = gcc  
CFLAGS = -fPIC -Wall -Wextra -O2 -Iinclude  
LDFLAGS = -shared  

# Fichiers
SRC = src/addition.c src/multiplication.c  
OBJ = $(SRC:.c=.o)  
LIB = libmath_utils.so  

# RÃ¨gle par dÃ©faut
all: $(LIB)

# CrÃ©er la bibliothÃ¨que partagÃ©e
$(LIB): $(OBJ)
	$(CC) $(LDFLAGS) -o $@ $^
	@echo "âœ“ BibliothÃ¨que crÃ©Ã©e : $(LIB)"

# Compiler les fichiers objets avec -fPIC
%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@

# Nettoyage
clean:
	rm -f $(OBJ) $(LIB)
	@echo "âœ“ Nettoyage effectuÃ©"

# Compiler le programme de test
test: test.c $(LIB)
	$(CC) -Iinclude test.c -L. -lmath_utils -o test_program
	@echo "âœ“ Programme de test compilÃ©"

# Afficher les informations de la bibliothÃ¨que
info: $(LIB)
	@echo "=== Type de fichier ==="
	@file $(LIB)
	@echo "\n=== Symboles exportÃ©s ==="
	@nm -D $(LIB)

.PHONY: all clean test info
```

### Utilisation

```bash
# Compiler la bibliothÃ¨que
make

# Voir les informations
make info

# Compiler le programme de test
make test

# ExÃ©cuter (nÃ©cessite de dÃ©finir LD_LIBRARY_PATH)
LD_LIBRARY_PATH=. ./test_program

# Nettoyer
make clean
```

---

## Commandes de diagnostic essentielles

### VÃ©rifier la compilation PIC

```bash
# Afficher les relocations
readelf -r fichier.o | grep -E "RELATIVE|PLT|GOT"

# VÃ©rifier si c'est un objet partagÃ©
file libmath_utils.so

# Inspecter les symboles
nm -D libmath_utils.so

# Afficher les dÃ©pendances dynamiques
ldd libmath_utils.so

# VÃ©rifier les text relocations (Ã  Ã©viter)
readelf -d libmath_utils.so | grep TEXTREL
```

### DÃ©tecter les problÃ¨mes

Si vous voyez `TEXTREL`, recompilez avec `-fPIC` :

```bash
# âŒ ProblÃ¨me dÃ©tectÃ©
$ readelf -d libmath_utils.so | grep TEXTREL
 0x0000000000000016 (TEXTREL)            0x0

# âœ… Solution
$ gcc -fPIC -shared addition.c -o libmath_utils.so
```

---

## Bonnes pratiques

### âœ… Recommandations

1. **Toujours utiliser `-fPIC` pour les bibliothÃ¨ques partagÃ©es**
   ```bash
   gcc -fPIC -c fichier.c -o fichier.o
   ```

2. **Utiliser la majuscule** (`-fPIC` et non `-fpic`)

3. **Activer les optimisations**
   ```bash
   gcc -fPIC -O2 -c fichier.c -o fichier.o
   ```

4. **Activer les warnings**
   ```bash
   gcc -fPIC -Wall -Wextra -c fichier.c -o fichier.o
   ```

5. **VÃ©rifier le rÃ©sultat**
   ```bash
   file libmoncode.so
   nm -D libmoncode.so
   ```

### âŒ Erreurs Ã  Ã©viter

1. **Oublier `-fPIC`**
   ```bash
   # âŒ Mauvais
   gcc -c fichier.c -o fichier.o
   gcc -shared fichier.o -o libfichier.so
   ```

2. **MÃ©langer PIC et non-PIC**
   ```bash
   # âŒ Mauvais
   gcc -fPIC -c file1.c -o file1.o
   gcc -c file2.c -o file2.o           # Oubli de -fPIC
   gcc -shared file1.o file2.o -o lib.so
   ```

3. **Utiliser `-fPIC` uniquement au linking**
   ```bash
   # âŒ Trop tard !
   gcc -c fichier.c -o fichier.o       # Pas de -fPIC
   gcc -fPIC -shared fichier.o -o lib.so  # -fPIC inutile ici
   ```

---

## RÃ©sumÃ© des commandes

| Commande | Description |
|----------|-------------|
| `gcc -fPIC -c file.c -o file.o` | Compile un fichier objet PIC |
| `gcc -shared *.o -o lib.so` | CrÃ©e une bibliothÃ¨que partagÃ©e |
| `gcc -fPIC -shared file.c -o lib.so` | Compile et crÃ©e la `.so` en une fois |
| `file lib.so` | VÃ©rifie le type de fichier |
| `nm -D lib.so` | Liste les symboles exportÃ©s |
| `readelf -r file.o` | Affiche les relocations |
| `readelf -d lib.so \| grep TEXTREL` | VÃ©rifie les text relocations (Ã  Ã©viter) |

---

## Points clÃ©s Ã  retenir

- âœ… **`-fPIC`** est **obligatoire** pour crÃ©er des bibliothÃ¨ques partagÃ©es (`.so`)
- âœ… **PIC** = Position Independent Code (code indÃ©pendant de la position)
- âœ… **Pourquoi ?** Les bibliothÃ¨ques partagÃ©es sont chargÃ©es Ã  des adresses diffÃ©rentes
- âœ… **Comment ?** Utilise des adresses **relatives** au lieu d'adresses **absolues**
- âœ… **CoÃ»t ?** Perte de performance de 2-5% en moyenne, acceptable vu les avantages
- âœ… **VÃ©rification ?** Utilisez `file`, `nm`, `readelf` pour valider
- âœ… **Majuscule !** Utilisez `-fPIC` (pas `-fpic`) pour la compatibilitÃ© maximale
- âœ… **Toujours compiler avec** `-fPIC` lors de la crÃ©ation des fichiers objets (`.o`)

Dans la section suivante, nous verrons comment gÃ©rer le **versioning et le SONAME** des bibliothÃ¨ques partagÃ©es, un aspect crucial pour la maintenance et la compatibilitÃ©.

â­ï¸ [Versioning et SONAME](/14-bibliotheques/02.2-versioning-soname.md)
