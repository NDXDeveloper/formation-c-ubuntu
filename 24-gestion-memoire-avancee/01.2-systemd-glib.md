üîù Retour au [Sommaire](/SOMMAIRE.md)

# 24.1.2 Utilisation dans systemd et GLib

## Introduction

Maintenant que nous avons compris le principe de `__attribute__((cleanup))`, voyons comment deux projets majeurs de l'√©cosyst√®me Linux l'utilisent en production : **systemd** et **GLib**.

Ces projets ont cr√©√© des patterns et des conventions que vous pouvez r√©utiliser dans vos propres projets. √âtudier leur code est une excellente fa√ßon d'apprendre les bonnes pratiques.

---

## systemd : Le syst√®me d'initialisation Linux moderne

### Qu'est-ce que systemd ?

**systemd** est le syst√®me d'initialisation (init system) utilis√© par la grande majorit√© des distributions Linux modernes (Ubuntu, Fedora, Debian, Arch, etc.). C'est le premier processus lanc√© au d√©marrage (PID 1) et il g√®re :

- Le d√©marrage des services
- La gestion des logs (journald)
- La gestion du r√©seau (networkd)
- Et bien plus...

**Quelques chiffres :**
- Plus de 1,3 million de lignes de code C
- Projet open-source depuis 2010
- D√©velopp√© principalement par Lennart Poettering et Red Hat
- Utilisation massive de `cleanup` depuis 2013

### Pourquoi systemd utilise cleanup ?

systemd manipule √©norm√©ment de ressources :
- Fichiers (logs, configurations)
- Sockets (communication inter-processus)
- M√©moire dynamique
- Descripteurs de fichiers
- Structures de donn√©es complexes

Avec un projet de cette taille, **les fuites de ressources sont inacceptables**. L'utilisation de `cleanup` permet :
- ‚úÖ D'√©viter les fuites m√©moire
- ‚úÖ De simplifier le code
- ‚úÖ De r√©duire les bugs
- ‚úÖ De faciliter la maintenance

---

## Les macros de systemd

### Organisation : src/basic/macro.h

systemd a cr√©√© un ensemble de macros r√©utilisables dans le fichier `src/basic/macro.h`. Voici les principales :

### 1. `_cleanup_free_`

**Usage :** Lib√©ration automatique de m√©moire allou√©e avec `malloc/calloc/realloc`

```c
// D√©finition dans systemd
#define _cleanup_free_ __attribute__((cleanup(freep)))

static inline void freep(void *p) {
    free(*(void**)p);
}
```

**Exemple d'utilisation :**

```c
int charger_configuration(const char *fichier) {
    _cleanup_free_ char *contenu = NULL;

    contenu = lire_fichier(fichier);
    if (contenu == NULL) {
        return -1;  // Pas de fuite, rien n'√©tait allou√©
    }

    if (parser_configuration(contenu) < 0) {
        return -1;  // contenu sera automatiquement lib√©r√©
    }

    return 0;  // contenu lib√©r√© automatiquement ici aussi
}
```

**Pourquoi `freep` et pas directement `free` ?**
Parce que `cleanup` passe **l'adresse de la variable**, donc on re√ßoit un `char**` et non un `char*`. La fonction `freep` fait le d√©r√©f√©rencement n√©cessaire.

---

### 2. `_cleanup_close_`

**Usage :** Fermeture automatique de descripteurs de fichiers (file descriptors)

```c
// D√©finition dans systemd
#define _cleanup_close_ __attribute__((cleanup(closep)))

static inline void closep(int *fd) {
    if (*fd >= 0)
        close(*fd);
}
```

**Exemple d'utilisation :**

```c
int lire_fichier_systeme(const char *chemin) {
    _cleanup_close_ int fd = -1;
    char buffer[1024];

    fd = open(chemin, O_RDONLY);
    if (fd < 0) {
        log_error("Impossible d'ouvrir %s: %m", chemin);
        return -1;
    }

    ssize_t n = read(fd, buffer, sizeof(buffer) - 1);
    if (n < 0) {
        log_error("Erreur de lecture: %m");
        return -1;  // fd sera automatiquement ferm√©
    }

    buffer[n] = '\0';
    printf("Contenu: %s\n", buffer);

    return 0;  // fd ferm√© automatiquement
}
```

**Note :** L'initialisation √† `-1` est importante. Si `open()` √©choue, `fd` reste √† `-1` et `closep()` ne fera rien (gr√¢ce √† la condition `if (*fd >= 0)`).

---

### 3. `_cleanup_fclose_`

**Usage :** Fermeture automatique de flux `FILE*`

```c
// D√©finition dans systemd
#define _cleanup_fclose_ __attribute__((cleanup(fclosep)))

static inline void fclosep(FILE **f) {
    if (*f)
        fclose(*f);
}
```

**Exemple d'utilisation :**

```c
int ecrire_pid_file(const char *chemin, pid_t pid) {
    _cleanup_fclose_ FILE *f = NULL;

    f = fopen(chemin, "w");
    if (!f) {
        return -errno;
    }

    if (fprintf(f, "%d\n", pid) < 0) {
        return -errno;  // f ferm√© automatiquement
    }

    return 0;  // f ferm√© automatiquement
}
```

---

### 4. `_cleanup_strv_free_`

**Usage :** Lib√©ration automatique de tableaux de cha√Ænes (string vectors)

Dans systemd, un "strv" est un tableau de cha√Ænes termin√© par `NULL` :
```c
char *strv[] = { "hello", "world", NULL };
```

```c
// D√©finition dans systemd
#define _cleanup_strv_free_ __attribute__((cleanup(strv_freep)))

static inline void strv_freep(char ***p) {
    if (*p) {
        for (size_t i = 0; (*p)[i]; i++)
            free((*p)[i]);
        free(*p);
    }
}
```

**Exemple d'utilisation :**

```c
int lire_lignes_fichier(const char *chemin) {
    _cleanup_strv_free_ char **lignes = NULL;

    // Supposons que cette fonction alloue un tableau de cha√Ænes
    lignes = charger_fichier_en_lignes(chemin);
    if (!lignes) {
        return -1;
    }

    // Traitement des lignes
    for (size_t i = 0; lignes[i]; i++) {
        printf("Ligne %zu: %s\n", i, lignes[i]);
    }

    return 0;  // Toutes les cha√Ænes et le tableau seront lib√©r√©s automatiquement
}
```

---

### 5. `_cleanup_(fonction)` - Forme g√©n√©rique

systemd d√©finit aussi une forme g√©n√©rique pour cr√©er facilement de nouveaux cleanups :

```c
#define _cleanup_(x) __attribute__((cleanup(x)))
```

**Exemple d'usage personnalis√© :**

```c
// D√©finir une fonction de cleanup pour un type personnalis√©
typedef struct {
    int *data;
    size_t size;
} MonTableau;

static inline void cleanup_mon_tableau(MonTableau *t) {
    if (t->data) {
        free(t->data);
        t->data = NULL;
        t->size = 0;
    }
}

void fonction_exemple(void) {
    _cleanup_(cleanup_mon_tableau) MonTableau tableau = {0};

    tableau.data = malloc(100 * sizeof(int));
    tableau.size = 100;

    if (!tableau.data) {
        return;  // cleanup_mon_tableau sera quand m√™me appel√©
    }

    // ... utilisation ...

    // Nettoyage automatique
}
```

---

## Exemple r√©el tir√© de systemd

Voici un extrait simplifi√© du code source de systemd montrant l'utilisation de plusieurs cleanups :

```c
// Extrait inspir√© de src/core/unit.c
int unit_load_configuration(Unit *u, const char *path) {
    _cleanup_free_ char *content = NULL;
    _cleanup_fclose_ FILE *f = NULL;
    _cleanup_strv_free_ char **lines = NULL;
    size_t size;

    assert(u);
    assert(path);

    // Ouvrir le fichier de configuration
    f = fopen(path, "r");
    if (!f)
        return -errno;

    // Lire le contenu
    if (fseek(f, 0, SEEK_END) < 0)
        return -errno;

    size = ftell(f);
    if (size == 0)
        return 0;  // Fichier vide, tous les cleanups s'ex√©cutent

    rewind(f);

    content = malloc(size + 1);
    if (!content)
        return -ENOMEM;  // f sera ferm√© automatiquement

    if (fread(content, 1, size, f) != size)
        return -EIO;  // content ET f seront nettoy√©s

    content[size] = '\0';

    // Parser le contenu en lignes
    lines = split_lines(content);
    if (!lines)
        return -ENOMEM;  // Tout est nettoy√© automatiquement

    // Traiter chaque ligne
    for (size_t i = 0; lines[i]; i++) {
        if (parse_line(u, lines[i]) < 0) {
            log_warning("Ligne invalide: %s", lines[i]);
            return -EINVAL;  // TOUT est nettoy√© automatiquement
        }
    }

    return 0;  // TOUT est nettoy√© automatiquement
}
```

**Comptez les points de sortie (`return`) :** Il y en a 8 ! Sans cleanup, il faudrait dupliquer le code de nettoyage 8 fois. Avec cleanup, c'est g√©r√© automatiquement.

---

## GLib : La biblioth√®que fondamentale de GNOME

### Qu'est-ce que GLib ?

**GLib** est une biblioth√®que C de bas niveau d√©velopp√©e pour GNOME (l'environnement de bureau Linux). Elle fournit :

- Structures de donn√©es (listes, tables de hachage, arbres)
- Utilitaires pour les cha√Ænes de caract√®res
- Gestion de la m√©moire
- Boucle d'√©v√©nements (event loop)
- Et bien plus...

**Pourquoi c'est important ?**
- Utilis√©e par GTK (toolkit graphique)
- Utilis√©e par des milliers d'applications Linux
- Code de tr√®s haute qualit√©
- Excellents exemples de programmation C moderne

---

## Les macros de GLib

### Syst√®me de macros g_auto*

GLib a cr√©√© un syst√®me coh√©rent de macros pour le cleanup automatique :

### 1. `g_autofree`

**Usage :** Lib√©ration automatique de m√©moire allou√©e avec `g_malloc()`, `g_new()`, ou les fonctions GLib

```c
// D√©finition (simplifi√©e)
#define g_autofree __attribute__((cleanup(g_autoptr_cleanup_generic_gfree)))
```

**Exemple :**

```c
#include <glib.h>

void exemple_glib(void) {
    g_autofree gchar *message = NULL;

    message = g_strdup_printf("Bonjour %s, vous avez %d messages",
                              "Alice", 5);

    g_print("%s\n", message);

    // message sera automatiquement lib√©r√© avec g_free()
}
```

---

### 2. `g_autoptr`

**Usage :** Lib√©ration automatique d'objets GLib complexes

```c
// Utilisation avec des types GLib
void manipuler_liste(void) {
    g_autoptr(GList) liste = NULL;

    // Ajouter des √©l√©ments
    liste = g_list_append(liste, "Premier");
    liste = g_list_append(liste, "Deuxi√®me");
    liste = g_list_append(liste, "Troisi√®me");

    // Afficher
    for (GList *l = liste; l != NULL; l = l->next) {
        g_print("%s\n", (char *)l->data);
    }

    // La liste sera automatiquement lib√©r√©e avec g_list_free()
}
```

**Avec GPtrArray (tableau dynamique) :**

```c
void manipuler_tableau(void) {
    g_autoptr(GPtrArray) tableau = g_ptr_array_new_with_free_func(g_free);

    // Ajouter des √©l√©ments
    g_ptr_array_add(tableau, g_strdup("Item 1"));
    g_ptr_array_add(tableau, g_strdup("Item 2"));
    g_ptr_array_add(tableau, g_strdup("Item 3"));

    // Afficher
    for (guint i = 0; i < tableau->len; i++) {
        g_print("%s\n", (gchar *)g_ptr_array_index(tableau, i));
    }

    // Le tableau ET tous ses √©l√©ments seront lib√©r√©s automatiquement
}
```

---

### 3. `g_auto`

**Usage :** Pour les types de base et structures

```c
void exemple_auto(void) {
    g_auto(GString) str = g_string_new("");

    g_string_append(str, "Hello ");
    g_string_append(str, "World");

    g_print("%s\n", str->str);

    // str sera automatiquement lib√©r√© avec g_string_free()
}
```

---

### 4. `g_autolist` et `g_autoslist`

**Usage :** Pour les listes cha√Æn√©es GLib

```c
void exemple_listes(void) {
    g_autolist(gchar) liste_chaines = NULL;

    liste_chaines = g_list_append(liste_chaines, g_strdup("Un"));
    liste_chaines = g_list_append(liste_chaines, g_strdup("Deux"));
    liste_chaines = g_list_append(liste_chaines, g_strdup("Trois"));

    // Afficher
    for (GList *l = liste_chaines; l; l = l->next) {
        g_print("%s\n", (char *)l->data);
    }

    // La liste ET toutes les cha√Ænes seront automatiquement lib√©r√©es
}
```

---

## Exemple complet avec GLib

Voici un exemple r√©aliste montrant comment GLib utilise cleanup pour simplifier le code :

```c
#include <glib.h>
#include <gio/gio.h>

// Fonction qui lit un fichier de configuration JSON
gboolean charger_configuration(const gchar *chemin, GError **error) {
    g_autofree gchar *contenu = NULL;
    g_autoptr(GFile) fichier = NULL;
    g_autoptr(GFileInputStream) stream = NULL;
    g_autoptr(JsonParser) parser = NULL;
    g_autoptr(JsonNode) root = NULL;
    gsize taille;

    // Cr√©er un objet GFile
    fichier = g_file_new_for_path(chemin);

    // Lire le contenu du fichier
    if (!g_file_load_contents(fichier, NULL, &contenu, &taille, NULL, error)) {
        return FALSE;  // Tout sera nettoy√© automatiquement
    }

    // Parser le JSON
    parser = json_parser_new();
    if (!json_parser_load_from_data(parser, contenu, taille, error)) {
        return FALSE;  // Tout sera nettoy√© automatiquement
    }

    root = json_parser_get_root(parser);
    if (!JSON_NODE_HOLDS_OBJECT(root)) {
        g_set_error(error, G_IO_ERROR, G_IO_ERROR_INVALID_DATA,
                    "Le fichier JSON doit contenir un objet");
        return FALSE;  // Tout sera nettoy√© automatiquement
    }

    // Traiter la configuration
    JsonObject *obj = json_node_get_object(root);

    if (json_object_has_member(obj, "nom")) {
        const gchar *nom = json_object_get_string_member(obj, "nom");
        g_print("Configuration pour: %s\n", nom);
    }

    return TRUE;  // Tout sera nettoy√© automatiquement
}

int main(void) {
    g_autoptr(GError) error = NULL;

    if (!charger_configuration("config.json", &error)) {
        g_printerr("Erreur: %s\n", error->message);
        return 1;
    }

    g_print("Configuration charg√©e avec succ√®s\n");
    return 0;
}
```

**Points √† noter :**
- 5 objets GLib avec cleanup automatique
- 4 points de sortie avec `return`
- Z√©ro appel manuel de lib√©ration de m√©moire
- Code propre et facile √† maintenir

---

## Comparaison : Avec et Sans GLib cleanup

### ‚ùå Sans cleanup (ancien style)

```c
gboolean ancienne_methode(const gchar *chemin, GError **error) {
    gchar *contenu = NULL;
    GFile *fichier = NULL;
    JsonParser *parser = NULL;
    gsize taille;
    gboolean success = FALSE;

    fichier = g_file_new_for_path(chemin);

    if (!g_file_load_contents(fichier, NULL, &contenu, &taille, NULL, error)) {
        goto cleanup;  // ‚ö†Ô∏è Besoin de goto
    }

    parser = json_parser_new();
    if (!json_parser_load_from_data(parser, contenu, taille, error)) {
        goto cleanup;  // ‚ö†Ô∏è Besoin de goto
    }

    // ... traitement ...

    success = TRUE;

cleanup:
    // ‚ö†Ô∏è Lib√©ration manuelle dans le bon ordre
    if (parser) g_object_unref(parser);
    if (contenu) g_free(contenu);
    if (fichier) g_object_unref(fichier);

    return success;
}
```

**Probl√®mes :**
- Code verbeux avec `goto cleanup`
- Risque d'oublier une lib√©ration
- Ordre de lib√©ration √† g√©rer manuellement
- Variable `success` n√©cessaire

### ‚úÖ Avec cleanup (style moderne)

```c
gboolean nouvelle_methode(const gchar *chemin, GError **error) {
    g_autofree gchar *contenu = NULL;
    g_autoptr(GFile) fichier = NULL;
    g_autoptr(JsonParser) parser = NULL;
    gsize taille;

    fichier = g_file_new_for_path(chemin);

    if (!g_file_load_contents(fichier, NULL, &contenu, &taille, NULL, error)) {
        return FALSE;  // ‚úÖ Nettoyage automatique
    }

    parser = json_parser_new();
    if (!json_parser_load_from_data(parser, contenu, taille, error)) {
        return FALSE;  // ‚úÖ Nettoyage automatique
    }

    // ... traitement ...

    return TRUE;  // ‚úÖ Nettoyage automatique
}
```

**Avantages :**
- ‚úÖ Code plus court et lisible
- ‚úÖ Impossible d'oublier une lib√©ration
- ‚úÖ Pas besoin de `goto`
- ‚úÖ Ordre de lib√©ration g√©r√© automatiquement

---

## Comment GLib impl√©mente g_autoptr

Pour les curieux, voici comment GLib d√©finit `g_autoptr` (simplifi√©) :

```c
// Chaque type GLib d√©finit sa fonction de cleanup
#define G_DEFINE_AUTOPTR_CLEANUP_FUNC(TypeName, func) \
    static inline void _g_autoptr_cleanup_##TypeName(TypeName **ptr) { \
        if (*ptr) \
            (func)(*ptr); \
    }

// Exemple pour GList
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GList, g_list_free)

// La macro g_autoptr utilise cette fonction
#define g_autoptr(TypeName) \
    __attribute__((cleanup(_g_autoptr_cleanup_##TypeName))) TypeName *
```

**Ce que √ßa fait :**
1. `G_DEFINE_AUTOPTR_CLEANUP_FUNC` cr√©e une fonction de cleanup pour chaque type
2. Cette fonction appelle la bonne fonction de lib√©ration (`g_list_free`, `g_object_unref`, etc.)
3. `g_autoptr` applique l'attribut `cleanup` avec la bonne fonction

**Vous pouvez faire pareil pour vos propres types !**

```c
// D√©finir un type personnalis√©
typedef struct {
    char *nom;
    int *donnees;
    size_t taille;
} MaStructure;

// Fonction de lib√©ration
void ma_structure_free(MaStructure *s) {
    if (s) {
        free(s->nom);
        free(s->donnees);
        free(s);
    }
}

// D√©finir le cleanup
G_DEFINE_AUTOPTR_CLEANUP_FUNC(MaStructure, ma_structure_free)

// Utilisation
void fonction(void) {
    g_autoptr(MaStructure) s = ma_structure_new();
    // ... utilisation ...
    // ma_structure_free(s) appel√© automatiquement
}
```

---

## Bonnes pratiques tir√©es de systemd et GLib

### 1. ‚úÖ Toujours initialiser les pointeurs

```c
// ‚úÖ BON
_cleanup_free_ char *buffer = NULL;

// ‚ùå MAUVAIS (valeur ind√©termin√©e)
_cleanup_free_ char *buffer;
```

**Pourquoi ?** Si l'allocation √©choue avant que le pointeur soit assign√©, la fonction de cleanup tentera de lib√©rer une adresse invalide.

---

### 2. ‚úÖ V√©rifier NULL dans les fonctions de cleanup

```c
// ‚úÖ BON
static inline void cleanup_free(void **p) {
    if (*p) {          // ‚Üê V√©rification importante
        free(*p);
        *p = NULL;     // ‚Üê Bonne pratique suppl√©mentaire
    }
}

// ‚ö†Ô∏è ACCEPTABLE MAIS MOINS ROBUSTE
static inline void cleanup_free_minimal(void **p) {
    free(*p);  // ‚Üê free(NULL) est s√ªr (C99 ¬ß7.20.3.2), mais sans
               //   *p = NULL on risque un double-free si le pointeur
               //   est r√©utilis√© apr√®s le cleanup
}
```

---

### 3. ‚úÖ Ordre de d√©claration = Ordre de nettoyage inverse

```c
void fonction(void) {
    // Ces cleanups seront appel√©s dans l'ordre : 3, 2, 1
    _cleanup_close_ int fd = -1;           // 1. D√©clar√© en premier
    _cleanup_free_ char *buffer = NULL;    // 2. D√©clar√© en second
    _cleanup_fclose_ FILE *f = NULL;       // 3. D√©clar√© en dernier, nettoy√© en premier

    // ...
}
```

**Pensez √† la d√©pendance :** Si `buffer` contient des donn√©es lues depuis `f`, alors `buffer` doit √™tre nettoy√© AVANT `f`. En LIFO, le dernier d√©clar√© est nettoy√© en premier, donc d√©clarez `f` AVANT `buffer` pour que `buffer` soit nettoy√© en premier.

---

### 4. ‚úÖ Utiliser des macros courtes et expressives

```c
// Style systemd
#define _cleanup_free_ __attribute__((cleanup(freep)))
#define _cleanup_close_ __attribute__((cleanup(closep)))

// Style GLib
#define g_autofree __attribute__((cleanup(g_free)))
#define g_autoptr(type) __attribute__((cleanup(cleanup_##type))) type *
```

**Avantage :** Le code reste lisible et l'intention est claire.

---

### 5. ‚úÖ Documenter les fonctions de cleanup

```c
/**
 * cleanup_database - Ferme automatiquement une connexion √† la base de donn√©es
 * @db: Pointeur vers le pointeur de connexion
 *
 * Fonction de cleanup pour _cleanup_database_.
 * Ferme la connexion si elle est ouverte et met le pointeur √† NULL.
 */
static inline void cleanup_database(Database **db) {
    if (*db) {
        database_close(*db);
        *db = NULL;
    }
}

#define _cleanup_database_ __attribute__((cleanup(cleanup_database)))
```

---

## Cas d'usage avanc√©s

### Cleanup conditionnel

Parfois, vous voulez **d√©sactiver** le cleanup (par exemple, si vous retournez la ressource) :

```c
char *creer_buffer(size_t taille) {
    _cleanup_free_ char *buffer = malloc(taille);

    if (!buffer) {
        return NULL;  // cleanup s'ex√©cute, buffer est NULL donc OK
    }

    memset(buffer, 0, taille);

    // D√©sactiver le cleanup et retourner la ressource
    char *resultat = buffer;
    buffer = NULL;  // ‚Üê Important : emp√™che le cleanup de lib√©rer la m√©moire

    return resultat;  // L'appelant doit maintenant lib√©rer resultat
}
```

### Cleanup de structures complexes

```c
typedef struct {
    char *nom;
    int *donnees;
    FILE *log_file;
    int socket_fd;
} Contexte;

static inline void cleanup_contexte(Contexte **ctx) {
    if (*ctx) {
        free((*ctx)->nom);
        free((*ctx)->donnees);
        if ((*ctx)->log_file)
            fclose((*ctx)->log_file);
        if ((*ctx)->socket_fd >= 0)
            close((*ctx)->socket_fd);
        free(*ctx);
        *ctx = NULL;
    }
}

#define _cleanup_contexte_ __attribute__((cleanup(cleanup_contexte)))

void fonction(void) {
    _cleanup_contexte_ Contexte *ctx = calloc(1, sizeof(Contexte));

    ctx->nom = strdup("Mon contexte");
    ctx->donnees = malloc(100 * sizeof(int));
    ctx->log_file = fopen("log.txt", "a");
    ctx->socket_fd = socket(AF_INET, SOCK_STREAM, 0);

    // Tout sera nettoy√© automatiquement, dans le bon ordre
}
```

---

## Performance et overhead

### Mythes et r√©alit√©

**Mythe :** "Les cleanup ajoutent de l'overhead et ralentissent le programme"

**R√©alit√© :** Le compilateur g√©n√®re **exactement le m√™me code** que si vous aviez √©crit le cleanup manuellement.

**Preuve par l'exemple :**

Code avec cleanup :
```c
void avec_cleanup(void) {
    _cleanup_free_ char *buffer = malloc(100);
    // ...
    return;
}
```

Code manuel √©quivalent :
```c
void sans_cleanup(void) {
    char *buffer = malloc(100);
    // ...
    free(buffer);
    return;
}
```

**Assembleur g√©n√©r√© (simplifi√©) - IDENTIQUE pour les deux :**
```assembly
call   malloc
; ... code ...
call   free  
ret  
```

**Conclusion :** Z√©ro overhead, seulement des avantages !

---

## Compatibilit√© et portabilit√©

### V√©rification de la disponibilit√©

Si vous √©crivez du code qui doit √™tre portable :

```c
#ifdef __GNUC__
    // GCC ou Clang : cleanup disponible
    #define _cleanup_(x) __attribute__((cleanup(x)))
    #define CLEANUP_SUPPORTED 1
#else
    // Autre compilateur : pas de cleanup
    #define _cleanup_(x)
    #define CLEANUP_SUPPORTED 0
#endif

// Utilisation
void fonction_portable(void) {
    #if CLEANUP_SUPPORTED
        _cleanup_free_ char *buffer = malloc(100);
    #else
        char *buffer = malloc(100);
    #endif

    // ... code ...

    #if !CLEANUP_SUPPORTED
        free(buffer);  // Fallback manuel si cleanup non support√©
    #endif
}
```

---

## Quand utiliser cleanup ? (Recommandations)

### ‚úÖ Utilisez cleanup pour :

1. **Projets Linux/UNIX** avec GCC ou Clang
2. **Gestion de ressources multiples** (fichiers, m√©moire, sockets)
3. **Fonctions avec plusieurs points de sortie**
4. **Code critique** o√π les fuites sont inacceptables
5. **Nouveaux projets** o√π vous contr√¥lez le toolchain

### ‚ö†Ô∏è √âvitez cleanup pour :

1. **Code strictement portable** (Windows MSVC, compilateurs embarqu√©s)
2. **Code C89 strict** (vieux compilateurs)
3. **Petites fonctions simples** avec un seul point de sortie
4. **Biblioth√®ques publiques** si vous ne connaissez pas le compilateur de l'utilisateur

---

## Ressources pour aller plus loin

### Code source √† √©tudier

**systemd :**
- `src/basic/macro.h` - D√©finitions des macros cleanup
- `src/core/unit.c` - Exemples d'utilisation intensive
- `src/shared/json.c` - Parsing JSON avec cleanup

**GLib :**
- `glib/glib-autocleanups.h` - D√©finitions g_auto*
- `gio/gfile.c` - Op√©rations fichiers avec cleanup
- Documentation : https://docs.gtk.org/glib/auto-cleanup.html

### Standards et guides

- [systemd Coding Style](https://github.com/systemd/systemd/blob/main/docs/CODING_STYLE.md)
- [GLib Documentation - Auto Cleanup](https://docs.gtk.org/glib/auto-cleanup.html)
- [GCC Documentation - Attribute Cleanup](https://gcc.gnu.org/onlinedocs/gcc/Common-Variable-Attributes.html)

---

## R√©sum√©

**systemd** et **GLib** nous montrent que `__attribute__((cleanup))` est :

- ‚úÖ **Utilis√© en production** dans des millions de lignes de code
- ‚úÖ **Fiable** et √©prouv√© depuis plus de 10 ans
- ‚úÖ **Sans overhead** de performance
- ‚úÖ **Une bonne pratique** pour le C moderne sous Linux

**Le√ßons √† retenir :**

1. Cr√©ez des macros r√©utilisables (`_cleanup_free_`, `g_autofree`)
2. Toujours initialiser les pointeurs √† `NULL`
3. V√©rifier `NULL` dans les fonctions de cleanup
4. L'ordre de d√©claration d√©termine l'ordre de nettoyage
5. Documenter vos fonctions de cleanup

Dans la section suivante (24.1.3), nous verrons des **patterns concrets** pour appliquer cleanup √† vos propres projets : fichiers, m√©moire, locks, et plus encore !

---

**üí° Conseil pratique :** √âtudiez le code source de systemd et GLib. C'est une mine d'or d'exemples de C moderne et de bonnes pratiques. Ces projets sont open-source et tr√®s bien document√©s !

‚è≠Ô∏è [Patterns pour fichiers, m√©moire, locks](/24-gestion-memoire-avancee/01.3-patterns.md)
