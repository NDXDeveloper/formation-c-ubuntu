üîù Retour au [Sommaire](/SOMMAIRE.md)

# 13.2.3 Variables et Macros

## Introduction

Les **variables** sont au c≈ìur de la flexibilit√© et de la maintenabilit√© des Makefiles. Elles permettent de centraliser les configurations, d'√©viter les r√©p√©titions et de rendre vos Makefiles param√©trables. Dans cette section, nous allons explorer en profondeur les variables et les macros de GNU Make.

## D√©claration et Utilisation de Base

### Syntaxe Simple

```makefile
# D√©claration
NOM_VARIABLE = valeur

# Utilisation (deux syntaxes √©quivalentes)
cible:
	echo $(NOM_VARIABLE)
	echo ${NOM_VARIABLE}
```

**Convention** : On utilise g√©n√©ralement `$(VAR)` par habitude, mais `${VAR}` fonctionne aussi.

### Exemple Concret

```makefile
CC = gcc  
CFLAGS = -Wall -Wextra  
PROGRAM = mon_app  

all: $(PROGRAM)

$(PROGRAM): main.o
	$(CC) $(CFLAGS) -o $(PROGRAM) main.o
```

**Avantage** : Pour changer de compilateur, il suffit de modifier `CC = clang` au lieu de chercher tous les `gcc` dans le fichier.

## Types d'Assignation

Make propose **quatre op√©rateurs** d'assignation diff√©rents, chacun avec un comportement sp√©cifique.

### 1. Assignation R√©cursive : `=`

```makefile
VAR = valeur
```

La valeur est **√©valu√©e √† chaque utilisation** (expansion r√©cursive).

**Exemple :**

```makefile
CC = gcc  
CFLAGS = $(WARNINGS) -O2  
WARNINGS = -Wall -Wextra  

all:
	echo $(CFLAGS)
# Affiche : -Wall -Wextra -O2
```

**Explication** :
- `CFLAGS` utilise `$(WARNINGS)`
- `WARNINGS` est d√©fini **apr√®s** `CFLAGS`
- √áa fonctionne car l'expansion est **r√©cursive** (√©valu√©e au moment de l'utilisation)

**‚ö†Ô∏è Pi√®ge : Boucles Infinies**

```makefile
CFLAGS = $(CFLAGS) -O2  # ‚ùå ERREUR : Expansion infinie !
```

### 2. Assignation Simple : `:=`

```makefile
VAR := valeur
```

La valeur est **√©valu√©e imm√©diatement** lors de la d√©claration (expansion simple).

**Exemple :**

```makefile
CC = gcc  
COMPILE := $(CC) -Wall  # √âvalu√© maintenant : "gcc -Wall"  
CC = clang              # Changement de CC  

all:
	echo $(COMPILE)
# Affiche : gcc -Wall (et non "clang -Wall")
```

**Quand l'utiliser ?**
- Quand vous voulez "capturer" une valeur √† un moment pr√©cis
- Pour appeler des fonctions shell (voir plus bas)
- Pour am√©liorer les performances (moins d'expansions)

### 3. Assignation Conditionnelle : `?=`

```makefile
VAR ?= valeur
```

Assigne la valeur **seulement si la variable n'existe pas d√©j√†**.

**Exemple :**

```makefile
CC ?= gcc        # Utilise gcc par d√©faut  
CFLAGS ?= -O2    # Utilise -O2 par d√©faut  

# L'utilisateur peut surcharger avec :
# make CC=clang CFLAGS="-O3 -march=native"
```

**Cas d'usage** : Valeurs par d√©faut surchargeables depuis la ligne de commande.

### 4. Assignation par Ajout : `+=`

```makefile
VAR += nouvelle_valeur
```

**Ajoute** une valeur √† une variable existante (avec un espace).

**Exemple :**

```makefile
CFLAGS = -Wall  
CFLAGS += -Wextra        # CFLAGS = "-Wall -Wextra"  
CFLAGS += -std=c11       # CFLAGS = "-Wall -Wextra -std=c11"  
```

**Comportement Subtil** :

```makefile
# Si VAR n'existe pas, += se comporte comme =
NEW_VAR += hello         # NEW_VAR = "hello"

# Si d√©finie avec :=, += pr√©serve :=
VAR := init  
VAR += add               # Expansion simple  
```

## Tableau Comparatif des Assignations

| Op√©rateur | Expansion | Usage Typique | Surchargeable |
|-----------|-----------|---------------|---------------|
| `=` | R√©cursive (√† l'utilisation) | Variables interd√©pendantes | Oui |
| `:=` | Imm√©diate (√† la d√©claration) | Appels shell, performance | Oui |
| `?=` | Conditionnelle | Valeurs par d√©faut | **Non** (si d√©j√† d√©finie) |
| `+=` | Ajout (h√©rite du type) | Accumuler des flags | Oui |

## Variables Pr√©d√©finies

Make fournit des variables standard avec des noms conventionnels.

### Variables d'Outils

```makefile
CC       # Compilateur C (d√©faut : cc)  
CXX      # Compilateur C++ (d√©faut : g++)  
AS       # Assembleur  
AR       # Archiveur (pour biblioth√®ques statiques)  
LD       # Linker  
```

### Variables de Flags

```makefile
CFLAGS   # Flags du compilateur C  
CXXFLAGS # Flags du compilateur C++  
CPPFLAGS # Flags du pr√©processeur (-I, -D)  
LDFLAGS  # Flags du linker (-L)  
LDLIBS   # Biblioth√®ques √† linker (-l)  
```

### Exemple Complet

```makefile
# Outils
CC = gcc  
AR = ar  

# Flags
CFLAGS = -Wall -Wextra -std=c11  
CPPFLAGS = -I./include -DDEBUG  
LDFLAGS = -L./lib  
LDLIBS = -lm -lpthread  

# Utilisation
programme: main.o utils.o
	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^ $(LDLIBS)

%.o: %.c
	$(CC) $(CFLAGS) $(CPPFLAGS) -c $< -o $@
```

## Variables Automatiques

Les **variables automatiques** sont d√©finies par Make dans le contexte d'une r√®gle. Elles facilitent l'√©criture de r√®gles g√©n√©riques.

### Variables Essentielles

| Variable | Signification | Exemple |
|----------|---------------|---------|
| `$@` | Nom de la cible | `programme` |
| `$<` | Premi√®re d√©pendance | `main.c` |
| `$^` | Toutes les d√©pendances (sans doublons) | `main.o utils.o` |
| `$+` | Toutes les d√©pendances (avec doublons) | `main.o utils.o utils.o` |
| `$?` | D√©pendances plus r√©centes que la cible | `main.o` |
| `$*` | Stem (partie variable d'un pattern) | `main` (dans `%.o: %.c`) |

### Exemples Pratiques

#### 1. Variable `$@` (cible)

```makefile
programme: main.o utils.o
	gcc -o $@ main.o utils.o
# √âquivalent √† : gcc -o programme main.o utils.o
```

#### 2. Variable `$<` (premi√®re d√©pendance)

```makefile
main.o: main.c
	gcc -c $< -o $@
# √âquivalent √† : gcc -c main.c -o main.o
```

#### 3. Variable `$^` (toutes les d√©pendances)

```makefile
programme: main.o utils.o config.o
	gcc -o $@ $^
# √âquivalent √† : gcc -o programme main.o utils.o config.o
```

#### 4. Variable `$?` (d√©pendances modifi√©es)

```makefile
archive.a: main.o utils.o
	ar rcs $@ $?
# N'ajoute √† l'archive que les .o modifi√©s
```

#### 5. Variable `$*` (stem)

```makefile
# Dans une pattern rule
%.o: %.c
	gcc -c $< -o $@
	@echo "Compil√© $* depuis le fichier source"
# Pour main.o, $* = main
```

### Variables Automatiques avec Modificateurs

Vous pouvez extraire des parties sp√©cifiques des chemins :

```makefile
$(@D)   # R√©pertoire de la cible
$(@F)   # Nom du fichier de la cible
$(<D)   # R√©pertoire de la premi√®re d√©pendance
$(<F)   # Nom du fichier de la premi√®re d√©pendance
```

**Exemple :**

```makefile
build/obj/main.o: src/main.c
	@echo "Cible : $@"        # build/obj/main.o
	@echo "Dir : $(@D)"       # build/obj
	@echo "Fichier : $(@F)"   # main.o
	@echo "Source : $<"       # src/main.c
	@echo "Dir src : $(<D)"   # src
	@echo "Nom src : $(<F)"   # main.c
	mkdir -p $(@D)
	gcc -c $< -o $@
```

## Fonctions de Manipulation de Variables

Make fournit des **fonctions** pour manipuler les cha√Ænes et les listes.

### Syntaxe G√©n√©rale

```makefile
$(function arguments)
# ou
${function arguments}
```

### 1. Substitution de Texte : `$(subst)`

**Syntaxe :** `$(subst from,to,text)`

Remplace toutes les occurrences de `from` par `to` dans `text`.

```makefile
SRC = main.c utils.c config.c  
OBJ = $(subst .c,.o,$(SRC))  
# OBJ = main.o utils.o config.o

all:
	@echo $(OBJ)
```

### 2. Substitution de Pattern : `$(patsubst)`

**Syntaxe :** `$(patsubst pattern,replacement,text)`

Remplace les √©l√©ments correspondant au pattern.

```makefile
SRC = main.c utils.c config.c  
OBJ = $(patsubst %.c,%.o,$(SRC))  
# OBJ = main.o utils.o config.o

# Forme abr√©g√©e (√©quivalent)
OBJ = $(SRC:.c=.o)
```

### 3. Filtrage : `$(filter)` et `$(filter-out)`

**Syntaxe :**
- `$(filter pattern,text)` : Garde les √©l√©ments correspondants
- `$(filter-out pattern,text)` : Exclut les √©l√©ments correspondants

```makefile
FILES = main.c utils.c README.md config.c doc.txt

# Garder seulement les .c
SOURCES = $(filter %.c,$(FILES))
# SOURCES = main.c utils.c config.c

# Exclure les .c
DOCS = $(filter-out %.c,$(FILES))
# DOCS = README.md doc.txt
```

### 4. Recherche de Fichiers : `$(wildcard)`

**Syntaxe :** `$(wildcard pattern)`

Retourne les fichiers existants correspondant au pattern.

```makefile
# Trouver tous les .c dans src/
SOURCES = $(wildcard src/*.c)
# SOURCES = src/main.c src/utils.c src/config.c

# G√©n√©rer les .o correspondants
OBJECTS = $(patsubst src/%.c,obj/%.o,$(SOURCES))
```

### 5. Manipulation de Chemins

```makefile
# $(dir names) : Extrait les r√©pertoires
PATHS = src/main.c lib/utils.c  
DIRS = $(dir $(PATHS))  
# DIRS = src/ lib/

# $(notdir names) : Extrait les noms de fichiers
FILES = $(notdir $(PATHS))
# FILES = main.c utils.c

# $(basename names) : Retire l'extension
BASES = $(basename $(PATHS))
# BASES = src/main lib/utils

# $(suffix names) : Extrait l'extension
EXTS = $(suffix $(PATHS))
# EXTS = .c .c

# $(addprefix prefix,names) : Ajoute un pr√©fixe
OBJS = $(addprefix obj/,$(FILES))
# OBJS = obj/main.c obj/utils.c

# $(addsuffix suffix,names) : Ajoute un suffixe
OBJS = $(addsuffix .o,$(BASES))
# OBJS = src/main.o lib/utils.o
```

### 6. Fonctions d'Information

```makefile
# $(words text) : Compte les mots
COUNT = $(words $(SOURCES))

# $(word n,text) : Extrait le n-i√®me mot (base 1)
FIRST = $(word 1,$(SOURCES))

# $(wordlist s,e,text) : Extrait de s √† e
MIDDLE = $(wordlist 2,4,$(SOURCES))

# $(firstword text) : Premier mot
FIRST = $(firstword $(SOURCES))

# $(lastword text) : Dernier mot
LAST = $(lastword $(SOURCES))
```

### 7. Tri et Unicit√©

```makefile
# $(sort list) : Trie et supprime les doublons
FILES = main.c utils.c main.c config.c  
UNIQUE = $(sort $(FILES))  
# UNIQUE = config.c main.c utils.c (tri√© alphab√©tiquement)
```

## Appels Shell : `$(shell)`

Vous pouvez ex√©cuter des commandes shell et capturer leur sortie.

**Syntaxe :** `$(shell commande)`

```makefile
# Date de compilation
BUILD_DATE := $(shell date +"%Y-%m-%d %H:%M:%S")

# Nombre de CPU pour compilation parall√®le
NCPU := $(shell nproc)

# Version de Git
GIT_VERSION := $(shell git describe --tags --always)

# Liste dynamique de fichiers
SOURCES := $(shell find src -name "*.c")

all:
	@echo "Build date: $(BUILD_DATE)"
	@echo "CPUs: $(NCPU)"
	@echo "Version: $(GIT_VERSION)"
	make -j$(NCPU) programme
```

**‚ö†Ô∏è Performance** : `$(shell)` est ex√©cut√© **√† chaque fois** que Make lit le Makefile. Utilisez `:=` pour l'ex√©cuter une seule fois :

```makefile
# ‚ùå LENT : Ex√©cut√© √† chaque expansion de SOURCES
SOURCES = $(shell find src -name "*.c")

# ‚úÖ RAPIDE : Ex√©cut√© une seule fois
SOURCES := $(shell find src -name "*.c")
```

## Macros Multi-lignes : `define`

Pour d√©finir des blocs de texte ou de commandes complexes :

**Syntaxe :**

```makefile
define NOM_MACRO  
contenu  
multi-ligne  
endef  
```

### Exemple 1 : Macro de Commandes

```makefile
define compile_c
	@echo "Compilation de $<..."
	$(CC) $(CFLAGS) -c $< -o $@
	@echo "Termin√© : $@"
endef

%.o: %.c
	$(compile_c)
```

### Exemple 2 : Macro avec Param√®tres

Les macros ne prennent pas de param√®tres directs, mais vous pouvez utiliser des variables :

```makefile
define install_binary
	@echo "Installation de $(1) vers $(2)"
	install -m 755 $(1) $(2)
endef

install: programme
	$(call install_binary,programme,/usr/local/bin/)
```

**Note** : `$(call)` permet d'appeler une macro avec des param√®tres (voir section suivante).

### Exemple 3 : Template de R√®gles

```makefile
define compile_rule
$(1): $(2)
	@echo "Building $(1) from $(2)"
	gcc -o $(1) $(2)
endef

# G√©n√©ration de r√®gles
$(eval $(call compile_rule,prog1,main1.c))
$(eval $(call compile_rule,prog2,main2.c))
```

## La Fonction `$(call)`

`$(call)` permet d'appeler une macro avec des param√®tres.

**Syntaxe :** `$(call macro,param1,param2,...)`

Les param√®tres sont accessibles via `$(1)`, `$(2)`, etc.

```makefile
# D√©finition d'une macro param√©tr√©e
define compile_and_link
@echo "Compilation de $(1)..."
gcc -c $(1).c -o $(1).o  
gcc -o $(2) $(1).o  
endef  

# Appel de la macro
programme1:
	$(call compile_and_link,main,programme1)

programme2:
	$(call compile_and_link,server,programme2)
```

## Variables d'Environnement

Make peut utiliser les variables d'environnement du syst√®me.

### Priorit√© des Variables

1. Variables pass√©es en **ligne de commande** (priorit√© maximale)
2. Variables d√©finies dans le **Makefile**
3. Variables d'**environnement** (priorit√© minimale)

**Exemple :**

```bash
# Variable d'environnement (priorit√© la plus basse)
export CC=clang

# Dans le Makefile (√©crase la variable d'environnement)
CC = gcc        # Utilise gcc

# En ligne de commande (priorit√© maximale, √©crase tout)
make CC=tcc     # Utilise tcc, ignore le Makefile ET l'environnement
```

### Exporter des Variables vers les Sous-Shells

```makefile
export CC CFLAGS

all:
	./script.sh  # Ce script verra CC et CFLAGS
```

### Emp√™cher l'Import de Variables d'Environnement

```makefile
# En d√©but de Makefile
MAKEFLAGS += --no-builtin-variables --no-builtin-rules
```

## Variables de Make

Make d√©finit aussi des variables internes :

```makefile
MAKE        # Chemin vers make (pour r√©cursion)  
MAKEFILE_LIST  # Liste des Makefiles lus  
MAKEFLAGS   # Flags pass√©s √† make  
CURDIR      # R√©pertoire courant  
```

**Exemple : Makefiles R√©cursifs**

```makefile
# Makefile principal
all:
	$(MAKE) -C subdir1
	$(MAKE) -C subdir2
```

## Exemple Complet : Projet R√©el

```makefile
# ============================================
# Configuration
# ============================================
CC := gcc  
CFLAGS := -Wall -Wextra -std=c11 -O2  
CPPFLAGS := -Iinclude  
LDFLAGS := -Llib  
LDLIBS := -lm  

# R√©pertoires
SRCDIR := src  
OBJDIR := obj  
BINDIR := bin  
INCDIR := include  

# Fichiers
SOURCES := $(wildcard $(SRCDIR)/*.c)  
OBJECTS := $(patsubst $(SRCDIR)/%.c,$(OBJDIR)/%.o,$(SOURCES))  
TARGET := $(BINDIR)/programme  

# M√©tadonn√©es
BUILD_DATE := $(shell date +"%Y-%m-%d %H:%M:%S")  
GIT_VERSION := $(shell git describe --tags --always 2>/dev/null || echo "unknown")  
CPPFLAGS += -DBUILD_DATE='"$(BUILD_DATE)"' -DVERSION='"$(GIT_VERSION)"'  

# ============================================
# R√®gles
# ============================================
.PHONY: all clean info

all: $(TARGET)

# Linkage
$(TARGET): $(OBJECTS) | $(BINDIR)
	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^ $(LDLIBS)
	@echo "‚úì Build termin√© : $@"

# Compilation
$(OBJDIR)/%.o: $(SRCDIR)/%.c | $(OBJDIR)
	$(CC) $(CFLAGS) $(CPPFLAGS) -c $< -o $@

# Cr√©ation des r√©pertoires
$(OBJDIR) $(BINDIR):
	mkdir -p $@

# Nettoyage
clean:
	rm -rf $(OBJDIR) $(BINDIR)

# Informations de build
info:
	@echo "=== Configuration ==="
	@echo "CC        : $(CC)"
	@echo "CFLAGS    : $(CFLAGS)"
	@echo "Sources   : $(words $(SOURCES)) fichiers"
	@echo "Objects   : $(OBJECTS)"
	@echo "Target    : $(TARGET)"
	@echo "Build date: $(BUILD_DATE)"
	@echo "Version   : $(GIT_VERSION)"
```

## Techniques Avanc√©es

### 1. Compilation Conditionnelle

```makefile
# Mode debug ou release
DEBUG ?= 0

ifeq ($(DEBUG),1)
    CFLAGS += -g -O0 -DDEBUG
else
    CFLAGS += -O2 -DNDEBUG
endif

# Utilisation : make DEBUG=1
```

### 2. D√©tection du Syst√®me d'Exploitation

```makefile
UNAME := $(shell uname -s)

ifeq ($(UNAME),Linux)
    CFLAGS += -DLINUX
    LDLIBS += -lpthread
endif

ifeq ($(UNAME),Darwin)  # macOS
    CFLAGS += -DMACOS
endif
```

### 3. G√©n√©ration Automatique de D√©pendances

```makefile
# G√©n√©ration des .d (fichiers de d√©pendances)
$(OBJDIR)/%.d: $(SRCDIR)/%.c | $(OBJDIR)
	$(CC) $(CPPFLAGS) -MM -MT $(OBJDIR)/$*.o $< > $@

# Inclusion des d√©pendances
DEPS := $(OBJECTS:.o=.d)
-include $(DEPS)
```

### 4. Variables Calcul√©es

```makefile
# Calcul du nombre de jobs pour compilation parall√®le
NCPU := $(shell nproc 2>/dev/null || echo 1)  
MAKEFLAGS += -j$(NCPU)  

# Taille du projet
LINES := $(shell cat $(SOURCES) | wc -l)
```

## Erreurs Courantes

### 1. Expansion R√©cursive Infinie

```makefile
# ‚ùå ERREUR
CFLAGS = $(CFLAGS) -Wall

# ‚úÖ SOLUTION
CFLAGS += -Wall
```

### 2. Oublier `:=` pour $(shell)

```makefile
# ‚ùå LENT (ex√©cut√© plusieurs fois)
FILES = $(shell ls *.c)

# ‚úÖ RAPIDE (ex√©cut√© une seule fois)
FILES := $(shell ls *.c)
```

### 3. Espaces dans les Chemins

```makefile
# ‚ùå PROBL√àME si un chemin contient un espace
DIR = /mon dossier/src

# ‚úÖ SOLUTION : √âchapper ou √©viter les espaces
DIR := /mon\ dossier/src
```

## R√©sum√©

| Concept | Syntaxe | Usage |
|---------|---------|-------|
| Assignation r√©cursive | `VAR = valeur` | Variables interd√©pendantes |
| Assignation simple | `VAR := valeur` | Performance, $(shell) |
| Assignation conditionnelle | `VAR ?= valeur` | Valeurs par d√©faut |
| Ajout | `VAR += valeur` | Accumuler des flags |
| Variable automatique | `$@, $<, $^` | R√®gles g√©n√©riques |
| Substitution | `$(VAR:.c=.o)` | Transformation de listes |
| Fonction | `$(wildcard *.c)` | Manipulation de texte |
| Shell | `$(shell cmd)` | Ex√©cution de commandes |
| Macro | `define...endef` | Blocs de code |
| Appel de macro | `$(call macro,args)` | Macros param√©tr√©es |

## Bonnes Pratiques

1. ‚úÖ **Utiliser `:=` pour `$(shell)`** (performance)
2. ‚úÖ **Pr√©fixer les variables internes** avec `_` (ex: `_OBJS`)
3. ‚úÖ **Nommer en MAJUSCULES** (convention)
4. ‚úÖ **Regrouper les configurations** en d√©but de Makefile
5. ‚úÖ **Documenter les variables** non-√©videntes
6. ‚úÖ **Utiliser `?=`** pour les valeurs surchargeables

## Prochaine √âtape

Dans la section suivante (**13.2.4 Pattern rules et automatic variables**), vous d√©couvrirez comment √©crire des r√®gles g√©n√©riques pour compiler automatiquement tous vos fichiers sans les lister individuellement.

---

**üìö R√©f√©rences :**
- `man make` : Variables et fonctions
- [GNU Make Manual - Variables](https://www.gnu.org/software/make/manual/html_node/Using-Variables.html)
- [GNU Make Manual - Functions](https://www.gnu.org/software/make/manual/html_node/Functions.html)

‚è≠Ô∏è [Pattern rules et automatic variables](/13-build-systems/02.4-pattern-rules.md)
