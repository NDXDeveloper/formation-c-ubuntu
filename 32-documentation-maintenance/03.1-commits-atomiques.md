üîù Retour au [Sommaire](/SOMMAIRE.md)

# 32.3.1 Commits atomiques

## Introduction

Vous avez pass√© plusieurs heures √† coder. Vous avez corrig√© trois bugs, ajout√© deux nouvelles fonctionnalit√©s, refactoris√© du code, et mis √† jour la documentation. Maintenant, vous voulez commiter vos changements. Que faire ?

- Option A : Un seul gros commit "Modifications diverses"
- Option B : Plusieurs petits commits, un par modification logique

Si vous avez choisi **Option B**, f√©licitations ! Vous comprenez d√©j√† le concept de **commits atomiques**.

Dans cette section, nous allons apprendre :
- Ce qu'est un commit atomique
- Pourquoi c'est crucial pour la qualit√© du code
- Comment cr√©er des commits atomiques efficaces
- Les erreurs courantes √† √©viter

---

## Qu'est-ce qu'un commit atomique ?

### D√©finition

Un **commit atomique** (ou "atomic commit") est un commit qui :

1. **Contient un seul changement logique** : Une seule fonctionnalit√©, un seul bugfix, une seule modification conceptuelle
2. **Est autonome** : Peut √™tre appliqu√© ou retir√© ind√©pendamment des autres commits
3. **Est complet** : Le code compile et les tests passent apr√®s ce commit
4. **Est minimal** : Ne contient rien d'autre que ce qui est n√©cessaire pour ce changement

Le terme "atomique" vient de la physique : un atome est la plus petite unit√© indivisible. Un commit atomique est la plus petite unit√© de changement qui a du sens.

### Analogie

Imaginez que vous r√©novez une maison :

‚ùå **Approche non-atomique** :
```
Commit : "R√©novation de la maison"
- Repeindre le salon
- Changer la plomberie de la salle de bain
- Installer une nouvelle cuisine
- Refaire l'√©lectricit√©
- Poser du parquet dans les chambres
```

Si un probl√®me survient (par exemple, la nouvelle cuisine ne rentre pas), vous devez tout d√©faire !

‚úÖ **Approche atomique** :
```
Commit 1: "Repeindre le salon en blanc cass√©"
Commit 2: "Remplacer la tuyauterie de la salle de bain"
Commit 3: "Installer les meubles de cuisine IKEA"
Commit 4: "Mettre aux normes l'√©lectricit√© du RDC"
Commit 5: "Poser parquet ch√™ne massif chambre principale"
```

Si la cuisine pose probl√®me, vous pouvez annuler juste ce commit sans toucher au reste !

---

## Pourquoi les commits atomiques sont essentiels

### 1. Facilite la relecture de code (Code Review)

**Sc√©nario** : Un coll√®gue doit relire votre code avant de le merger.

‚ùå **Avec un gros commit** :
```
Commit: "Modifications diverses"
Fichiers modifi√©s: 27
Lignes ajout√©es: 847
Lignes supprim√©es: 423
```

Votre coll√®gue doit comprendre 847 lignes de changements d'un coup. Il va probablement :
- Survoler rapidement sans vraiment comprendre
- Rater des bugs
- Approuver sans vraiment relire

‚úÖ **Avec des commits atomiques** :
```
Commit 1: "Ajouter fonction de hachage MD5"
Fichiers modifi√©s: 2
Lignes: +45 -0

Commit 2: "Corriger buffer overflow dans read_config()"
Fichiers modifi√©s: 1
Lignes: +3 -1

Commit 3: "Ajouter tests unitaires pour le parser"
Fichiers modifi√©s: 2
Lignes: +127 -0
```

Chaque commit est facile √† comprendre et √† valider individuellement.

### 2. Simplifie le debugging avec `git bisect`

`git bisect` est un outil puissant qui trouve automatiquement quel commit a introduit un bug en faisant une recherche binaire.

**Avec des commits atomiques**, `bisect` peut identifier pr√©cis√©ment :
```
Commit a3f7d2c: "Optimiser l'allocation m√©moire dans parse_json()" ‚Üê Ce commit a cass√© quelque chose
```

**Sans commits atomiques** :
```
Commit z9k4m1p: "Plein de trucs" ‚Üê Un des 50 changements dans ce commit a cass√© quelque chose... lequel ?
```

### 3. Permet de "cherry-pick" facilement

**Cherry-pick** = appliquer un commit sp√©cifique d'une branche vers une autre.

**Exemple** : Vous avez d√©velopp√© 3 fonctionnalit√©s sur une branche `feature/new-stuff`. Finalement, seule la fonctionnalit√© #2 est pr√™te pour la production.

‚úÖ **Avec commits atomiques** :
```bash
git cherry-pick abc123f  # Juste la feature #2
```

‚ùå **Sans commits atomiques** : Impossible de prendre juste une partie du gros commit "Ajout de 3 features".

### 4. Facilite le rollback

Si un commit introduit un bug en production, vous pouvez le retirer proprement :

```bash
git revert abc123f  # Annule exactement ce commit
```

Avec des commits atomiques, vous retirez juste le probl√®me. Avec un gros commit, vous perdez aussi tous les autres changements bons qui √©taient dedans.

### 5. Am√©liore l'historique Git

Un historique propre avec des commits atomiques raconte l'histoire du projet :

```
* 7f3a2d1 - Ajouter support UTF-8 dans le parser (il y a 2 heures)
* 3b8c5e9 - Corriger memory leak dans free_config() (il y a 3 heures)
* a1d4f6c - Refactoriser format_output() pour clart√© (il y a 5 heures)
* 9e2c8b7 - Ajouter tests pour edge cases du parser (il y a 6 heures)
```

Vs un historique sale :

```
* x9z2k4m - Modifications (il y a 6 heures)
* p7q3j1n - Encore des trucs (il y a 12 heures)
* w5v8h2l - WIP (il y a 1 jour)
```

---

## Comment cr√©er des commits atomiques

### R√®gle n¬∞1 : Un changement logique = Un commit

Posez-vous la question : **"Ce commit fait-il UNE chose ?"**

‚úÖ **Bons exemples de commits atomiques** :
- "Ajouter fonction de calcul de CRC32"
- "Corriger segfault dans parse_header()"
- "Optimiser boucle de tri (gain de 30%)"
- "Mettre √† jour README avec instructions Docker"
- "Ajouter tests unitaires pour module crypto"

‚ùå **Mauvais exemples (non-atomiques)** :
- "Modifications" (trop vague)
- "Ajout de 3 fonctions + correction de 2 bugs + update doc" (plusieurs choses)
- "WIP" (Work In Progress - pas complet)
- "Fix" (quel fix ?)
- "Test commit please ignore" (ne devrait pas √™tre commit√©)

### R√®gle n¬∞2 : Le code doit compiler apr√®s chaque commit

Chaque commit doit laisser le projet dans un √©tat **fonctionnel** :

‚úÖ **Bon** :
```
Commit 1: Ajouter d√©claration de la fonction new_feature() dans header.h
Commit 2: Impl√©menter new_feature() dans source.c
Commit 3: Ajouter tests pour new_feature()
```
Apr√®s chaque commit, le code compile.

‚ùå **Mauvais** :
```
Commit 1: Ajouter appel √† new_feature() dans main()
         ‚Üê Le code ne compile pas ! new_feature() n'existe pas encore
Commit 2: Impl√©menter new_feature()
         ‚Üê Maintenant √ßa compile
```

### R√®gle n¬∞3 : Utiliser `git add -p` pour des commits partiels

Souvent, vous avez modifi√© plusieurs choses dans le m√™me fichier. Utilisez `git add -p` (patch mode) pour commiter seulement certaines parties :

**Exemple** : Vous avez dans `parser.c` :
- Correction d'un bug (lignes 45-47)
- Ajout d'une nouvelle fonctionnalit√© (lignes 120-180)

```bash
# Ajouter interactivement
git add -p parser.c

# Git vous montre chaque "hunk" (bloc de modifications)
# Vous pouvez r√©pondre :
# y = yes, ajouter ce hunk
# n = non, sauter ce hunk
# s = split, diviser en plus petits hunks
# e = edit, √©diter manuellement

# Commit 1 : Juste le bugfix
git commit -m "Corriger buffer overflow dans parse_line()"

# Commit 2 : La nouvelle feature
git add parser.c
git commit -m "Ajouter support des commentaires multilignes"
```

### R√®gle n¬∞4 : S√©parer le refactoring des changements de fonctionnalit√©

**Mauvaise pratique** : Refactoriser du code ET ajouter une feature dans le m√™me commit.

**Pourquoi c'est un probl√®me ?** Si la nouvelle feature introduit un bug, et que vous voulez la retirer, vous perdez aussi le refactoring b√©n√©fique.

‚úÖ **Bonne pratique** :
```
Commit 1: "Refactoriser parse_config() pour clart√©"
          - Renommer variables
          - Extraire sous-fonctions
          - Am√©liorer lisibilit√©
          - Aucun changement de comportement

Commit 2: "Ajouter validation des entr√©es dans parse_config()"
          - Nouvelle fonctionnalit√©
          - S'appuie sur le code refactoris√©
```

### R√®gle n¬∞5 : Un commit = Un message clair

Le message de commit doit expliquer **quoi** et **pourquoi** :

‚ùå **Mauvais messages** :
```bash
git commit -m "fix"
git commit -m "Update file.c"
git commit -m "test"
git commit -m "oops"
```

‚úÖ **Bons messages** :
```bash
git commit -m "Corriger memory leak dans free_user_data()

La fonction ne lib√©rait pas le champ 'name' allou√© dynamiquement,
causant une fuite de ~50 bytes par utilisateur."

git commit -m "Optimiser recherche binaire (O(log n) au lieu de O(n))

Remplacer la recherche lin√©aire par dichotomie dans find_user().
Mesure: 100x plus rapide sur 10k utilisateurs."
```

**Format recommand√©** :
```
Ligne 1: R√©sum√© imp√©ratif (max 50 caract√®res)
Ligne 2: Vide
Lignes 3+: Description d√©taill√©e si n√©cessaire
```

---

## Workflow pratique pour commits atomiques

### Workflow quotidien recommand√©

Voici comment travailler pour produire naturellement des commits atomiques :

#### 1. Planifier avant de coder

Avant de commencer, identifiez les √©tapes logiques :

**T√¢che** : "Ajouter une commande `--export` qui exporte les donn√©es en JSON"

**D√©composition** :
1. Cr√©er la structure JSON de sortie
2. Impl√©menter la fonction `export_to_json()`
3. Ajouter l'option `--export` au CLI
4. Ajouter tests
5. Mettre √† jour la documentation

**Plan de commits** :
```
Commit 1: "D√©finir structure JSON pour export des donn√©es"
Commit 2: "Impl√©menter export_to_json() avec biblioth√®que cJSON"
Commit 3: "Ajouter option --export au parseur d'arguments"
Commit 4: "Ajouter tests unitaires pour export JSON"
Commit 5: "Documenter option --export dans README"
```

#### 2. Coder une √©tape √† la fois

Travaillez sur **une seule √©tape logique**, puis commitez avant de passer √† la suivante :

```bash
# √âtape 1
vim json_export.h    # Cr√©er header avec structures
git add json_export.h
git commit -m "D√©finir structure JSON pour export des donn√©es"

# √âtape 2
vim json_export.c    # Impl√©menter les fonctions
git add json_export.c
git commit -m "Impl√©menter export_to_json() avec cJSON"

# Etc.
```

#### 3. Utiliser des branches pour exp√©rimenter

Si vous n'√™tes pas s√ªr de votre approche, travaillez sur une branche temporaire :

```bash
git checkout -b experimental/new-approach

# Exp√©rimentez librement avec des commits "sale"
git commit -m "WIP: essai 1"
git commit -m "WIP: essai 2"

# Une fois satisfait, rebasez pour nettoyer l'historique
git rebase -i main

# Fusionnez dans main avec des commits propres
git checkout main
git merge experimental/new-approach
```

#### 4. Commiter fr√©quemment, mais de mani√®re atomique

Certains disent "commitez souvent", d'autres "ne commitez que du code stable". La v√©rit√© est entre les deux :

- ‚úÖ Commitez chaque changement logique d√®s qu'il est complet
- ‚ùå Ne commitez pas du code qui ne compile pas
- ‚úÖ Faites des "savepoints" locaux si besoin (`git stash` ou commits WIP locaux)
- ‚ùå Ne pushez pas de commits "WIP" ou cass√©s

### Nettoyer l'historique avec `git rebase -i`

Si vous avez fait des commits d√©sordonn√©s pendant le d√©veloppement, nettoyez avant de pusher :

```bash
# Rebase interactif sur les 5 derniers commits
git rebase -i HEAD~5
```

Cela ouvre un √©diteur :

```
pick a1b2c3d Ajouter fonction export
pick e4f5g6h WIP: tests
pick i7j8k9l Fix typo
pick m0n1o2p Ajouter plus de tests
pick q3r4s5t Update doc

# Commandes disponibles :
# pick = garder le commit
# reword = changer le message
# squash = fusionner avec le commit pr√©c√©dent
# fixup = comme squash mais sans le message
# drop = supprimer le commit
```

Transformez en :

```
pick a1b2c3d Ajouter fonction export
squash e4f5g6h WIP: tests
squash m0n1o2p Ajouter plus de tests
fixup i7j8k9l Fix typo
pick q3r4s5t Update doc
```

R√©sultat : 5 commits mal organis√©s deviennent 2 commits atomiques propres.

---

## Exemples concrets

### Exemple 1 : Correction de bug

#### ‚ùå Commit non-atomique

```bash
git commit -m "Corrections diverses"

Fichiers modifi√©s:
- parser.c (correction buffer overflow)
- logger.c (correction format string)
- main.c (ajout log debug)
- config.c (refactoring)
```

**Probl√®me** : Si le refactoring de `config.c` introduit un bug, impossible de le retirer sans perdre les corrections de bugs importantes !

#### ‚úÖ Commits atomiques

```bash
Commit 1: "Corriger buffer overflow dans parse_line()

La fonction ne v√©rifiait pas la taille du buffer avant strcpy(),
causant un overflow si la ligne > 256 caract√®res.
Utiliser strncpy() avec v√©rification de taille."

Fichiers: parser.c

---

Commit 2: "Corriger format string vulnerability dans log_message()

Utiliser printf("%s", message) au lieu de printf(message) qui
permettait une exploitation via format strings."

Fichiers: logger.c

---

Commit 3: "Ajouter logs debug pour troubleshooting

Ajouter des logs au niveau DEBUG pour tracer le flux d'ex√©cution
lors du parsing de configuration."

Fichiers: main.c, config.c

---

Commit 4: "Refactoriser config.c pour s√©parer parsing et validation

Extraire la logique de validation dans validate_config() pour
am√©liorer la testabilit√© et la lisibilit√©."

Fichiers: config.c
```

### Exemple 2 : Nouvelle fonctionnalit√©

**T√¢che** : Ajouter support des threads pour acc√©l√©rer le traitement.

#### ‚ùå Un seul gros commit

```bash
git commit -m "Ajouter support multi-thread"

Fichiers modifi√©s: 12
Lignes: +734 -89
```

#### ‚úÖ D√©composition atomique

```bash
Commit 1: "Ajouter structure thread_pool et types associ√©s"
Fichiers: thread_pool.h
Lignes: +45 -0

---

Commit 2: "Impl√©menter thread_pool_create() et thread_pool_destroy()"
Fichiers: thread_pool.c
Lignes: +127 -0

---

Commit 3: "Impl√©menter thread_pool_submit() pour soumettre des t√¢ches"
Fichiers: thread_pool.c
Lignes: +89 -0

---

Commit 4: "Int√©grer thread pool dans le traitement de fichiers"
Fichiers: file_processor.c
Lignes: +67 -45

---

Commit 5: "Ajouter tests unitaires pour thread_pool"
Fichiers: test_thread_pool.c
Lignes: +234 -0

---

Commit 6: "Ajouter option --threads pour contr√¥ler le nombre de threads"
Fichiers: main.c, cli.c
Lignes: +43 -12

---

Commit 7: "Documenter utilisation multi-thread dans README"
Fichiers: README.md
Lignes: +34 -0
```

**Avantages** :
- Chaque commit est compr√©hensible isol√©ment
- Si un probl√®me survient avec les threads, on peut retirer les commits 2-6 et garder le reste
- Facile √† relire commit par commit

### Exemple 3 : Refactoring

#### ‚ùå M√©langer refactoring et nouvelles features

```bash
git commit -m "Refactorer et ajouter feature X"

parser.c:
- Renommage de variables (refactoring)
- Extraction de fonctions (refactoring)
- Ajout feature validation XML (nouvelle feature)
- Correction d'un vieux bug (bugfix)
```

**Probl√®me** : 3 types de changements dans un commit ! Impossible √† d√©faire s√©lectivement.

#### ‚úÖ S√©parer clairement

```bash
Commit 1: "Corriger bug d'indexation dans find_element()

L'index pouvait d√©passer la taille du tableau si l'√©l√©ment
n'√©tait pas trouv√©."

---

Commit 2: "Refactoriser parse_document() pour clart√©

- Renommer 'buf' en 'document_buffer'
- Renommer 'n' en 'element_count'
- Extraire validate_syntax() pour r√©duire complexit√©"

---

Commit 3: "Ajouter validation de sch√©ma XML

Impl√©menter check_xml_schema() qui valide un document XML
contre un sch√©ma XSD fourni."
```

---

## Erreurs courantes et comment les √©viter

### Erreur 1 : Le commit fourre-tout

**Sympt√¥me** :
```bash
git commit -m "Modifications diverses"
```

**Pourquoi c'est mal** : Aucune information, impossible √† comprendre sans lire tout le diff.

**Solution** : D√©composez en commits s√©par√©s avec `git add -p`.

### Erreur 2 : Les commits "WIP" ou "Fix" pouss√©s

**Sympt√¥me** :
```
* 3f7a2b1 - WIP
* 9e2c8d4 - fix
* a1d4f6c - fix fix
* 7b8c5e9 - test
```

**Pourquoi c'est mal** : Historique pollu√©, aucune information utile.

**Solution** : Utilisez `git rebase -i` pour nettoyer avant de push :
```bash
git rebase -i HEAD~4  # Squash les 4 derniers commits
```

### Erreur 3 : Commits trop gros

**Sympt√¥me** :
```
Commit: "Impl√©menter module r√©seau complet"
Fichiers modifi√©s: 15
Lignes: +2847 -123
```

**Pourquoi c'est mal** : Impossible √† relire, impossible √† d√©boguer si √ßa casse.

**Solution** : D√©composez en sous-t√¢ches logiques d√®s le d√©but du d√©veloppement.

### Erreur 4 : Commits qui cassent la compilation

**Sympt√¥me** :
```
Commit 1: "Ajouter appel √† process_data()"
          ‚Üê ne compile pas ! process_data() n'existe pas
Commit 2: "Impl√©menter process_data()"
          ‚Üê maintenant √ßa compile
```

**Pourquoi c'est mal** : `git bisect` et autres outils cassent, impossible de tester un commit interm√©diaire.

**Solution** : Organisez diff√©remment :
```
Commit 1: "Ajouter fonction process_data()"
          ‚Üê compile (fonction existe mais pas utilis√©e)
Commit 2: "Utiliser process_data() dans le pipeline"
          ‚Üê compile (fonction appel√©e)
```

### Erreur 5 : M√©langer formatting et logique

**Sympt√¥me** :
```bash
git diff
# Modifications:
# - Reformatage avec clang-format (300 lignes)
# - Correction d'un bug critique (3 lignes)
```

**Pourquoi c'est mal** : Le bugfix est noy√© dans le bruit du reformatage.

**Solution** : Toujours s√©parer :
```bash
Commit 1: "Reformater network.c avec clang-format"
Commit 2: "Corriger use-after-free dans close_connection()"
```

---

## Messages de commit efficaces

Un bon commit atomique a aussi besoin d'un bon message.

### Structure recommand√©e

```
Ligne 1: R√©sum√© en imp√©ratif (50 caract√®res max)
[Ligne vide]
Corps: Explication d√©taill√©e du POURQUOI
- Peut contenir des bullet points
- Contexte additionnel
- R√©f√©rence √† des issues/tickets

[Ligne vide]
Fixes: #123
See also: #456
```

### Exemples de bons messages

```bash
git commit -m "Optimiser allocation m√©moire dans parse_json()

Remplacer allocations multiples par un seul malloc() suivi de
placements manuels. R√©duit les appels syst√®me de 40 √† 1 par parsing.

Mesures sur fichier 1MB:
- Avant: 234ms
- Apr√®s: 87ms

Fixes: #789"
```

```bash
git commit -m "Ajouter validation des entr√©es utilisateur

Pr√©venir injection SQL en √©chappant les caract√®res sp√©ciaux
dans build_query(). Utiliser prepared statements quand disponible.

Cette correction r√©pond aux recommandations de l'audit s√©curit√©
du 2025-01-15.

Security: CVE-2025-12345
See also: docs/security/sql-injection.md"
```

### Conventions de pr√©fixe (optionnel)

Certains projets utilisent des pr√©fixes pour cat√©goriser :

```
feat: Ajouter feature X
fix: Corriger bug Y
docs: Mettre √† jour documentation
style: Reformatage code
refactor: Refactoriser module Z
test: Ajouter tests
chore: T√¢ches maintenance (update deps, etc.)
perf: Am√©lioration performance
```

Exemple :
```bash
git commit -m "feat: Ajouter export CSV des r√©sultats"
git commit -m "fix: Corriger segfault dans free_list()"
git commit -m "docs: Ajouter exemples d'utilisation au README"
```

C'est une convention popularis√©e par Angular. Utilisez-la si votre √©quipe l'adopte, sinon des messages clairs suffisent.

---

## Outils pour faciliter les commits atomiques

### 1. `git add -p` (Patch mode)

Ajoutez interactivement des parties de fichiers :

```bash
git add -p src/parser.c

# Git montre chaque changement et demande :
# Stage this hunk [y,n,q,a,d,/,s,e,?]?
```

### 2. `git gui`

Interface graphique pour s√©lectionner visuellement les lignes √† commiter :

```bash
git gui
```

Permet de cocher ligne par ligne ce qui va dans le commit.

### 3. `tig`

Navigateur ncurses pour Git, excellente visualisation :

```bash
sudo apt install tig
tig
```

### 4. IDE avec support Git

Les IDE modernes (VS Code, CLion, etc.) permettent de :
- Voir les changements en temps r√©el
- Stager/unstager des fichiers ou des lignes
- Commiter avec interface graphique

**VS Code** :
- Source Control panel (Ctrl+Shift+G)
- Clic droit sur les changements ‚Üí "Stage Selected Ranges"

### 5. `git stash`

Mettre de c√¥t√© des changements temporairement :

```bash
# Vous travaillez sur feature A et feature B en m√™me temps
git stash      # Mettre de c√¥t√© les changements

# Commiter feature A
git add fileA.c
git commit -m "Impl√©menter feature A"

# R√©cup√©rer feature B
git stash pop
git add fileB.c
git commit -m "Impl√©menter feature B"
```

---

## Bonnes pratiques r√©capitulatives

### Do ‚úÖ

1. **Un commit = une id√©e** : Chaque commit doit avoir un objectif clair et unique
2. **Tests passent** : Chaque commit doit laisser le code dans un √©tat testable
3. **Message descriptif** : Expliquez le QUOI et le POURQUOI
4. **Commits fr√©quents** : Commitez chaque changement logique compl√©t√©
5. **Review avant push** : Relisez vos commits avec `git log --oneline` avant de pusher
6. **Utilisez `git add -p`** : Pour des commits partiels dans un fichier
7. **Rebase pour nettoyer** : Utilisez `git rebase -i` pour organiser l'historique avant push
8. **S√©parez refactoring et features** : Toujours dans des commits diff√©rents

### Don't ‚ùå

1. **Pas de "WIP"** : Ne pushez jamais des commits Work In Progress
2. **Pas de commits fourre-tout** : "Modifications diverses" ne dit rien
3. **Pas de code qui ne compile pas** : Chaque commit doit √™tre fonctionnel
4. **Pas de m√©lange logique/formatting** : Toujours s√©parer
5. **Pas de commits g√©ants** : Si >300 lignes, c'est probablement d√©composable
6. **Pas de messages vagues** : "Fix", "Update", "Test" ne sont pas des messages
7. **Pas de commits sur main sans review** : Utilisez des branches et PRs
8. **Pas de commit de fichiers g√©n√©r√©s** : Binaires, .o, .exe, etc. ‚Üí .gitignore

---

## Commits atomiques en √©quipe

### Code Review facilit√©

Avec des commits atomiques, les reviewers peuvent :

```bash
# Voir les commits de la PR un par un
git log --oneline origin/main..feature/new-stuff

# Reviewer commit par commit
git show abc123f  # Premier commit
git show def456g  # Deuxi√®me commit
```

Chaque commit est une unit√© de review ind√©pendante et compr√©hensible.

### Gestion des conflits

Des commits atomiques r√©duisent les conflits et les rendent plus faciles √† r√©soudre :

**Sc√©nario** : Deux d√©veloppeurs modifient `parser.c`

- Dev A : Commits atomiques sur diff√©rentes fonctions
- Dev B : Commits atomiques sur d'autres fonctions

R√©sultat : Peu ou pas de conflits. Git peut merger automatiquement.

Vs :

- Dev A : Un gros commit touchant tout le fichier
- Dev B : Un gros commit touchant tout le fichier

R√©sultat : Conflit massif, r√©solution manuelle p√©nible.

### Convention d'√©quipe

√âtablissez des conventions avec votre √©quipe :

```markdown
# .github/CONTRIBUTING.md

## Commits

- Chaque commit doit compiler
- Message en anglais, imp√©ratif ("Add" pas "Added")
- Pr√©fixer avec type: feat, fix, docs, etc.
- R√©f√©rencer l'issue (#123)
- Pas de commits WIP sur les branches partag√©es
```

---

## Cas particuliers

### Que faire d'un tr√®s gros changement ?

Parfois, un changement est intrins√®quement gros (refonte d'architecture, migration vers nouvelle API, etc.).

**Strat√©gie** : D√©composez quand m√™me au maximum

```bash
Commit 1: "Ajouter couche d'abstraction pour nouvelle API"
          (Ajout de wrappers, ancien code continue de fonctionner)

Commit 2: "Migrer module_a vers nouvelle API"

Commit 3: "Migrer module_b vers nouvelle API"

Commit 4: "Migrer module_c vers nouvelle API"

Commit 5: "Supprimer ancien code devenu inutile"
```

M√™me si au total c'est √©norme, c'est d√©coup√© en √©tapes logiques.

### Commits de merge

Les commits de merge ne sont pas atomiques au sens classique, c'est normal :

```bash
Merge branch 'feature/export-json' into main
```

C'est acceptable car le merge lui-m√™me est une op√©ration atomique (fusionner une branche).

### Commits de correction apr√®s review

Si un reviewer demande des corrections :

**Option A** : Nouveau commit
```bash
git commit -m "Corriger remarque review: valider entr√©es"
```

**Option B** : Amend le commit original (si pas encore pushed publiquement)
```bash
git commit --amend
```

**Option C** : Fixup puis rebase (pratique courante)
```bash
git commit -m "fixup! Ajouter validation"
git rebase -i --autosquash main
```

---

## Checklist : Avant de commiter

Avant chaque commit, posez-vous ces questions :

- [ ] Ce commit fait-il **une seule chose** logique ?
- [ ] Le code **compile-t-il** apr√®s ce commit ?
- [ ] Les **tests passent-ils** ?
- [ ] Le message de commit est-il **clair et descriptif** ?
- [ ] Ai-je inclus **seulement ce qui est n√©cessaire** (pas de changements non li√©s) ?
- [ ] Ce commit pourrait-il √™tre **retir√© ind√©pendamment** des autres ?
- [ ] Quelqu'un comprendra-t-il ce commit dans **6 mois** ?

Si vous r√©pondez OUI √† toutes ces questions, commitez ! Sinon, d√©composez ou nettoyez.

---

## Conclusion

Les commits atomiques sont une discipline, pas une contrainte. Ils demandent un peu plus d'effort initial, mais vous font gagner **√©norm√©ment** de temps sur :

- Le debugging
- Les code reviews
- La maintenance
- La compr√©hension de l'historique

**Principe √† retenir** :

> *Un commit atomique est la plus petite unit√© de changement qui a du sens et qui peut vivre ind√©pendamment.*

Avec la pratique, cr√©er des commits atomiques devient naturel. Vous planifierez automatiquement vos changements en √©tapes logiques, et votre historique Git deviendra une documentation vivante de votre projet.

---

## Ressources compl√©mentaires

- **Pro Git Book** - Chapitre sur les commits : https://git-scm.com/book/en/v2/Git-Basics-Recording-Changes-to-the-Repository
- **Conventional Commits** : https://www.conventionalcommits.org/
- **How to Write a Git Commit Message** : https://chris.beams.io/posts/git-commit/
- **Git Best Practices** : https://github.com/trein/dev-best-practices/wiki/Git-Commit-Best-Practices

**Prochaine section** : 32.3.2 Branches et workflow) - Nous verrons comment organiser les branches Git et les diff√©rents workflows d'√©quipe (Git Flow, GitHub Flow, etc.).

‚è≠Ô∏è [Branches et workflow](/32-documentation-maintenance/03.2-branches-workflow.md)
