üîù Retour au [Sommaire](/SOMMAIRE.md)

# 15.7.1 gcov - Outil de Couverture de Code

## Introduction

**gcov** est l'outil de couverture de code (code coverage) fourni avec GCC. Il permet de mesurer **quelles parties de votre code ont √©t√© ex√©cut√©es** pendant les tests. C'est un outil essentiel pour √©valuer la qualit√© de vos tests et identifier les zones de code non test√©es.

### Qu'est-ce que la couverture de code ?

La **couverture de code** (code coverage) est une m√©trique qui indique le pourcentage de votre code source qui a √©t√© ex√©cut√© lors des tests. Elle r√©pond √† des questions comme :

- ‚úÖ Cette fonction a-t-elle √©t√© appel√©e ?
- ‚úÖ Cette ligne de code a-t-elle √©t√© ex√©cut√©e ?
- ‚úÖ Toutes les branches d'un `if/else` ont-elles √©t√© test√©es ?
- ‚úÖ Combien de fois chaque ligne a-t-elle √©t√© ex√©cut√©e ?

### Pourquoi mesurer la couverture de code ?

**Avantages :**
- üéØ **Identifier le code non test√©** : Zones √† risque √©lev√© de bugs
- üìä **√âvaluer la qualit√© des tests** : Plus la couverture est √©lev√©e, plus les tests sont complets
- üêõ **D√©tecter le code mort** : Code jamais ex√©cut√© (peut-√™tre obsol√®te)
- üîç **Guider l'√©criture de tests** : Savoir o√π ajouter des tests suppl√©mentaires
- üìà **Suivre l'√©volution** : M√©triques objectives de progression

**Attention :** Une couverture de 100% ne garantit pas l'absence de bugs ! Elle indique seulement que tout le code a √©t√© ex√©cut√©, pas qu'il a √©t√© test√© correctement.

---

## Comment fonctionne gcov ?

### Principe de fonctionnement

gcov fonctionne en trois √©tapes :

```
1. INSTRUMENTATION               2. EX√âCUTION                3. ANALYSE
   (Compilation)                     (Tests)                   (Rapport)
        ‚Üì                               ‚Üì                         ‚Üì
   gcc -fprofile-arcs       ‚Üí    ./programme          ‚Üí    gcov fichier.c
   gcc -ftest-coverage             (g√©n√®re .gcda)           (g√©n√®re .gcov)
   (g√©n√®re .gcno)
```

**D√©tails de chaque √©tape :**

1. **Instrumentation** : Le compilateur ins√®re du code suppl√©mentaire pour compter les ex√©cutions
   - Fichiers `.gcno` cr√©√©s : Contiennent les informations structurelles du code

2. **Ex√©cution** : Le programme enregistre les donn√©es de couverture
   - Fichiers `.gcda` cr√©√©s : Contiennent les compteurs d'ex√©cution

3. **Analyse** : gcov g√©n√®re un rapport lisible
   - Fichiers `.gcov` cr√©√©s : Code source annot√© avec les compteurs

---

## Installation et pr√©requis

### V√©rification de l'installation

gcov est **automatiquement install√©** avec GCC. V√©rifiez sa pr√©sence :

```bash
gcov --version
```

**Sortie typique :**
```
gcov (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0  
Copyright (C) 2021 Free Software Foundation, Inc.  
```

### Pr√©requis

- **GCC** : Version 4.0 ou sup√©rieure (recommand√© : 9+)
- **Code source** : Acc√®s au code source pour l'annotation
- **Tests** : Un programme ou des tests √† ex√©cuter

---

## Utilisation de base

### Exemple simple : Hello World avec gcov

**√âtape 1 : Cr√©er un fichier source**

Cr√©ons `hello.c` :

```c
#include <stdio.h>

void print_hello() {
    printf("Hello, World!\n");
}

void print_goodbye() {
    printf("Goodbye, World!\n");
}

int main() {
    print_hello();
    // print_goodbye() n'est jamais appel√©e
    return 0;
}
```

**√âtape 2 : Compiler avec les options de couverture**

```bash
gcc -fprofile-arcs -ftest-coverage -o hello hello.c
```

**Explication des options :**
- `-fprofile-arcs` : Ins√®re le code pour compter les transitions entre blocs
- `-ftest-coverage` : G√©n√®re les fichiers `.gcno` avec les infos structurelles

Apr√®s compilation, vous devriez voir appara√Ætre :
- `hello` : L'ex√©cutable
- `hello.gcno` : Fichier de notes (structure du code)

**√âtape 3 : Ex√©cuter le programme**

```bash
./hello
```

**Sortie :**
```
Hello, World!
```

Apr√®s ex√©cution, un nouveau fichier appara√Æt :
- `hello.gcda` : Donn√©es de couverture (compteurs d'ex√©cution)

**√âtape 4 : G√©n√©rer le rapport de couverture**

```bash
gcov hello.c
```

**Sortie typique :**
```
File 'hello.c'  
Lines executed:60.00% of 5  
Creating 'hello.c.gcov'  
```

**√âtape 5 : Consulter le rapport d√©taill√©**

```bash
cat hello.c.gcov
```

**Contenu du fichier `hello.c.gcov` :**

```
        -:    0:Source:hello.c
        -:    1:#include <stdio.h>
        -:    2:
        1:    3:void print_hello() {
        1:    4:    printf("Hello, World!\n");
        1:    5:}
        -:    6:
    #####:    7:void print_goodbye() {
    #####:    8:    printf("Goodbye, World!\n");
    #####:    9:}
        -:   10:
        1:   11:int main() {
        1:   12:    print_hello();
        -:   13:    // print_goodbye() n'est jamais appel√©e
        1:   14:    return 0;
        1:   15:}
```

**Interpr√©tation des symboles :**
- **Nombre** (ex: `1:`) : La ligne a √©t√© ex√©cut√©e ce nombre de fois
- **`#####:`** : La ligne n'a **jamais** √©t√© ex√©cut√©e (code non couvert)
- **`-:`** : Ligne non ex√©cutable (commentaires, d√©clarations)

Dans cet exemple :
- ‚úÖ `print_hello()` a √©t√© ex√©cut√©e (couverture : 100%)
- ‚ùå `print_goodbye()` n'a jamais √©t√© ex√©cut√©e (couverture : 0%)
- **Couverture totale** : 60% (3 lignes sur 5)

---

## Comprendre les m√©triques de couverture

### Types de couverture

gcov mesure principalement la **couverture de lignes** (line coverage), mais il peut aussi donner des informations sur :

#### 1. Couverture de lignes (Line Coverage)

Pourcentage de lignes ex√©cut√©es au moins une fois.

```c
int x = 10;        // ‚úÖ Ex√©cut√©  
if (x > 5) {       // ‚úÖ Ex√©cut√©  
    printf("Big");  // ‚úÖ Ex√©cut√©
} else {
    printf("Small"); // ‚ùå Non ex√©cut√© (couverture 75%)
}
```

#### 2. Couverture de branches (Branch Coverage)

Pourcentage de branches conditionnelles test√©es.

```c
if (condition) {   // Branch 1: condition vraie
    // ...
} else {           // Branch 2: condition fausse
    // ...
}
```

Pour avoir 100% de couverture de branches, il faut tester les **deux** cas.

**Activer l'affichage des branches :**

```bash
gcov -b hello.c
```

**Sortie avec branches :**
```
File 'hello.c'  
Lines executed:60.00% of 5  
Branches executed:100.00% of 2  
Taken at least once:50.00% of 2  
```

#### 3. Couverture de fonctions (Function Coverage)

Pourcentage de fonctions appel√©es.

```bash
gcov -f hello.c
```

**Sortie :**
```
Function 'print_hello' executed 100.00% of 2 lines  
Function 'print_goodbye' executed 0.00% of 2 lines  
Function 'main' executed 100.00% of 3 lines  
```

---

## Options importantes de gcov

### Options de base

#### `-b` : Afficher les informations sur les branches

```bash
gcov -b programme.c
```

Montre quelles branches conditionnelles ont √©t√© test√©es.

#### `-c` : Afficher le nombre d'appels de branches

```bash
gcov -b -c programme.c
```

Donne le nombre exact de fois o√π chaque branche a √©t√© prise.

#### `-f` : Afficher les statistiques par fonction

```bash
gcov -f programme.c
```

Rapport de couverture fonction par fonction.

#### `-l` : Cr√©er un fichier de couverture par fonction

```bash
gcov -l programme.c
```

G√©n√®re un fichier `.gcov` s√©par√© pour chaque fonction.

### Options de formatage

#### `-m` : Afficher le nom de la fonction pour chaque bloc

```bash
gcov -m programme.c
```

Ajoute le nom de la fonction avant chaque bloc de code.

#### `-n` : Ne pas cr√©er de fichier `.gcov`

```bash
gcov -n programme.c
```

Affiche seulement les statistiques dans le terminal.

#### `-r` : Afficher uniquement les informations sur le fichier courant

```bash
gcov -r programme.c
```

Ignore les fichiers d'en-t√™te inclus.

### Options avanc√©es

#### `-a` : Afficher tous les blocs

```bash
gcov -a programme.c
```

Montre tous les blocs de base, m√™me ceux non ex√©cut√©s.

#### `-u` : Afficher les lignes non ex√©cut√©es uniquement

```bash
gcov -u programme.c
```

Liste seulement les lignes qui n'ont pas √©t√© test√©es.

---

## Exemple complet : Programme avec tests

### Code source : `calculator.c`

```c
#include <stdio.h>
#include <stdlib.h>

int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

int multiply(int a, int b) {
    return a * b;
}

int divide(int a, int b) {
    if (b == 0) {
        fprintf(stderr, "Error: Division by zero\n");
        return 0;
    }
    return a / b;
}

int main(int argc, char *argv[]) {
    if (argc != 4) {
        printf("Usage: %s <num1> <op> <num2>\n", argv[0]);
        return 1;
    }

    int a = atoi(argv[1]);
    int b = atoi(argv[3]);
    char op = argv[2][0];
    int result;

    switch (op) {
        case '+':
            result = add(a, b);
            break;
        case '-':
            result = subtract(a, b);
            break;
        case '*':
            result = multiply(a, b);
            break;
        case '/':
            result = divide(a, b);
            break;
        default:
            printf("Unknown operator: %c\n", op);
            return 1;
    }

    printf("Result: %d\n", result);
    return 0;
}
```

### Compilation avec couverture

```bash
gcc -fprofile-arcs -ftest-coverage -o calculator calculator.c
```

### Ex√©cution de tests

```bash
# Test 1 : Addition
./calculator 5 + 3

# Test 2 : Soustraction
./calculator 10 - 4

# Test 3 : Multiplication
./calculator 6 * 7
```

**Note :** Nous n'avons pas test√© la division ni la gestion d'erreurs !

### G√©n√©ration du rapport

```bash
gcov calculator.c
```

**Sortie :**
```
File 'calculator.c'  
Lines executed:70.00% of 30  
Creating 'calculator.c.gcov'  
```

### Analyse du rapport

```bash
cat calculator.c.gcov | grep -E "^[# ]+#####:"
```

Cette commande affiche toutes les lignes **non ex√©cut√©es** :

```
    #####:   17:    if (b == 0) {
    #####:   18:        fprintf(stderr, "Error: Division by zero\n");
    #####:   19:        return 0;
    #####:   46:        case '/':
    #####:   47:            result = divide(a, b);
    #####:   48:            break;
```

**Constat :**
- ‚ùå La fonction `divide()` n'a jamais √©t√© appel√©e
- ‚ùå La gestion d'erreur de division par z√©ro n'a pas √©t√© test√©e
- **Couverture : 70%** ‚Üí Il faut ajouter des tests !

### Ajout de tests manquants

```bash
# Test 4 : Division normale
./calculator 20 / 5

# Test 5 : Division par z√©ro
./calculator 10 / 0
```

### Nouvelle g√©n√©ration du rapport

```bash
# R√©g√©n√©rer le rapport
gcov calculator.c
```

**Sortie :**
```
File 'calculator.c'  
Lines executed:100.00% of 30  
Creating 'calculator.c.gcov'  
```

‚úÖ **Couverture : 100%** ‚Üí Tous les chemins ont √©t√© test√©s !

---

## Gestion de plusieurs fichiers

### Projet multi-fichiers

**Structure :**
```
project/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.c
‚îÇ   ‚îî‚îÄ‚îÄ utils.c
‚îú‚îÄ‚îÄ include/
‚îÇ   ‚îî‚îÄ‚îÄ utils.h
‚îî‚îÄ‚îÄ Makefile
```

**Makefile avec support gcov :**

```makefile
CC = gcc  
CFLAGS = -Wall -Wextra -std=c11 -I./include  
COVERAGE_FLAGS = -fprofile-arcs -ftest-coverage  
LDFLAGS = -lgcov  

SRC = src/main.c src/utils.c  
OBJ = $(SRC:.c=.o)  
EXEC = myprogram  

# Build normal
all: $(EXEC)

$(EXEC): $(OBJ)
	$(CC) $(OBJ) -o $@

%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@

# Build avec couverture
coverage: CFLAGS += $(COVERAGE_FLAGS)  
coverage: clean $(EXEC)  

# Ex√©cuter et g√©n√©rer le rapport
test-coverage: coverage
	./$(EXEC)
	gcov src/*.c
	@echo "Coverage reports generated: *.gcov"

# Nettoyer
clean:
	rm -f $(OBJ) $(EXEC) *.gcno *.gcda *.gcov

.PHONY: all coverage test-coverage clean
```

**Utilisation :**

```bash
# Compiler avec couverture et ex√©cuter les tests
make test-coverage
```

### Analyser tous les fichiers

```bash
# G√©n√©rer les rapports pour tous les fichiers
gcov -r src/*.c

# Afficher un r√©sum√©
for file in src/*.c; do
    echo "=== $file ==="
    gcov "$file" | grep "Lines executed"
done
```

---

## Int√©gration dans le workflow de d√©veloppement

### Script automatis√© de couverture

Cr√©ez `run_coverage.sh` :

```bash
#!/bin/bash

set -e

echo "üßπ Cleaning old coverage data..."  
rm -f *.gcda *.gcno *.gcov  

echo "üî® Compiling with coverage..."  
gcc -fprofile-arcs -ftest-coverage -o myapp src/*.c  

echo "üß™ Running tests..."
./myapp test1
./myapp test2
./myapp test3

echo "üìä Generating coverage report..."  
gcov -b -c src/*.c  

echo ""  
echo "üìà Coverage Summary:"  
echo "===================="  
grep "Lines executed" *.gcov  

# V√©rifier le seuil de couverture
COVERAGE=$(gcov src/main.c | grep "Lines executed" | awk '{print $3}' | tr -d '%')  
THRESHOLD=80  

if (( $(echo "$COVERAGE < $THRESHOLD" | bc -l) )); then
    echo "‚ùå Coverage ($COVERAGE%) is below threshold ($THRESHOLD%)"
    exit 1
else
    echo "‚úÖ Coverage ($COVERAGE%) meets threshold ($THRESHOLD%)"
fi
```

Rendez-le ex√©cutable :

```bash
chmod +x run_coverage.sh
./run_coverage.sh
```

---

## Visualisation avec lcov (aper√ßu)

gcov g√©n√®re des fichiers texte, mais pour une meilleure visualisation, on peut utiliser **lcov** (voir section 15.7.2).

**Aper√ßu rapide :**

```bash
# Installer lcov
sudo apt install lcov

# G√©n√©rer un rapport HTML
lcov --capture --directory . --output-file coverage.info  
genhtml coverage.info --output-directory coverage_html  

# Ouvrir le rapport
xdg-open coverage_html/index.html
```

Cela cr√©e un magnifique rapport HTML interactif avec :
- Vue d'ensemble par fichier
- Code source color√© (vert = couvert, rouge = non couvert)
- Graphiques de couverture

---

## Bonnes pratiques avec gcov

### 1. Nettoyer les donn√©es entre les tests

Les fichiers `.gcda` sont **cumulatifs**. Si vous ex√©cutez votre programme plusieurs fois, les compteurs s'additionnent.

**Nettoyage avant chaque test :**

```bash
# Supprimer les anciennes donn√©es
rm -f *.gcda

# Ou r√©initialiser les compteurs
lcov --zerocounters --directory .
```

### 2. Exclure le code non pertinent

Certaines parties du code n'ont pas besoin d'√™tre test√©es :
- Code de d√©bogage
- Code legacy
- Code g√©n√©r√© automatiquement

**Marquage avec LCOV_EXCL :**

```c
// LCOV_EXCL_START
void debug_function() {
    // Ce code ne sera pas compt√© dans la couverture
    printf("Debug info...\n");
}
// LCOV_EXCL_STOP

void another_function() {
    // LCOV_EXCL_LINE
    assert(condition);  // Cette ligne est exclue
}
```

### 3. Viser un seuil r√©aliste

**Seuils recommand√©s :**
- üü¢ **80-90%** : Excellent pour du code m√©tier
- üü° **60-80%** : Acceptable, mais peut √™tre am√©lior√©
- üî¥ **< 60%** : Insuffisant, risques √©lev√©s

**Note :** 100% de couverture n'est pas toujours n√©cessaire ni r√©aliste !

### 4. Se concentrer sur le code critique

Priorisez la couverture pour :
- ‚úÖ Fonctions de traitement de donn√©es
- ‚úÖ Gestion d'erreurs
- ‚úÖ Logique m√©tier complexe
- ‚úÖ Code de s√©curit√©

Moins prioritaire :
- ‚ùå Code de logging
- ‚ùå Getters/setters simples
- ‚ùå Code d'affichage

### 5. Analyser la couverture de branches

La couverture de lignes ne suffit pas. V√©rifiez aussi les branches :

```bash
gcov -b -c programme.c
```

**Exemple :**

```c
if (x > 0 && y > 0) {  // 4 branches possibles !
    // ...
}
```

Branches √† tester :
1. `x > 0` vrai, `y > 0` vrai
2. `x > 0` vrai, `y > 0` faux
3. `x > 0` faux, `y > 0` vrai
4. `x > 0` faux, `y > 0` faux

### 6. Int√©grer dans le CI/CD

Automatisez la v√©rification de couverture dans votre pipeline :

```yaml
# .github/workflows/coverage.yml
- name: Run tests with coverage
  run: |
    gcc -fprofile-arcs -ftest-coverage -o test test.c
    ./test
    gcov test.c

- name: Check coverage threshold
  run: |
    COVERAGE=$(gcov test.c | grep "Lines executed" | awk '{print $3}' | tr -d '%')
    if (( $(echo "$COVERAGE < 80" | bc -l) )); then
      echo "Coverage too low: $COVERAGE%"
      exit 1
    fi
```

---

## Limitations et pr√©cautions

### 1. Overhead de performance

L'instrumentation ajoute du code suppl√©mentaire :
- ‚è±Ô∏è **Ralentissement** : 10-30% en moyenne
- üíæ **Taille** : Binaire plus gros de 20-50%

**Solution :** N'utilisez gcov que pour les builds de test, jamais en production.

### 2. Fichiers de donn√©es volumineux

Les fichiers `.gcda` peuvent devenir gros sur de gros projets :
- Plusieurs Mo pour des projets de 100k+ lignes

**Solution :** Nettoyez r√©guli√®rement avec `rm *.gcda`.

### 3. Couverture ‚â† Qualit√© des tests

**100% de couverture ne garantit pas :**
- ‚ùå L'absence de bugs
- ‚ùå La qualit√© des assertions
- ‚ùå La pertinence des cas de test

**Exemple de mauvais test avec 100% de couverture :**

```c
int divide(int a, int b) {
    if (b == 0) return 0;
    return a / b;
}

// Test qui couvre 100% mais ne teste rien !
void test() {
    divide(10, 2);   // ‚úÖ Couvert
    divide(5, 0);    // ‚úÖ Couvert
    // Mais pas d'assertion ! On ne v√©rifie pas les r√©sultats.
}
```

### 4. Probl√®mes avec le code optimis√©

La couverture peut √™tre impr√©cise avec `-O2` ou `-O3` :
- Le compilateur peut r√©organiser ou supprimer du code
- Les compteurs peuvent √™tre inexacts

**Recommandation :** Utilisez `-O0` (pas d'optimisation) pour mesurer la couverture.

### 5. Code inline et macros

gcov peut avoir du mal avec :
- Fonctions `inline`
- Macros complexes
- Code g√©n√©r√© par le pr√©processeur

**Exemple probl√©matique :**

```c
#define MAX(a, b) ((a) > (b) ? (a) : (b))

int x = MAX(10, 20);  // gcov peut mal compter ceci
```

---

## Cas d'usage pratiques

### Cas 1 : Identifier le code mort

```bash
# G√©n√©rer le rapport
gcov -u programme.c

# Afficher seulement les lignes non ex√©cut√©es
grep "^    #####:" programme.c.gcov
```

**Utilit√© :** D√©tecter du code obsol√®te √† supprimer.

### Cas 2 : Valider les tests de r√©gression

```bash
# Baseline
./run_tests
gcov src/*.c  
mv *.gcov coverage_baseline/  

# Apr√®s modifications
./run_tests
gcov src/*.c

# Comparer
diff coverage_baseline/ *.gcov
```

### Cas 3 : Test-Driven Development (TDD)

1. **√âcrire le test** (qui √©choue)
2. **V√©rifier la couverture** : 0% sur la nouvelle fonction
3. **Impl√©menter** la fonction
4. **V√©rifier la couverture** : 100% sur la nouvelle fonction

```bash
# Cycle TDD avec gcov
write_test() {
    # √âcrire test_new_feature.c
    gcc -fprofile-arcs -ftest-coverage test.c -o test
    ./test  # √âchoue
    gcov test.c  # 0% sur new_feature()
}

implement() {
    # Impl√©menter new_feature()
    gcc -fprofile-arcs -ftest-coverage test.c -o test
    ./test  # R√©ussit
    gcov test.c  # 100% sur new_feature()
}
```

### Cas 4 : Code Review avec couverture

Avant d'accepter une Pull Request :

```bash
# V√©rifier la couverture du code ajout√©
git diff main...feature --name-only | grep "\.c$" | while read file; do
    gcov "$file"
    COVERAGE=$(gcov "$file" | grep "Lines executed" | awk '{print $3}' | tr -d '%')
    echo "$file: $COVERAGE%"
done
```

---

## Commandes utiles - Cheat Sheet

```bash
# Compilation avec couverture
gcc -fprofile-arcs -ftest-coverage -o prog prog.c

# Ex√©cution
./prog

# Rapport basique
gcov prog.c

# Rapport avec branches
gcov -b prog.c

# Rapport avec fonctions
gcov -f prog.c

# Rapport d√©taill√©
gcov -b -c -f prog.c

# Afficher seulement les lignes non couvertes
gcov -u prog.c

# Nettoyer les donn√©es
rm -f *.gcda *.gcno *.gcov

# R√©sum√© rapide
gcov prog.c | grep "Lines executed"

# Lister les fichiers non couverts
grep "^    #####:" prog.c.gcov | wc -l

# V√©rifier un seuil
COVERAGE=$(gcov prog.c | grep "Lines executed" | awk '{print $3}' | tr -d '%')  
if (( $(echo "$COVERAGE < 80" | bc -l) )); then  
    echo "Coverage too low: $COVERAGE%"
fi
```

---

## Int√©gration avec CMake

Pour les projets utilisant CMake, voici comment int√©grer gcov :

**CMakeLists.txt :**

```cmake
cmake_minimum_required(VERSION 3.15)  
project(MyProject C)  

set(CMAKE_C_STANDARD 11)

# Option pour activer la couverture
option(ENABLE_COVERAGE "Enable code coverage" OFF)

if(ENABLE_COVERAGE)
    message(STATUS "Code coverage enabled")

    # Flags pour gcov
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -fprofile-arcs -ftest-coverage")
    set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -lgcov")

    # Target pour g√©n√©rer le rapport
    add_custom_target(coverage
        COMMAND ${CMAKE_MAKE_PROGRAM} test
        COMMAND gcov ${CMAKE_SOURCE_DIR}/src/*.c
        COMMAND echo "Coverage reports generated"
        WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
        COMMENT "Generating coverage report"
    )
endif()

# Sources
add_executable(myapp src/main.c src/utils.c)

# Tests
enable_testing()  
add_test(NAME test_myapp COMMAND myapp)  
```

**Utilisation :**

```bash
# Build avec couverture
cmake -B build -DENABLE_COVERAGE=ON  
cmake --build build  

# Ex√©cuter les tests et g√©n√©rer le rapport
cd build  
make coverage  
```

---

## D√©pannage

### Probl√®me : "cannot open notes file"

**Erreur :**
```
prog.gcda:cannot open notes file
```

**Cause :** Les fichiers `.gcno` sont introuvables ou dans un autre r√©pertoire.

**Solution :**
```bash
# Ex√©cuter gcov dans le m√™me r√©pertoire que les .gcno
cd directory_with_gcno  
gcov ../source/prog.c  
```

### Probl√®me : "no executable lines"

**Erreur :**
```
No executable lines
```

**Cause :** Le fichier ne contient que des d√©clarations/commentaires.

**Solution :** C'est normal pour les fichiers d'en-t√™te. Ignorez-les.

### Probl√®me : Couverture √† 0% alors que le code s'ex√©cute

**Cause :** Les fichiers `.gcda` ne sont pas g√©n√©r√©s ou √©cras√©s.

**Solutions :**
1. V√©rifier que le programme se termine normalement (pas de SIGKILL)
2. V√©rifier les permissions d'√©criture dans le r√©pertoire
3. Compiler avec `-lgcov` explicitement

```bash
gcc -fprofile-arcs -ftest-coverage prog.c -o prog -lgcov
```

### Probl√®me : Fichiers .gcda √©normes

**Cause :** Trop d'ex√©cutions accumul√©es.

**Solution :**
```bash
# R√©initialiser les compteurs
rm *.gcda
```

---

## Comparaison avec d'autres outils

| Outil | Langage | Gratuit | Int√©gration | Visualisation |
|-------|---------|---------|-------------|---------------|
| **gcov** | C/C++ | ‚úÖ Oui | GCC natif | ‚≠ê‚≠ê Texte |
| **lcov** | C/C++ | ‚úÖ Oui | Wrapper gcov | ‚≠ê‚≠ê‚≠ê‚≠ê HTML |
| **Codecov** | Multi | ‚úÖ/üí∞ | Cloud | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Web |
| **Coveralls** | Multi | ‚úÖ/üí∞ | Cloud | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Web |
| **gcovr** | C/C++ | ‚úÖ Oui | Wrapper gcov | ‚≠ê‚≠ê‚≠ê‚≠ê HTML/XML |

**Recommandation :**
- **D√©veloppement local** : gcov seul suffit
- **Projets s√©rieux** : gcov + lcov pour visualisation
- **Open-source** : gcov + Codecov/Coveralls pour badges et historique

---

## Ressources suppl√©mentaires

### Documentation officielle
- **Manuel GCC** : [https://gcc.gnu.org/onlinedocs/gcc/Gcov.html](https://gcc.gnu.org/onlinedocs/gcc/Gcov.html)
- **Page man** : `man gcov`

### Tutoriels et guides
- GNU gcov tutorial
- Linux Test Project Coverage
- Embedded Testing with gcov

### Outils compl√©mentaires
- **lcov** : Frontend graphique pour gcov
- **gcovr** : G√©n√©rateur de rapports Python
- **kcov** : Alternative moderne

---

## R√©sum√©

**gcov** est l'outil de couverture de code standard pour C :

- ‚úÖ **Gratuit** et inclus avec GCC
- ‚úÖ **Simple √† utiliser** : 3 commandes suffisent
- ‚úÖ **Pr√©cis** : Mesure ligne par ligne
- ‚úÖ **L√©ger** : Pas de d√©pendances externes
- ‚úÖ **Standard** : Utilis√© par de nombreux projets open-source

**Workflow minimal :**

```bash
# 1. Compiler avec couverture
gcc -fprofile-arcs -ftest-coverage -o prog prog.c

# 2. Ex√©cuter
./prog

# 3. Analyser
gcov prog.c
```

**Commande recommand√©e pour d√©buter :**

```bash
gcov -b -c -f votre_fichier.c
```

**üí° Conseil final :** La couverture de code est un **indicateur**, pas un objectif en soi. Visez 80-90% sur le code critique, et concentrez-vous sur la **qualit√©** des tests plut√¥t que sur le simple pourcentage de couverture. Un bon test avec 70% de couverture vaut mieux que des tests inutiles qui atteignent 100% !

---

**üéØ Prochaine √©tape :** Dans la section suivante (15.7.2), nous d√©couvrirons **lcov**, qui transforme les donn√©es brutes de gcov en magnifiques rapports HTML interactifs.

‚è≠Ô∏è [lcov](/15-debogage-et-qualite/07.2-lcov.md)
