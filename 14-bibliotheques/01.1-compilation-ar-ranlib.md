üîù Retour au [Sommaire](/SOMMAIRE.md)

# 14.1.1 Compilation avec ar et ranlib

## Introduction

Les biblioth√®ques statiques (fichiers `.a` sous Linux) sont des archives contenant plusieurs fichiers objets (`.o`) compil√©s. Elles permettent de regrouper du code r√©utilisable qui sera int√©gr√© directement dans votre programme lors de la compilation.

Pour cr√©er ces biblioth√®ques statiques, nous utilisons deux outils essentiels :
- **`ar`** (archiver) : pour cr√©er et manipuler les archives
- **`ranlib`** : pour indexer la biblioth√®que et optimiser le linking

---

## L'outil `ar` : L'archiveur

### Qu'est-ce que `ar` ?

`ar` est un utilitaire Unix qui permet de cr√©er, modifier et extraire des archives. Dans le contexte du C, on l'utilise principalement pour cr√©er des biblioth√®ques statiques en regroupant plusieurs fichiers objets.

### Syntaxe de base

```bash
ar [options] nom_bibliotheque.a fichier1.o fichier2.o ...
```

### Options principales de `ar`

| Option | Signification | Description |
|--------|---------------|-------------|
| `r` | **Replace** | Ajoute ou remplace des fichiers dans l'archive |
| `c` | **Create** | Cr√©e l'archive si elle n'existe pas (supprime l'avertissement) |
| `s` | **Symbol index** | Cr√©e un index des symboles (√©quivalent √† ranlib) |
| `v` | **Verbose** | Mode verbeux, affiche les d√©tails des op√©rations |
| `t` | **Table** | Liste le contenu de l'archive |
| `x` | **Extract** | Extrait des fichiers de l'archive |

Les options les plus couramment combin√©es sont : **`rcs`** ou **`rcv`**

---

## Cr√©ation d'une biblioth√®que statique : √âtape par √©tape

### √âtape 1 : Cr√©er les fichiers source

Imaginons que nous voulons cr√©er une biblioth√®que math√©matique simple avec deux fonctions.

**Fichier `math_utils.h`** (en-t√™te) :
```c
#ifndef MATH_UTILS_H
#define MATH_UTILS_H

int addition(int a, int b);
int multiplication(int a, int b);

#endif
```

**Fichier `addition.c`** :
```c
#include "math_utils.h"

int addition(int a, int b) {
    return a + b;
}
```

**Fichier `multiplication.c`** :
```c
#include "math_utils.h"

int multiplication(int a, int b) {
    return a * b;
}
```

### √âtape 2 : Compiler les fichiers en fichiers objets

Avant de cr√©er la biblioth√®que, nous devons compiler chaque fichier source en fichier objet (`.o`) :

```bash
gcc -c addition.c -o addition.o
gcc -c multiplication.c -o multiplication.o
```

**Explication des options :**
- `-c` : Compile sans linker (g√©n√®re uniquement le fichier objet)
- `-o` : Sp√©cifie le nom du fichier de sortie

Apr√®s cette √©tape, vous aurez deux fichiers : `addition.o` et `multiplication.o`

### √âtape 3 : Cr√©er la biblioth√®que statique avec `ar`

Maintenant, nous regroupons les fichiers objets dans une archive :

```bash
ar rcs libmath_utils.a addition.o multiplication.o
```

**D√©composition de la commande :**
- `ar` : L'outil archiveur
- `rcs` : Options combin√©es
  - `r` : Remplace ou ajoute les fichiers
  - `c` : Cr√©e l'archive si elle n'existe pas
  - `s` : Cr√©e l'index des symboles automatiquement
- `libmath_utils.a` : Nom de la biblioth√®que (convention : `lib<nom>.a`)
- `addition.o multiplication.o` : Les fichiers objets √† inclure

> **Convention de nommage** : Les biblioth√®ques statiques commencent toujours par `lib` et se terminent par `.a`

### √âtape 4 : V√©rifier le contenu de la biblioth√®que

Pour visualiser ce que contient notre biblioth√®que :

```bash
ar -t libmath_utils.a
```

Sortie attendue :
```
addition.o
multiplication.o
```

Pour avoir plus de d√©tails (taille, permissions, date) :

```bash
ar -tv libmath_utils.a
```

Sortie exemple :
```
rw-r--r-- 1000/1000   1456 Nov 26 10:30 2025 addition.o
rw-r--r-- 1000/1000   1512 Nov 26 10:30 2025 multiplication.o
```

---

## L'outil `ranlib` : Indexation des symboles

### Qu'est-ce que `ranlib` ?

`ranlib` est un utilitaire qui g√©n√®re un **index des symboles** dans une biblioth√®que statique. Cet index permet au linker de trouver rapidement les fonctions d√©finies dans la biblioth√®que, ce qui acc√©l√®re le processus de compilation.

### Pourquoi `ranlib` ?

Historiquement, `ar` ne cr√©ait pas automatiquement l'index des symboles. Il fallait donc ex√©cuter `ranlib` apr√®s avoir cr√©√© l'archive. Sur les syst√®mes modernes, l'option `s` de `ar` fait le m√™me travail, mais `ranlib` reste utilis√© pour :
- La compatibilit√© avec des scripts anciens
- Mettre √† jour l'index si la biblioth√®que a √©t√© modifi√©e manuellement
- Des raisons de portabilit√© entre syst√®mes Unix

### Utilisation de `ranlib`

```bash
ranlib libmath_utils.a
```

Cette commande r√©g√©n√®re l'index des symboles dans la biblioth√®que.

> **Note importante** : Si vous utilisez `ar rcs`, l'option `s` fait d√©j√† le travail de `ranlib`, donc cette √©tape devient optionnelle sur les syst√®mes modernes (Linux, macOS r√©cents).

### V√©rifier l'index des symboles

Pour voir les symboles d√©finis dans la biblioth√®que :

```bash
nm libmath_utils.a
```

Sortie exemple :
```
addition.o:
0000000000000000 T addition

multiplication.o:
0000000000000000 T multiplication
```

**L√©gende :**
- `T` : Symbole d√©fini dans la section `.text` (code)
- Les nombres repr√©sentent les adresses (relatives)

---

## Workflow complet : R√©sum√©

Voici le processus complet pour cr√©er une biblioth√®que statique :

```bash
# 1. Compiler les fichiers sources en fichiers objets
gcc -c addition.c -o addition.o
gcc -c multiplication.c -o multiplication.o

# 2. Cr√©er la biblioth√®que statique avec ar
ar rcs libmath_utils.a addition.o multiplication.o

# 3. (Optionnel) Indexer avec ranlib si n√©cessaire
ranlib libmath_utils.a

# 4. V√©rifier le contenu
ar -t libmath_utils.a

# 5. V√©rifier les symboles
nm libmath_utils.a
```

---

## Utilisation de la biblioth√®que cr√©√©e

Une fois la biblioth√®que cr√©√©e, vous pouvez l'utiliser dans un programme :

**Fichier `main.c`** :
```c
#include <stdio.h>
#include "math_utils.h"

int main() {
    int a = 10, b = 5;

    printf("Addition : %d + %d = %d\n", a, b, addition(a, b));
    printf("Multiplication : %d * %d = %d\n", a, b, multiplication(a, b));

    return 0;
}
```

**Compilation avec la biblioth√®que statique** :
```bash
gcc main.c -L. -lmath_utils -o programme
```

**Explication des options :**
- `-L.` : Ajoute le r√©pertoire courant (`.`) au chemin de recherche des biblioth√®ques
- `-lmath_utils` : Lie avec `libmath_utils.a` (on enl√®ve le pr√©fixe `lib` et le suffixe `.a`)
- `-o programme` : Nom de l'ex√©cutable

**Ex√©cution** :
```bash
./programme
```

Sortie :
```
Addition : 10 + 5 = 15
Multiplication : 10 * 5 = 50
```

---

## Op√©rations avanc√©es avec `ar`

### Ajouter un fichier √† une biblioth√®que existante

```bash
# Compiler le nouveau fichier
gcc -c soustraction.c -o soustraction.o

# Ajouter √† la biblioth√®que existante
ar rs libmath_utils.a soustraction.o
```

### Supprimer un fichier d'une biblioth√®que

```bash
ar d libmath_utils.a multiplication.o
```

### Extraire un fichier d'une biblioth√®que

```bash
ar x libmath_utils.a addition.o
```

Cela extrait `addition.o` dans le r√©pertoire courant.

### Remplacer un fichier dans une biblioth√®que

Si vous modifiez un fichier source et recompilez :

```bash
# Recompiler
gcc -c addition.c -o addition.o

# Remplacer dans la biblioth√®que
ar rs libmath_utils.a addition.o
```

---

## Bonnes pratiques

### 1. **Toujours utiliser l'option `s`**
```bash
ar rcs libmoncode.a *.o
```
Cela garantit que l'index des symboles est cr√©√© automatiquement.

### 2. **Conventions de nommage**
- Pr√©fixe : `lib`
- Suffixe : `.a`
- Exemple : `libmath.a`, `libutils.a`, `libnetwork.a`

### 3. **Organisation des fichiers**
Structure de projet recommand√©e :
```
mon_projet/
‚îú‚îÄ‚îÄ include/           # Fichiers .h
‚îÇ   ‚îî‚îÄ‚îÄ math_utils.h
‚îú‚îÄ‚îÄ src/              # Fichiers .c
‚îÇ   ‚îú‚îÄ‚îÄ addition.c
‚îÇ   ‚îî‚îÄ‚îÄ multiplication.c
‚îú‚îÄ‚îÄ lib/              # Biblioth√®ques compil√©es
‚îÇ   ‚îî‚îÄ‚îÄ libmath_utils.a
‚îî‚îÄ‚îÄ build/            # Fichiers objets temporaires
    ‚îú‚îÄ‚îÄ addition.o
    ‚îî‚îÄ‚îÄ multiplication.o
```

### 4. **Automatisation avec un Makefile**

Au lieu de taper toutes les commandes manuellement, utilisez un Makefile :

```makefile
# Variables
CC = gcc
CFLAGS = -Wall -Wextra
AR = ar
ARFLAGS = rcs

# Fichiers
OBJS = addition.o multiplication.o
LIB = libmath_utils.a

# R√®gle par d√©faut
all: $(LIB)

# Cr√©er la biblioth√®que
$(LIB): $(OBJS)
	$(AR) $(ARFLAGS) $@ $^

# Compiler les fichiers objets
%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@

# Nettoyage
clean:
	rm -f $(OBJS) $(LIB)

.PHONY: all clean
```

Ensuite, il suffit de taper :
```bash
make
```

---

## Diff√©rences entre syst√®mes

### Linux vs macOS

Sur **macOS**, `ranlib` est **obligatoire** car `ar` ne poss√®de pas l'option `s` sur les anciennes versions :

```bash
# macOS (compatibilit√©)
ar rc libmath_utils.a addition.o multiplication.o
ranlib libmath_utils.a
```

Sur **Linux moderne**, `ar rcs` suffit :
```bash
# Linux (moderne)
ar rcs libmath_utils.a addition.o multiplication.o
```

### Portabilit√©

Pour un code portable, utilisez cette combinaison :
```bash
ar rc libmath_utils.a addition.o multiplication.o
ranlib libmath_utils.a
```

Ou utilisez `ar rcs` et ajoutez `ranlib` conditionnellement dans votre syst√®me de build.

---

## Commandes de diagnostic

### Lister les symboles export√©s
```bash
nm -g libmath_utils.a
```

### V√©rifier la taille de la biblioth√®que
```bash
ls -lh libmath_utils.a
```

### Obtenir des informations d√©taill√©es
```bash
file libmath_utils.a
```

Sortie exemple :
```
libmath_utils.a: current ar archive
```

---

## R√©sum√©

| Outil | R√¥le | Commande typique |
|-------|------|------------------|
| `ar` | Cr√©e et manipule des archives | `ar rcs libnom.a *.o` |
| `ranlib` | Indexe les symboles | `ranlib libnom.a` |
| `nm` | Liste les symboles | `nm libnom.a` |

**Workflow minimal :**
1. Compiler : `gcc -c fichier.c`
2. Archiver : `ar rcs libnom.a *.o`
3. Utiliser : `gcc main.c -L. -lnom`

---

## Points cl√©s √† retenir

- ‚úÖ **`ar rcs`** est la commande standard pour cr√©er une biblioth√®que statique moderne
- ‚úÖ **`ranlib`** reste n√©cessaire sur certains syst√®mes Unix (macOS, BSD)
- ‚úÖ Les biblioth√®ques statiques ont l'extension **`.a`** et commencent par **`lib`**
- ‚úÖ Les fichiers objets (`.o`) sont les briques de base des biblioth√®ques
- ‚úÖ L'index des symboles acc√©l√®re le linking et est cr√©√© par `-s` ou `ranlib`

Dans les sections suivantes, nous verrons comment **utiliser ces biblioth√®ques** lors de la compilation, et nous comparerons les biblioth√®ques statiques aux biblioth√®ques dynamiques (`.so`).

‚è≠Ô∏è [Linking statique](/14-bibliotheques/01.2-linking-statique.md)
