üîù Retour au [Sommaire](/SOMMAIRE.md)

# 13.1.5 Gestion des d√©pendances

## Introduction

Tr√®s peu de projets C sont compl√®tement autonomes. La plupart utilisent des biblioth√®ques externes : OpenSSL pour la cryptographie, libcurl pour HTTP, SQLite pour les bases de donn√©es, etc. La gestion de ces **d√©pendances** est l'un des d√©fis majeurs du d√©veloppement C, et CMake offre plusieurs m√©canismes puissants pour les g√©rer.

Dans cette section, nous allons explorer toutes les fa√ßons de g√©rer les d√©pendances, de la plus simple (biblioth√®ques syst√®me) √† la plus avanc√©e (t√©l√©chargement automatique).

---

## Qu'est-ce qu'une d√©pendance ?

Une **d√©pendance** est une biblioth√®que ou un composant externe dont votre projet a besoin pour fonctionner.

**Exemple concret :**
```c
// Votre code utilise libcurl
#include <curl/curl.h>

int main(void) {
    CURL *curl = curl_easy_init();
    // ...
    return 0;
}
```

Pour compiler ce code, vous devez :
1. **Trouver** les headers de libcurl (`curl/curl.h`)
2. **Lier** avec la biblioth√®que libcurl (`-lcurl`)

CMake automatise ces deux √©tapes.

---

## Types de d√©pendances

### 1. D√©pendances syst√®me (d√©j√† install√©es)

Ce sont les biblioth√®ques install√©es sur le syst√®me via le gestionnaire de paquets :

```bash
# Installer des biblioth√®ques sur Ubuntu
sudo apt install libssl-dev      # OpenSSL  
sudo apt install libcurl4-openssl-dev  # libcurl  
sudo apt install libsqlite3-dev  # SQLite3  
sudo apt install libpq-dev       # PostgreSQL  
```

**Avantages** :
- ‚úÖ Facile √† installer
- ‚úÖ Partag√©es entre tous les projets
- ‚úÖ Maintenues par la distribution

**Inconv√©nients** :
- ‚ùå Versions impos√©es par la distribution
- ‚ùå Portabilit√© limit√©e (d√©pend du syst√®me)

### 2. D√©pendances externes (√† t√©l√©charger)

Biblioth√®ques que CMake peut t√©l√©charger et compiler automatiquement.

**Avantages** :
- ‚úÖ Version exacte contr√¥l√©e
- ‚úÖ Portable (fonctionne partout)
- ‚úÖ Pas besoin d'installation manuelle

**Inconv√©nients** :
- ‚ùå Temps de compilation plus long
- ‚ùå Chaque projet recompile la biblioth√®que

### 3. D√©pendances internes (sous-projets)

Biblioth√®ques faisant partie de votre projet (sous-modules Git, r√©pertoires locaux).

---

## M√©thode 1 : find_package() - La m√©thode standard

### Concept de base

`find_package()` est la commande CMake pour chercher une biblioth√®que d√©j√† install√©e.

```cmake
find_package(OpenSSL REQUIRED)
```

**Ce qui se passe :**
1. CMake cherche un fichier `FindOpenSSL.cmake` ou `OpenSSLConfig.cmake`
2. Ce fichier contient la logique pour localiser OpenSSL sur le syst√®me
3. Si trouv√©, CMake cr√©e des **targets import√©s** (ex: `OpenSSL::SSL`)

### Syntaxe compl√®te

```cmake
find_package(<nom>
    [version]           # Version minimale requise
    [EXACT]            # Version exacte requise
    [QUIET]            # Pas de messages
    [REQUIRED]         # Erreur si non trouv√©
    [COMPONENTS ...]   # Composants sp√©cifiques
)
```

### Exemples pratiques

#### Exemple 1 : OpenSSL (obligatoire)

```cmake
# Chercher OpenSSL (version 1.1.0 minimum)
find_package(OpenSSL 1.1.0 REQUIRED)

add_executable(secure_app src/main.c)

# Lier avec OpenSSL
target_link_libraries(secure_app
    OpenSSL::SSL      # libssl
    OpenSSL::Crypto   # libcrypto
)
```

Si OpenSSL n'est pas install√©, CMake affiche :
```
CMake Error at CMakeLists.txt:5 (find_package):
  Could not find a package configuration file provided by "OpenSSL" with
  any of the following names:

    OpenSSLConfig.cmake
    openssl-config.cmake

  Add the installation prefix of "OpenSSL" to CMAKE_PREFIX_PATH or set
  "OpenSSL_DIR" to a directory containing one of the above files.
```

**Solution** : Installer OpenSSL
```bash
sudo apt install libssl-dev
```

#### Exemple 2 : Biblioth√®que optionnelle

```cmake
# Chercher ZLIB (optionnel)
find_package(ZLIB)

add_executable(compressor src/main.c)

if(ZLIB_FOUND)
    message(STATUS "ZLIB trouv√© : compression activ√©e")
    target_link_libraries(compressor ZLIB::ZLIB)
    target_compile_definitions(compressor PRIVATE HAVE_ZLIB)
else()
    message(WARNING "ZLIB non trouv√© : compression d√©sactiv√©e")
endif()
```

Dans le code C :
```c
#ifdef HAVE_ZLIB
#include <zlib.h>
// Utiliser la compression
#else
// Compression d√©sactiv√©e
#endif
```

#### Exemple 3 : Composants sp√©cifiques (Boost)

```cmake
# Boost avec composants sp√©cifiques
find_package(Boost 1.70 REQUIRED
    COMPONENTS
        system      # Boost.System
        filesystem  # Boost.Filesystem
        thread      # Boost.Thread
)

add_executable(file_app src/main.c)  
target_link_libraries(file_app  
    Boost::system
    Boost::filesystem
    Boost::thread
)
```

### Variables d√©finies par find_package()

Chaque `find_package()` d√©finit des variables :

```cmake
find_package(OpenSSL REQUIRED)

# Variables automatiquement d√©finies :
# - OpenSSL_FOUND         : TRUE si trouv√©
# - OpenSSL_VERSION       : Version trouv√©e (ex: "1.1.1f")
# - OpenSSL_INCLUDE_DIRS  : Chemins des headers (ancien style)
# - OpenSSL_LIBRARIES     : Biblioth√®ques √† lier (ancien style)

message(STATUS "OpenSSL version : ${OpenSSL_VERSION}")  
message(STATUS "OpenSSL include : ${OpenSSL_INCLUDE_DIRS}")  
```

**Note** : Avec CMake moderne, utilisez les **targets import√©s** (`OpenSSL::SSL`) plut√¥t que ces variables.

### O√π cherche find_package() ?

CMake cherche dans ces r√©pertoires (ordre) :

1. `CMAKE_PREFIX_PATH` (variable personnalis√©e)
2. `/usr/local/` (installation manuelle classique)
3. `/usr/` (paquets syst√®me)
4. Chemins sp√©cifiques √† chaque biblioth√®que

**Sp√©cifier un chemin personnalis√©** :

```bash
# M√©thode 1 : Variable d'environnement
export CMAKE_PREFIX_PATH="/opt/custom/openssl"  
cmake -B build  

# M√©thode 2 : Argument CMake
cmake -B build -DCMAKE_PREFIX_PATH="/opt/custom/openssl"

# M√©thode 3 : Variable sp√©cifique
cmake -B build -DOpenSSL_ROOT="/opt/custom/openssl"
```

### Biblioth√®ques courantes avec find_package()

| Biblioth√®que | Nom CMake | Targets import√©s |
|--------------|-----------|------------------|
| OpenSSL | `find_package(OpenSSL)` | `OpenSSL::SSL`, `OpenSSL::Crypto` |
| libcurl | `find_package(CURL)` | `CURL::libcurl` |
| SQLite3 | `find_package(SQLite3)` | `SQLite::SQLite3` |
| zlib | `find_package(ZLIB)` | `ZLIB::ZLIB` |
| PostgreSQL | `find_package(PostgreSQL)` | `PostgreSQL::PostgreSQL` |
| Threads (pthread) | `find_package(Threads)` | `Threads::Threads` |

---

## M√©thode 2 : pkg-config - Pour les biblioth√®ques Linux

### Qu'est-ce que pkg-config ?

`pkg-config` est un outil standard Linux qui fournit les flags de compilation/link pour les biblioth√®ques install√©es.

```bash
# V√©rifier si une biblioth√®que est disponible
pkg-config --modversion libcurl
# Sortie : 7.81.0

# Obtenir les flags de compilation
pkg-config --cflags libcurl
# Sortie : -I/usr/include/x86_64-linux-gnu

# Obtenir les flags de link
pkg-config --libs libcurl
# Sortie : -lcurl
```

### Utiliser pkg-config dans CMake

```cmake
# Charger le module PkgConfig
find_package(PkgConfig REQUIRED)

# Chercher libcurl via pkg-config
pkg_check_modules(CURL REQUIRED libcurl)

add_executable(downloader src/main.c)

# M√©thode 1 : Variables (ancien style)
target_include_directories(downloader PRIVATE ${CURL_INCLUDE_DIRS})  
target_link_libraries(downloader ${CURL_LIBRARIES})  

# M√©thode 2 : Target import√© (moderne)
target_link_libraries(downloader PkgConfig::CURL)
```

**Quand utiliser pkg-config ?**
- ‚úÖ Biblioth√®ques sans support CMake natif
- ‚úÖ Projets Linux uniquement
- ‚ùå Windows (pkg-config peu utilis√©)

---

## M√©thode 3 : FetchContent - T√©l√©charger automatiquement

### Concept

`FetchContent` permet de t√©l√©charger et compiler des d√©pendances directement depuis leur d√©p√¥t Git, au moment de la configuration CMake.

**Avantages** :
- ‚úÖ Pas d'installation manuelle n√©cessaire
- ‚úÖ Version exacte contr√¥l√©e
- ‚úÖ Portable (fonctionne partout)

**Inconv√©nients** :
- ‚ùå Temps de configuration plus long (premi√®re fois)
- ‚ùå N√©cessite une connexion internet

### Exemple : T√©l√©charger une biblioth√®que JSON

```cmake
include(FetchContent)

# D√©clarer la d√©pendance
FetchContent_Declare(
    json
    GIT_REPOSITORY https://github.com/nlohmann/json.git
    GIT_TAG v3.11.2  # Version sp√©cifique (tag Git)
)

# T√©l√©charger et rendre disponible
FetchContent_MakeAvailable(json)

# Utiliser la biblioth√®que
add_executable(json_app src/main.c)  
target_link_libraries(json_app nlohmann_json::nlohmann_json)  
```

**Premi√®re configuration** :
```bash
cmake -B build
# T√©l√©charge json depuis GitHub...
# -- Fetching json
# -- Configuring done
```

**Configurations suivantes** : Utilise la version en cache (rapide).

### Exemple avanc√© : T√©l√©charger plusieurs d√©pendances

```cmake
include(FetchContent)

# ===================================
# D√©pendance 1 : cJSON (parsing JSON)
# ===================================
FetchContent_Declare(
    cjson
    GIT_REPOSITORY https://github.com/DaveGamble/cJSON.git
    GIT_TAG v1.7.16
)

# ===================================
# D√©pendance 2 : Unity (tests unitaires)
# ===================================
FetchContent_Declare(
    unity
    GIT_REPOSITORY https://github.com/ThrowTheSwitch/Unity.git
    GIT_TAG v2.5.2
)

# Rendre disponibles toutes les d√©pendances
FetchContent_MakeAvailable(cjson unity)

# ===================================
# Utilisation
# ===================================
add_executable(parser src/main.c)  
target_link_libraries(parser cjson)  

add_executable(tests tests/test_parser.c)  
target_link_libraries(tests unity cjson)  
```

### Options avanc√©es de FetchContent

```cmake
FetchContent_Declare(
    ma_lib
    GIT_REPOSITORY https://github.com/user/ma_lib.git
    GIT_TAG main                    # Branche ou tag
    GIT_SHALLOW TRUE               # Clone superficiel (plus rapide)
    GIT_PROGRESS TRUE              # Afficher la progression
    SOURCE_DIR ${CMAKE_BINARY_DIR}/ma_lib  # R√©pertoire de t√©l√©chargement
)

# Options de configuration de la biblioth√®que
set(MA_LIB_BUILD_TESTS OFF CACHE BOOL "" FORCE)  
set(MA_LIB_BUILD_DOCS OFF CACHE BOOL "" FORCE)  

FetchContent_MakeAvailable(ma_lib)
```

### T√©l√©charger depuis une archive

```cmake
FetchContent_Declare(
    sqlite3
    URL https://www.sqlite.org/2023/sqlite-amalgamation-3430000.zip
    URL_HASH SHA256=abc123...  # Hash pour v√©rifier l'int√©grit√©
)

FetchContent_MakeAvailable(sqlite3)
```

---

## M√©thode 4 : add_subdirectory() - Sous-projets locaux

### Concept

Si vous avez une biblioth√®que dans un sous-r√©pertoire de votre projet (ou un sous-module Git), utilisez `add_subdirectory()`.

### Structure du projet

```
mon_projet/
‚îú‚îÄ‚îÄ CMakeLists.txt          # Principal
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îî‚îÄ‚îÄ main.c
‚îî‚îÄ‚îÄ libs/
    ‚îú‚îÄ‚îÄ mylib/
    ‚îÇ   ‚îú‚îÄ‚îÄ CMakeLists.txt  # Biblioth√®que locale
    ‚îÇ   ‚îú‚îÄ‚îÄ src/
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ mylib.c
    ‚îÇ   ‚îî‚îÄ‚îÄ include/
    ‚îÇ       ‚îî‚îÄ‚îÄ mylib.h
    ‚îî‚îÄ‚îÄ utils/
        ‚îú‚îÄ‚îÄ CMakeLists.txt
        ‚îî‚îÄ‚îÄ utils.c
```

### CMakeLists.txt principal

```cmake
cmake_minimum_required(VERSION 3.15)  
project(MonProjet C)  

# Ajouter les sous-r√©pertoires contenant des biblioth√®ques
add_subdirectory(libs/mylib)  
add_subdirectory(libs/utils)  

# Ex√©cutable principal
add_executable(mon_app src/main.c)

# Lier avec les biblioth√®ques locales
target_link_libraries(mon_app mylib utils)
```

### libs/mylib/CMakeLists.txt

```cmake
add_library(mylib src/mylib.c)

target_include_directories(mylib PUBLIC
    ${CMAKE_CURRENT_SOURCE_DIR}/include
)
```

**Avantages** :
- ‚úÖ Contr√¥le total du code source
- ‚úÖ Modification facile
- ‚úÖ Pas de d√©pendance externe

**Cas d'usage** :
- Biblioth√®ques internes au projet
- Sous-modules Git
- Code partag√© entre plusieurs ex√©cutables

---

## M√©thode 5 : ExternalProject_Add - Pour les d√©pendances complexes

### Concept

`ExternalProject_Add` t√©l√©charge, configure, compile et installe une d√©pendance externe **au moment du build** (pas de la configuration).

**Diff√©rence avec FetchContent :**
- `FetchContent` : Int√©gr√© au build principal (une seule phase)
- `ExternalProject` : Build s√©par√© (deux phases)

### Exemple : Compiler OpenSSL depuis les sources

```cmake
include(ExternalProject)

ExternalProject_Add(
    openssl_external
    URL https://www.openssl.org/source/openssl-3.1.0.tar.gz
    URL_HASH SHA256=abc123...
    CONFIGURE_COMMAND ./config --prefix=${CMAKE_BINARY_DIR}/external/openssl
    BUILD_COMMAND make
    INSTALL_COMMAND make install
    BUILD_IN_SOURCE 1
)

# Cr√©er un target import√©
add_library(OpenSSL::SSL STATIC IMPORTED)  
set_target_properties(OpenSSL::SSL PROPERTIES  
    IMPORTED_LOCATION ${CMAKE_BINARY_DIR}/external/openssl/lib/libssl.a
)
add_dependencies(OpenSSL::SSL openssl_external)
```

**Quand utiliser ExternalProject ?**
- ‚ùå Rarement n√©cessaire pour d√©buter
- ‚úÖ D√©pendances tr√®s sp√©cifiques (version custom)
- ‚úÖ Biblioth√®ques sans CMakeLists.txt
- ‚úÖ Build exotiques (configure/make/autotools)

---

## M√©thode 6 : Gestionnaires de paquets modernes

### vcpkg (Microsoft)

**Installation** :
```bash
git clone https://github.com/microsoft/vcpkg.git  
cd vcpkg  
./bootstrap-vcpkg.sh
```

**Installer des biblioth√®ques** :
```bash
./vcpkg install curl openssl sqlite3
```

**Utiliser avec CMake** :
```bash
cmake -B build -DCMAKE_TOOLCHAIN_FILE=/path/to/vcpkg/scripts/buildsystems/vcpkg.cmake
```

Dans le CMakeLists.txt :
```cmake
find_package(CURL REQUIRED)  
find_package(OpenSSL REQUIRED)  
find_package(SQLite3 REQUIRED)  

add_executable(mon_app src/main.c)  
target_link_libraries(mon_app  
    CURL::libcurl
    OpenSSL::SSL
    SQLite::SQLite3
)
```

**Avantages** :
- ‚úÖ Gestion automatique des versions
- ‚úÖ Cross-platform (Windows, Linux, macOS)
- ‚úÖ Plus de 1800 biblioth√®ques disponibles

### Conan (C/C++ Package Manager)

**Installation** :
```bash
pip install conan
```

**Fichier conanfile.txt** :
```ini
[requires]
openssl/3.1.0  
curl/8.0.1  
sqlite3/3.42.0  

[generators]
CMakeDeps  
CMakeToolchain  
```

**Installer les d√©pendances** :
```bash
conan install . --build=missing
```

**CMakeLists.txt** :
```cmake
cmake_minimum_required(VERSION 3.15)  
project(MonProjet C)  

# Charger les d√©pendances Conan
include(${CMAKE_BINARY_DIR}/conan_toolchain.cmake)

find_package(OpenSSL REQUIRED)  
find_package(CURL REQUIRED)  
find_package(SQLite3 REQUIRED)  

add_executable(mon_app src/main.c)  
target_link_libraries(mon_app  
    OpenSSL::SSL
    CURL::libcurl
    SQLite::SQLite3
)
```

---

## Strat√©gie de gestion des d√©pendances

### Pour les d√©butants (projets simples)

```cmake
# 1. D√©pendances syst√®me (les plus courantes)
find_package(Threads REQUIRED)  
find_package(OpenSSL REQUIRED)  
find_package(ZLIB)  

add_executable(mon_app src/main.c)  
target_link_libraries(mon_app  
    Threads::Threads
    OpenSSL::SSL
)

if(ZLIB_FOUND)
    target_link_libraries(mon_app ZLIB::ZLIB)
endif()
```

**Avantages** : Simple, rapide, pas de complications.

### Pour les projets moyens

```cmake
# Combinaison : syst√®me + FetchContent pour les petites libs
find_package(OpenSSL REQUIRED)

include(FetchContent)  
FetchContent_Declare(  
    cjson
    GIT_REPOSITORY https://github.com/DaveGamble/cJSON.git
    GIT_TAG v1.7.16
)
FetchContent_MakeAvailable(cjson)

add_executable(mon_app src/main.c)  
target_link_libraries(mon_app OpenSSL::SSL cjson)  
```

### Pour les gros projets (production)

```cmake
# Utiliser un gestionnaire de paquets (vcpkg ou Conan)
find_package(OpenSSL REQUIRED)  
find_package(CURL REQUIRED)  
find_package(PostgreSQL REQUIRED)  
find_package(Protobuf REQUIRED)  

add_executable(mon_app src/main.c)  
target_link_libraries(mon_app  
    OpenSSL::SSL
    CURL::libcurl
    PostgreSQL::PostgreSQL
    protobuf::libprotobuf
)
```

**Installation des d√©pendances** :
```bash
# Avec vcpkg
vcpkg install openssl curl libpq protobuf

# Ou avec Conan
conan install . --build=missing
```

---

## Gestion des versions

### Sp√©cifier une version minimale

```cmake
# Version minimale
find_package(OpenSSL 1.1.0 REQUIRED)

# Version exacte
find_package(OpenSSL 3.0.0 EXACT REQUIRED)
```

### V√©rifier la version trouv√©e

```cmake
find_package(OpenSSL REQUIRED)

if(OpenSSL_VERSION VERSION_LESS "1.1.0")
    message(FATAL_ERROR "OpenSSL 1.1.0+ requis, trouv√© ${OpenSSL_VERSION}")
endif()

message(STATUS "OpenSSL version : ${OpenSSL_VERSION}")
```

---

## Gestion des d√©pendances optionnelles

### Pattern standard

```cmake
option(ENABLE_COMPRESSION "Activer la compression ZLIB" ON)

if(ENABLE_COMPRESSION)
    find_package(ZLIB)
    if(ZLIB_FOUND)
        target_link_libraries(mon_app ZLIB::ZLIB)
        target_compile_definitions(mon_app PRIVATE HAVE_ZLIB)
    else()
        message(WARNING "ZLIB demand√© mais non trouv√©")
    endif()
endif()
```

Dans le code C :
```c
#ifdef HAVE_ZLIB
#include <zlib.h>
// Code avec compression
#else
// Code sans compression
#endif
```

---

## R√©solution de probl√®mes courants

### Probl√®me 1 : "Could not find package"

**Erreur** :
```
CMake Error: Could not find a package configuration file provided by "OpenSSL"
```

**Solutions** :

1. **Installer la biblioth√®que** :
```bash
sudo apt install libssl-dev
```

2. **Sp√©cifier le chemin** :
```bash
cmake -B build -DOpenSSL_ROOT=/opt/openssl
```

3. **V√©rifier que les fichiers -dev sont install√©s** :
```bash
dpkg -L libssl-dev  # Liste les fichiers install√©s
```

### Probl√®me 2 : Mauvaise version trouv√©e

```cmake
find_package(OpenSSL 3.0.0 REQUIRED)
# Erreur : Found OpenSSL 1.1.1, but required is at least 3.0.0
```

**Solution** : Installer une version plus r√©cente ou adapter votre code.

### Probl√®me 3 : Conflit de versions

Si plusieurs versions sont install√©es :

```bash
# Forcer une version sp√©cifique
cmake -B build -DOpenSSL_ROOT=/usr/local/openssl-3.0
```

### Probl√®me 4 : D√©pendance non trouv√©e sur le CI/CD

**Dans GitHub Actions** :
```yaml
- name: Installer les d√©pendances
  run: |
    sudo apt update
    sudo apt install libssl-dev libcurl4-openssl-dev libsqlite3-dev
```

---

## Exemple complet : Projet avec plusieurs types de d√©pendances

```cmake
cmake_minimum_required(VERSION 3.15)  
project(WebScraper VERSION 1.0.0 LANGUAGES C)  

# ============================================
# D√âPENDANCES SYST√àME (obligatoires)
# ============================================
find_package(CURL REQUIRED)  
find_package(Threads REQUIRED)  

# ============================================
# D√âPENDANCES SYST√àME (optionnelles)
# ============================================
find_package(OpenSSL)

if(OpenSSL_FOUND)
    message(STATUS "OpenSSL trouv√© : HTTPS activ√©")
else()
    message(WARNING "OpenSSL non trouv√© : HTTPS d√©sactiv√©")
endif()

# ============================================
# D√âPENDANCES T√âL√âCHARG√âES (FetchContent)
# ============================================
include(FetchContent)

# Parser HTML
FetchContent_Declare(
    gumbo
    GIT_REPOSITORY https://github.com/google/gumbo-parser.git
    GIT_TAG v0.10.1
)

# JSON
FetchContent_Declare(
    cjson
    GIT_REPOSITORY https://github.com/DaveGamble/cJSON.git
    GIT_TAG v1.7.16
)

FetchContent_MakeAvailable(gumbo cjson)

# ============================================
# D√âPENDANCES LOCALES (sous-projet)
# ============================================
add_subdirectory(libs/logger)

# ============================================
# APPLICATION PRINCIPALE
# ============================================
add_executable(webscraper src/main.c src/scraper.c)

# Lier toutes les d√©pendances
target_link_libraries(webscraper
    # Syst√®me
    CURL::libcurl
    Threads::Threads

    # T√©l√©charg√©es
    gumbo
    cjson

    # Locale
    logger
)

# OpenSSL (si disponible)
if(OpenSSL_FOUND)
    target_link_libraries(webscraper OpenSSL::SSL OpenSSL::Crypto)
    target_compile_definitions(webscraper PRIVATE HAVE_OPENSSL)
endif()

# ============================================
# INFORMATIONS
# ============================================
message(STATUS "")  
message(STATUS "Configuration WebScraper")  
message(STATUS "  CURL:    ${CURL_VERSION}")  
message(STATUS "  OpenSSL: ${OpenSSL_FOUND}")  
message(STATUS "")  
```

**Build** :
```bash
cmake -B build  
cmake --build build  
```

---

## Bonnes pratiques

### 1. Toujours sp√©cifier REQUIRED ou g√©rer l'absence

‚ùå **Mauvais** :
```cmake
find_package(OpenSSL)
# Et si OpenSSL n'est pas trouv√© ?
target_link_libraries(mon_app OpenSSL::SSL)  # ‚ùå Erreur !
```

‚úÖ **Bon** :
```cmake
find_package(OpenSSL REQUIRED)
# ou
find_package(OpenSSL)  
if(OpenSSL_FOUND)  
    target_link_libraries(mon_app OpenSSL::SSL)
endif()
```

### 2. Utiliser les targets import√©s modernes

‚ùå **Ancien style** :
```cmake
find_package(OpenSSL REQUIRED)  
target_include_directories(mon_app PRIVATE ${OPENSSL_INCLUDE_DIR})  
target_link_libraries(mon_app ${OPENSSL_LIBRARIES})  
```

‚úÖ **Style moderne** :
```cmake
find_package(OpenSSL REQUIRED)  
target_link_libraries(mon_app OpenSSL::SSL OpenSSL::Crypto)  
# Les includes sont automatiques !
```

### 3. Documenter les d√©pendances

```cmake
# ============================================
# D√âPENDANCES REQUISES
# ============================================
# Installer sur Ubuntu :
#   sudo apt install libcurl4-openssl-dev libssl-dev

find_package(CURL REQUIRED)  
find_package(OpenSSL REQUIRED)  
```

Ou dans un README :
````markdown
## D√©pendances

- libcurl 7.68+
- OpenSSL 1.1.0+
- SQLite3 3.30+

### Installation Ubuntu/Debian
```bash
sudo apt install libcurl4-openssl-dev libssl-dev libsqlite3-dev
```
````

### 4. Versionner les d√©pendances dans FetchContent

‚úÖ **Bon** : Tag Git sp√©cifique
```cmake
FetchContent_Declare(
    json
    GIT_REPOSITORY https://github.com/nlohmann/json.git
    GIT_TAG v3.11.2  # Version fixe
)
```

‚ùå **Mauvais** : Branche main (version variable)
```cmake
FetchContent_Declare(
    json
    GIT_REPOSITORY https://github.com/nlohmann/json.git
    GIT_TAG main  # ‚ùå Peut casser √† tout moment !
)
```

### 5. Mettre en cache les t√©l√©chargements FetchContent

CMake met en cache automatiquement, mais vous pouvez sp√©cifier :

```cmake
set(FETCHCONTENT_BASE_DIR ${CMAKE_BINARY_DIR}/_deps CACHE PATH "")
```

---

## R√©capitulatif : Quelle m√©thode choisir ?

| Situation | M√©thode recommand√©e |
|-----------|---------------------|
| Biblioth√®que standard (OpenSSL, libcurl) | `find_package()` |
| Petite biblioth√®que header-only | `FetchContent` |
| Biblioth√®que sans CMake | `pkg-config` |
| Sous-module Git dans votre projet | `add_subdirectory()` |
| Projet complexe (50+ d√©pendances) | `vcpkg` ou `Conan` |
| Build exotique (autotools, configure) | `ExternalProject_Add` |

---

## Conclusion

La gestion des d√©pendances est souvent la partie la plus frustrante du d√©veloppement C, mais CMake fournit des outils puissants pour l'automatiser :

- **find_package()** pour les biblioth√®ques syst√®me (90% des cas)
- **FetchContent** pour t√©l√©charger automatiquement
- **add_subdirectory()** pour les sous-projets
- **vcpkg/Conan** pour les gros projets

**Principe cl√©** : Commencez simple (`find_package()` uniquement), puis ajoutez de la complexit√© seulement si n√©cessaire.

---


‚è≠Ô∏è [Build types](/13-build-systems/01.6-build-types.md)
