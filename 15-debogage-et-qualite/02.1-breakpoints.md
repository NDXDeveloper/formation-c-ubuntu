üîù Retour au [Sommaire](/SOMMAIRE.md)

# 15.2.1 Breakpoints, Watchpoints et Catchpoints

## Introduction

Lorsque vous d√©boguez un programme avec GDB, vous avez besoin de **contr√¥ler l'ex√©cution** pour observer ce qui se passe √† des moments pr√©cis. C'est l√† qu'interviennent trois outils essentiels : les breakpoints, watchpoints et catchpoints. Ces m√©canismes vous permettent de mettre en pause l'ex√©cution de votre programme selon diff√©rents crit√®res.

---

## 1. Les Breakpoints (Points d'arr√™t)

### Qu'est-ce qu'un breakpoint ?

Un **breakpoint** (point d'arr√™t) est un marqueur que vous placez dans votre code pour dire √† GDB : *"Arr√™te-toi ici"*. Lorsque l'ex√©cution du programme atteint cette ligne, GDB met le programme en pause et vous rend la main pour inspecter l'√©tat du programme.

### Pourquoi utiliser des breakpoints ?

Les breakpoints sont l'outil le plus utilis√© en d√©bogage. Ils permettent de :
- Examiner l'√©tat des variables √† un moment pr√©cis
- V√©rifier le chemin d'ex√©cution du programme
- Observer le comportement avant qu'un bug ne se produise
- Comprendre le flux logique de votre code

### Cr√©er un breakpoint simple

La syntaxe de base dans GDB est :

```gdb
break <emplacement>
```

**Exemples courants :**

```gdb
# Arr√™t √† une ligne sp√©cifique
break main.c:42

# Arr√™t au d√©but d'une fonction
break calcul_moyenne

# Arr√™t dans un fichier sp√©cifique
break utils.c:compute_sum
```

### Exemple concret

Imaginons ce programme simple :

```c
#include <stdio.h>

int addition(int a, int b) {
    int resultat = a + b;
    return resultat;
}

int main() {
    int x = 5;
    int y = 10;
    int somme = addition(x, y);
    printf("La somme est : %d\n", somme);
    return 0;
}
```

Dans GDB, vous pourriez faire :

```gdb
(gdb) break main
Breakpoint 1 at 0x1149: file exemple.c, line 8.

(gdb) break addition
Breakpoint 2 at 0x1129: file exemple.c, line 4.

(gdb) run
Starting program: ./exemple
Breakpoint 1, main () at exemple.c:8
8           int x = 5;
```

Le programme s'arr√™te √† la premi√®re ligne de `main()`.

### Types de breakpoints avanc√©s

#### Breakpoints conditionnels

Vous pouvez cr√©er un breakpoint qui ne s'active que si une **condition** est vraie :

```gdb
break main.c:42 if compteur > 100
```

Ceci est extr√™mement utile dans les boucles. Par exemple :

```c
for (int i = 0; i < 1000; i++) {
    traiter_element(i);  // Bug quand i > 500
}
```

Vous pouvez faire :

```gdb
break traiter_element if i > 500
```

Ainsi, GDB ne s'arr√™tera que lorsque `i` d√©passe 500, au lieu de s'arr√™ter 1000 fois.

#### Breakpoints temporaires

Un **breakpoint temporaire** s'active une seule fois, puis est automatiquement supprim√© :

```gdb
tbreak main.c:42
```

Utile quand vous voulez vous arr√™ter une fois √† un endroit sans avoir √† supprimer le breakpoint manuellement ensuite.

### G√©rer vos breakpoints

GDB offre plusieurs commandes pour g√©rer vos breakpoints :

```gdb
# Lister tous les breakpoints
info breakpoints

# D√©sactiver temporairement un breakpoint
disable 1

# R√©activer un breakpoint
enable 1

# Supprimer un breakpoint
delete 1

# Supprimer tous les breakpoints
delete
```

**Exemple de sortie de `info breakpoints` :**

```
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x0000000000001149 in main at exemple.c:8
        breakpoint already hit 1 time
2       breakpoint     keep y   0x0000000000001129 in addition at exemple.c:4
```

Ici :
- **Num** : Num√©ro du breakpoint
- **Disp** : Disposition (keep = permanent, del = temporaire)
- **Enb** : Activ√© (y = yes, n = no)
- **Address** : Adresse m√©moire
- **What** : Emplacement dans le code source

---

## 2. Les Watchpoints (Points de surveillance)

### Qu'est-ce qu'un watchpoint ?

Un **watchpoint** surveille une **variable ou une zone m√©moire** et arr√™te le programme d√®s que cette valeur **change**. Contrairement √† un breakpoint qui s'arr√™te √† un endroit du code, un watchpoint s'arr√™te quand une **donn√©e** est modifi√©e, peu importe o√π cela se produit dans le code.

### Pourquoi utiliser des watchpoints ?

Les watchpoints sont parfaits pour :
- D√©tecter des modifications inattendues d'une variable
- Trouver o√π une variable est corrompue
- Suivre l'√©volution d'une valeur globale
- Identifier les √©critures m√©moire non autoris√©es

### Cr√©er un watchpoint

La syntaxe de base :

```gdb
watch <expression>
```

**Exemples :**

```gdb
# Surveiller une variable locale
watch compteur

# Surveiller un membre de structure
watch utilisateur.age

# Surveiller une zone m√©moire via un pointeur
watch *ptr
```

### Exemple concret

Consid√©rons ce code probl√©matique :

```c
#include <stdio.h>

int total = 0;

void fonction_a() {
    total = 100;
}

void fonction_b() {
    total = total * 2;  // Bug : modification inattendue
}

void fonction_c() {
    printf("Total : %d\n", total);
}

int main() {
    fonction_a();
    fonction_b();
    fonction_c();
    return 0;
}
```

Vous suspectez que `total` est modifi√© √† un endroit inattendu. Dans GDB :

```gdb
(gdb) break main
(gdb) run
Breakpoint 1, main () at exemple.c:16

(gdb) watch total
Hardware watchpoint 2: total

(gdb) continue
Continuing.
Hardware watchpoint 2: total

Old value = 0
New value = 100
fonction_a () at exemple.c:6
6       }

(gdb) continue
Continuing.
Hardware watchpoint 2: total

Old value = 100
New value = 200
fonction_b () at exemple.c:10
10      }
```

GDB vous montre **exactement o√π et quand** `total` change de valeur !

### Types de watchpoints

#### Read watchpoint (rwatch)

S'arr√™te quand une variable est **lue** :

```gdb
rwatch ma_variable
```

Utile pour trouver qui acc√®de √† une donn√©e sensible.

#### Read/Write watchpoint (awatch)

S'arr√™te quand une variable est **lue OU √©crite** :

```gdb
awatch ma_variable
```

Plus complet mais peut ralentir l'ex√©cution.

### Limitations des watchpoints

‚ö†Ô∏è **Important √† savoir :**

1. **Port√©e des variables locales** : Un watchpoint sur une variable locale s'arr√™te automatiquement quand la variable sort de la port√©e (fin de fonction).

2. **Performance** : Les watchpoints peuvent ralentir consid√©rablement l'ex√©cution car le processeur doit v√©rifier √† chaque instruction si la valeur a chang√©.

3. **Hardware vs Software** : GDB pr√©f√®re utiliser les watchpoints mat√©riels (limit√©s en nombre, g√©n√©ralement 4) mais peut utiliser des watchpoints logiciels (tr√®s lents).

---

## 3. Les Catchpoints (Points de capture)

### Qu'est-ce qu'un catchpoint ?

Un **catchpoint** capture des **√©v√©nements sp√©cifiques** du programme, comme :
- Le lancement d'un appel syst√®me
- La lev√©e d'une exception (en C++)
- Le chargement d'une biblioth√®que partag√©e
- Les signaux syst√®me
- Les appels √† `fork()` ou `exec()`

### Pourquoi utiliser des catchpoints ?

Les catchpoints sont utiles pour :
- D√©boguer les interactions avec le syst√®me d'exploitation
- Intercepter les signaux (SIGSEGV, SIGINT, etc.)
- Observer le chargement dynamique de biblioth√®ques
- Comprendre les appels syst√®me

### Cr√©er un catchpoint

La syntaxe g√©n√©rale :

```gdb
catch <√©v√©nement>
```

**√âv√©nements courants :**

```gdb
# Capturer les appels √† fork()
catch fork

# Capturer les appels √† exec()
catch exec

# Capturer les appels syst√®me (syscall)
catch syscall

# Capturer un syscall sp√©cifique (ex: open)
catch syscall open

# Capturer le chargement de biblioth√®ques
catch load
```

### Exemple : Capturer les appels syst√®me

Imaginons que vous voulez voir quand votre programme ouvre un fichier :

```c
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>

int main() {
    int fd = open("data.txt", O_RDONLY);
    if (fd == -1) {
        perror("Erreur ouverture");
        return 1;
    }

    char buffer[100];
    read(fd, buffer, 100);
    close(fd);

    return 0;
}
```

Dans GDB :

```gdb
(gdb) catch syscall open
Catchpoint 1 (syscall 'open' [2])

(gdb) run
Starting program: ./exemple

Catchpoint 1 (call to syscall open), 0x00007ffff7e9c5b7 in open64 ()
   from /lib/x86_64-linux-gnu/libc.so.6

(gdb) continue
Continuing.

Catchpoint 1 (returned from syscall open), 0x00007ffff7e9c5b7 in open64 ()
   from /lib/x86_64-linux-gnu/libc.so.6
```

GDB s'arr√™te **deux fois** :
1. √Ä l'**appel** de `open()`
2. Au **retour** de `open()`

Cela vous permet d'inspecter les arguments et la valeur de retour.

### Exemple : Capturer les signaux

Les signaux sont des interruptions envoy√©es √† votre programme (Ctrl+C envoie SIGINT, un acc√®s m√©moire invalide d√©clenche SIGSEGV, etc.).

```gdb
# Capturer tous les signaux
catch signal

# Capturer un signal sp√©cifique
catch signal SIGSEGV
catch signal SIGINT
```

Ceci est particuli√®rement utile pour d√©boguer les **segmentation faults** (SIGSEGV) :

```c
#include <stdio.h>

int main() {
    int *ptr = NULL;
    *ptr = 42;  // Acc√®s √† une adresse invalide -> SIGSEGV
    return 0;
}
```

Dans GDB :

```gdb
(gdb) catch signal SIGSEGV
Catchpoint 1 (signal SIGSEGV)

(gdb) run
Starting program: ./crash

Catchpoint 1 (signal SIGSEGV), 0x0000555555555149 in main () at crash.c:5
5           *ptr = 42;
```

GDB vous arr√™te **exactement** √† la ligne qui cause le crash, avant m√™me que le programme ne s'arr√™te compl√®tement.

### Catchpoints et C++ (bonus)

Bien que ce cours se concentre sur C, sachez que les catchpoints sont tr√®s puissants en C++ pour capturer les exceptions :

```gdb
catch throw       # Capture toutes les exceptions lev√©es
catch catch       # Capture toutes les exceptions attrap√©es
```

---

## R√©sum√© et Comparaison

| Type | Quand s'arr√™te-t-il ? | Utilisation principale |
|------|----------------------|------------------------|
| **Breakpoint** | √Ä un **emplacement** du code (ligne, fonction) | Observer l'ex√©cution √† un point pr√©cis |
| **Watchpoint** | Quand une **valeur** change | Trouver o√π une variable est modifi√©e |
| **Catchpoint** | Lors d'un **√©v√©nement** syst√®me | Intercepter signaux, syscalls, fork, etc. |

### Quelle commande utiliser quand ?

**Utilisez un breakpoint si :**
- Vous savez o√π se trouve le bug approximativement
- Vous voulez suivre le flux d'ex√©cution ligne par ligne
- Vous voulez inspecter l'√©tat √† un moment pr√©cis

**Utilisez un watchpoint si :**
- Une variable a une valeur incorrecte mais vous ne savez pas o√π elle change
- Vous suspectez une corruption m√©moire
- Vous voulez traquer toutes les modifications d'une donn√©e

**Utilisez un catchpoint si :**
- Votre programme re√ßoit un signal inattendu
- Vous voulez observer les interactions syst√®me
- Vous d√©boguez des probl√®mes li√©s au chargement de biblioth√®ques

---

## Commandes GDB r√©capitulatives

### Breakpoints
```gdb
break <lieu>              # Cr√©er un breakpoint
tbreak <lieu>             # Breakpoint temporaire
break <lieu> if <cond>    # Breakpoint conditionnel
info breakpoints          # Liste des breakpoints
disable <num>             # D√©sactiver
enable <num>              # Activer
delete <num>              # Supprimer
```

### Watchpoints
```gdb
watch <var>               # Watchpoint (√©criture)
rwatch <var>              # Read watchpoint
awatch <var>              # Access watchpoint (lecture/√©criture)
info watchpoints          # Liste des watchpoints
```

### Catchpoints
```gdb
catch <event>             # Cr√©er un catchpoint
catch syscall [nom]       # Capturer syscall
catch signal [SIG]        # Capturer signal
catch fork                # Capturer fork()
info breakpoints          # Les catchpoints apparaissent ici aussi
```

---

## Conseils pratiques

### 1. Commencez simple
Ne placez pas 20 breakpoints d√®s le d√©but. Commencez par un ou deux aux endroits strat√©giques (d√©but de `main`, fonction suspecte).

### 2. Utilisez les conditions
Dans une boucle de 10 000 it√©rations, un breakpoint conditionnel vous √©vitera de presser 9 999 fois "continue".

### 3. Watchpoints sur petites zones
Les watchpoints sont co√ªteux en performance. Surveillez des variables sp√©cifiques, pas de gros tableaux.

### 4. Notez vos breakpoints
Quand vous travaillez sur un bug complexe, notez les num√©ros de vos breakpoints et leur but sur papier ou dans un fichier texte.

### 5. Nettoyez r√©guli√®rement
Supprimez les breakpoints/watchpoints dont vous n'avez plus besoin avec `delete` pour garder votre session claire.

---

## Prochaines √©tapes

Maintenant que vous ma√Ætrisez ces trois outils fondamentaux de GDB, vous √™tes pr√™t √† explorer :
- **15.2.2 Stepping** : Avancer pas √† pas dans le code
- **15.2.3 Backtrace** : Analyser la pile d'appels
- **15.2.4 Inspection des variables** : Examiner les donn√©es en profondeur

Ces commandes combin√©es aux breakpoints, watchpoints et catchpoints forment un arsenal complet pour r√©soudre n'importe quel bug en C !

---

**üí° Astuce finale :** GDB peut sembler intimidant au d√©but, mais ces trois concepts (break/watch/catch) repr√©sentent 80% de l'utilisation quotidienne. Une fois ma√Ætris√©s, le d√©bogage devient bien plus efficace que l'ajout de `printf()` partout dans le code.

‚è≠Ô∏è [Stepping](/15-debogage-et-qualite/02.2-stepping.md)
