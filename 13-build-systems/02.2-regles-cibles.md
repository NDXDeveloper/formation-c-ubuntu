üîù Retour au [Sommaire](/SOMMAIRE.md)

# 13.2.2 R√®gles, Cibles et D√©pendances

## Introduction

Dans la section pr√©c√©dente, nous avons vu la syntaxe de base des Makefiles. Maintenant, nous allons approfondir le c≈ìur du syst√®me Make : les **r√®gles**, les **cibles** et les **d√©pendances**. C'est ce m√©canisme qui permet √† Make de savoir **quoi** construire, **quand** le construire, et **comment** le construire.

## Rappel : Anatomie d'une R√®gle

```makefile
cible: d√©pendance1 d√©pendance2
	commande1
	commande2
```

- **Cible** : Ce que vous voulez cr√©er (fichier ou action)
- **D√©pendances** : Ce dont la cible a besoin pour √™tre construite
- **Commandes** : Comment construire la cible

## Types de Cibles

### 1. Cibles Fichiers

Les cibles les plus courantes repr√©sentent des **fichiers r√©els** √† cr√©er :

```makefile
# programme est un fichier ex√©cutable
programme: main.o utils.o
	gcc -o programme main.o utils.o

# main.o est un fichier objet
main.o: main.c
	gcc -c main.c -o main.o
```

**Comportement cl√©** : Make compare les timestamps (dates de modification) :
- Si `main.o` n'existe pas ‚Üí Make le compile
- Si `main.c` est plus r√©cent que `main.o` ‚Üí Make recompile
- Si `main.o` est plus r√©cent que `main.c` ‚Üí Make ne fait rien (d√©j√† √† jour)

### 2. Cibles Phony (Factices)

Les cibles qui ne cr√©ent **pas de fichiers** doivent √™tre d√©clar√©es comme `.PHONY` :

```makefile
.PHONY: clean all test install

clean:
	rm -f *.o programme

all: programme doc

test: programme
	./programme --test

install: programme
	cp programme /usr/local/bin/
```

**Pourquoi .PHONY est important ?**

```makefile
# Sans .PHONY
clean:
	rm -f *.o

# Si un fichier nomm√© "clean" existe dans le r√©pertoire,
# Make dira "clean is up to date" et ne fera rien !

# Avec .PHONY
.PHONY: clean
clean:
	rm -f *.o
# Fonctionne toujours, m√™me si un fichier "clean" existe
```

### 3. Cible par D√©faut

La **premi√®re cible** non-phony est la cible par d√©faut (ex√©cut√©e avec `make` sans argument) :

```makefile
# Cible par d√©faut
all: programme1 programme2

programme1: main1.o
	gcc -o programme1 main1.o

programme2: main2.o
	gcc -o programme2 main2.o

.PHONY: clean
clean:
	rm -f *.o programme1 programme2
```

Tapez simplement `make` ‚Üí Construit `all` ‚Üí Construit `programme1` et `programme2`

## Les D√©pendances

### D√©pendances Normales

Les d√©pendances indiquent quels fichiers doivent exister (et √™tre √† jour) avant de construire la cible :

```makefile
programme: main.o utils.o config.h
	gcc -o programme main.o utils.o
```

Ici, `programme` d√©pend de :
- `main.o` (fichier objet)
- `utils.o` (fichier objet)
- `config.h` (header)

**R√®gle d'or** : Si **une** d√©pendance est plus r√©cente que la cible, Make reconstruit la cible.

### Cha√Ænes de D√©pendances

Les d√©pendances peuvent elles-m√™mes avoir des d√©pendances, cr√©ant un **graphe** :

```makefile
# Niveau 0 : Ex√©cutable final
programme: main.o utils.o
	gcc -o programme main.o utils.o

# Niveau 1 : Fichiers objets
main.o: main.c utils.h
	gcc -c main.c

utils.o: utils.c utils.h
	gcc -c utils.c

# Niveau 2 : Fichiers sources (pas de r√®gle, ils existent d√©j√†)
```

**Graphe de d√©pendances** :
```
        programme
        /        \
     main.o    utils.o
     /    \      /    \
main.c utils.h utils.c utils.h
```

**Ordre de construction** (Make le calcule automatiquement) :
1. V√©rifie `main.c` et `utils.h` ‚Üí Compile `main.o` si n√©cessaire
2. V√©rifie `utils.c` et `utils.h` ‚Üí Compile `utils.o` si n√©cessaire
3. Link `main.o` et `utils.o` ‚Üí Cr√©e `programme`

### D√©pendances sur des Cibles Phony

Vous pouvez d√©pendre d'une cible phony :

```makefile
.PHONY: all clean test

all: programme doc

programme: main.o
	gcc -o programme main.o

doc: README.md
	markdown README.md > doc.html

test: programme
	./programme --run-tests

clean:
	rm -f *.o programme doc.html
```

`make all` ‚Üí Construit `programme` ET `doc`

### D√©pendances d'Ordre (Order-Only Prerequisites)

Parfois, vous voulez qu'un r√©pertoire existe **avant** de compiler, mais vous ne voulez **pas** recompiler si le r√©pertoire change :

```makefile
# Syntaxe : cible: d√©pendances-normales | d√©pendances-ordre

build/programme: main.o | build
	gcc -o build/programme main.o

build:
	mkdir -p build
```

**Diff√©rence** :
- **D√©pendances normales** (`main.o`) : Si modifi√©es ‚Üí recompile
- **D√©pendances d'ordre** (`| build`) : Doivent exister, mais leur modification ne d√©clenche pas de recompilation

**Cas d'usage typique** : Cr√©er des r√©pertoires de build

```makefile
OBJDIR = obj  
BINDIR = bin  

$(BINDIR)/programme: $(OBJDIR)/main.o $(OBJDIR)/utils.o | $(BINDIR)
	gcc -o $@ $^

$(OBJDIR)/%.o: src/%.c | $(OBJDIR)
	gcc -c $< -o $@

$(OBJDIR):
	mkdir -p $(OBJDIR)

$(BINDIR):
	mkdir -p $(BINDIR)

.PHONY: clean
clean:
	rm -rf $(OBJDIR) $(BINDIR)
```

## R√®gles Multiples pour une M√™me Cible

### Plusieurs R√®gles de D√©pendances

Vous pouvez d√©finir plusieurs r√®gles pour ajouter des d√©pendances √† une cible :

```makefile
# Premi√®re r√®gle : d√©finit la commande
programme: main.o
	gcc -o programme main.o utils.o config.o

# Deuxi√®me r√®gle : ajoute des d√©pendances
programme: utils.o

# Troisi√®me r√®gle : ajoute encore des d√©pendances
programme: config.o
```

C'est √©quivalent √† :

```makefile
programme: main.o utils.o config.o
	gcc -o programme main.o utils.o config.o
```

**‚ö†Ô∏è Attention** : Une seule r√®gle peut avoir des commandes. Les autres ne servent qu'√† ajouter des d√©pendances.

### Utilit√© : S√©paration des Pr√©occupations

```makefile
# D√©pendances de base
programme: main.o utils.o
	gcc -o programme $(OBJS)

# Selon la configuration, on ajoute des d√©pendances
ifdef DEBUG  
programme: debug.o  
endif  

ifdef PROFILING  
programme: profiler.o  
endif  
```

## Cibles Multiples

### M√™me Recette pour Plusieurs Cibles

```makefile
# Plusieurs cibles avec les m√™mes commandes
programme1 programme2: main.o utils.o
	gcc -o programme1 main.o
	gcc -o programme2 utils.o
```

**‚ö†Ô∏è Attention** : Chaque cible re√ßoit **toutes** les commandes. C'est √©quivalent √† :

```makefile
programme1: main.o utils.o
	gcc -o programme1 main.o
	gcc -o programme2 utils.o

programme2: main.o utils.o
	gcc -o programme1 main.o
	gcc -o programme2 utils.o
```

Les deux commandes `gcc` sont ex√©cut√©es pour chaque cible. Pour des commandes sp√©cifiques par cible, utilisez la variable automatique `$@` :

```makefile
# ‚úÖ Correct : $@ repr√©sente la cible en cours
programme1 programme2:
	gcc -o $@ $@.o utils.o
```

### Cas d'Usage Pratique

```makefile
# Installation de plusieurs binaires
.PHONY: install
install: prog1 prog2
	cp prog1 /usr/local/bin/
	cp prog2 /usr/local/bin/
	chmod 755 /usr/local/bin/prog1 /usr/local/bin/prog2
```

## D√©pendances Implicites

Make conna√Æt certaines d√©pendances automatiquement :

```makefile
# Make sait que .o d√©pend de .c
main.o: main.c
	gcc -c main.c

# √âquivalent (r√®gle implicite de Make)
main.o: main.c
	# Pas besoin de commande, Make utilise : $(CC) -c main.c -o main.o
```

Mais vous devez **toujours d√©clarer les d√©pendances sur les headers** :

```makefile
# ‚úÖ CORRECT : D√©clare la d√©pendance sur le header
main.o: main.c utils.h
	gcc -c main.c

# ‚ùå INCORRECT : Si utils.h change, main.o ne sera pas recompil√©
main.o: main.c
	gcc -c main.c
```

## Ordre d'√âvaluation de Make

### Phase 1 : Lecture du Makefile

Make lit **tout** le Makefile en premier et construit le graphe de d√©pendances :

```makefile
all: programme

programme: main.o utils.o
	gcc -o programme main.o utils.o

main.o: main.c utils.h  
utils.o: utils.c utils.h  
```

**Graphe construit** :
```
all ‚Üí programme ‚Üí main.o ‚Üí main.c, utils.h
              ‚îî‚Üí utils.o ‚Üí utils.c, utils.h
```

### Phase 2 : Calcul des Cibles √† Construire

Make parcourt le graphe en **profondeur d'abord** (depth-first) :

1. Cible demand√©e : `all`
2. D√©pendances de `all` : `programme`
3. D√©pendances de `programme` : `main.o`, `utils.o`
4. D√©pendances de `main.o` : `main.c`, `utils.h` (fichiers sources, pas de r√®gles)
5. Retour : Si `main.c` ou `utils.h` plus r√©cent que `main.o` ‚Üí Compile `main.o`
6. D√©pendances de `utils.o` : `utils.c`, `utils.h`
7. Retour : Si `utils.c` ou `utils.h` plus r√©cent que `utils.o` ‚Üí Compile `utils.o`
8. Retour √† `programme` : Si `main.o` ou `utils.o` plus r√©cent que `programme` ‚Üí Link

### Phase 3 : Ex√©cution des Commandes

Make ex√©cute les commandes dans l'ordre calcul√© (ordre topologique du graphe).

## Exemples Pratiques

### Exemple 1 : Projet Simple avec Headers

```makefile
# Variables
CC = gcc  
CFLAGS = -Wall -Wextra -std=c11  

# Cible par d√©faut
all: calculatrice

# Ex√©cutable
calculatrice: main.o operations.o affichage.o
	$(CC) $(CFLAGS) -o calculatrice main.o operations.o affichage.o

# D√©pendances explicites sur les headers
main.o: main.c operations.h affichage.h  
operations.o: operations.c operations.h  
affichage.o: affichage.c affichage.h  

# R√®gles implicites pour compiler les .c en .o
# (Make utilise : $(CC) $(CFLAGS) -c $< -o $@)

# Nettoyage
.PHONY: clean
clean:
	rm -f *.o calculatrice
```

### Exemple 2 : Projet avec Sous-R√©pertoires

```makefile
# R√©pertoires
SRCDIR = src  
OBJDIR = obj  
BINDIR = bin  

# Fichiers
SOURCES = $(SRCDIR)/main.c $(SRCDIR)/utils.c $(SRCDIR)/config.c  
OBJECTS = $(OBJDIR)/main.o $(OBJDIR)/utils.o $(OBJDIR)/config.o  
TARGET = $(BINDIR)/programme  

# Cible par d√©faut
all: $(TARGET)

# Linkage
$(TARGET): $(OBJECTS) | $(BINDIR)
	gcc -o $(TARGET) $(OBJECTS)

# Compilation avec d√©pendances sur headers
$(OBJDIR)/main.o: $(SRCDIR)/main.c $(SRCDIR)/utils.h | $(OBJDIR)
	gcc -c $(SRCDIR)/main.c -o $(OBJDIR)/main.o

$(OBJDIR)/utils.o: $(SRCDIR)/utils.c $(SRCDIR)/utils.h | $(OBJDIR)
	gcc -c $(SRCDIR)/utils.c -o $(OBJDIR)/utils.o

$(OBJDIR)/config.o: $(SRCDIR)/config.c $(SRCDIR)/config.h | $(OBJDIR)
	gcc -c $(SRCDIR)/config.c -o $(OBJDIR)/config.o

# Cr√©ation des r√©pertoires (d√©pendances d'ordre)
$(OBJDIR):
	mkdir -p $(OBJDIR)

$(BINDIR):
	mkdir -p $(BINDIR)

# Nettoyage
.PHONY: clean
clean:
	rm -rf $(OBJDIR) $(BINDIR)
```

### Exemple 3 : Cibles Multiples et Phony

```makefile
# Programmes √† construire
PROGRAMS = client server

# Cible par d√©faut : construire tous les programmes
.PHONY: all
all: $(PROGRAMS)

# R√®gles individuelles
client: client.o network.o
	gcc -o client client.o network.o

server: server.o network.o
	gcc -o server server.o network.o

# D√©pendances sur headers
client.o: client.c network.h  
server.o: server.c network.h  
network.o: network.c network.h  

# Installation
.PHONY: install
install: $(PROGRAMS)
	cp client /usr/local/bin/
	cp server /usr/local/bin/

# Tests
.PHONY: test
test: $(PROGRAMS)
	./server &
	sleep 1
	./client localhost
	killall server

# Nettoyage
.PHONY: clean
clean:
	rm -f *.o $(PROGRAMS)

# Nettoyage complet
.PHONY: distclean
distclean: clean
	rm -f *~ *.bak
```

## V√©rification du Graphe de D√©pendances

### Visualiser ce que Make va faire

```bash
# Afficher les commandes sans les ex√©cuter (dry-run)
make -n

# Afficher le raisonnement de Make
make -d

# Afficher pourquoi Make reconstruit (ou non) une cible
make --debug=b
```

### Exemple de sortie

```bash
$ make -n
gcc -c main.c -o main.o  
gcc -c utils.c -o utils.o  
gcc -o programme main.o utils.o  
```

## Erreurs Courantes

### 1. Oublier des D√©pendances sur les Headers

```makefile
# ‚ùå PROBL√àME
main.o: main.c
	gcc -c main.c

# Si utils.h change, main.o ne sera PAS recompil√© !

# ‚úÖ SOLUTION
main.o: main.c utils.h config.h
	gcc -c main.c
```

### 2. D√©pendances Circulaires

```makefile
# ‚ùå ERREUR : Boucle infinie
a: b  
b: a  

# Make d√©tecte l'erreur :
# Makefile:1: Circular a <- b dependency dropped.
```

### 3. Cibles Phony non D√©clar√©es

```makefile
# ‚ùå PROBL√àME
clean:
	rm -f *.o

# Si un fichier "clean" existe, Make ne fera rien

# ‚úÖ SOLUTION
.PHONY: clean
clean:
	rm -f *.o
```

### 4. Ordre des D√©pendances Incorrect

```makefile
# ‚ùå PROBL√àME : Si main.o n'existe pas encore
programme: main.o  
main.o: main.c  

# Bien que cela fonctionne (Make calcule l'ordre),
# il est plus clair d'organiser logiquement :

# ‚úÖ MEILLEUR
main.o: main.c  
programme: main.o  
```

## Commandes Utiles pour D√©boguer

```bash
# Afficher les r√®gles implicites de Make
make -p

# Voir toutes les cibles disponibles
make -qp | grep -v '^#' | grep ':' | cut -d: -f1 | sort -u

# Reconstruire une cible m√™me si elle est √† jour
make -B cible

# Afficher la version de Make
make --version

# Ignorer les erreurs et continuer
make -k
```

## Concepts Avanc√©s (Aper√ßu)

### D√©pendances G√©n√©r√©es Automatiquement

Pour les gros projets, g√©rer manuellement les d√©pendances sur les headers devient fastidieux. GCC peut g√©n√©rer automatiquement ces d√©pendances :

```makefile
# G√©n√©ration automatique des d√©pendances
-include $(OBJECTS:.o=.d)

%.o: %.c
	gcc -c $(CFLAGS) $< -o $@
	gcc -MM $(CFLAGS) $< > $*.d
```

Cela sera d√©taill√© dans la section sur les **pattern rules**.

## R√©sum√©

| Concept | Syntaxe | Description |
|---------|---------|-------------|
| Cible fichier | `prog: deps` | Cr√©e un fichier r√©el |
| Cible phony | `.PHONY: clean` | Action sans fichier |
| D√©pendances normales | `a: b c` | Si b ou c changent ‚Üí reconstruit a |
| D√©pendances d'ordre | `a: b \| c` | c doit exister, mais sa modification ne d√©clenche pas a |
| Cibles multiples | `a b: deps` | M√™me r√®gle pour a et b |
| R√®gles multiples | `a: b` puis `a: c` | Ajoute des d√©pendances |

## Bonnes Pratiques

1. ‚úÖ **Toujours d√©clarer les d√©pendances sur les headers**
2. ‚úÖ **Utiliser .PHONY pour les cibles factices**
3. ‚úÖ **Organiser logiquement** : Sources ‚Üí Objets ‚Üí Ex√©cutable
4. ‚úÖ **Tester avec `make -n`** avant d'ex√©cuter
5. ‚úÖ **Utiliser des d√©pendances d'ordre** pour cr√©er des r√©pertoires
6. ‚úÖ **Documenter les cibles complexes** avec des commentaires

## Prochaines √âtapes

Dans les sections suivantes, vous d√©couvrirez :

- **13.2.3** : Variables et macros avanc√©es (substitutions, fonctions)
- **13.2.4** : Pattern rules et variables automatiques (`$@`, `$<`, `$^`)

Ces outils vous permettront d'√©crire des Makefiles g√©n√©riques et maintenables, m√™me pour de gros projets.

---

**üìö R√©f√©rences :**
- `man make` : Documentation compl√®te
- [GNU Make Manual - Rules](https://www.gnu.org/software/make/manual/html_node/Rules.html) : Chapitre officiel sur les r√®gles

‚è≠Ô∏è [Variables et macros](/13-build-systems/02.3-variables-macros.md)
