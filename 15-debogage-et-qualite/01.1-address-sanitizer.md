üîù Retour au [Sommaire](/SOMMAIRE.md)

# 15.1.1 AddressSanitizer (ASan)

## Introduction

**AddressSanitizer** (souvent abr√©g√© **ASan**) est un outil de d√©tection d'erreurs m√©moire extr√™mement puissant d√©velopp√© par Google. Il s'agit d'un **sanitizer**, c'est-√†-dire un d√©tecteur automatique de bugs qui s'int√®gre directement dans votre programme lors de la compilation.

### Pourquoi AddressSanitizer est essentiel ?

En programmation C, la gestion manuelle de la m√©moire est source de nombreux bugs parfois tr√®s difficiles √† d√©tecter :
- Acc√®s √† une zone m√©moire non allou√©e
- Utilisation de m√©moire apr√®s l'avoir lib√©r√©e
- D√©bordement de buffer (√©criture au-del√† d'un tableau)
- Fuites m√©moire

Ces erreurs peuvent :
- ‚ùå Provoquer des **plantages al√©atoires** (segmentation fault)
- ‚ùå Corrompre silencieusement les donn√©es
- ‚ùå Cr√©er des **failles de s√©curit√© exploitables**
- ‚ùå Ne se manifester que dans certaines conditions (rendant le d√©bogage cauchemardesque)

**AddressSanitizer d√©tecte ces erreurs imm√©diatement** et vous dit exactement o√π elles se produisent dans votre code.

---

## Qu'est-ce qu'ASan d√©tecte ?

AddressSanitizer peut d√©tecter les types d'erreurs suivants :

### 1. **Use-after-free** (Utilisation apr√®s lib√©ration)
Vous utilisez un pointeur apr√®s avoir appel√© `free()` dessus.

```c
int *ptr = malloc(sizeof(int));
*ptr = 42;
free(ptr);
*ptr = 10;  // ‚ùå ERREUR : Utilisation apr√®s lib√©ration
```

### 2. **Heap buffer overflow** (D√©bordement de buffer sur le tas)
Vous √©crivez au-del√† de la m√©moire allou√©e.

```c
int *arr = malloc(10 * sizeof(int));  
arr[15] = 100;  // ‚ùå ERREUR : √âcriture hors des limites  
```

### 3. **Stack buffer overflow** (D√©bordement de buffer sur la pile)
Vous √©crivez au-del√† d'un tableau local.

```c
void fonction() {
    int tab[5];
    tab[10] = 42;  // ‚ùå ERREUR : D√©bordement de la pile
}
```

### 4. **Global buffer overflow** (D√©bordement sur variable globale)
```c
int global[10];

void fonction() {
    global[20] = 99;  // ‚ùå ERREUR : D√©bordement variable globale
}
```

### 5. **Use-after-return** (Utilisation apr√®s retour de fonction)
Vous acc√©dez √† une variable locale apr√®s la fin de la fonction.

```c
int* fonction() {
    int local = 42;
    return &local;  // ‚ùå ERREUR : Retour d'adresse de variable locale
}
```

### 6. **Use-after-scope**
Vous utilisez une variable en dehors de sa port√©e.

```c
int *ptr;
{
    int local = 42;
    ptr = &local;
}
*ptr = 10;  // ‚ùå ERREUR : 'local' n'existe plus
```

### 7. **Double-free**
Vous lib√©rez la m√™me m√©moire deux fois.

```c
int *ptr = malloc(sizeof(int));  
free(ptr);  
free(ptr);  // ‚ùå ERREUR : Double lib√©ration  
```

### 8. **Memory leaks** (Fuites m√©moire)
Vous allouez de la m√©moire sans jamais la lib√©rer (d√©tection optionnelle avec LeakSanitizer, inclus dans ASan).

---

## Comment utiliser AddressSanitizer ?

### Activation pendant la compilation

Pour activer ASan, il suffit d'ajouter l'option `-fsanitize=address` lors de la compilation avec GCC ou Clang :

```bash
gcc -fsanitize=address -g -o mon_programme mon_programme.c
```

**Options importantes :**
- `-fsanitize=address` : Active AddressSanitizer
- `-g` : Ajoute les informations de d√©bogage (pour voir les num√©ros de lignes dans les rapports)
- `-O1` ou `-O0` : Niveau d'optimisation faible recommand√© pour plus de pr√©cision

### Exemple complet

Prenons un programme simple avec une erreur :

**fichier : `bug.c`**
```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int *tableau = malloc(5 * sizeof(int));

    for (int i = 0; i < 10; i++) {  // Boucle va trop loin !
        tableau[i] = i * 2;
    }

    printf("Termin√© !\n");
    free(tableau);
    return 0;
}
```

**Compilation avec ASan :**
```bash
gcc -fsanitize=address -g -o bug bug.c
```

**Ex√©cution :**
```bash
./bug
```

---

## Interpr√©ter les rapports d'AddressSanitizer

Lorsqu'ASan d√©tecte une erreur, il affiche un rapport d√©taill√©. Voici un exemple :

```
=================================================================
==12345==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000034 at pc 0x000000401234 bp 0x7fffffffdc80 sp 0x7fffffffdc78
WRITE of size 4 at 0x602000000034 thread T0
    #0 0x401233 in main bug.c:7
    #1 0x7ffff7a03c86 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21c86)
    #2 0x401099 in _start (/home/user/bug+0x401099)

0x602000000034 is located 4 bytes to the right of 20-byte region [0x602000000020,0x602000000034)
allocated by thread T0 here:
    #0 0x7ffff7b01d38 in __interceptor_malloc (/usr/lib/x86_64-linux-gnu/libasan.so.4+0xdfd38)
    #1 0x4011d3 in main bug.c:5
    #2 0x7ffff7a03c86 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21c86)

SUMMARY: AddressSanitizer: heap-buffer-overflow bug.c:7 in main
```

### D√©crypter le rapport

#### 1. **Type d'erreur**
```
ERROR: AddressSanitizer: heap-buffer-overflow
```
‚Üí Un **d√©bordement de buffer sur le tas** a √©t√© d√©tect√©.

#### 2. **Op√©ration probl√©matique**
```
WRITE of size 4 at 0x602000000034
```
‚Üí Une **√©criture de 4 octets** (un `int`) √† une adresse invalide.

#### 3. **Stack trace (pile d'appels)**
```
#0 0x401233 in main bug.c:7
```
‚Üí L'erreur s'est produite √† la **ligne 7** du fichier `bug.c`, dans la fonction `main`.

#### 4. **Contexte de l'allocation**
```
allocated by thread T0 here:
    #1 0x4011d3 in main bug.c:5
```
‚Üí La m√©moire a √©t√© allou√©e √† la **ligne 5** (le `malloc`).

#### 5. **R√©sum√©**
```
0x602000000034 is located 4 bytes to the right of 20-byte region
```
‚Üí Vous avez √©crit **4 octets apr√®s la fin** de la zone allou√©e (20 octets = 5 entiers √ó 4 octets).

---

## Correction du bug

D'apr√®s le rapport, le probl√®me est clair : la boucle it√®re 10 fois alors que seulement 5 entiers ont √©t√© allou√©s.

**Code corrig√© :**
```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int *tableau = malloc(5 * sizeof(int));

    for (int i = 0; i < 5; i++) {  // ‚úÖ Corrig√© : boucle jusqu'√† 5
        tableau[i] = i * 2;
    }

    printf("Termin√© !\n");
    free(tableau);
    return 0;
}
```

---

## Options d'environnement utiles

ASan peut √™tre configur√© via la variable d'environnement `ASAN_OPTIONS` :

### D√©sactiver la d√©tection de fuites m√©moire
Par d√©faut, ASan d√©tecte aussi les fuites. Pour d√©sactiver :
```bash
ASAN_OPTIONS=detect_leaks=0 ./mon_programme
```

### Continuer apr√®s la premi√®re erreur
Par d√©faut, ASan arr√™te √† la premi√®re erreur. Pour continuer :
```bash
ASAN_OPTIONS=halt_on_error=0 ./mon_programme
```

### Obtenir des rapports plus d√©taill√©s
```bash
ASAN_OPTIONS=verbosity=1 ./mon_programme
```

### Exemple combin√©
```bash
ASAN_OPTIONS=detect_leaks=1:halt_on_error=0 ./mon_programme
```

---

## Avantages et Limites

### ‚úÖ Avantages

1. **D√©tection imm√©diate** : Les erreurs sont signal√©es d√®s qu'elles se produisent
2. **Pr√©cision** : Indique exactement la ligne fautive et le contexte
3. **Facile √† utiliser** : Un simple flag de compilation suffit
4. **Peu de faux positifs** : Les erreurs rapport√©es sont g√©n√©ralement r√©elles
5. **Int√©gration CI/CD** : Peut √™tre automatis√© dans les pipelines de test

### ‚ö†Ô∏è Limites

1. **Ralentissement** : Le programme s'ex√©cute environ **2√ó plus lentement**
2. **Consommation m√©moire** : Utilise environ **3√ó plus de RAM**
3. **Pas en production** : √Ä utiliser uniquement en d√©veloppement/tests
4. **Recompilation n√©cessaire** : Vous devez recompiler avec le flag
5. **Ne d√©tecte pas tout** : Par exemple, les erreurs de logique m√©tier

---

## Bonnes pratiques

### 1. Compiler syst√©matiquement avec ASan pendant le d√©veloppement
Ajoutez un target dans votre Makefile ou CMakeLists.txt :

**Makefile :**
```makefile
debug: CFLAGS += -fsanitize=address -g -O1  
debug: mon_programme  
```

**CMake :**
```cmake
add_compile_options(-fsanitize=address -g)  
add_link_options(-fsanitize=address)  
```

### 2. Ex√©cuter tous vos tests avec ASan activ√©
```bash
gcc -fsanitize=address -g -o tests tests.c
./tests
```

### 3. Combiner avec d'autres sanitizers (plus tard dans le cours)
ASan peut √™tre combin√© avec UBSan (undefined behavior) mais pas avec TSan (threads).

### 4. Ne jamais ignorer les erreurs ASan
M√™me si votre programme "semble fonctionner", une erreur ASan indique un bug r√©el qui peut causer des probl√®mes plus tard.

---

## Exemple r√©el : D√©tection de use-after-free

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int id;
    char nom[20];
} Utilisateur;

int main() {
    Utilisateur *user = malloc(sizeof(Utilisateur));
    user->id = 123;

    printf("ID utilisateur : %d\n", user->id);

    free(user);

    // ‚ùå ERREUR : Utilisation apr√®s lib√©ration
    printf("ID utilisateur : %d\n", user->id);

    return 0;
}
```

**Compilation et ex√©cution :**
```bash
gcc -fsanitize=address -g -o use_after_free use_after_free.c
./use_after_free
```

**Rapport ASan :**
```
ERROR: AddressSanitizer: heap-use-after-free on address 0x602000000010  
READ of size 4 at 0x602000000010 thread T0  
    #0 0x401234 in main use_after_free.c:16

freed by thread T0 here:
    #0 0x7ffff7b01f70 in __interceptor_free
    #1 0x401220 in main use_after_free.c:14

previously allocated by thread T0 here:
    #0 0x7ffff7b01d38 in __interceptor_malloc
    #1 0x4011e3 in main use_after_free.c:10

SUMMARY: AddressSanitizer: heap-use-after-free use_after_free.c:16 in main
```

Le rapport indique clairement :
1. **Ligne 16** : Lecture apr√®s lib√©ration
2. **Ligne 14** : O√π la m√©moire a √©t√© lib√©r√©e
3. **Ligne 10** : O√π elle avait √©t√© allou√©e

---

## Int√©gration dans votre workflow

### Phase de d√©veloppement
```bash
# Compilation pour le d√©veloppement
gcc -fsanitize=address -g -O1 -Wall -Wextra -o mon_app *.c

# Lancement
./mon_app
```

### Tests automatis√©s
```bash
# Script de test
#!/bin/bash
gcc -fsanitize=address -g -o tests tests.c  
if ./tests; then  
    echo "‚úÖ Tests r√©ussis, aucune erreur m√©moire"
else
    echo "‚ùå Erreurs d√©tect√©es par ASan"
    exit 1
fi
```

### Dans un pipeline CI (GitHub Actions, GitLab CI, etc.)
```yaml
- name: Build avec ASan
  run: gcc -fsanitize=address -g -o app main.c

- name: Ex√©cuter les tests
  run: ./app --run-tests
```

---

## Comparaison avec Valgrind

| Crit√®re | AddressSanitizer | Valgrind |
|---------|------------------|----------|
| **Vitesse** | ~2√ó plus lent | ~10-50√ó plus lent |
| **D√©tection** | Imm√©diate | Imm√©diate |
| **Recompilation** | Oui (avec `-fsanitize=address`) | Non |
| **Pr√©cision** | Tr√®s pr√©cise | Tr√®s pr√©cise |
| **Overhead m√©moire** | ~3√ó | ~2√ó |
| **Plateformes** | Linux, macOS, Windows | Principalement Linux |

**Recommandation :**
- Utilisez **ASan pendant le d√©veloppement** (rapide, feedback imm√©diat)
- Utilisez **Valgrind pour une analyse finale** (plus exhaustif)

---

## R√©sum√©

### Points cl√©s √† retenir

1. **ASan d√©tecte automatiquement** les erreurs m√©moire courantes en C
2. **Activation simple** : `-fsanitize=address` lors de la compilation
3. **Rapports d√©taill√©s** : Ligne exacte de l'erreur + contexte
4. **Indispensable** pour tout d√©veloppeur C s√©rieux
5. **Utilisez-le syst√©matiquement** en d√©veloppement et dans les tests

### Commande √† retenir
```bash
gcc -fsanitize=address -g -O1 -Wall -Wextra -o programme programme.c
```

### Prochaines √©tapes
Dans les sections suivantes, vous d√©couvrirez :
- **UndefinedBehaviorSanitizer (UBSan)** : D√©tection de comportements ind√©finis
- **ThreadSanitizer (TSan)** : D√©tection de race conditions
- **LeakSanitizer (LSan)** : D√©tection de fuites m√©moire (souvent inclus dans ASan)

---

**üéØ AddressSanitizer est votre meilleur alli√© pour √©crire du code C robuste et s√©curis√©. Ne codez plus jamais sans lui !**

‚è≠Ô∏è [UndefinedBehaviorSanitizer (UBSan)](/15-debogage-et-qualite/01.2-undefined-behavior-sanitizer.md)
