ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 21.2.4 JIT Compilation

## Introduction

La **JIT compilation** (Just-In-Time compilation) est l'une des raisons pour lesquelles eBPF est si rapide. C'est la technologie qui transforme le bytecode eBPF en **code machine natif** qui s'exÃ©cute directement sur votre processeur, sans intermÃ©diaire.

Sans JIT, les programmes eBPF seraient interprÃ©tÃ©s instruction par instruction, ce qui serait beaucoup trop lent. Avec JIT, ils atteignent des performances Ã©quivalentes au code C compilÃ© directement dans le noyau.

Dans cette section, nous allons dÃ©couvrir comment fonctionne cette magie.

---

## ğŸ¯ Qu'est-ce que la JIT Compilation ?

### DÃ©finition Simple

**JIT** signifie **Just-In-Time** (juste Ã  temps). C'est une technique qui compile du bytecode en **code machine natif** au moment oÃ¹ le programme est chargÃ© dans le noyau.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Votre code C                                 â”‚
â”‚   program.bpf.c                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼ Compilation (clang)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Bytecode eBPF                                â”‚
â”‚   (instructions de la machine virtuelle eBPF)  â”‚
â”‚   mov r0, 42                                   â”‚
â”‚   exit                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼ JIT Compilation (dans le noyau)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Code Machine Natif (x86-64, ARM64, etc.)     â”‚
â”‚   (instructions directes du processeur)        â”‚
â”‚   0x48 0xc7 0xc0 0x2a 0x00 0x00 0x00           â”‚
â”‚   0xc3                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Les Deux Approches

**1. InterprÃ©tation (lent)**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Ã‰vÃ©nement â†’ Programme eBPF         â”‚
â”‚                                      â”‚
â”‚   Pour chaque instruction :          â”‚
â”‚   1. Lire l'instruction              â”‚
â”‚   2. DÃ©coder                         â”‚
â”‚   3. ExÃ©cuter                        â”‚
â”‚   4. Passer Ã  la suivante            â”‚
â”‚                                      â”‚
â”‚   Boucle d'interprÃ©tation =          â”‚
â”‚   OVERHEAD IMPORTANT                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**2. JIT Compilation (rapide)**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Ã‰vÃ©nement â†’ Code Machine Natif     â”‚
â”‚                                      â”‚
â”‚   ExÃ©cution directe par le CPU :     â”‚
â”‚   â€¢ Pas de boucle d'interprÃ©tation   â”‚
â”‚   â€¢ Pas de dÃ©codage                  â”‚
â”‚   â€¢ Instructions natives             â”‚
â”‚                                      â”‚
â”‚   Performance = Code C du noyau      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ¤” Analogie : Le Traducteur vs Le Locuteur Natif

### Sans JIT : Le Traducteur SimultanÃ©

Imaginez que vous assistez Ã  une confÃ©rence en langue Ã©trangÃ¨re avec un traducteur :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ConfÃ©rencier (Bytecode eBPF)          â”‚
â”‚   "Hello, how are you?"                 â”‚
â”‚           â†“                             â”‚
â”‚   Traducteur (InterprÃ©teur)             â”‚
â”‚   Ã‰coute â†’ Comprend â†’ Traduit           â”‚
â”‚   "Bonjour, comment allez-vous ?"       â”‚
â”‚           â†“                             â”‚
â”‚   Vous (CPU)                            â”‚
â”‚   Comprend la traduction                â”‚
â”‚                                         â”‚
â”‚   DÃ‰LAI : Temps de traduction           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ProblÃ¨me** : Il y a un **dÃ©lai** Ã  chaque phrase. Le traducteur doit :
1. Ã‰couter
2. Comprendre
3. Traduire
4. Parler

### Avec JIT : Le Locuteur Natif

Maintenant, imaginez que le confÃ©rencier parle directement votre langue :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ConfÃ©rencier Bilingue (Code Natif)    â”‚
â”‚   "Bonjour, comment allez-vous ?"       â”‚
â”‚           â†“                             â”‚
â”‚   Vous (CPU)                            â”‚
â”‚   Comprend IMMÃ‰DIATEMENT                â”‚
â”‚                                         â”‚
â”‚   PAS DE DÃ‰LAI                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Avantage** : Communication **directe et instantanÃ©e**. Pas d'intermÃ©diaire.

C'est exactement ce que fait le JIT : il "traduit" une seule fois le bytecode en langage natif du CPU, puis le CPU exÃ©cute directement.

---

## âš™ï¸ Comment Fonctionne la JIT Compilation ?

### Le Pipeline Complet

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 ESPACE UTILISATEUR                      â”‚
â”‚                                                         â”‚
â”‚   1. Code C Source                                      â”‚
â”‚      program.bpf.c                                      â”‚
â”‚      â†“                                                  â”‚
â”‚   2. Compilation avec clang                             â”‚
â”‚      $ clang -O2 -target bpf -c program.bpf.c           â”‚
â”‚      â†“                                                  â”‚
â”‚   3. Bytecode eBPF (.o)                                 â”‚
â”‚      program.bpf.o                                      â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â”‚ bpf() syscall
                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 NOYAU LINUX                             â”‚
â”‚                                                         â”‚
â”‚   4. Chargement du bytecode                             â”‚
â”‚      â†“                                                  â”‚
â”‚   5. VÃ‰RIFICATEUR                                       â”‚
â”‚      â€¢ Analyse statique                                 â”‚
â”‚      â€¢ Garantie de sÃ©curitÃ©                             â”‚
â”‚      âœ“ Programme validÃ©                                 â”‚
â”‚      â†“                                                  â”‚
â”‚   6. JIT COMPILER                                       â”‚
â”‚      â€¢ Traduction bytecode â†’ code natif                 â”‚
â”‚      â€¢ Optimisations                                    â”‚
â”‚      â€¢ GÃ©nÃ©ration code machine                          â”‚
â”‚      â†“                                                  â”‚
â”‚   7. Code Machine Natif en MÃ©moire Kernel               â”‚
â”‚      â€¢ ExÃ©cutable directement par le CPU                â”‚
â”‚      â€¢ Performance maximale                             â”‚
â”‚                                                         â”‚
â”‚   8. Attachement au Hook                                â”‚
â”‚      â†’ Programme prÃªt Ã  s'exÃ©cuter                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Ã‰tape 6 : Le JIT Compiler en DÃ©tail

Le JIT compiler effectue plusieurs transformations :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   BYTECODE eBPF (indÃ©pendant de l'architecture)  â”‚
â”‚                                                  â”‚
â”‚   R0 = 42           // Charger 42 dans R0        â”‚
â”‚   R1 = R0 + 10      // Additionner 10            â”‚
â”‚   exit              // Retourner                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼ JIT Compilation
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   CODE MACHINE x86-64 (architecture spÃ©cifique)  â”‚
â”‚                                                  â”‚
â”‚   mov    rax, 42    // RAX = 42                  â”‚
â”‚   add    rax, 10    // RAX = RAX + 10            â”‚
â”‚   ret               // Retourner                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Mapping des registres** :

| Registre eBPF | x86-64 | ARM64 | Description |
|---------------|--------|-------|-------------|
| R0 | RAX | X0 | Valeur de retour |
| R1 | RDI | X1 | 1er argument |
| R2 | RSI | X2 | 2e argument |
| R3 | RDX | X3 | 3e argument |
| R4 | RCX | X4 | 4e argument |
| R5 | R8 | X5 | 5e argument |
| R6 | RBX | X19 | Callee-saved |
| R7 | R13 | X20 | Callee-saved |
| R8 | R14 | X21 | Callee-saved |
| R9 | R15 | X22 | Callee-saved |
| R10 | RBP | X29 | Frame pointer |

---

## ğŸš€ Avantages de la JIT Compilation

### 1. Performance Exceptionnelle

**Benchmark : Addition simple (1 million d'itÃ©rations)**

```
Sans JIT (interprÃ©tÃ©) :  ~500 ms  
Avec JIT (natif)      :   ~10 ms  

GAIN : 50x plus rapide !
```

**Pourquoi cette diffÃ©rence ?**

```
INTERPRÃ‰TATION (sans JIT)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Pour chaque instruction :
  1. Fetch instruction       (lecture mÃ©moire)
  2. Decode opcode           (switch/case)
  3. Fetch operands          (lecture registres)
  4. Execute operation       (calcul)
  5. Store result            (Ã©criture registre)
  6. Update program counter  (incrÃ©ment)

Overhead par instruction : ~10-50 cycles CPU


JIT COMPILATION (avec JIT)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Code natif exÃ©cutÃ© directement :
  mov    rax, [rbx]
  add    rax, 10
  mov    [rbx], rax

Overhead par instruction : ~1-3 cycles CPU

GAIN : 10-50x par instruction
```

### 2. Utilisation Optimale du CPU

Le JIT peut gÃ©nÃ©rer du code qui utilise les fonctionnalitÃ©s modernes du CPU :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   OPTIMISATIONS JIT                      â”‚
â”‚                                          â”‚
â”‚   â€¢ Pipeline CPU                         â”‚
â”‚   â€¢ PrÃ©diction de branchement            â”‚
â”‚   â€¢ Registres matÃ©riels                  â”‚
â”‚   â€¢ Cache d'instructions                 â”‚
â”‚   â€¢ Instructions SIMD (si applicable)    â”‚
â”‚                                          â”‚
â”‚   = Performance maximale                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3. Consommation MÃ©moire RÃ©duite

Le code JIT est compact et optimisÃ© :

```
Bytecode eBPF :     100 instructions
â†“
Code machine JIT :  ~300-500 bytes

VS

InterprÃ©teur :      ~10-20 KB (boucle + dispatch table)
```

### 4. Pas d'Overhead d'InterprÃ©tation

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Performance Relative                    â”‚
â”‚                                           â”‚
â”‚   Code C natif du kernel    : 100%        â”‚
â”‚   eBPF avec JIT             : ~95-100%    â”‚
â”‚   eBPF sans JIT (interprÃ©tÃ©): ~5-20%      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Le JIT permet d'atteindre des performances **presque identiques** au code C compilÃ© directement dans le noyau !

---

## ğŸ—ï¸ Architectures SupportÃ©es

### JIT Support par Architecture

Le JIT eBPF est supportÃ© sur de nombreuses architectures :

| Architecture | Support JIT | Depuis | QualitÃ© |
|--------------|-------------|--------|---------|
| **x86-64** | âœ… Oui | Linux 3.16+ | Excellent |
| **ARM64** | âœ… Oui | Linux 3.18+ | Excellent |
| **ARM32** | âœ… Oui | Linux 4.14+ | Bon |
| **PowerPC 64** | âœ… Oui | Linux 4.8+ | Bon |
| **s390x** | âœ… Oui | Linux 4.1+ | Bon |
| **MIPS 64** | âœ… Oui | Linux 4.13+ | Moyen |
| **RISC-V 64** | âœ… Oui | Linux 5.1+ | Bon |
| **SPARC 64** | âœ… Oui | Linux 4.12+ | Moyen |

### VÃ©rifier le Support JIT

```bash
# VÃ©rifier si le JIT est activÃ©
$ cat /proc/sys/net/core/bpf_jit_enable
1  # 0 = dÃ©sactivÃ©, 1 = activÃ©, 2 = activÃ© + debug

# Activer le JIT (si root)
$ sudo sysctl net.core.bpf_jit_enable=1

# Rendre permanent (ajouter dans /etc/sysctl.conf)
$ echo "net.core.bpf_jit_enable = 1" | sudo tee -a /etc/sysctl.conf
```

### VÃ©rifier la Version du JIT

```bash
# Voir les capacitÃ©s eBPF du systÃ¨me
$ bpftool feature

# Rechercher la ligne JIT
Scanning system configuration...  
bpf() syscall for unprivileged users is enabled  
JIT compiler is enabled  
...
```

---

## ğŸ”¬ Exemple de Transformation JIT

### Bytecode eBPF â†’ Code Machine

Prenons un programme simple qui compte les paquets :

#### Code C Source

```c
SEC("xdp")  
int count_packets(struct xdp_md *ctx)  
{
    __u32 key = 0;
    __u64 *count = bpf_map_lookup_elem(&packet_count, &key);

    if (count)
        __sync_fetch_and_add(count, 1);

    return XDP_PASS;
}
```

#### Bytecode eBPF (simplifiÃ©)

```
0:  (b7) r1 = 0                    ; key = 0
1:  (63) *(u32 *)(r10 -4) = r1     ; stack[0] = key
2:  (bf) r2 = r10                  ; r2 = frame pointer
3:  (07) r2 += -4                  ; r2 = &key
4:  (18) r1 = map[id:5]            ; r1 = &packet_count
6:  (85) call bpf_map_lookup_elem  ; r0 = lookup(r1, r2)
7:  (15) if r0 == 0 goto pc+3      ; if (r0 == NULL) goto exit
8:  (b7) r1 = 1                    ; r1 = 1
9:  (db) lock *(u64 *)(r0 +0) += r1; atomic add
10: (b7) r0 = 2                    ; r0 = XDP_PASS
11: (95) exit                       ; return
```

#### Code Machine x86-64 (aprÃ¨s JIT)

```asm
; Prologue
push   %rbp  
mov    %rsp, %rbp  
sub    $0x10, %rsp  

; key = 0
xor    %edi, %edi  
mov    %edi, -0x4(%rbp)  

; r2 = &key
lea    -0x4(%rbp), %rsi

; r1 = &packet_count (adresse de la map)
movabs $0xffff888012345000, %rdi

; call bpf_map_lookup_elem
callq  0xffffffffa0001234

; if (r0 == NULL) goto exit
test   %rax, %rax  
je     exit  

; atomic add
lock addq $0x1, 0x0(%rax)

; return XDP_PASS
exit:  
mov    $0x2, %eax  
leave  
retq  
```

**Observations** :
- Le bytecode eBPF (12 instructions) â†’ Code machine (~20 instructions x86-64)
- Instructions atomiques (`lock addq`) gÃ©nÃ©rÃ©es nativement
- Appels de helpers compilÃ©s en `callq` directs
- Performance Ã©quivalente au C

---

## ğŸ“Š Performance : JIT vs InterprÃ©tÃ©

### Benchmark RÃ©el : Tracer les Syscalls

```
Programme : Trace tous les appels open()  
Charge    : 100,000 appels open() par seconde  

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   MODE            OVERHEAD    LATENCE      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Sans eBPF       0%          10 Âµs        â”‚
â”‚   eBPF + JIT      2-3%        10.2 Âµs      â”‚
â”‚   eBPF sans JIT   15-30%      11.5 Âµs      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Conclusion : JIT rÃ©duit l'overhead de 10x !
```

### XDP : Traitement de Paquets

```
Programme : Filtrage simple de paquets rÃ©seau  
Charge    : 10 Mpps (millions de paquets/sec)  

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   MODE            DÃ‰BIT       CPU          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   XDP + JIT       24 Mpps     40%          â”‚
â”‚   XDP sans JIT    3 Mpps      90%          â”‚
â”‚   iptables        1 Mpps      100%         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Conclusion : JIT = 8x plus rapide que sans JIT
                   24x plus rapide qu'iptables
```

---

## ğŸ” Inspecter le Code JIT GÃ©nÃ©rÃ©

### Activer le Debug du JIT

```bash
# Activer le JIT avec debug
$ sudo sysctl net.core.bpf_jit_enable=2

# Les dumps JIT apparaÃ®tront dans dmesg
$ sudo dmesg | grep "flen="
```

### Exemple de Sortie dmesg

```
[ 1234.567890] flen=11 proglen=123 pass=3 image=ffffffffa0123000 from=program pid=5678
ffffffffa0123000: 55                      push   %rbp  
ffffffffa0123001: 48 89 e5                mov    %rsp,%rbp  
ffffffffa0123004: 48 83 ec 10             sub    $0x10,%rsp  
...
```

**InterprÃ©tation** :
- `flen=11` : 11 instructions eBPF
- `proglen=123` : 123 bytes de code machine gÃ©nÃ©rÃ©
- `image=0xffffffffa0123000` : Adresse mÃ©moire du code JIT

### Utiliser bpftool

```bash
# Charger un programme
$ sudo bpftool prog load program.bpf.o /sys/fs/bpf/test type xdp

# Lister les programmes
$ sudo bpftool prog list
1234: xdp  name count_packets  tag a1b2c3d4e5f6g7h8  jited

# Voir le bytecode eBPF
$ sudo bpftool prog dump xlated id 1234

# Voir le code JIT (assembleur)
$ sudo bpftool prog dump jited id 1234

# Avec dÃ©sassemblage visuel
$ sudo bpftool prog dump jited id 1234 visual
```

### Exemple de Sortie `dump jited`

```asm
int count_packets(struct xdp_md * ctx):  
bpf_prog_a1b2c3d4e5f6g7h8:  
   0:   push   %rbp
   1:   mov    %rsp,%rbp
   4:   sub    $0x10,%rsp
   8:   xor    %edi,%edi
   a:   mov    %edi,-0x4(%rbp)
   d:   lea    -0x4(%rbp),%rsi
  11:   movabs $0xffff888100000000,%rdi
  1b:   callq  0xffffffffa0001000
  20:   test   %rax,%rax
  23:   je     0x000000000000002e
  25:   lock   addq $0x1,(%rax)
  2e:   mov    $0x2,%eax
  33:   leaveq
  34:   retq
```

---

## ğŸ› ï¸ Optimisations du JIT Compiler

### 1. Ã‰limination de Code Mort

Le JIT peut supprimer du code inutile :

```c
// Code source
int result = 42;  // Variable jamais utilisÃ©e  
return 0;  

// Le JIT va simplement gÃ©nÃ©rer :
mov $0x0, %eax  
ret  
```

### 2. Propagation de Constantes

```c
// Code source
int a = 5;  
int b = 10;  
int c = a + b;  
return c;  

// Le JIT optimise en :
mov $15, %eax  // Calcul fait Ã  la compilation JIT  
ret  
```

### 3. Fusion d'Instructions

```c
// Bytecode eBPF
r1 = 0  
r2 = r1  
r3 = r2  

// Code JIT optimisÃ©
xor %edi, %edi  
xor %esi, %esi  
xor %edx, %edx  
```

### 4. Optimisation des Boucles

Pour les boucles dÃ©roulÃ©es (`#pragma unroll`), le JIT gÃ©nÃ¨re du code linÃ©aire :

```c
#pragma unroll
for (int i = 0; i < 4; i++) {
    sum += array[i];
}

// Devient (code JIT) :
add    (%rax), %rdx      // array[0]  
add    0x8(%rax), %rdx   // array[1]  
add    0x10(%rax), %rdx  // array[2]  
add    0x18(%rax), %rdx  // array[3]  
```

Pas de boucle = pas de branchement = plus rapide !

---

## âš™ï¸ Configuration du JIT

### Niveaux d'Activation

```bash
# 0 = JIT dÃ©sactivÃ© (interprÃ©tÃ©)
$ sudo sysctl net.core.bpf_jit_enable=0

# 1 = JIT activÃ© (recommandÃ©)
$ sudo sysctl net.core.bpf_jit_enable=1

# 2 = JIT activÃ© + debug (logs dans dmesg)
$ sudo sysctl net.core.bpf_jit_enable=2
```

### Hardening (Durcissement de SÃ©curitÃ©)

```bash
# Activer le JIT hardening (randomisation des constantes)
$ sudo sysctl net.core.bpf_jit_harden=1

# 0 = dÃ©sactivÃ©
# 1 = activÃ© pour utilisateurs non-root
# 2 = activÃ© pour tout le monde
```

**JIT Hardening** rend plus difficile les attaques qui exploiteraient des constantes prÃ©visibles :

```asm
Sans hardening :
  mov    $0xffff888012345000, %rdi  ; Adresse prÃ©visible

Avec hardening :
  mov    $0x1234, %edi
  movabs $0xffff888000000000, %rax
  add    %rax, %rdi                 ; Adresse obfusquÃ©e
```

**Trade-off** : LÃ©gÃ¨re rÃ©duction de performance (~5-10%) mais meilleure sÃ©curitÃ©.

---

## ğŸ› Debugging avec le JIT

### ProblÃ¨mes Potentiels

**1. Programme fonctionne en interprÃ©tÃ© mais pas en JIT**

```bash
# Tester sans JIT
$ sudo sysctl net.core.bpf_jit_enable=0
$ sudo ./load_program

# Tester avec JIT
$ sudo sysctl net.core.bpf_jit_enable=1
$ sudo ./load_program
```

Si Ã§a fonctionne sans JIT mais pas avec, c'est probablement un bug du JIT compiler (rare).

**2. Voir les logs du JIT**

```bash
# Activer le debug
$ sudo sysctl net.core.bpf_jit_enable=2

# Charger le programme
$ sudo ./load_program

# Voir les logs
$ sudo dmesg | tail -50
```

**3. Comparer bytecode et code JIT**

```bash
# Bytecode eBPF
$ sudo bpftool prog dump xlated id 1234

# Code machine JIT
$ sudo bpftool prog dump jited id 1234

# VÃ©rifier que la traduction est cohÃ©rente
```

---

## ğŸ“ˆ Impact du JIT sur DiffÃ©rents Workloads

### Tracing (Syscalls, Fonctions)

```
Impact du JIT :  MOYEN (5-10x plus rapide)  
Pourquoi ?       Le coÃ»t principal est la collecte  
                 de donnÃ©es, pas le code du programme
```

**Exemple** : Tracer `open()`
- Avec JIT : 0.5 Âµs par Ã©vÃ©nement
- Sans JIT : 2.5 Âµs par Ã©vÃ©nement
- **Gain** : 5x, mais le syscall lui-mÃªme prend ~10 Âµs

### Networking (XDP, TC)

```
Impact du JIT :  CRITIQUE (10-50x plus rapide)  
Pourquoi ?       Performance absolue requise,  
                 traitement par paquet trÃ¨s rapide
```

**Exemple** : Filtrage XDP
- Avec JIT : 50 ns par paquet â†’ 20 Mpps
- Sans JIT : 500 ns par paquet â†’ 2 Mpps
- **Gain** : 10x, critique pour DDoS protection

### Calculs Intensifs

```
Impact du JIT :  TRÃˆS Ã‰LEVÃ‰ (50-100x plus rapide)  
Pourquoi ?       Le programme fait beaucoup de calculs,  
                 l'overhead d'interprÃ©tation domine
```

**Exemple** : Hachage/Checksum
- Avec JIT : 100 ns
- Sans JIT : 5000 ns
- **Gain** : 50x

---

## ğŸ”¬ Ã‰volution du JIT eBPF

### Historique

| Version Linux | AmÃ©lioration JIT |
|---------------|------------------|
| **3.0** | Premier JIT (x86-64, basique) |
| **3.16** | JIT amÃ©liorÃ©, support ARM |
| **4.0** | JIT pour PowerPC, s390x |
| **4.8** | Optimisations diverses |
| **5.0** | Support RISC-V |
| **5.10** | AmÃ©liorations performance (+10-20%) |
| **5.18** | Optimisations boucles |
| **6.0+** | Support instructions vectorielles (expÃ©rimental) |

### Ã‰volution des Performances

```
Benchmark : Filtrage rÃ©seau simple (paquets/sec)

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Linux 3.16 (2014)  : 5 Mpps         â”‚
â”‚ Linux 4.10 (2017)  : 12 Mpps        â”‚
â”‚ Linux 5.0  (2019)  : 20 Mpps        â”‚
â”‚ Linux 5.10 (2021)  : 24 Mpps        â”‚
â”‚ Linux 6.0  (2022)  : 28 Mpps        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

AmÃ©lioration continue du JIT = +460% en 8 ans
```

---

## ğŸ’¡ Bonnes Pratiques

### 1. Toujours Activer le JIT

```bash
# VÃ©rifier
$ cat /proc/sys/net/core/bpf_jit_enable

# Si 0, activer
$ sudo sysctl net.core.bpf_jit_enable=1

# Rendre permanent
$ echo "net.core.bpf_jit_enable = 1" | sudo tee -a /etc/sysctl.conf
```

**Pourquoi ?** Performance 10-50x meilleure, aucun inconvÃ©nient.

### 2. Utiliser Hardening en Production

```bash
# Pour la sÃ©curitÃ©
$ sudo sysctl net.core.bpf_jit_harden=1
```

Le lÃ©ger overhead (~5-10%) est nÃ©gligeable comparÃ© au gain de sÃ©curitÃ©.

### 3. Compiler avec -O2

```bash
# Optimisations pour meilleure gÃ©nÃ©ration de code
$ clang -O2 -target bpf -c program.bpf.c -o program.bpf.o
```

Les optimisations du compilateur facilitent le travail du JIT.

### 4. Profiler les Programmes

```bash
# Voir le temps passÃ© dans chaque programme
$ sudo bpftool prog profile id 1234 duration 10

# Identifier les hot paths
```

### 5. Ã‰viter les Patterns Qui Bloquent les Optimisations

```c
// âŒ AccÃ¨s indirect complexe
int idx = calculate_complex_index();  
return array[idx];  

// âœ… AccÃ¨s direct quand possible
return array[known_index];
```

---

## ğŸ“ RÃ©sumÃ©

La **JIT compilation** est essentielle pour les performances d'eBPF :

**Ce qu'est le JIT** :
- Compilation Just-In-Time (au moment du chargement)
- Transformation bytecode eBPF â†’ code machine natif
- ExÃ©cution directe par le CPU

**Avantages** :
- âš¡ Performance 10-50x meilleure que l'interprÃ©tation
- ğŸ¯ Ã‰quivalent au code C natif du noyau
- ğŸ’¾ MÃ©moire optimisÃ©e
- ğŸ”§ Utilisation optimale du CPU

**Architectures supportÃ©es** :
- âœ… x86-64, ARM64, ARM32
- âœ… PowerPC, s390x, MIPS, RISC-V
- âœ… Support excellent sur les principales architectures

**Configuration** :
```bash
# Activer le JIT (recommandÃ©)
net.core.bpf_jit_enable = 1

# Hardening pour la sÃ©curitÃ©
net.core.bpf_jit_harden = 1
```

**Inspection** :
```bash
# Voir le code JIT gÃ©nÃ©rÃ©
$ sudo bpftool prog dump jited id <ID>

# Debug
$ sudo sysctl net.core.bpf_jit_enable=2
$ sudo dmesg | grep "flen="
```

**Impact** :
- Critique pour XDP/rÃ©seau (10-50x)
- Important pour calculs (50-100x)
- Moyen pour tracing (5-10x)

---

## ğŸ¯ Prochaine Ã‰tape

Maintenant que vous comprenez comment le vÃ©rificateur garantit la sÃ©curitÃ© et comment le JIT assure la performance, nous allons explorer les **cas d'usage concrets** d'eBPF dans le DevOps et l'observabilitÃ©.

**ğŸ‘‰ Prochaine section : 21.3 Use Cases DevOps et ObservabilitÃ©**

Nous verrons :
- Tracing et monitoring en production
- Networking haute performance (XDP, Cilium)
- SÃ©curitÃ© runtime (Falco)
- Cas d'usage concrets avec exemples

**Ã€ bientÃ´t !** ğŸš€

---

## ğŸ“š RÃ©fÃ©rences

### Documentation Officielle
- [BPF JIT Compiler](https://www.kernel.org/doc/html/latest/bpf/bpf_design_QA.html#q-jit-compiler)
- [BPF JIT x86-64](https://github.com/torvalds/linux/blob/master/arch/x86/net/bpf_jit_comp.c)

### Articles Techniques
- [BPF JIT Optimizations](https://lwn.net/Articles/804112/)
- [Understanding BPF JIT](https://www.brendangregg.com/blog/2015-05-15/ebpf-one-small-step.html)

### Benchmarks
- [XDP Performance](https://www.netdevconf.org/2.1/papers/XDP-performance.pdf)
- [eBPF Performance Guide](https://github.com/iovisor/bcc/blob/master/docs/kernel-versions.md)

### Code Source
- [x86-64 JIT](https://github.com/torvalds/linux/blob/master/arch/x86/net/bpf_jit_comp.c)
- [ARM64 JIT](https://github.com/torvalds/linux/blob/master/arch/arm64/net/bpf_jit_comp.c)
- [RISC-V JIT](https://github.com/torvalds/linux/blob/master/arch/riscv/net/bpf_jit_comp64.c)

â­ï¸ [Use cases DevOps et observabilitÃ©](/21-introduction-ebpf/03-use-cases-devops.md)
