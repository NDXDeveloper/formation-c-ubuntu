üîù Retour au [Sommaire](/SOMMAIRE.md)

# 5.7.2 Styles courants

## Introduction

clang-format propose plusieurs **styles pr√©d√©finis** qui correspondent aux conventions de formatage utilis√©es dans de grands projets open-source ou par des entreprises. Chacun de ces styles a ses particularit√©s et refl√®te les pr√©f√©rences d'√©quipes de d√©veloppement diff√©rentes.

Dans cette section, nous allons explorer en d√©tail les styles les plus courants, les comparer visuellement, et vous aider √† choisir celui qui convient le mieux √† votre projet.

---

## Les styles pr√©d√©finis disponibles

clang-format propose les styles suivants :

| Style | Origine | Popularit√© | Indentation | Accolades |
|-------|---------|-----------|-------------|-----------|
| **LLVM** | Projet LLVM/Clang | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | 2 espaces | Attach√©es |
| **Google** | Google Style Guide | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | 2 espaces | Attach√©es |
| **Chromium** | Projet Chromium | ‚≠ê‚≠ê‚≠ê | 2 espaces | Attach√©es |
| **Mozilla** | Projet Mozilla Firefox | ‚≠ê‚≠ê‚≠ê | 2 espaces | Attach√©es |
| **WebKit** | Moteur WebKit (Safari) | ‚≠ê‚≠ê‚≠ê | 4 espaces | Attach√©es |
| **Microsoft** | Style Visual Studio | ‚≠ê‚≠ê‚≠ê | 4 espaces | Allman |
| **GNU** | Projet GNU | ‚≠ê‚≠ê | 2 espaces | GNU |
| **Linux** | Noyau Linux (variante K&R) | ‚≠ê‚≠ê‚≠ê‚≠ê | Tabs (8) | K&R |

---

## Style LLVM

### Pr√©sentation

Le style LLVM est le style par d√©faut de clang-format. Il est utilis√© dans les projets LLVM, Clang et de nombreux autres projets C/C++ modernes.

**Caract√©ristiques principales :**
- Indentation : **2 espaces**
- Accolades : **Attach√©es** (sur la m√™me ligne)
- Largeur de ligne : **80 caract√®res**
- Style √©quilibr√© et compact

### Configuration de base

```yaml
---
BasedOnStyle: LLVM
...
```

### Exemple de code format√©

**Code source :**
```c
#include <stdio.h>
#include <stdlib.h>

int calculer_somme(int *tableau, int taille) {
  int somme = 0;
  for (int i = 0; i < taille; i++) {
    somme += tableau[i];
  }
  return somme;
}

int main() {
  int nombres[] = {1, 2, 3, 4, 5};
  int taille = sizeof(nombres) / sizeof(nombres[0]);
  int resultat = calculer_somme(nombres, taille);

  if (resultat > 10) {
    printf("La somme est grande : %d\n", resultat);
  } else {
    printf("La somme est petite : %d\n", resultat);
  }

  return 0;
}
```

### Points notables

- ‚úÖ Tr√®s lisible et compact
- ‚úÖ Indentation de 2 espaces √©conomise l'espace horizontal
- ‚úÖ Largement utilis√© dans la communaut√© C++
- ‚úÖ Bon √©quilibre entre compacit√© et clart√©
- ‚ö†Ô∏è L'indentation de 2 espaces peut sembler peu pour les d√©butants

### Quand l'utiliser

- Projets C/C++ modernes
- Quand vous voulez un style standard et reconnu
- Projets avec beaucoup de niveaux d'imbrication (gain de place)
- Si vous contribuez √† des projets LLVM

---

## Style Google

### Pr√©sentation

Le style Google suit le [Google C++ Style Guide](https://google.github.io/styleguide/cppguide.html), l'un des guides de style les plus populaires et d√©taill√©s.

**Caract√©ristiques principales :**
- Indentation : **2 espaces**
- Accolades : **Attach√©es**
- Largeur de ligne : **80 caract√®res**
- Espaces sp√©cifiques autour des pointeurs

### Configuration de base

```yaml
---
BasedOnStyle: Google
...
```

### Exemple de code format√©

**Code source :**
```c
#include <stdio.h>
#include <stdlib.h>

int calculer_somme(int* tableau, int taille) {
  int somme = 0;
  for (int i = 0; i < taille; i++) {
    somme += tableau[i];
  }
  return somme;
}

int main() {
  int nombres[] = {1, 2, 3, 4, 5};
  int taille = sizeof(nombres) / sizeof(nombres[0]);
  int resultat = calculer_somme(nombres, taille);

  if (resultat > 10) {
    printf("La somme est grande : %d\n", resultat);
  } else {
    printf("La somme est petite : %d\n", resultat);
  }

  return 0;
}
```

### Diff√©rences avec LLVM

```c
// LLVM
int *pointeur;  
int fonction(int *param) {  

// Google
int* pointeur;  
int fonction(int* param) {  
```

**Note :** Google place l'ast√©risque du pointeur **pr√®s du type** plut√¥t que pr√®s du nom.

### Points notables

- ‚úÖ Style tr√®s document√© et d√©taill√©
- ‚úÖ Utilis√© par Google et de nombreuses entreprises
- ‚úÖ Coh√©rent et pr√©visible
- ‚úÖ Bonne documentation des raisons derri√®re chaque choix
- ‚ö†Ô∏è Position du pointeur peut d√©router les habitu√©s du style C classique

### Quand l'utiliser

- Projets d'entreprise n√©cessitant un guide de style strict
- Contributions aux projets Google
- √âquipes appr√©ciant un guide tr√®s d√©taill√©
- Projets C++ (moins courant en C pur)

---

## Style GNU

### Pr√©sentation

Le style GNU est utilis√© dans les projets GNU (GCC, coreutils, bash, etc.). C'est un style tr√®s vertical et distinctif.

**Caract√©ristiques principales :**
- Indentation : **2 espaces**
- Accolades : **Toujours sur une nouvelle ligne et indent√©es**
- Largeur de ligne : **79 caract√®res**
- Style tr√®s vertical

### Configuration de base

```yaml
---
BasedOnStyle: GNU
...
```

### Exemple de code format√©

**Code source :**
```c
#include <stdio.h>
#include <stdlib.h>

int  
calculer_somme (int *tableau, int taille)  
{
  int somme = 0;
  for (int i = 0; i < taille; i++)
    {
      somme += tableau[i];
    }
  return somme;
}

int  
main ()  
{
  int nombres[] = {1, 2, 3, 4, 5};
  int taille = sizeof (nombres) / sizeof (nombres[0]);
  int resultat = calculer_somme (nombres, taille);

  if (resultat > 10)
    {
      printf ("La somme est grande : %d\n", resultat);
    }
  else
    {
      printf ("La somme est petite : %d\n", resultat);
    }

  return 0;
}
```

### Points notables

- ‚úÖ Tr√®s clair pour la structure des blocs
- ‚úÖ Accolades toujours visibles
- ‚úÖ Style historique et reconnaissable
- ‚ö†Ô∏è Tr√®s vertical (utilise beaucoup de lignes)
- ‚ö†Ô∏è Type de retour sur sa propre ligne
- ‚ö†Ô∏è Espaces avant les parenth√®ses : `fonction (param)` au lieu de `fonction(param)`

### Particularit√©s du style GNU

```c
// Type de retour sur ligne s√©par√©e
int  
ma_fonction (int param)  
{
  // Code
}

// Espaces avant les parenth√®ses
printf ("Hello");  
if (condition)  
  {
    // Code
  }
```

### Quand l'utiliser

- Contributions aux projets GNU (GCC, bash, etc.)
- Quand vous pr√©f√©rez un style tr√®s explicite
- Projets C traditionnels
- ‚ö†Ô∏è Peu recommand√© pour les d√©butants ou les nouveaux projets

---

## Style Linux (Kernel)

### Pr√©sentation

Le style du noyau Linux est une variante du style K&R (Kernighan & Ritchie). C'est le style officiel du d√©veloppement du noyau Linux.

**Caract√©ristiques principales :**
- Indentation : **Tabulations de 8 caract√®res**
- Accolades : **K&R** (nouvelle ligne pour fonctions, m√™me ligne pour le reste)
- Largeur de ligne : **80 caract√®res** (strict)
- Style classique et robuste

### Configuration de base

```yaml
---
BasedOnStyle: LLVM  
UseTab: Always  
TabWidth: 8  
IndentWidth: 8  
BreakBeforeBraces: Linux  
ColumnLimit: 80  
...
```

### Exemple de code format√©

**Code source :**
```c
#include <stdio.h>
#include <stdlib.h>

int calculer_somme(int *tableau, int taille)
{
	int somme = 0;
	for (int i = 0; i < taille; i++) {
		somme += tableau[i];
	}
	return somme;
}

int main(void)
{
	int nombres[] = {1, 2, 3, 4, 5};
	int taille = sizeof(nombres) / sizeof(nombres[0]);
	int resultat = calculer_somme(nombres, taille);

	if (resultat > 10) {
		printf("La somme est grande : %d\n", resultat);
	} else {
		printf("La somme est petite : %d\n", resultat);
	}

	return 0;
}
```

**Note :** Les indentations sont des tabulations (repr√©sent√©es ici par des espaces pour la lisibilit√©).

### Points notables

- ‚úÖ Style classique et √©prouv√©
- ‚úÖ Tabulations de 8 caract√®res d√©couragent l'imbrication profonde
- ‚úÖ Tr√®s utilis√© en programmation syst√®me
- ‚úÖ Bon pour le C pur
- ‚ö†Ô∏è Tabulations larges peuvent sembler √©normes sur certains √©diteurs
- ‚ö†Ô∏è Limite stricte de 80 caract√®res peut √™tre contraignante

### Particularit√©s du style Linux

```c
// Fonctions : accolade sur nouvelle ligne
int fonction(void)
{
	// Code avec tabulation de 8
}

// Structures de contr√¥le : accolade sur m√™me ligne
if (condition) {
	// Code
} else {
	// Code
}

// main() avec (void) explicite
int main(void)
{
	return 0;
}
```

### Quand l'utiliser

- D√©veloppement de drivers Linux
- Programmation syst√®me bas niveau
- Contributions au noyau Linux
- Projets C embarqu√©
- Si vous aimez le style K&R classique

---

## Style WebKit

### Pr√©sentation

Le style WebKit est utilis√© dans le moteur de rendu WebKit (Safari, anciennement Chrome).

**Caract√©ristiques principales :**
- Indentation : **4 espaces**
- Accolades : **Attach√©es**
- Largeur de ligne : **Flexible**
- Plus d'espace que LLVM/Google

### Configuration de base

```yaml
---
BasedOnStyle: WebKit
...
```

### Exemple de code format√©

**Code source :**
```c
#include <stdio.h>
#include <stdlib.h>

int calculer_somme(int* tableau, int taille)
{
    int somme = 0;
    for (int i = 0; i < taille; i++) {
        somme += tableau[i];
    }
    return somme;
}

int main()
{
    int nombres[] = { 1, 2, 3, 4, 5 };
    int taille = sizeof(nombres) / sizeof(nombres[0]);
    int resultat = calculer_somme(nombres, taille);

    if (resultat > 10) {
        printf("La somme est grande : %d\n", resultat);
    } else {
        printf("La somme est petite : %d\n", resultat);
    }

    return 0;
}
```

### Points notables

- ‚úÖ Indentation de 4 espaces (confortable pour beaucoup)
- ‚úÖ Bon compromis entre compacit√© et lisibilit√©
- ‚úÖ Accolades de fonction sur nouvelle ligne
- ‚úÖ Espaces dans les initialisateurs de tableau : `{ 1, 2, 3 }`

### Quand l'utiliser

- Projets de navigateurs ou moteurs de rendu
- Si vous pr√©f√©rez 4 espaces mais avec accolades de fonction s√©par√©es
- Bon compromis entre styles modernes et classiques

---

## Style Microsoft (Visual Studio)

### Pr√©sentation

Le style Microsoft correspond aux conventions de Visual Studio et des projets Microsoft.

**Caract√©ristiques principales :**
- Indentation : **4 espaces**
- Accolades : **Allman** (toujours sur nouvelle ligne)
- Style proche du C# et .NET

### Configuration de base

```yaml
---
BasedOnStyle: Microsoft
...
```

### Exemple de code format√©

**Code source :**
```c
#include <stdio.h>
#include <stdlib.h>

int calculer_somme(int* tableau, int taille)
{
    int somme = 0;
    for (int i = 0; i < taille; i++)
    {
        somme += tableau[i];
    }
    return somme;
}

int main()
{
    int nombres[] = { 1, 2, 3, 4, 5 };
    int taille = sizeof(nombres) / sizeof(nombres[0]);
    int resultat = calculer_somme(nombres, taille);

    if (resultat > 10)
    {
        printf("La somme est grande : %d\n", resultat);
    }
    else
    {
        printf("La somme est petite : %d\n", resultat);
    }

    return 0;
}
```

### Points notables

- ‚úÖ Tr√®s clair et vertical
- ‚úÖ Accolades toujours visibles
- ‚úÖ Familier pour les d√©veloppeurs C# et .NET
- ‚úÖ 4 espaces d'indentation (confortable)
- ‚ö†Ô∏è Utilise beaucoup de lignes verticales

### Quand l'utiliser

- Projets Windows ou Visual Studio
- D√©veloppement multi-langage avec C#
- Si vous pr√©f√©rez le style Allman
- √âquipes habitu√©es √† .NET

---

## Comparaison visuelle c√¥te √† c√¥te

Voici le m√™me code format√© avec diff√©rents styles :

### Code source original

```c
#include <stdio.h>
struct Point{int x;int y;};  
int calculer(struct Point *p){if(p->x>0&&p->y>0){return p->x+p->y;}else{return 0;}}  
int main(){struct Point p={10,20};printf("R√©sultat: %d\n",calculer(&p));return 0;}  
```

### Style LLVM

```c
#include <stdio.h>

struct Point {
  int x;
  int y;
};

int calculer(struct Point *p) {
  if (p->x > 0 && p->y > 0) {
    return p->x + p->y;
  } else {
    return 0;
  }
}

int main() {
  struct Point p = {10, 20};
  printf("R√©sultat: %d\n", calculer(&p));
  return 0;
}
```

### Style GNU

```c
#include <stdio.h>

struct Point
{
  int x;
  int y;
};

int  
calculer (struct Point *p)  
{
  if (p->x > 0 && p->y > 0)
    {
      return p->x + p->y;
    }
  else
    {
      return 0;
    }
}

int  
main ()  
{
  struct Point p = {10, 20};
  printf ("R√©sultat: %d\n", calculer (&p));
  return 0;
}
```

### Style Linux

```c
#include <stdio.h>

struct Point {
	int x;
	int y;
};

int calculer(struct Point *p)
{
	if (p->x > 0 && p->y > 0) {
		return p->x + p->y;
	} else {
		return 0;
	}
}

int main(void)
{
	struct Point p = {10, 20};
	printf("R√©sultat: %d\n", calculer(&p));
	return 0;
}
```

### Style Microsoft

```c
#include <stdio.h>

struct Point
{
    int x;
    int y;
};

int calculer(struct Point* p)
{
    if (p->x > 0 && p->y > 0)
    {
        return p->x + p->y;
    }
    else
    {
        return 0;
    }
}

int main()
{
    struct Point p = { 10, 20 };
    printf("R√©sultat: %d\n", calculer(&p));
    return 0;
}
```

---

## Tableau comparatif d√©taill√©

| Aspect | LLVM | Google | GNU | Linux | WebKit | Microsoft |
|--------|------|--------|-----|-------|--------|-----------|
| **Indentation** | 2 esp. | 2 esp. | 2 esp. | 8 tabs | 4 esp. | 4 esp. |
| **Accolades fonctions** | M√™me ligne | M√™me ligne | Nouvelle ligne | Nouvelle ligne | Nouvelle ligne | Nouvelle ligne |
| **Accolades if/while** | M√™me ligne | M√™me ligne | Nouvelle ligne | M√™me ligne | M√™me ligne | Nouvelle ligne |
| **Largeur ligne** | 80 | 80 | 79 | 80 | 0 (illimit√©) | 120 |
| **Pointeurs** | `int *p` | `int* p` | `int *p` | `int *p` | `int* p` | `int* p` |
| **Espaces avant ()** | Non | Non | Oui | Non | Non | Non |
| **Espaces dans {}** | Non | Non | Non | Non | Oui | Oui |
| **Verticalit√©** | Compact | Compact | Tr√®s vertical | Moyen | Moyen | Vertical |
| **Popularit√© en C** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê |

---

## Comment choisir son style ?

### Questions √† se poser

**1. Quel est le contexte de votre projet ?**
- Projet existant ‚Üí Utilisez le style d√©j√† en place
- Nouveau projet ‚Üí Choisissez selon vos pr√©f√©rences
- Contribution open-source ‚Üí Suivez le style du projet

**2. Quel langage principalement ?**
- C pur ‚Üí Linux, LLVM recommand√©s
- C++ moderne ‚Üí LLVM, Google recommand√©s
- Multi-langage ‚Üí Google (bien document√©)

**3. Quelle est votre exp√©rience ?**
- D√©butant ‚Üí LLVM ou WebKit (bon √©quilibre)
- Exp√©riment√© ‚Üí Selon pr√©f√©rences personnelles
- √âquipe ‚Üí Choisir collectivement

**4. Quel environnement de d√©veloppement ?**
- Linux/Syst√®me ‚Üí Style Linux
- Windows/Visual Studio ‚Üí Style Microsoft
- Multi-plateforme ‚Üí LLVM ou Google

### Recommandations par cas d'usage

**üéØ Pour d√©buter en C :**
- **Style recommand√© :** WebKit ou LLVM
- **Raison :** Indentation confortable, largement utilis√©, bon √©quilibre

**üéØ Pour un projet professionnel :**
- **Style recommand√© :** Google
- **Raison :** Tr√®s bien document√©, guide de style complet, largement adopt√©

**üéØ Pour le syst√®me/embarqu√© :**
- **Style recommand√© :** Linux
- **Raison :** Standard de fait pour la programmation syst√®me

**üéØ Pour un projet Windows :**
- **Style recommand√© :** Microsoft
- **Raison :** Int√©gration naturelle avec Visual Studio

**üéØ Pour un projet acad√©mique :**
- **Style recommand√© :** LLVM ou WebKit
- **Raison :** Standards, √©quilibr√©s, faciles √† enseigner

---

## Cr√©er un style personnalis√©

### Partir d'un style existant

Vous pouvez cr√©er votre propre style en partant d'un style pr√©d√©fini :

```yaml
---
# Mon style personnalis√© bas√© sur LLVM
BasedOnStyle: LLVM

# Modifications personnelles
IndentWidth: 4              # Passer de 2 √† 4 espaces  
ColumnLimit: 100            # Passer de 80 √† 100 caract√®res  
PointerAlignment: Right     # int *p au lieu de int* p  
BreakBeforeBraces: Linux    # Accolades K&R au lieu d'attach√©es partout  

# Garder le reste du style LLVM
...
```

### M√©langer les caract√©ristiques

```yaml
---
# Style hybride : confort de WebKit + rigueur de Google
BasedOnStyle: WebKit        # 4 espaces, base confortable

# Adopter certaines r√®gles de Google
PointerAlignment: Left      # int* p (style Google)  
ColumnLimit: 80             # Limite stricte (style Google)  

# Garder certaines r√®gles de WebKit
BreakBeforeBraces: WebKit   # Accolades de fonctions s√©par√©es  
SpacesInContainerLiterals: true  # { 1, 2, 3 }  

...
```

### Exemple complet de style personnalis√©

```yaml
---
# Mon style C moderne (2025)
Language: Cpp  
BasedOnStyle: LLVM  

# === INDENTATION ===
IndentWidth: 4  
TabWidth: 4  
UseTab: Never  
IndentCaseLabels: false  

# === ACCOLADES ===
BreakBeforeBraces: Linux
# Fonctions : nouvelle ligne
# if/while/for : m√™me ligne

# === LARGEUR ===
ColumnLimit: 100

# === POINTEURS ===
PointerAlignment: Right
# int *ptr;

# === ESPACES ===
SpaceAfterCStyleCast: false  
SpaceBeforeParens: ControlStatements  
SpaceBeforeAssignmentOperators: true  
SpacesInContainerLiterals: false  

# === ALIGNEMENT ===
AlignConsecutiveAssignments: false  
AlignConsecutiveDeclarations: false  
AlignTrailingComments: true  

# === FONCTIONS COURTES ===
AllowShortFunctionsOnASingleLine: None  
AllowShortIfStatementsOnASingleLine: Never  
AllowShortLoopsOnASingleLine: false  

# === INCLUDES ===
SortIncludes: true  
IncludeBlocks: Regroup  

# === COMMENTAIRES ===
ReflowComments: true  
SpacesBeforeTrailingComments: 2  

# === DIVERS ===
MaxEmptyLinesToKeep: 1  
KeepEmptyLinesAtTheStartOfBlocks: false  
...
```

---

## Tester diff√©rents styles

### Script de comparaison

Cr√©ez un script `compare_styles.sh` pour comparer les styles :

```bash
#!/bin/bash
# Script pour comparer diff√©rents styles sur un fichier

if [ $# -eq 0 ]; then
    echo "Usage: $0 <fichier.c>"
    exit 1
fi

FILE=$1  
STYLES=("llvm" "google" "gnu" "webkit" "microsoft")  

echo "Comparaison des styles pour $FILE"  
echo "=================================="  

for style in "${STYLES[@]}"; do
    echo ""
    echo "=== Style $style ==="
    clang-format -style=$style "$FILE"
    echo ""
done
```

**Utilisation :**
```bash
chmod +x compare_styles.sh
./compare_styles.sh mon_fichier.c
```

### Visualiser les diff√©rences

```bash
# Comparer deux styles
diff <(clang-format -style=llvm mon_fichier.c) \
     <(clang-format -style=google mon_fichier.c)
```

---

## Exemples de configurations de projets r√©els

### Configuration type "Projet moderne C"

```yaml
---
BasedOnStyle: LLVM  
IndentWidth: 4  
ColumnLimit: 100  
BreakBeforeBraces: Linux  
PointerAlignment: Right  
...
```

### Configuration type "Projet syst√®me"

```yaml
---
BasedOnStyle: LLVM  
UseTab: Always  
TabWidth: 8  
IndentWidth: 8  
ColumnLimit: 80  
BreakBeforeBraces: Linux  
...
```

### Configuration type "Projet d'entreprise"

```yaml
---
BasedOnStyle: Google  
ColumnLimit: 120  
PointerAlignment: Left  
AllowShortFunctionsOnASingleLine: Inline  
...
```

### Configuration type "Projet √©ducatif"

```yaml
---
BasedOnStyle: WebKit  
IndentWidth: 4  
ColumnLimit: 100  
AllowShortFunctionsOnASingleLine: None  
AllowShortIfStatementsOnASingleLine: Never  
...
```

---

## Bonnes pratiques

### 1. Choisir t√¥t dans le projet

D√©finissez votre style **d√®s le d√©but** du projet pour √©viter les reformatages massifs plus tard.

### 2. Documenter le choix

Ajoutez dans votre README.md :

```markdown
## Style de code

Ce projet utilise le style **LLVM** avec les modifications suivantes :
- Indentation : 4 espaces (au lieu de 2)
- Largeur de ligne : 100 caract√®res (au lieu de 80)

Voir `.clang-format` pour la configuration compl√®te.
```

### 3. √ätre coh√©rent

**Une fois un style choisi, tenez-vous-y !** La coh√©rence est plus importante que le style sp√©cifique.

### 4. Ne pas d√©battre √† l'infini

Les d√©bats sur le style peuvent √™tre sans fin. Utilisez clang-format pour :
- Arr√™ter les discussions de style
- Automatiser le formatage
- Concentrer les revues de code sur la logique

### 5. Respecter le style du projet existant

Si vous contribuez √† un projet existant, **utilisez leur style**, m√™me si ce n'est pas votre pr√©f√©r√©.

---

## R√©sum√©

### Styles les plus courants

| Style | Meilleur pour | Indentation | Accolades |
|-------|---------------|-------------|-----------|
| **LLVM** | Projets C/C++ modernes | 2 espaces | Attach√©es |
| **Google** | Projets d'entreprise | 2 espaces | Attach√©es |
| **Linux** | Programmation syst√®me | 8 tabs | K&R |
| **WebKit** | Compromis confortable | 4 espaces | Mixte |
| **Microsoft** | Projets Windows | 4 espaces | Allman |
| **GNU** | Projets GNU/historiques | 2 espaces | GNU |

### Comment choisir

1. **Projet existant ?** ‚Üí Utilisez le style en place
2. **Nouveau projet C pur ?** ‚Üí Linux ou LLVM
3. **Projet C++ moderne ?** ‚Üí LLVM ou Google
4. **D√©butant ?** ‚Üí WebKit ou LLVM
5. **Entreprise ?** ‚Üí Google (bien document√©)
6. **Syst√®me/embarqu√© ?** ‚Üí Linux

### Points cl√©s

- ‚úÖ Tous les styles sont valables
- ‚úÖ La coh√©rence prime sur le choix sp√©cifique
- ‚úÖ clang-format √©limine les d√©bats de style
- ‚úÖ Vous pouvez cr√©er votre propre style
- ‚úÖ Respectez le style des projets auxquels vous contribuez

---

## Pour aller plus loin

Dans les prochaines sections, vous d√©couvrirez :
- **5.7.3 Int√©gration IDE** : Configurer clang-format dans VS Code, Vim, etc.
- **5.7.4 Pre-commit hooks Git** : Automatiser le formatage avant les commits
- **5.7.5 Formatage dans le CI/CD** : V√©rification automatique dans GitHub Actions

Le choix du style n'est pas permanent. Vous pouvez toujours changer plus tard, mais il est pr√©f√©rable de d√©cider t√¥t et de s'y tenir pour maintenir la coh√©rence de votre code !

‚è≠Ô∏è [Int√©gration IDE](/05-operateurs-et-controle/07.3-integration-ide.md)
