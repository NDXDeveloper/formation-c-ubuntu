üîù Retour au [Sommaire](/SOMMAIRE.md)

# 15.6.3 Configuration et Int√©gration Continue

## Introduction

Maintenant que nous connaissons **cppcheck** et **clang-tidy**, il est temps d'int√©grer ces outils dans notre workflow de d√©veloppement de mani√®re automatis√©e. L'objectif est de d√©tecter les probl√®mes de qualit√© **avant m√™me qu'ils n'atteignent le d√©p√¥t principal**, id√©alement √† chaque modification du code.

### Qu'est-ce que l'int√©gration continue (CI) ?

L'**int√©gration continue** (Continuous Integration - CI) est une pratique DevOps qui consiste √† :
- Fusionner fr√©quemment les modifications de code dans une branche principale
- Ex√©cuter automatiquement des tests et v√©rifications √† chaque modification
- D√©tecter rapidement les probl√®mes avant qu'ils ne s'accumulent

Pour les projets C, cela inclut :
- ‚úÖ Compilation du code
- ‚úÖ Ex√©cution des tests unitaires
- ‚úÖ **Analyse statique avec cppcheck et clang-tidy**
- ‚úÖ V√©rification avec sanitizers
- ‚úÖ Tests de fuites m√©moire avec Valgrind
- ‚úÖ Mesure de couverture de code

### Pourquoi automatiser l'analyse statique ?

**Avantages :**
- ü§ñ **Automatisation** : Plus besoin de penser √† lancer les outils manuellement
- üîí **Qualit√© garantie** : Aucun code d√©fectueux ne passe sans √™tre d√©tect√©
- üë• **Coh√©rence** : Tous les d√©veloppeurs appliquent les m√™mes standards
- üìä **Tra√ßabilit√©** : Historique des probl√®mes d√©tect√©s et corrig√©s
- ‚è∞ **Gain de temps** : Les probl√®mes sont d√©tect√©s imm√©diatement, pas en phase de review

---

## Organisation des fichiers de configuration

Pour un projet C bien structur√©, voici l'organisation recommand√©e :

```
my_project/
‚îú‚îÄ‚îÄ .github/
‚îÇ   ‚îî‚îÄ‚îÄ workflows/
‚îÇ       ‚îî‚îÄ‚îÄ ci.yml              # GitHub Actions
‚îú‚îÄ‚îÄ .gitlab-ci.yml              # GitLab CI (alternatif)
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.c
‚îÇ   ‚îî‚îÄ‚îÄ utils.c
‚îú‚îÄ‚îÄ include/
‚îÇ   ‚îî‚îÄ‚îÄ utils.h
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îî‚îÄ‚îÄ test_utils.c
‚îú‚îÄ‚îÄ .clang-tidy                 # Configuration clang-tidy
‚îú‚îÄ‚îÄ .clang-format               # Configuration formatage
‚îú‚îÄ‚îÄ .cppcheck                   # Configuration cppcheck (optionnel)
‚îú‚îÄ‚îÄ CMakeLists.txt              # Build system
‚îî‚îÄ‚îÄ README.md
```

---

## Configuration locale des outils

### 1. Fichier .clang-tidy

Cr√©ez un fichier `.clang-tidy` √† la racine du projet :

```yaml
---
# Configuration clang-tidy pour projet C
Checks: >
  -*,
  bugprone-*,
  cert-*,
  clang-analyzer-*,
  modernize-*,
  performance-*,
  readability-*,
  -readability-magic-numbers,
  -readability-isolate-declaration,
  -modernize-use-trailing-return-type

# Traiter certains checks comme des erreurs
WarningsAsErrors: >
  bugprone-*,
  cert-err33-c,
  cert-err34-c,
  clang-analyzer-security.*

# Filtrer les headers √† v√©rifier (√©viter les biblioth√®ques externes)
HeaderFilterRegex: '(src|include)/.*'

# Utiliser le style de formatage d√©fini dans .clang-format
FormatStyle: file

# Options de configuration sp√©cifiques
CheckOptions:
  # Conventions de nommage
  - key: readability-identifier-naming.FunctionCase
    value: lower_case
  - key: readability-identifier-naming.VariableCase
    value: lower_case
  - key: readability-identifier-naming.MacroCase
    value: UPPER_CASE
  - key: readability-identifier-naming.ConstantCase
    value: UPPER_CASE
  - key: readability-identifier-naming.TypedefCase
    value: lower_case
  - key: readability-identifier-naming.StructCase
    value: lower_case

  # Limites de complexit√©
  - key: readability-function-size.LineThreshold
    value: '100'
  - key: readability-function-cognitive-complexity.Threshold
    value: '15'

  # Fonctions √† v√©rifier pour cert-err33-c
  - key: cert-err33-c.CheckedFunctions
    value: 'malloc;calloc;realloc;fopen;fclose;fread;fwrite;fprintf;fscanf'
```

### 2. Fichier .cppcheck (optionnel)

Pour cppcheck, vous pouvez cr√©er un fichier `.cppcheck` :

```
# Configuration cppcheck
--enable=all
--std=c11
--language=c
--platform=unix64
--suppress=missingIncludeSystem
--suppress=unmatchedSuppression
--inline-suppr
-I./include
-i./tests/vendor
-i./build
```

Ou utiliser un fichier de suppressions `.cppcheck-suppressions` :

```
# Suppressions cppcheck
# Format: [type]:[fichier]:[ligne]

# Ignorer les warnings dans les biblioth√®ques externes
*:third_party/*
*:vendor/*

# Ignorer les faux positifs connus
uninitvar:src/legacy_code.c:42
```

### 3. Script de v√©rification local

Cr√©ez un script `check_code.sh` pour v√©rifier le code localement avant de commiter :

```bash
#!/bin/bash

set -e  # Arr√™ter en cas d'erreur

echo "üîç Running code quality checks..."

# Couleurs pour l'output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Compteur d'erreurs
ERRORS=0

# 1. V√©rifier le formatage avec clang-format
echo ""
echo "üìù Checking code formatting..."
if command -v clang-format &> /dev/null; then
    UNFORMATTED=$(find src -name "*.c" -o -name "*.h" | xargs clang-format -n -Werror 2>&1 || true)
    if [ -n "$UNFORMATTED" ]; then
        echo -e "${RED}‚ùå Code formatting issues found!${NC}"
        echo "$UNFORMATTED"
        ERRORS=$((ERRORS + 1))
    else
        echo -e "${GREEN}‚úÖ Code formatting OK${NC}"
    fi
else
    echo -e "${YELLOW}‚ö†Ô∏è  clang-format not found, skipping${NC}"
fi

# 2. Analyse avec cppcheck
echo ""
echo "üîé Running cppcheck..."
if command -v cppcheck &> /dev/null; then
    if cppcheck --enable=warning,style --std=c11 --error-exitcode=1 --quiet src/ 2>&1; then
        echo -e "${GREEN}‚úÖ cppcheck passed${NC}"
    else
        echo -e "${RED}‚ùå cppcheck found issues${NC}"
        ERRORS=$((ERRORS + 1))
    fi
else
    echo -e "${YELLOW}‚ö†Ô∏è  cppcheck not found, skipping${NC}"
fi

# 3. Analyse avec clang-tidy
echo ""
echo "üîç Running clang-tidy..."
if command -v clang-tidy &> /dev/null; then
    # Trouver tous les fichiers .c
    C_FILES=$(find src -name "*.c")

    if [ -n "$C_FILES" ]; then
        for file in $C_FILES; do
            echo "  Checking $file..."
            if ! clang-tidy "$file" -- -std=c11 -I./include 2>&1 | grep -q "warning:\|error:"; then
                echo -e "${GREEN}    ‚úÖ OK${NC}"
            else
                echo -e "${RED}    ‚ùå Issues found${NC}"
                ERRORS=$((ERRORS + 1))
            fi
        done
    fi
else
    echo -e "${YELLOW}‚ö†Ô∏è  clang-tidy not found, skipping${NC}"
fi

# 4. Compilation avec tous les warnings
echo ""
echo "üî® Compiling with strict warnings..."
if command -v gcc &> /dev/null; then
    if gcc -Wall -Wextra -Werror -std=c11 -I./include -c src/*.c -o /dev/null 2>&1; then
        echo -e "${GREEN}‚úÖ Compilation successful${NC}"
    else
        echo -e "${RED}‚ùå Compilation failed${NC}"
        ERRORS=$((ERRORS + 1))
    fi
else
    echo -e "${YELLOW}‚ö†Ô∏è  gcc not found, skipping${NC}"
fi

# R√©sultat final
echo ""
echo "========================================"
if [ $ERRORS -eq 0 ]; then
    echo -e "${GREEN}‚úÖ All checks passed!${NC}"
    exit 0
else
    echo -e "${RED}‚ùå $ERRORS check(s) failed${NC}"
    exit 1
fi
```

Rendez-le ex√©cutable :

```bash
chmod +x check_code.sh
```

Utilisez-le avant chaque commit :

```bash
./check_code.sh
```

---

## Int√©gration avec Git : Pre-commit Hooks

Les **Git hooks** permettent d'ex√©cuter automatiquement des scripts √† certains moments cl√©s (avant commit, avant push, etc.).

### Configuration d'un pre-commit hook

Cr√©ez le fichier `.git/hooks/pre-commit` :

```bash
#!/bin/bash

echo "üîç Running pre-commit checks..."

# Obtenir les fichiers C/H modifi√©s
FILES=$(git diff --cached --name-only --diff-filter=ACMR | grep -E '\.(c|h)$')

if [ -z "$FILES" ]; then
    echo "‚úÖ No C files modified, skipping checks"
    exit 0
fi

# V√©rifier le formatage avec clang-format
echo "üìù Checking formatting..."
for file in $FILES; do
    if ! clang-format -n -Werror "$file" 2>/dev/null; then
        echo "‚ùå Formatting issues in $file"
        echo "üí° Run: clang-format -i $file"
        exit 1
    fi
done

# Analyse rapide avec cppcheck
echo "üîé Running cppcheck..."
if ! cppcheck --enable=warning --quiet --error-exitcode=1 $FILES 2>&1; then
    echo "‚ùå cppcheck found issues"
    exit 1
fi

echo "‚úÖ Pre-commit checks passed!"
exit 0
```

Rendez-le ex√©cutable :

```bash
chmod +x .git/hooks/pre-commit
```

Maintenant, √† chaque `git commit`, ces v√©rifications s'ex√©cuteront automatiquement !

### Utiliser pre-commit framework (recommand√©)

Pour une approche plus robuste, utilisez le framework **pre-commit** :

**Installation :**

```bash
pip install pre-commit
```

**Cr√©ez `.pre-commit-config.yaml` :**

```yaml
# Configuration pre-commit
repos:
  # Checks g√©n√©raux
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: trailing-whitespace
      - id: end-of-file-fixer
      - id: check-yaml
      - id: check-added-large-files
        args: ['--maxkb=1000']

  # Formatage avec clang-format
  - repo: https://github.com/pre-commit/mirrors-clang-format
    rev: v18.1.0
    hooks:
      - id: clang-format
        types_or: [c, c++]
        args: ['-i']

  # Analyse statique locale
  - repo: local
    hooks:
      # cppcheck
      - id: cppcheck
        name: cppcheck
        entry: cppcheck
        language: system
        files: \.(c|h)$
        args:
          - --enable=warning,style
          - --error-exitcode=1
          - --quiet
          - --std=c11

      # clang-tidy (optionnel, peut √™tre lent)
      - id: clang-tidy
        name: clang-tidy
        entry: clang-tidy
        language: system
        files: \.c$
        args:
          - --
          - -std=c11
          - -I./include
```

**Installation des hooks :**

```bash
pre-commit install
```

Maintenant, `pre-commit` s'ex√©cutera automatiquement avant chaque commit !

**Ex√©cution manuelle :**

```bash
# V√©rifier tous les fichiers
pre-commit run --all-files

# V√©rifier seulement les fichiers modifi√©s
pre-commit run
```

---

## Int√©gration Continue avec GitHub Actions

GitHub Actions est le syst√®me de CI/CD natif de GitHub. Voici comment configurer l'analyse statique.

### Configuration de base : .github/workflows/ci.yml

```yaml
name: CI - Code Quality

# D√©clencher le workflow sur push et pull request
on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

# Variables d'environnement globales
env:
  BUILD_TYPE: Debug

jobs:
  # Job 1 : Analyse statique
  static-analysis:
    runs-on: ubuntu-latest

    steps:
      # 1. Checkout du code
      - name: Checkout code
        uses: actions/checkout@v4

      # 2. Installation des outils
      - name: Install tools
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            cppcheck \
            clang-tidy \
            clang-format

      # 3. V√©rification du formatage
      - name: Check code formatting
        run: |
          echo "Checking code formatting..."
          find src include -name "*.c" -o -name "*.h" | \
            xargs clang-format -n -Werror

      # 4. Analyse avec cppcheck
      - name: Run cppcheck
        run: |
          echo "Running cppcheck..."
          cppcheck \
            --enable=all \
            --std=c11 \
            --error-exitcode=1 \
            --suppress=missingIncludeSystem \
            --inline-suppr \
            -I./include \
            src/

      # 5. Analyse avec clang-tidy
      - name: Run clang-tidy
        run: |
          echo "Running clang-tidy..."
          find src -name "*.c" -exec \
            clang-tidy {} -- -std=c11 -I./include \;

  # Job 2 : Compilation et tests
  build-and-test:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y cmake gcc

      # Configuration CMake
      - name: Configure CMake
        run: |
          cmake -B build \
            -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }} \
            -DCMAKE_C_FLAGS="-Wall -Wextra -Werror"

      # Compilation
      - name: Build
        run: cmake --build build --config ${{ env.BUILD_TYPE }}

      # Ex√©cution des tests
      - name: Run tests
        run: |
          cd build
          ctest --output-on-failure
```

### Configuration avanc√©e avec matrice de build

Pour tester sur plusieurs versions de compilateurs :

```yaml
name: CI - Advanced

on: [push, pull_request]

jobs:
  build-matrix:
    strategy:
      matrix:
        os: [ubuntu-20.04, ubuntu-22.04]
        compiler: [gcc-9, gcc-11, clang-14]
        build_type: [Debug, Release]

    runs-on: ${{ matrix.os }}

    steps:
      - uses: actions/checkout@v4

      - name: Install compiler
        run: |
          sudo apt-get update
          sudo apt-get install -y ${{ matrix.compiler }}

      - name: Set compiler
        run: |
          if [[ "${{ matrix.compiler }}" == gcc-* ]]; then
            echo "CC=${{ matrix.compiler }}" >> $GITHUB_ENV
          else
            echo "CC=clang" >> $GITHUB_ENV
          fi

      - name: Build
        run: |
          cmake -B build -DCMAKE_BUILD_TYPE=${{ matrix.build_type }}
          cmake --build build

  static-analysis:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Install analysis tools
        run: |
          sudo apt-get update
          sudo apt-get install -y cppcheck clang-tidy

      - name: Run cppcheck
        run: |
          cppcheck --enable=all --std=c11 \
            --error-exitcode=1 \
            --xml --xml-version=2 \
            src/ 2> cppcheck-report.xml

      # Uploader le rapport en artifact
      - name: Upload cppcheck report
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: cppcheck-report
          path: cppcheck-report.xml

      - name: Run clang-tidy
        run: |
          find src -name "*.c" | while read file; do
            clang-tidy "$file" -- -std=c11 -I./include || exit 1
          done
```

### G√©n√©ration de rapports HTML

Pour g√©n√©rer des rapports HTML de cppcheck :

```yaml
- name: Generate cppcheck HTML report
  run: |
    # Installer cppcheck-htmlreport
    pip install cppcheck-htmlreport

    # G√©n√©rer le rapport XML
    cppcheck --enable=all --std=c11 \
      --xml --xml-version=2 \
      src/ 2> cppcheck-report.xml

    # Convertir en HTML
    cppcheck-htmlreport \
      --file=cppcheck-report.xml \
      --report-dir=cppcheck-html \
      --source-dir=.

- name: Upload HTML report
  uses: actions/upload-artifact@v3
  with:
    name: cppcheck-html-report
    path: cppcheck-html/
```

---

## Int√©gration Continue avec GitLab CI

Pour les projets h√©berg√©s sur GitLab, cr√©ez `.gitlab-ci.yml` :

### Configuration de base

```yaml
# .gitlab-ci.yml
image: ubuntu:22.04

# √âtapes du pipeline
stages:
  - lint
  - build
  - test

# Variables globales
variables:
  GIT_SUBMODULE_STRATEGY: recursive
  CMAKE_BUILD_TYPE: Debug

# Installation des d√©pendances (r√©utilisable)
.install_deps: &install_deps
  before_script:
    - apt-get update -qq
    - apt-get install -y -qq cmake gcc cppcheck clang-tidy clang-format

# Job : V√©rification du formatage
check-format:
  stage: lint
  <<: *install_deps
  script:
    - echo "Checking code formatting..."
    - find src include -name "*.c" -o -name "*.h" | xargs clang-format -n -Werror
  allow_failure: false

# Job : cppcheck
cppcheck:
  stage: lint
  <<: *install_deps
  script:
    - echo "Running cppcheck..."
    - cppcheck --enable=all --std=c11 --error-exitcode=1 --quiet src/
  artifacts:
    when: always
    reports:
      junit: cppcheck-report.xml
  allow_failure: false

# Job : clang-tidy
clang-tidy:
  stage: lint
  <<: *install_deps
  script:
    - echo "Running clang-tidy..."
    - find src -name "*.c" -exec clang-tidy {} -- -std=c11 -I./include \;
  allow_failure: true  # Peut √™tre strict selon les projets

# Job : Compilation
build:
  stage: build
  <<: *install_deps
  script:
    - cmake -B build -DCMAKE_BUILD_TYPE=$CMAKE_BUILD_TYPE -DCMAKE_C_FLAGS="-Wall -Wextra -Werror"
    - cmake --build build
  artifacts:
    paths:
      - build/
    expire_in: 1 day

# Job : Tests unitaires
test:
  stage: test
  <<: *install_deps
  dependencies:
    - build
  script:
    - cd build
    - ctest --output-on-failure
```

### Configuration avanc√©e avec cache

```yaml
# Optimisation avec cache
cache:
  paths:
    - build/

# Job avec g√©n√©ration de rapport
cppcheck-report:
  stage: lint
  before_script:
    - apt-get update -qq
    - apt-get install -y -qq cppcheck python3-pip
    - pip3 install cppcheck-htmlreport
  script:
    # G√©n√©rer rapport XML
    - cppcheck --enable=all --std=c11 --xml --xml-version=2 src/ 2> cppcheck-report.xml

    # Convertir en HTML
    - cppcheck-htmlreport --file=cppcheck-report.xml --report-dir=cppcheck-html --source-dir=.

  artifacts:
    paths:
      - cppcheck-html/
      - cppcheck-report.xml
    expire_in: 30 days

  # Publier les pages
  pages:
    paths:
      - cppcheck-html
```

---

## Bonnes pratiques d'int√©gration

### 1. Principe du "Fail Fast"

Organisez les jobs pour √©chouer rapidement en cas de probl√®me :

```yaml
# Ordre recommand√© :
stages:
  - format      # Le plus rapide (< 10s)
  - lint        # Rapide (< 1 min)
  - build       # Moyen (1-5 min)
  - test        # Peut √™tre long
  - deploy      # Seulement si tout passe
```

### 2. Gestion des faux positifs

Cr√©ez un fichier de suppressions document√© :

**suppressions.txt :**

```
# Suppressions cppcheck
# Ajouter une justification pour chaque suppression

# Faux positif : cppcheck ne reconna√Æt pas notre allocateur custom
uninitvar:src/memory.c:42

# Intention : Cette fonction legacy sera refactoris√©e dans la v2.0
unusedFunction:src/legacy.c
```

Utilisez-le dans le CI :

```bash
cppcheck --enable=all --suppressions-list=suppressions.txt src/
```

### 3. Gestion progressive de la qualit√©

Pour un projet existant avec beaucoup de probl√®mes, proc√©dez progressivement :

**√âtape 1 : Warnings uniquement**

```yaml
- name: cppcheck (warnings only)
  run: cppcheck --enable=warning --std=c11 src/
  continue-on-error: true  # Ne pas bloquer le CI
```

**√âtape 2 : Bloquer les nouveaux warnings**

```bash
# Comparer avec la branche main
git diff main...HEAD --name-only | grep '\.c$' | xargs cppcheck --enable=warning
```

**√âtape 3 : Activer tous les checks progressivement**

### 4. Notification des r√©sultats

Configurez les notifications pour alerter l'√©quipe :

```yaml
# GitHub Actions : notification Slack
- name: Notify on failure
  if: failure()
  uses: 8398a7/action-slack@v3
  with:
    status: ${{ job.status }}
    text: 'Static analysis failed! Check the logs.'
    webhook_url: ${{ secrets.SLACK_WEBHOOK }}
```

### 5. Badge de statut

Ajoutez un badge dans votre README.md :

```markdown
# Mon Projet C

![CI Status](https://github.com/user/repo/workflows/CI/badge.svg)
![Code Quality](https://img.shields.io/badge/cppcheck-passing-brightgreen)
```

---

## Exemple complet : Projet avec CMake

Structure du projet :

```
my_project/
‚îú‚îÄ‚îÄ .github/
‚îÇ   ‚îî‚îÄ‚îÄ workflows/
‚îÇ       ‚îî‚îÄ‚îÄ ci.yml
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.c
‚îÇ   ‚îî‚îÄ‚îÄ utils.c
‚îú‚îÄ‚îÄ include/
‚îÇ   ‚îî‚îÄ‚îÄ utils.h
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îî‚îÄ‚îÄ test_utils.c
‚îú‚îÄ‚îÄ .clang-tidy
‚îú‚îÄ‚îÄ .clang-format
‚îú‚îÄ‚îÄ CMakeLists.txt
‚îî‚îÄ‚îÄ README.md
```

**CMakeLists.txt :**

```cmake
cmake_minimum_required(VERSION 3.15)
project(MyProject C)

set(CMAKE_C_STANDARD 11)
set(CMAKE_C_STANDARD_REQUIRED ON)

# Options de compilation strictes
add_compile_options(-Wall -Wextra -Wpedantic)

# Option pour activer les sanitizers en debug
option(ENABLE_SANITIZERS "Enable AddressSanitizer and UBSanitizer" OFF)

if(ENABLE_SANITIZERS)
    add_compile_options(-fsanitize=address,undefined -fno-omit-frame-pointer)
    add_link_options(-fsanitize=address,undefined)
endif()

# Inclure les headers
include_directories(include)

# Biblioth√®que
add_library(utils src/utils.c)

# Ex√©cutable principal
add_executable(myapp src/main.c)
target_link_libraries(myapp utils)

# Tests
enable_testing()
add_executable(test_utils tests/test_utils.c)
target_link_libraries(test_utils utils)
add_test(NAME test_utils COMMAND test_utils)

# Target pour clang-tidy
find_program(CLANG_TIDY_EXE NAMES clang-tidy)
if(CLANG_TIDY_EXE)
    set_target_properties(myapp PROPERTIES C_CLANG_TIDY "${CLANG_TIDY_EXE}")
    set_target_properties(utils PROPERTIES C_CLANG_TIDY "${CLANG_TIDY_EXE}")
endif()

# Target pour cppcheck
find_program(CPPCHECK_EXE NAMES cppcheck)
if(CPPCHECK_EXE)
    add_custom_target(
        cppcheck
        COMMAND ${CPPCHECK_EXE}
            --enable=all
            --std=c11
            --suppress=missingIncludeSystem
            -I ${CMAKE_SOURCE_DIR}/include
            ${CMAKE_SOURCE_DIR}/src
        WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
        COMMENT "Running cppcheck"
    )
endif()
```

**Workflow CI complet (.github/workflows/ci.yml) :**

```yaml
name: Complete CI Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  BUILD_TYPE: Debug

jobs:
  # Job 1 : Checks rapides (formatage)
  format-check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install clang-format
        run: sudo apt-get update && sudo apt-get install -y clang-format

      - name: Check formatting
        run: |
          find src include tests -name "*.c" -o -name "*.h" | \
            xargs clang-format -n -Werror

  # Job 2 : Analyse statique
  static-analysis:
    runs-on: ubuntu-latest
    needs: format-check

    steps:
      - uses: actions/checkout@v4

      - name: Install tools
        run: |
          sudo apt-get update
          sudo apt-get install -y cppcheck clang-tidy cmake gcc

      - name: Configure CMake
        run: cmake -B build -DCMAKE_EXPORT_COMPILE_COMMANDS=ON

      - name: Run cppcheck
        run: |
          cppcheck \
            --enable=all \
            --std=c11 \
            --error-exitcode=1 \
            --suppress=missingIncludeSystem \
            -I./include \
            src/

      - name: Run clang-tidy
        run: |
          find src -name "*.c" | while read file; do
            clang-tidy -p build "$file"
          done

  # Job 3 : Build et tests
  build-and-test:
    runs-on: ubuntu-latest
    needs: static-analysis

    strategy:
      matrix:
        compiler: [gcc, clang]

    steps:
      - uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y cmake ${{ matrix.compiler }}

      - name: Configure
        run: |
          CC=${{ matrix.compiler }} cmake -B build \
            -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }} \
            -DENABLE_SANITIZERS=ON

      - name: Build
        run: cmake --build build

      - name: Run tests
        run: |
          cd build
          ctest --output-on-failure --verbose

  # Job 4 : Valgrind (seulement sur GCC)
  valgrind:
    runs-on: ubuntu-latest
    needs: build-and-test

    steps:
      - uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y cmake gcc valgrind

      - name: Build
        run: |
          cmake -B build -DCMAKE_BUILD_TYPE=Debug
          cmake --build build

      - name: Run with Valgrind
        run: |
          valgrind --leak-check=full --error-exitcode=1 \
            ./build/myapp
```

---

## Tableau de bord et m√©triques

### M√©triques √† suivre

1. **Nombre de warnings** par type (bugprone, cert, etc.)
2. **Tendance** : Les warnings augmentent ou diminuent ?
3. **Temps d'ex√©cution** de chaque analyse
4. **Couverture** : % du code analys√©

### Outils de visualisation

**SonarQube** (pour projets d'entreprise) :

```yaml
# Int√©gration SonarQube dans GitHub Actions
- name: SonarQube Scan
  uses: SonarSource/sonarqube-scan-action@master
  env:
    SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
    SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
```

**Codecov** (pour la couverture de code) :

```yaml
- name: Upload coverage to Codecov
  uses: codecov/codecov-action@v3
  with:
    files: ./coverage.xml
    flags: unittests
    name: codecov-umbrella
```

---

## Gestion des √©checs et debugging

### Comprendre pourquoi le CI √©choue

1. **Lire les logs** attentivement
2. **Reproduire localement** :

```bash
# Reproduire exactement ce que fait le CI
docker run -v $(pwd):/project -w /project ubuntu:22.04 bash -c "
  apt-get update && apt-get install -y cppcheck clang-tidy cmake gcc &&
  cppcheck --enable=all --std=c11 src/ &&
  cmake -B build &&
  cmake --build build
"
```

3. **V√©rifier les diff√©rences d'environnement** (versions d'outils, etc.)

### D√©bugger les probl√®mes de CI

```yaml
# Activer le mode debug dans GitHub Actions
- name: Debug info
  run: |
    echo "Current directory: $(pwd)"
    echo "Files:"
    ls -la
    echo "Compiler version:"
    gcc --version
    echo "cppcheck version:"
    cppcheck --version
```

---

## R√©sum√© et checklist

### Checklist d'int√©gration CI pour projets C

- [ ] **Fichier `.clang-tidy`** configur√© avec les checks appropri√©s
- [ ] **Fichier `.clang-format`** pour le formatage automatique
- [ ] **Pre-commit hooks** install√©s (git hooks ou pre-commit framework)
- [ ] **Workflow CI** configur√© (GitHub Actions ou GitLab CI)
- [ ] **Jobs organis√©s** : format ‚Üí lint ‚Üí build ‚Üí test
- [ ] **Matrice de build** pour tester plusieurs compilateurs
- [ ] **Rapports** g√©n√©r√©s et archiv√©s (XML, HTML)
- [ ] **Badges** ajout√©s dans le README
- [ ] **Documentation** mise √† jour avec instructions CI

### Commandes essentielles

```bash
# V√©rification locale compl√®te
./check_code.sh

# Pre-commit manuel
pre-commit run --all-files

# Reproduire le CI localement
docker run --rm -v $(pwd):/project -w /project ubuntu:22.04 \
  bash -c "apt-get update && apt-get install -y cppcheck && cppcheck --enable=all src/"
```

### Architecture recommand√©e

```
D√©veloppeur ‚Üí Pre-commit hook ‚Üí Push ‚Üí CI Pipeline ‚Üí Merge
                ‚Üì                         ‚Üì
          (format, lint)         (full analysis, tests)
```

---

**üí° Conseil final :** Commencez simple avec juste cppcheck et clang-tidy de base, puis ajoutez progressivement plus de checks et d'outils (sanitizers, Valgrind, coverage). L'important est d'avoir un syst√®me qui fonctionne et que l'√©quipe utilise r√©ellement, plut√¥t qu'un syst√®me parfait mais jamais utilis√© !

**üéØ Objectif :** Zero tolerance pour les bugs d√©tectables automatiquement. Chaque warning doit √™tre soit corrig√©, soit explicitement supprim√© avec justification.

‚è≠Ô∏è [Code coverage](/15-debogage-et-qualite/07-code-coverage.md)
