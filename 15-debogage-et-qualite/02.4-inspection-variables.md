üîù Retour au [Sommaire](/SOMMAIRE.md)

# 15.2.4 Inspection des Variables

## Introduction

Vous avez appris √† arr√™ter votre programme avec des breakpoints, √† naviguer dans le code avec le stepping, et √† comprendre le flux d'ex√©cution avec le backtrace. Maintenant, il est temps de ma√Ætriser la comp√©tence la plus fondamentale du d√©bogage : **inspecter les variables**.

D√©boguer, c'est essentiellement **observer l'√©tat** de votre programme √† un moment donn√©. Les variables contiennent cet √©tat. Savoir comment examiner leur contenu, leur type, leur adresse m√©moire, et m√™me les modifier √† la vol√©e est essentiel pour comprendre et corriger les bugs.

Dans cette section, nous allons apprendre √† :
- Afficher la valeur des variables
- Utiliser diff√©rents formats d'affichage
- Inspecter les structures complexes, tableaux et pointeurs
- Examiner la m√©moire brute
- Modifier les variables pendant l'ex√©cution
- Suivre automatiquement l'√©volution des variables

---

## 1. La Commande `print` : Afficher une Variable

### Syntaxe de Base

La commande la plus utilis√©e pour inspecter les variables est `print` :

```gdb
print <expression>
```

Ou son raccourci :

```gdb
p <expression>
```

### Premier Exemple

Prenons ce programme simple :

```c
#include <stdio.h>

int main() {
    int age = 25;
    double prix = 19.99;
    char lettre = 'A';

    printf("Age : %d\n", age);
    return 0;
}
```

Dans GDB :

```gdb
(gdb) break 7
Breakpoint 1 at 0x1149: file exemple.c, line 7.

(gdb) run
Breakpoint 1, main () at exemple.c:7
7           printf("Age : %d\n", age);

(gdb) print age
$1 = 25

(gdb) print prix
$2 = 19.989999999999998

(gdb) print lettre
$3 = 65 'A'
```

### Comprendre la Sortie

Regardons la sortie de `print age` :

```
$1 = 25
```

- **$1** : C'est un "history value" - GDB sauvegarde chaque valeur affich√©e dans un historique. Vous pouvez y acc√©der plus tard avec `$1`, `$2`, etc.
- **25** : La valeur de la variable `age`

### Utiliser l'Historique

L'historique des valeurs est tr√®s pratique :

```gdb
(gdb) print age
$1 = 25

(gdb) print prix
$2 = 19.99

(gdb) print $1 + 10
$3 = 35

(gdb) print $2 * 2
$4 = 39.98
```

Vous pouvez faire des **calculs** avec les valeurs pr√©c√©demment affich√©es !

---

## 2. Types de Variables et Affichage

### Variables Primitives

GDB affiche automatiquement les types primitifs de mani√®re lisible :

```c
int entier = 42;  
float decimal = 3.14f;  
double grand_decimal = 3.141592653589793;  
char caractere = 'Z';  
unsigned int positif = 4294967295;  // Max uint32  
```

```gdb
(gdb) print entier
$1 = 42

(gdb) print decimal
$2 = 3.14000011

(gdb) print grand_decimal
$3 = 3.141592653589793

(gdb) print caractere
$4 = 90 'Z'

(gdb) print positif
$5 = 4294967295
```

**Remarque** : Pour `caractere`, GDB affiche √† la fois la **valeur num√©rique** (90) et le **caract√®re** ('Z').

### Pointeurs

Les pointeurs affichent leur **adresse m√©moire** :

```c
int valeur = 100;  
int *ptr = &valeur;  
```

```gdb
(gdb) print valeur
$1 = 100

(gdb) print ptr
$2 = (int *) 0x7fffffffddb4

(gdb) print *ptr
$3 = 100
```

- **ptr** : Affiche l'adresse m√©moire (0x7fffffffddb4)
- **\*ptr** : D√©r√©f√©rencement - affiche la valeur point√©e (100)

### Op√©rateur d'Adresse `&`

Pour obtenir l'**adresse** d'une variable :

```gdb
(gdb) print &valeur
$4 = (int *) 0x7fffffffddb4
```

Ceci est l'inverse du d√©r√©f√©rencement : `&` donne l'adresse, `*` lit le contenu.

---

## 3. Formats d'Affichage

Par d√©faut, GDB affiche les variables selon leur type. Mais vous pouvez **forcer un format sp√©cifique** avec le suffixe `/format`.

### Syntaxe

```gdb
print/format <expression>
```

### Formats Disponibles

| Format | Signification | Exemple |
|--------|---------------|---------|
| `/d` | D√©cimal (sign√©) | `print/d variable` |
| `/u` | D√©cimal (non sign√©) | `print/u variable` |
| `/x` | Hexad√©cimal | `print/x variable` |
| `/o` | Octal | `print/o variable` |
| `/t` | Binaire (two's complement) | `print/t variable` |
| `/c` | Caract√®re | `print/c variable` |
| `/f` | Nombre √† virgule flottante | `print/f variable` |
| `/s` | Cha√Æne de caract√®res | `print/s variable` |
| `/a` | Adresse | `print/a variable` |

### Exemples Pratiques

```c
int nombre = 255;
```

```gdb
(gdb) print nombre
$1 = 255

(gdb) print/x nombre
$2 = 0xff

(gdb) print/o nombre
$3 = 0377

(gdb) print/t nombre
$4 = 11111111

(gdb) print/c nombre
$5 = -1 '\377'
```

**Cas d'usage** : L'hexad√©cimal est tr√®s utile pour examiner les adresses m√©moire et les flags binaires.

### Affichage de Caract√®res

```c
char lettre = 65;  // Code ASCII de 'A'
```

```gdb
(gdb) print lettre
$1 = 65 'A'

(gdb) print/d lettre
$2 = 65

(gdb) print/c lettre
$3 = 65 'A'

(gdb) print/x lettre
$4 = 0x41
```

### Affichage de Pointeurs

```c
int valeur = 42;  
int *ptr = &valeur;  
```

```gdb
(gdb) print ptr
$1 = (int *) 0x7fffffffddb4

(gdb) print/x ptr
$2 = 0x7fffffffddb4

(gdb) print *ptr
$3 = 42
```

---

## 4. Inspecter les Tableaux

### Tableaux Simples

Pour un tableau, `print` affiche tous les √©l√©ments :

```c
int nombres[5] = {10, 20, 30, 40, 50};
```

```gdb
(gdb) print nombres
$1 = {10, 20, 30, 40, 50}

(gdb) print nombres[0]
$2 = 10

(gdb) print nombres[2]
$3 = 30
```

### Afficher une Plage d'√âl√©ments

Pour afficher seulement une partie d'un grand tableau :

```gdb
print nombres[2]@3
```

Ceci affiche **3 √©l√©ments** √† partir de l'index 2 :

```gdb
(gdb) print nombres[2]@3
$4 = {30, 40, 50}
```

**Syntaxe** : `variable[index]@nombre_elements`

### Tableaux de Grande Taille

GDB limite l'affichage par d√©faut. Pour changer cette limite :

```gdb
set print elements 100
```

Ou pour afficher **tous** les √©l√©ments :

```gdb
set print elements unlimited
```

### Tableaux Multidimensionnels

```c
int matrice[3][3] = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};
```

```gdb
(gdb) print matrice
$1 = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}

(gdb) print matrice[0]
$2 = {1, 2, 3}

(gdb) print matrice[1][1]
$3 = 5
```

### Tableaux Dynamiques

Pour un tableau allou√© dynamiquement :

```c
int *tableau = malloc(10 * sizeof(int));  
for (int i = 0; i < 10; i++) {  
    tableau[i] = i * 10;
}
```

```gdb
(gdb) print tableau
$1 = (int *) 0x555555559290

(gdb) print *tableau@10
$2 = {0, 10, 20, 30, 40, 50, 60, 70, 80, 90}
```

**Important** : Utilisez `*tableau@taille` pour afficher le contenu d'un tableau dynamique.

---

## 5. Inspecter les Cha√Ænes de Caract√®res

### Cha√Ænes Simples

```c
char message[] = "Bonjour";  
char *texte = "Hello World";  
```

```gdb
(gdb) print message
$1 = "Bonjour"

(gdb) print texte
$2 = 0x555555556004 "Hello World"
```

Pour un pointeur de cha√Æne, GDB affiche √† la fois **l'adresse** et le **contenu**.

### Format `/s` pour les Cha√Ænes

Si GDB ne reconna√Æt pas automatiquement une cha√Æne :

```gdb
(gdb) print/s ptr_char
```

### Cha√Ænes Tronqu√©es

Par d√©faut, GDB limite l'affichage des cha√Ænes √† 200 caract√®res. Pour changer :

```gdb
set print elements 500

# Ou illimit√©
set print elements unlimited
```

### Afficher une Cha√Æne √† une Adresse

Si vous avez une adresse m√©moire et voulez voir le contenu comme une cha√Æne :

```gdb
x/s 0x555555556004
```

(Nous verrons la commande `x` en d√©tail plus loin)

---

## 6. Inspecter les Structures

### Structure Simple

```c
struct Personne {
    char nom[50];
    int age;
    double salaire;
};

struct Personne employe = {"Alice", 30, 50000.00};
```

```gdb
(gdb) print employe
$1 = {
  nom = "Alice",
  age = 30,
  salaire = 50000
}

(gdb) print employe.nom
$2 = "Alice"

(gdb) print employe.age
$3 = 30

(gdb) print employe.salaire
$4 = 50000
```

GDB affiche la structure de mani√®re **format√©e** avec indentation !

### Pointeur vers Structure

```c
struct Personne *ptr_employe = &employe;
```

```gdb
(gdb) print ptr_employe
$1 = (struct Personne *) 0x7fffffffdd40

(gdb) print *ptr_employe
$2 = {
  nom = "Alice",
  age = 30,
  salaire = 50000
}

(gdb) print ptr_employe->age
$3 = 30
```

### Structures Imbriqu√©es

```c
struct Adresse {
    char rue[100];
    int code_postal;
};

struct Personne {
    char nom[50];
    struct Adresse adresse;
};

struct Personne p = {
    "Bob",
    {"10 rue de Paris", 75001}
};
```

```gdb
(gdb) print p
$1 = {
  nom = "Bob",
  adresse = {
    rue = "10 rue de Paris",
    code_postal = 75001
  }
}

(gdb) print p.adresse
$2 = {
  rue = "10 rue de Paris",
  code_postal = 75001
}

(gdb) print p.adresse.code_postal
$3 = 75001
```

### Contr√¥ler le Format d'Affichage

Par d√©faut, GDB affiche les structures sur plusieurs lignes. Pour un affichage compact :

```gdb
set print pretty off

(gdb) print employe
$1 = {nom = "Alice", age = 30, salaire = 50000}
```

Pour revenir au format indent√© :

```gdb
set print pretty on
```

---

## 7. Inspecter les Unions et Enums

### Unions

```c
union Donnee {
    int entier;
    float decimal;
    char octets[4];
};

union Donnee d;  
d.entier = 1078530011;  // Repr√©sentation de 3.14159 en float  
```

```gdb
(gdb) print d
$1 = {
  entier = 1078530011,
  decimal = 3.14159012,
  octets = "€ö@"
}
```

GDB affiche **tous les membres** de l'union simultan√©ment, ce qui est tr√®s utile pour voir diff√©rentes interpr√©tations des m√™mes donn√©es.

### Enums

```c
enum Jour {
    LUNDI = 1,
    MARDI,
    MERCREDI,
    JEUDI,
    VENDREDI
};

enum Jour aujourd_hui = MERCREDI;
```

```gdb
(gdb) print aujourd_hui
$1 = MERCREDI

(gdb) print/d aujourd_hui
$2 = 3
```

GDB affiche le **nom symbolique** (MERCREDI) plut√¥t que juste la valeur (3), ce qui est beaucoup plus lisible !

---

## 8. Examiner la M√©moire Brute avec `x`

La commande `x` (examine) permet d'inspecter la **m√©moire brute** √† une adresse donn√©e.

### Syntaxe

```gdb
x/NFU <adresse>
```

O√π :
- **N** : Nombre d'unit√©s √† afficher
- **F** : Format (comme `print` : x, d, u, o, t, a, c, f, s)
- **U** : Unit√© de taille (b=byte, h=halfword/2 bytes, w=word/4 bytes, g=giant/8 bytes)

### Exemples de Base

```c
int nombre = 0x12345678;  
int *ptr = &nombre;  
```

```gdb
(gdb) x/1xw ptr
0x7fffffffddb4:  0x12345678

(gdb) x/4xb ptr
0x7fffffffddb4:  0x78  0x56  0x34  0x12
```

**Lecture** :
- `x/1xw` : Afficher **1** unit√© en **hexad√©cimal** de taille **word (4 bytes)**
- `x/4xb` : Afficher **4** unit√©s en **hexad√©cimal** de taille **byte (1 byte)**

**Remarque** : On voit l'**endianness** (little-endian) : les octets sont invers√©s (78 56 34 12 au lieu de 12 34 56 78).

### Afficher une Cha√Æne

```c
char *message = "Hello";
```

```gdb
(gdb) x/s message
0x555555556004:  "Hello"

(gdb) x/6cb message
0x555555556004:  72 'H'  101 'e'  108 'l'  108 'l'  111 'o'  0 '\000'
```

### Afficher un Tableau

```c
int tableau[5] = {10, 20, 30, 40, 50};
```

```gdb
(gdb) x/5dw tableau
0x7fffffffdda0:  10  20  30  40  50

(gdb) x/5xw tableau
0x7fffffffdda0:  0x0000000a  0x00000014  0x0000001e  0x00000028  0x00000032
```

### Avancer dans la M√©moire

Apr√®s avoir utilis√© `x`, appuyer sur **Entr√©e** r√©p√®te la commande mais **avance** dans la m√©moire :

```gdb
(gdb) x/4xw tableau
0x7fffffffdda0:  0x0000000a  0x00000014  0x0000001e  0x00000028

(gdb) [Entr√©e]
0x7fffffffddb0:  0x00000032  0x00000000  0xf7df8d8a  0x00007fff
```

### Formats Utiles

**Afficher comme instructions assembleur** :

```gdb
x/10i main
```

Ceci affiche les 10 premi√®res instructions de la fonction `main`.

**Afficher comme adresses** :

```gdb
x/10a $sp
```

Affiche 10 adresses √† partir du pointeur de pile.

---

## 9. Expressions et Calculs

GDB peut √©valuer des **expressions C compl√®tes** :

### Op√©rations Arithm√©tiques

```gdb
(gdb) print 5 + 3
$1 = 8

(gdb) print age * 2
$2 = 50

(gdb) print prix / 2.0
$3 = 9.995
```

### Op√©rateurs Bit-√†-Bit

```gdb
(gdb) print 0xFF & 0x0F
$1 = 15

(gdb) print 0b1010 | 0b0101
$2 = 15

(gdb) print 1 << 4
$3 = 16

(gdb) print ~0
$4 = -1
```

### Op√©rateurs de Comparaison

```gdb
(gdb) print age > 18
$1 = 1  # true

(gdb) print age == 25
$2 = 1  # true

(gdb) print age < 20
$3 = 0  # false
```

En C, `true` = 1 et `false` = 0.

### Appel de Fonctions

Vous pouvez m√™me **appeler des fonctions** depuis GDB :

```c
int addition(int a, int b) {
    return a + b;
}

int main() {
    int x = 5;
    int y = 10;
    // ...
}
```

```gdb
(gdb) break main
(gdb) run
(gdb) print addition(3, 7)
$1 = 10

(gdb) print addition(x, y)
$2 = 15
```

**Attention** : Appeler des fonctions peut avoir des **effets secondaires** (modifier des variables globales, I/O, etc.). Utilisez avec pr√©caution !

### Cast de Types

Vous pouvez forcer un type avec un cast :

```c
void *ptr_void = malloc(sizeof(int));
*(int*)ptr_void = 42;
```

```gdb
(gdb) print ptr_void
$1 = (void *) 0x555555559290

(gdb) print *(int*)ptr_void
$2 = 42
```

Sans le cast `(int*)`, GDB ne pourrait pas d√©r√©f√©rencer un `void*`.

---

## 10. La Commande `display` : Affichage Automatique

Lorsque vous steppez dans le code, il est fastidieux de taper `print variable` √† chaque arr√™t. La commande `display` affiche automatiquement des variables **√† chaque arr√™t**.

### Syntaxe

```gdb
display <expression>
```

### Exemple

```c
int main() {
    int compteur = 0;
    for (int i = 0; i < 5; i++) {
        compteur += i;
    }
    return 0;
}
```

```gdb
(gdb) break 4
(gdb) run
(gdb) display compteur
1: compteur = 0

(gdb) next
1: compteur = 0

(gdb) next
1: compteur = 1

(gdb) next
1: compteur = 3

(gdb) next
1: compteur = 6
```

√Ä chaque `next`, GDB affiche automatiquement la valeur de `compteur` !

### Afficher Plusieurs Variables

```gdb
(gdb) display compteur
1: compteur = 0

(gdb) display i
2: i = 0

(gdb) next
1: compteur = 0
2: i = 1
```

### G√©rer les Displays

**Voir tous les displays actifs** :

```gdb
info display
```

**D√©sactiver un display** :

```gdb
disable display 1
```

**R√©activer** :

```gdb
enable display 1
```

**Supprimer un display** :

```gdb
undisplay 1
# Ou
delete display 1
```

**Supprimer tous les displays** :

```gdb
undisplay
# ou
delete display
```

### Display avec Format

Vous pouvez sp√©cifier un format :

```gdb
display/x compteur
```

Cela affichera `compteur` en hexad√©cimal √† chaque arr√™t.

---

## 11. Modifier des Variables avec `set`

GDB permet non seulement d'**inspecter** les variables, mais aussi de les **modifier** pendant l'ex√©cution. Ceci est extr√™mement puissant pour tester des hypoth√®ses sans recompiler.

### Syntaxe

```gdb
set variable <nom> = <valeur>
```

Ou plus simplement :

```gdb
set <nom> = <valeur>
```

### Exemple Simple

```c
int main() {
    int age = 20;
    if (age >= 18) {
        printf("Majeur\n");
    } else {
        printf("Mineur\n");
    }
    return 0;
}
```

```gdb
(gdb) break 3
(gdb) run
(gdb) print age
$1 = 20

(gdb) set age = 15
(gdb) print age
$2 = 15

(gdb) continue
Mineur
```

Nous avons **chang√©** la valeur de `age` pour tester le comportement avec une valeur diff√©rente !

### Modifier des Pointeurs

```c
int valeur = 100;  
int *ptr = &valeur;  
```

```gdb
(gdb) print *ptr
$1 = 100

(gdb) set *ptr = 200
(gdb) print *ptr
$2 = 200

(gdb) print valeur
$3 = 200
```

La valeur point√©e par `ptr` (qui est `valeur`) a √©t√© modifi√©e.

### Modifier des √âl√©ments de Tableau

```c
int tableau[5] = {10, 20, 30, 40, 50};
```

```gdb
(gdb) print tableau
$1 = {10, 20, 30, 40, 50}

(gdb) set tableau[2] = 99
(gdb) print tableau
$2 = {10, 20, 99, 40, 50}
```

### Modifier des Champs de Structure

```c
struct Personne {
    char nom[50];
    int age;
};

struct Personne p = {"Alice", 30};
```

```gdb
(gdb) print p
$1 = {nom = "Alice", age = 30}

(gdb) set p.age = 35
(gdb) print p
$2 = {nom = "Alice", age = 35}
```

### Cas d'Usage : Tester des Branches

Vous pouvez forcer le programme √† prendre une branche sp√©cifique :

```c
int erreur = fonction_reseau();  // Peut retourner 0 ou -1  
if (erreur != 0) {  
    // Gestion d'erreur
}
```

```gdb
(gdb) break 2
(gdb) run
(gdb) set erreur = -1  # Forcer une erreur
(gdb) continue
# Observe la gestion d'erreur sans d√©clencher une vraie erreur r√©seau
```

---

## 12. La Commande `whatis` : Conna√Ætre le Type

Si vous ne savez pas le type d'une variable, utilisez `whatis` :

```gdb
whatis <variable>
```

### Exemples

```c
int nombre = 42;  
double prix = 19.99;  
char *message = "Bonjour";  
struct Personne employe;  
```

```gdb
(gdb) whatis nombre
type = int

(gdb) whatis prix
type = double

(gdb) whatis message
type = char *

(gdb) whatis employe
type = struct Personne

(gdb) whatis employe.age
type = int
```

### `ptype` : Information D√©taill√©e sur un Type

Pour voir la **structure compl√®te** d'un type :

```gdb
ptype <variable>
```

Exemple avec une structure :

```c
struct Personne {
    char nom[50];
    int age;
    double salaire;
};

struct Personne p;
```

```gdb
(gdb) ptype p
type = struct Personne {
    char nom[50];
    int age;
    double salaire;
}

(gdb) ptype struct Personne
type = struct Personne {
    char nom[50];
    int age;
    double salaire;
}
```

Ceci est **extr√™mement utile** quand vous d√©boguez du code que vous ne connaissez pas bien.

---

## 13. Inspecter les Variables Optimis√©es

### Le Probl√®me de l'Optimisation

Avec les options d'optimisation (`-O1`, `-O2`, `-O3`), le compilateur peut :
- √âliminer des variables "inutiles"
- Les garder uniquement dans des registres CPU
- Les inliner ou les r√©utiliser

R√©sultat : GDB peut afficher `<optimized out>` :

```gdb
(gdb) print variable
$1 = <optimized out>
```

### Solutions

**Solution 1** : Compiler sans optimisation pour le d√©bogage

```bash
gcc -g -O0 -o programme programme.c
```

`-O0` = Pas d'optimisation.

**Solution 2** : Utiliser `volatile`

En C, d√©clarer une variable comme `volatile` dit au compilateur de **ne jamais l'optimiser** :

```c
volatile int variable_debug = 42;
```

**Solution 3** : Inspecter les Registres

Si une variable est dans un registre CPU :

```gdb
info registers

# Exemple : variable dans le registre rax
print $rax
```

---

## 14. Variables Hors de Port√©e

### Le Probl√®me

Vous ne pouvez pas acc√©der √† une variable qui n'est **pas dans la port√©e actuelle** :

```c
void fonction_a() {
    int local_a = 10;
}

void fonction_b() {
    int local_b = 20;
    fonction_a();
}

int main() {
    fonction_b();
    return 0;
}
```

Si vous √™tes dans `fonction_b()`, vous ne pouvez pas acc√©der √† `local_a` :

```gdb
(gdb) break fonction_b
(gdb) run
(gdb) print local_a
No symbol "local_a" in current context.
```

### Solution : Changer de Frame

Utilisez `frame` ou `up`/`down` pour changer de contexte :

```gdb
(gdb) bt
#0  fonction_a () at test.c:2
#1  fonction_b () at test.c:7

(gdb) frame 1
(gdb) print local_b
$1 = 20

(gdb) frame 0
(gdb) print local_a
$2 = 10
```

---

## 15. Variables Globales et Statiques

### Variables Globales

Les variables globales sont **toujours accessibles**, peu importe o√π vous √™tes dans le code :

```c
int compteur_global = 0;

void incrementer() {
    compteur_global++;
}

int main() {
    incrementer();
    return 0;
}
```

```gdb
(gdb) break incrementer
(gdb) run
(gdb) print compteur_global
$1 = 0

(gdb) next
(gdb) print compteur_global
$2 = 1
```

### Variables Statiques Locales

Les variables `static` locales **persistent** entre les appels :

```c
void compteur() {
    static int appels = 0;
    appels++;
    printf("Appel num√©ro %d\n", appels);
}

int main() {
    compteur();
    compteur();
    compteur();
    return 0;
}
```

```gdb
(gdb) break compteur
(gdb) run
(gdb) print appels
$1 = 0

(gdb) continue
(gdb) print appels
$2 = 1

(gdb) continue
(gdb) print appels
$3 = 2
```

### Conflit de Noms

Si deux fonctions ont des variables locales de m√™me nom, GDB utilise celle de la **port√©e actuelle** :

```c
void fonction_a() {
    int x = 10;
}

void fonction_b() {
    int x = 20;
}
```

Pour forcer une variable d'un fichier sp√©cifique :

```gdb
print fichier.c::x  
print fonction_a::x  
```

---

## 16. Techniques Avanc√©es

### Afficher des Structures Complexes

Pour une liste cha√Æn√©e :

```c
struct Node {
    int valeur;
    struct Node *suivant;
};

struct Node *tete = ...;
```

```gdb
(gdb) print *tete
$1 = {valeur = 10, suivant = 0x555555559290}

(gdb) print *tete->suivant
$2 = {valeur = 20, suivant = 0x5555555592b0}

(gdb) print *tete->suivant->suivant
$3 = {valeur = 30, suivant = 0x0}
```

### Afficher R√©cursivement

Pour afficher toute une liste :

```gdb
define afficher_liste
  set $node = $arg0
  while $node != 0
    print *$node
    set $node = $node->suivant
  end
end

(gdb) afficher_liste tete
```

Ceci est une **macro GDB** personnalis√©e !

### Pretty Printers

GDB supporte des "pretty printers" pour afficher des structures complexes de mani√®re plus lisible. Certaines biblioth√®ques (comme la STL C++) fournissent leurs propres pretty printers.

---

## 17. Conseils Pratiques

### Conseil 1 : Utilisez `display` pour les Variables Critiques

Mettez en `display` les 2-3 variables les plus importantes pour votre bug. Vous les verrez √©voluer √† chaque √©tape.

```gdb
display compteur  
display ptr  
display resultat  
```

### Conseil 2 : Inspectez √† Diff√©rents Niveaux

Combinez `print` avec navigation dans la pile :

```gdb
bt            # Voir la pile  
frame 2       # Aller au frame 2  
print var     # Inspecter variable  
up            # Monter d'un niveau  
print var     # Voir si elle a chang√©  
```

### Conseil 3 : Utilisez l'Historique

Les valeurs `$1`, `$2`, etc. sont tr√®s pratiques :

```gdb
print calcul_complexe()
$1 = 42

print $1 * 2
$2 = 84

# Vous n'avez pas besoin de recalculer !
```

### Conseil 4 : Formats Hexad√©cimaux pour les Pointeurs

Les adresses sont plus lisibles en hexad√©cimal :

```gdb
print/x ptr
```

### Conseil 5 : V√©rifiez les Pointeurs NULL

Avant de d√©r√©f√©rencer :

```gdb
(gdb) print ptr
$1 = (int *) 0x0

(gdb) print ptr != 0
$2 = 0  # false - c'est NULL !
```

### Conseil 6 : Utilisez `x` pour la M√©moire Brute

Quand `print` ne suffit pas (corruption m√©moire, analyse bas niveau), utilisez `x` :

```gdb
x/100xb ptr  # Afficher 100 octets en hexa
```

---

## 18. R√©sum√© des Commandes

### Affichage de Base

| Commande | Action |
|----------|--------|
| `print <var>` ou `p <var>` | Affiche la valeur d'une variable |
| `print/x <var>` | Affiche en hexad√©cimal |
| `print/t <var>` | Affiche en binaire |
| `print *ptr` | D√©r√©f√©rence un pointeur |
| `print &var` | Affiche l'adresse d'une variable |
| `print tableau[0]@10` | Affiche 10 √©l√©ments d'un tableau |

### Examen M√©moire

| Commande | Action |
|----------|--------|
| `x/NFU <adresse>` | Examine la m√©moire |
| `x/s <adresse>` | Affiche une cha√Æne |
| `x/10i main` | Affiche 10 instructions assembleur |

### Affichage Automatique

| Commande | Action |
|----------|--------|
| `display <expression>` | Affiche automatiquement √† chaque arr√™t |
| `info display` | Liste des displays actifs |
| `undisplay <num>` | Supprime un display |

### Modification

| Commande | Action |
|----------|--------|
| `set <var> = <valeur>` | Modifie une variable |
| `set *ptr = <valeur>` | Modifie via un pointeur |

### Information sur les Types

| Commande | Action |
|----------|--------|
| `whatis <var>` | Affiche le type d'une variable |
| `ptype <var>` | Affiche la structure compl√®te du type |

### Historique

| Commande | Action |
|----------|--------|
| `$1`, `$2`, etc. | Acc√®de aux valeurs pr√©c√©dentes |
| `show values` | Affiche l'historique |

---

## 19. Cas Pratique Complet

### Le Programme

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Client {
    int id;
    char nom[50];
    double solde;
};

void afficher_client(struct Client *c) {
    printf("Client #%d : %s, Solde : %.2f‚Ç¨\n", c->id, c->nom, c->solde);
}

int main() {
    struct Client *clients = malloc(3 * sizeof(struct Client));

    clients[0] = (struct Client){1, "Alice", 1500.50};
    clients[1] = (struct Client){2, "Bob", 2300.75};
    clients[2] = (struct Client){3, "Charlie", 500.00};

    for (int i = 0; i < 3; i++) {
        afficher_client(&clients[i]);
    }

    free(clients);
    return 0;
}
```

### Session de D√©bogage

```gdb
(gdb) break main
(gdb) run

(gdb) next  # Apr√®s allocation
(gdb) print clients
$1 = (struct Client *) 0x555555559290

(gdb) print *clients
$2 = {id = 0, nom = "", solde = 0}

(gdb) next  # Apr√®s premi√®re initialisation
(gdb) print clients[0]
$3 = {id = 1, nom = "Alice", solde = 1500.5}

(gdb) next
(gdb) next
(gdb) print clients[1]
$4 = {id = 2, nom = "Bob", solde = 2300.75}

(gdb) display i
1: i = 0

(gdb) break afficher_client
Breakpoint 2 at 0x555555555189

(gdb) continue
Breakpoint 2, afficher_client (c=0x555555559290) at client.c:11
1: i = 0

(gdb) print *c
$5 = {id = 1, nom = "Alice", solde = 1500.5}

(gdb) print c->solde
$6 = 1500.5

(gdb) set c->solde = 2000.00
(gdb) print c->solde
$7 = 2000

(gdb) continue
Client #1 : Alice, Solde : 2000.00‚Ç¨

(gdb) continue
Breakpoint 2, afficher_client (c=0x5555555592c0) at client.c:11
1: i = 1

(gdb) print *c
$8 = {id = 2, nom = "Bob", solde = 2300.75}
```

Dans cette session, nous avons :
1. Inspect√© le pointeur allou√©
2. V√©rifi√© le contenu des structures
3. Utilis√© `display` pour suivre `i`
4. Modifi√© une valeur avec `set`
5. Observ√© l'effet de la modification

---

## Conclusion

L'inspection des variables est au **c≈ìur** du d√©bogage. C'est en observant l'√©tat de votre programme que vous comprendrez ce qui ne va pas.

### Les Commandes Essentielles √† Retenir

Pour 90% des cas, vous aurez besoin de :
- **`print`** : Afficher une variable
- **`print/x`** : Afficher en hexad√©cimal
- **`print *ptr`** : D√©r√©f√©rencer un pointeur
- **`print array[0]@10`** : Afficher un tableau
- **`display`** : Suivre automatiquement une variable
- **`x/s`** : Examiner la m√©moire
- **`set`** : Modifier une variable
- **`whatis`** : Conna√Ætre le type

### Progression Naturelle

1. **D√©butant** : `print`, `print/x`, bases des tableaux
2. **Interm√©diaire** : `display`, structures, `x`, modification avec `set`
3. **Avanc√©** : Expressions complexes, macros GDB, inspection m√©moire bas niveau

### Prochaines √âtapes

Maintenant que vous ma√Ætrisez l'inspection des variables, vous √™tes pr√™t pour :
- **15.2.5 GDB TUI mode** : Interface visuelle dans le terminal
- **15.3 GDB avanc√©** : Core dumps, debugging distant, scripts GDB
- **15.4 Valgrind** : D√©tection de fuites m√©moire et corruption

L'inspection des variables, combin√©e aux breakpoints, stepping et backtrace, forme le **socle complet** du d√©bogage en C. Avec ces quatre comp√©tences, vous pouvez r√©soudre pratiquement n'importe quel bug !

---

**üí° Astuce finale :** La comp√©tence la plus importante n'est pas de conna√Ætre toutes les commandes, mais de savoir **quoi chercher**. Posez-vous toujours la question : "Quelle variable a une valeur inattendue ?" Une fois que vous savez quoi chercher, GDB vous donne tous les outils pour l'inspecter en d√©tail. Avec la pratique, vous d√©velopperez une intuition pour rep√©rer rapidement les valeurs suspectes.

‚è≠Ô∏è [GDB TUI mode](/15-debogage-et-qualite/02.5-gdb-tui.md)
