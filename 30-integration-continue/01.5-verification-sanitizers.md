üîù Retour au [Sommaire](/SOMMAIRE.md)

# 30.1.5 V√©rification avec sanitizers

## Introduction

Les **sanitizers** (assainisseurs en fran√ßais) sont des outils d'analyse dynamique int√©gr√©s aux compilateurs modernes (GCC et Clang) qui d√©tectent automatiquement des bugs difficiles √† trouver pendant l'ex√©cution de votre programme. Ils constituent votre **premi√®re ligne de d√©fense** contre les bugs m√©moire, les comportements ind√©finis et les probl√®mes de concurrence.

En int√©grant les sanitizers dans votre pipeline CI/CD, vous d√©tectez ces bugs **automatiquement** √† chaque modification du code, avant qu'ils n'atteignent la production.

---

## Pourquoi les sanitizers sont essentiels ?

### Les bugs qu'ils d√©tectent

Les sanitizers d√©tectent des bugs **invisibles** qui ne font pas n√©cessairement crasher votre programme imm√©diatement, mais qui causent :

- **Corruptions de m√©moire** : Acc√®s hors limites, double free, use-after-free
- **Comportements ind√©finis** : Division par z√©ro, d√©bordements d'entiers, pointeurs NULL
- **Fuites m√©moire** : M√©moire allou√©e mais jamais lib√©r√©e
- **Race conditions** : Acc√®s concurrents non synchronis√©s dans les programmes multi-thread

### Avantages en CI

1. **D√©tection imm√©diate** : Les bugs sont trouv√©s d√®s qu'ils sont introduits
2. **Rapports pr√©cis** : Stack trace exacte de l'erreur
3. **Faible co√ªt** : Pas besoin d'outils externes comme Valgrind
4. **Performance acceptable** : Overhead de 2-3x (vs 20-50x pour Valgrind)
5. **Facilit√© d'utilisation** : Simple flag de compilation

---

## Les 4 principaux sanitizers

### 1. AddressSanitizer (ASan) üî¥

**D√©tecte :**
- Buffer overflow (lecture/√©criture hors limites)
- Use-after-free (acc√®s √† de la m√©moire lib√©r√©e)
- Use-after-return (acc√®s √† des variables locales apr√®s le retour de fonction)
- Double free
- Memory leaks (fuites m√©moire)

**Flag de compilation :**
```bash
-fsanitize=address
```

**Le plus utilis√© et le plus important pour d√©buter.**

### 2. UndefinedBehaviorSanitizer (UBSan) üü°

**D√©tecte :**
- Division par z√©ro
- D√©bordement d'entiers sign√©s
- D√©calages invalides (shift)
- D√©r√©f√©rencement de pointeur NULL
- Conversions de types invalides
- Acc√®s √† des tableaux hors limites

**Flag de compilation :**
```bash
-fsanitize=undefined
```

**Compl√©ment parfait d'ASan.**

### 3. ThreadSanitizer (TSan) üîµ

**D√©tecte :**
- Race conditions (acc√®s concurrent √† la m√©moire)
- Deadlocks potentiels
- Probl√®mes de synchronisation

**Flag de compilation :**
```bash
-fsanitize=thread
```

**Essentiel pour les programmes multi-thread.**

‚ö†Ô∏è **Incompatible avec ASan** : Ne peut pas √™tre utilis√© en m√™me temps qu'AddressSanitizer.

### 4. LeakSanitizer (LSan) üü¢

**D√©tecte :**
- Fuites m√©moire (memory leaks)

**Flag de compilation :**
```bash
-fsanitize=leak
```

**Note :** LSan est automatiquement inclus dans ASan. Vous pouvez aussi l'utiliser seul pour moins d'overhead.

---

## Compilation avec sanitizers

### Syntaxe de base

Pour activer un sanitizer, ajoutez le flag lors de la compilation **ET** du linking :

```bash
gcc -fsanitize=address -g -o app main.c
```

**Flags recommand√©s suppl√©mentaires :**

```bash
gcc -fsanitize=address \
    -fno-omit-frame-pointer \
    -g \
    -O1 \
    -o app main.c
```

**Explications :**

- `-fsanitize=address` : Active AddressSanitizer
- `-fno-omit-frame-pointer` : Am√©liore les stack traces
- `-g` : Ajoute les symboles de debug (essentiel pour les rapports)
- `-O1` : Optimisation l√©g√®re (√©quilibre entre performance et debugging)

### Combiner plusieurs sanitizers

Vous pouvez combiner ASan et UBSan :

```bash
gcc -fsanitize=address,undefined \
    -fno-omit-frame-pointer \
    -g \
    -O1 \
    -o app main.c
```

**Combinaisons possibles :**
- ‚úÖ ASan + UBSan
- ‚úÖ ASan + LSan (LSan est d√©j√† dans ASan)
- ‚úÖ UBSan + LSan
- ‚ùå ASan + TSan (incompatibles)
- ‚ùå LSan + TSan (incompatibles)

---

## Exemple : D√©tecter un buffer overflow

### Code avec bug

**main.c**
```c
#include <stdio.h>

int main(void) {
    int array[5] = {1, 2, 3, 4, 5};

    // Bug : acc√®s hors limites !
    for (int i = 0; i <= 5; i++) {  // Devrait √™tre i < 5
        printf("array[%d] = %d\n", i, array[i]);
    }

    return 0;
}
```

### Compilation normale (sans sanitizer)

```bash
$ gcc -o app main.c
$ ./app
array[0] = 1  
array[1] = 2  
array[2] = 3  
array[3] = 4  
array[4] = 5  
array[5] = 32767  # Valeur al√©atoire, pas de crash !  
```

Le programme ne crash pas, mais lit de la m√©moire invalide.

### Compilation avec ASan

```bash
$ gcc -fsanitize=address -g -o app main.c
$ ./app
array[0] = 1  
array[1] = 2  
array[2] = 3  
array[3] = 4  
array[4] = 5  

=================================================================
==12345==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffc123456
READ of size 4 at 0x7ffc123456 thread T0
    #0 0x401234 in main main.c:7
    #1 0x7f1234567890 in __libc_start_main

Address 0x7ffc123456 is located in stack of thread T0 at offset 36
=================================================================
```

**ASan d√©tecte imm√©diatement le bug avec un rapport pr√©cis !**

---

## Interpr√©ter un rapport ASan

Voici comment lire un rapport AddressSanitizer :

```
=================================================================
==12345==ERROR: AddressSanitizer: stack-buffer-overflow
READ of size 4 at 0x7ffc123456 thread T0
    #0 0x401234 in main main.c:7
    #1 0x7f1234 in __libc_start_main
=================================================================
```

**D√©cortication :**

1. **Type d'erreur** : `stack-buffer-overflow` = Lecture hors limites d'un tableau sur la stack
2. **Op√©ration** : `READ of size 4` = Lecture de 4 octets (un `int`)
3. **Localisation** : `main.c:7` = Ligne 7 du fichier main.c
4. **Stack trace** : Chemin d'appels jusqu'√† l'erreur

### Types d'erreurs ASan courants

| Erreur | Signification |
|--------|---------------|
| `heap-buffer-overflow` | Acc√®s hors limites sur le tas (malloc) |
| `stack-buffer-overflow` | Acc√®s hors limites sur la pile (variables locales) |
| `heap-use-after-free` | Utilisation de m√©moire lib√©r√©e |
| `stack-use-after-return` | Utilisation de variable locale apr√®s retour de fonction |
| `double-free` | Lib√©ration de la m√™me m√©moire deux fois |
| `memory leak` | M√©moire allou√©e non lib√©r√©e |

---

## Workflow de base avec sanitizers

Voici un workflow GitHub Actions minimal pour ex√©cuter votre code avec sanitizers :

```yaml
name: V√©rification avec Sanitizers

on: [push, pull_request]

jobs:
  sanitizers:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout du code
      uses: actions/checkout@v4

    - name: Installer les outils
      run: |
        sudo apt-get update
        sudo apt-get install -y gcc cmake

    - name: Configurer avec ASan
      run: |
        cmake -B build \
          -DCMAKE_BUILD_TYPE=Debug \
          -DCMAKE_C_FLAGS="-fsanitize=address -fno-omit-frame-pointer -g"

    - name: Compiler
      run: cmake --build build

    - name: Lancer les tests avec ASan
      run: |
        cd build
        ctest --output-on-failure
```

**Si un test d√©tecte un bug, le workflow √©chouera avec le rapport ASan dans les logs.**

---

## Matrice de sanitizers

Pour tester avec diff√©rents sanitizers, utilisez une matrice :

```yaml
name: CI avec Sanitizers

on: [push, pull_request]

jobs:
  test-sanitizers:
    name: Tests avec ${{ matrix.sanitizer }}
    runs-on: ubuntu-latest

    strategy:
      fail-fast: false
      matrix:
        sanitizer:
          - address
          - undefined
          - leak
          - thread

    steps:
    - uses: actions/checkout@v4

    - name: Configurer avec ${{ matrix.sanitizer }}
      run: |
        cmake -B build \
          -DCMAKE_BUILD_TYPE=Debug \
          -DCMAKE_C_FLAGS="-fsanitize=${{ matrix.sanitizer }} -fno-omit-frame-pointer -g -O1"

    - name: Compiler
      run: cmake --build build

    - name: Lancer les tests
      run: |
        cd build
        ctest --output-on-failure
```

**Ce workflow lance 4 jobs en parall√®le, un pour chaque sanitizer.**

---

## Configuration CMake avec sanitizers

Pour int√©grer les sanitizers proprement dans votre CMakeLists.txt :

**CMakeLists.txt**

```cmake
cmake_minimum_required(VERSION 3.10)  
project(MonProjet C)  

# Option pour activer les sanitizers
option(ENABLE_ASAN "Enable AddressSanitizer" OFF)  
option(ENABLE_UBSAN "Enable UndefinedBehaviorSanitizer" OFF)  
option(ENABLE_TSAN "Enable ThreadSanitizer" OFF)  

# Configuration des sanitizers
if(ENABLE_ASAN)
    message(STATUS "AddressSanitizer activ√©")
    add_compile_options(-fsanitize=address -fno-omit-frame-pointer)
    add_link_options(-fsanitize=address)
endif()

if(ENABLE_UBSAN)
    message(STATUS "UndefinedBehaviorSanitizer activ√©")
    add_compile_options(-fsanitize=undefined)
    add_link_options(-fsanitize=undefined)
endif()

if(ENABLE_TSAN)
    message(STATUS "ThreadSanitizer activ√©")
    add_compile_options(-fsanitize=thread)
    add_link_options(-fsanitize=thread)
endif()

# Votre projet
add_executable(app src/main.c)
```

**Utilisation dans le workflow :**

```yaml
- name: Configurer avec ASan
  run: cmake -B build -DENABLE_ASAN=ON

- name: Configurer avec UBSan
  run: cmake -B build -DENABLE_UBSAN=ON
```

---

## Workflow complet avec ASan et UBSan combin√©s

```yaml
name: CI avec ASan + UBSan

on:
  push:
    branches: [ main ]
  pull_request:

jobs:
  test-with-sanitizers:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Installer GCC r√©cent
      run: |
        sudo apt-get update
        sudo apt-get install -y gcc-13 g++-13
        sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-13 100

    - name: Configurer avec ASan + UBSan
      run: |
        cmake -B build \
          -DCMAKE_BUILD_TYPE=Debug \
          -DCMAKE_C_FLAGS="-fsanitize=address,undefined -fno-omit-frame-pointer -g -O1"

    - name: Compiler
      run: cmake --build build -j$(nproc)

    - name: Lancer les tests
      run: |
        cd build
        ASAN_OPTIONS=detect_leaks=1:halt_on_error=0 \
        ctest --output-on-failure --verbose

    - name: Afficher r√©sum√© des erreurs
      if: failure()
      run: |
        echo "=== Des erreurs ont √©t√© d√©tect√©es par les sanitizers ==="
        echo "Consultez les logs ci-dessus pour les d√©tails"
```

**Variables d'environnement ASAN_OPTIONS :**

- `detect_leaks=1` : Active la d√©tection de fuites m√©moire
- `halt_on_error=0` : Continue l'ex√©cution apr√®s une erreur (pour voir toutes les erreurs)

---

## Variables d'environnement des sanitizers

### AddressSanitizer (ASAN_OPTIONS)

```yaml
- name: Lancer avec options ASan
  env:
    ASAN_OPTIONS: detect_leaks=1:halt_on_error=1:symbolize=1
  run: ./build/app
```

**Options utiles :**

| Option | Valeur | Description |
|--------|--------|-------------|
| `detect_leaks` | 0 ou 1 | D√©tecte les fuites m√©moire |
| `halt_on_error` | 0 ou 1 | Arr√™te √† la premi√®re erreur |
| `symbolize` | 0 ou 1 | Affiche les symboles dans les stack traces |
| `abort_on_error` | 0 ou 1 | Appelle abort() lors d'une erreur |

### UndefinedBehaviorSanitizer (UBSAN_OPTIONS)

```yaml
- name: Lancer avec options UBSan
  env:
    UBSAN_OPTIONS: print_stacktrace=1:halt_on_error=1
  run: ./build/app
```

### ThreadSanitizer (TSAN_OPTIONS)

```yaml
- name: Lancer avec options TSan
  env:
    TSAN_OPTIONS: halt_on_error=1:second_deadlock_stack=1
  run: ./build/app
```

---

## Exemple : Use-after-free

### Code avec bug

```c
#include <stdlib.h>
#include <stdio.h>

int main(void) {
    int *ptr = malloc(sizeof(int));
    *ptr = 42;

    free(ptr);

    // Bug : utilisation apr√®s lib√©ration !
    printf("Value: %d\n", *ptr);

    return 0;
}
```

### Rapport ASan

```
=================================================================
==12345==ERROR: AddressSanitizer: heap-use-after-free
READ of size 4 at 0x602000000010 thread T0
    #0 0x401234 in main main.c:10

0x602000000010 is located 0 bytes inside of 4-byte region
freed by thread T0 here:
    #0 0x7f123456 in free
    #1 0x401200 in main main.c:8

previously allocated by thread T0 here:
    #0 0x7f123456 in malloc
    #1 0x4011f0 in main main.c:5
=================================================================
```

**Le rapport montre :**
1. O√π la m√©moire a √©t√© lib√©r√©e (ligne 8)
2. O√π elle a √©t√© allou√©e (ligne 5)
3. O√π elle est utilis√©e apr√®s lib√©ration (ligne 10)

---

## Exemple : Memory leak

### Code avec fuite

```c
#include <stdlib.h>

void function(void) {
    int *ptr = malloc(100 * sizeof(int));
    // Oups ! Pas de free()
}

int main(void) {
    for (int i = 0; i < 10; i++) {
        function();
    }
    return 0;
}
```

### Rapport LSan (inclus dans ASan)

```
=================================================================
==12345==ERROR: LeakSanitizer: detected memory leaks

Direct leak of 4000 byte(s) in 10 object(s) allocated from:
    #0 0x7f123456 in malloc
    #1 0x401200 in function main.c:4
    #2 0x401250 in main main.c:10

SUMMARY: AddressSanitizer: 4000 byte(s) leaked in 10 allocation(s).
=================================================================
```

**Le rapport indique :**
- 4000 octets (10 allocations √ó 400 octets) non lib√©r√©s
- O√π les allocations ont eu lieu (ligne 4)

---

## ThreadSanitizer pour programmes multi-thread

### Code avec race condition

```c
#include <pthread.h>
#include <stdio.h>

int shared_counter = 0;  // Variable partag√©e non prot√©g√©e !

void *increment(void *arg) {
    for (int i = 0; i < 100000; i++) {
        shared_counter++;  // Race condition !
    }
    return NULL;
}

int main(void) {
    pthread_t t1, t2;

    pthread_create(&t1, NULL, increment, NULL);
    pthread_create(&t2, NULL, increment, NULL);

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    printf("Counter: %d\n", shared_counter);
    return 0;
}
```

### Compilation et ex√©cution avec TSan

```bash
gcc -fsanitize=thread -g -o app main.c -lpthread
./app
```

### Rapport TSan

```
==================
WARNING: ThreadSanitizer: data race (pid=12345)
  Write of size 4 at 0x601234 by thread T2:
    #0 increment main.c:7

  Previous write of size 4 at 0x601234 by thread T1:
    #0 increment main.c:7

  Location is global 'shared_counter' of size 4 at main.c:4
==================
```

**TSan d√©tecte la race condition sur `shared_counter` !**

---

## Workflow avec TSan pour programmes multi-thread

```yaml
name: Tests avec ThreadSanitizer

on: [push, pull_request]

jobs:
  test-tsan:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4

    - name: Configurer avec TSan
      run: |
        cmake -B build \
          -DCMAKE_BUILD_TYPE=Debug \
          -DCMAKE_C_FLAGS="-fsanitize=thread -g -O1"

    - name: Compiler
      run: cmake --build build

    - name: Lancer les tests multi-thread
      env:
        TSAN_OPTIONS: halt_on_error=1:second_deadlock_stack=1
      run: |
        cd build
        ctest --output-on-failure
```

---

## Matrice compl√®te : Sanitizers + Compilateurs

```yaml
name: CI Compl√®te avec Sanitizers

on: [push, pull_request]

jobs:
  test:
    name: ${{ matrix.compiler }}-${{ matrix.compiler-version }} / ${{ matrix.sanitizer }}
    runs-on: ubuntu-latest

    strategy:
      fail-fast: false
      matrix:
        compiler: [gcc, clang]
        compiler-version: [12, 13]
        sanitizer: [address, undefined, thread]

        exclude:
          # TSan a de meilleurs r√©sultats avec Clang
          - compiler: gcc
            sanitizer: thread

    steps:
    - uses: actions/checkout@v4

    - name: Installer le compilateur
      run: |
        sudo apt-get update
        if [ "${{ matrix.compiler }}" = "gcc" ]; then
          sudo apt-get install -y gcc-${{ matrix.compiler-version }}
          echo "CC=gcc-${{ matrix.compiler-version }}" >> $GITHUB_ENV
        else
          sudo apt-get install -y clang-${{ matrix.compiler-version }}
          echo "CC=clang-${{ matrix.compiler-version }}" >> $GITHUB_ENV
        fi

    - name: Configurer
      run: |
        cmake -B build \
          -DCMAKE_C_COMPILER=$CC \
          -DCMAKE_BUILD_TYPE=Debug \
          -DCMAKE_C_FLAGS="-fsanitize=${{ matrix.sanitizer }} -fno-omit-frame-pointer -g -O1"

    - name: Compiler
      run: cmake --build build

    - name: Lancer les tests
      run: |
        cd build
        ctest --output-on-failure
```

---

## Performance et overhead

### Comparaison des overhead

| Sanitizer | Overhead m√©moire | Overhead CPU | Utilisation |
|-----------|------------------|--------------|-------------|
| ASan | 2-3x | 2x | Tests unitaires, CI |
| UBSan | N√©gligeable | 1.2x | Tests unitaires, CI |
| TSan | 5-10x | 5-15x | Tests concurrence |
| LSan | Faible | N√©gligeable | Fin d'ex√©cution |

**Valgrind pour comparaison** : 20-50x overhead

### Recommandations

‚úÖ **Toujours en CI :**
- AddressSanitizer (ASan)
- UndefinedBehaviorSanitizer (UBSan)

‚úÖ **Si programme multi-thread :**
- ThreadSanitizer (TSan)

‚úÖ **En d√©veloppement local :**
- Tous les sanitizers pendant le d√©veloppement

‚ùå **Jamais en production :**
- Les sanitizers ne doivent JAMAIS √™tre activ√©s en production

---

## Faux positifs et suppressions

Parfois, un sanitizer peut signaler un "bug" qui n'en est pas un (faux positif). Vous pouvez cr√©er un fichier de suppression :

**asan_suppressions.txt**
```
# Supprimer les leaks de la libc (faux positifs)
leak:libc.so

# Supprimer une fonction sp√©cifique
leak:ma_fonction_externe
```

**Utilisation dans le workflow :**

```yaml
- name: Lancer avec suppressions
  env:
    LSAN_OPTIONS: suppressions=asan_suppressions.txt
  run: ./build/app
```

---

## Int√©gration avec compilation conditionnelle

Dans votre code, vous pouvez d√©tecter si ASan est actif :

```c
#if defined(__has_feature)
  #if __has_feature(address_sanitizer)
    #define RUNNING_ON_ASAN 1
  #endif
#elif defined(__SANITIZE_ADDRESS__)
  #define RUNNING_ON_ASAN 1
#endif

#ifdef RUNNING_ON_ASAN
  // Code sp√©cifique pour ASan
  printf("Running with AddressSanitizer\n");
#endif
```

Utile pour d√©sactiver certaines optimisations ou tests incompatibles.

---

## Debugging avec sanitizers

### Obtenir plus d'informations

```yaml
- name: Lancer avec debug verbeux
  env:
    ASAN_OPTIONS: verbosity=1:debug=1
  run: ./build/app
```

### G√©n√©rer un core dump lors d'une erreur

```yaml
- name: Lancer avec core dump
  env:
    ASAN_OPTIONS: abort_on_error=1:disable_coredump=0
  run: |
    ulimit -c unlimited
    ./build/app
```

---

## Workflow complet et production-ready

Voici un workflow complet qui combine tout :

```yaml
name: CI avec Sanitizers Complets

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test-sanitizers:
    name: ${{ matrix.name }}
    runs-on: ubuntu-latest

    strategy:
      fail-fast: false
      matrix:
        include:
          - name: "ASan + UBSan"
            sanitizer: "address,undefined"
            cc: gcc-13

          - name: "TSan"
            sanitizer: "thread"
            cc: clang-15

          - name: "LSan seul"
            sanitizer: "leak"
            cc: gcc-13

    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        submodules: recursive

    - name: Installer le compilateur
      run: |
        sudo apt-get update
        sudo apt-get install -y ${{ matrix.cc }}

    - name: Configurer
      run: |
        cmake -B build \
          -DCMAKE_C_COMPILER=${{ matrix.cc }} \
          -DCMAKE_BUILD_TYPE=Debug \
          -DCMAKE_C_FLAGS="-fsanitize=${{ matrix.sanitizer }} -fno-omit-frame-pointer -g -O1"

    - name: Compiler
      run: cmake --build build -j$(nproc)

    - name: Lancer les tests
      env:
        ASAN_OPTIONS: detect_leaks=1:halt_on_error=0:print_stats=1
        UBSAN_OPTIONS: print_stacktrace=1:halt_on_error=0
        TSAN_OPTIONS: halt_on_error=0:second_deadlock_stack=1
      run: |
        cd build
        ctest --output-on-failure --verbose

    - name: Uploader les logs (si √©chec)
      if: failure()
      uses: actions/upload-artifact@v4
      with:
        name: sanitizer-logs-${{ matrix.name }}
        path: |
          build/Testing/Temporary/
          build/**/*.log
```

---

## Comparaison : Sanitizers vs Valgrind

| Crit√®re | Sanitizers | Valgrind |
|---------|-----------|----------|
| **Overhead** | 2-3x | 20-50x |
| **Vitesse CI** | ‚úÖ Rapide | ‚ùå Tr√®s lent |
| **Facilit√©** | ‚úÖ Flag de compilation | Outil externe |
| **D√©tection** | M√©moire, UB, threads | M√©moire principalement |
| **Pr√©cision** | ‚úÖ Tr√®s pr√©cise | ‚úÖ Tr√®s pr√©cise |
| **Quand utiliser** | CI quotidienne | Tests approfondis ponctuels |

**Recommandation :** Utilisez les sanitizers en CI, Valgrind pour investigations approfondies.

---

## Bonnes pratiques

### 1. Toujours compiler avec `-g`

```bash
-fsanitize=address -g  # Stack traces lisibles
```

Sans `-g`, les rapports ne montreront que des adresses m√©moire.

### 2. Utilisez `-O1` en Debug

```bash
-fsanitize=address -g -O1  # Meilleur √©quilibre
```

`-O1` am√©liore les performances sans nuire au debugging.

### 3. Combinez ASan et UBSan

```bash
-fsanitize=address,undefined
```

Ces deux sanitizers sont compl√©mentaires et compatibles.

### 4. Testez avec TSan pour le multi-threading

Si votre code utilise pthread ou std::thread, testez TOUJOURS avec TSan.

### 5. Ne les activez JAMAIS en production

Les sanitizers ajoutent un overhead important et sont r√©serv√©s au d√©veloppement/CI.

### 6. Corrigez TOUS les bugs d√©tect√©s

Ne supprimez pas les warnings sans comprendre. Chaque erreur d√©tect√©e est un vrai bug.

---

## Erreurs courantes et solutions

### Erreur : "Sanitizer libraries not found"

**Solution :**
```yaml
- name: Installer les biblioth√®ques sanitizer
  run: sudo apt-get install -y libasan6 libubsan1 libtsan0
```

### Erreur : "Cannot combine ASan and TSan"

**Solution :** Utilisez des jobs s√©par√©s dans la matrice.

### Performances trop lentes

**Solution :** Augmentez `-O1` √† `-O2` :
```bash
-fsanitize=address -O2
```

### Trop de faux positifs

**Solution :** Cr√©ez un fichier de suppressions (voir section pr√©c√©dente).

---

## R√©sum√©

**Les 4 sanitizers essentiels :**

1. **ASan** (`-fsanitize=address`) : Bugs m√©moire
2. **UBSan** (`-fsanitize=undefined`) : Comportements ind√©finis
3. **TSan** (`-fsanitize=thread`) : Race conditions
4. **LSan** (`-fsanitize=leak`) : Fuites m√©moire (inclus dans ASan)

**Flags de compilation recommand√©s :**
```bash
-fsanitize=address,undefined -fno-omit-frame-pointer -g -O1
```

**En CI, testez avec :**
- ASan + UBSan (combin√©s)
- TSan (s√©par√© si multi-thread)

---

## Prochaines √©tapes

Maintenant que vous utilisez les sanitizers, vous pouvez :

- Ajouter **Valgrind** pour des analyses approfondies
- Configurer l'**analyse statique** avec clang-tidy
- Mesurer la **couverture de code** avec gcov
- Impl√©menter des **tests de performance**

Ces sujets sont couverts dans les sections suivantes.

---

## Ressources compl√©mentaires

- [AddressSanitizer Wiki](https://github.com/google/sanitizers/wiki/AddressSanitizer)
- [UndefinedBehaviorSanitizer](https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html)
- [ThreadSanitizer](https://github.com/google/sanitizers/wiki/ThreadSanitizerCppManual)
- [GCC Sanitizer Options](https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html)

---

**üéØ Points cl√©s √† retenir :**

- ‚úÖ Les sanitizers d√©tectent bugs m√©moire, UB et race conditions
- ‚úÖ ASan est le plus important : activez-le toujours en CI
- ‚úÖ Combinez ASan + UBSan pour une couverture maximale
- ‚úÖ TSan pour le multi-threading (incompatible avec ASan)
- ‚úÖ Flag minimal : `-fsanitize=address -g`
- ‚úÖ Overhead acceptable en CI : 2-3x (vs 20-50x pour Valgrind)
- ‚úÖ JAMAIS en production, seulement en dev/CI
- ‚úÖ Corrigez tous les bugs d√©tect√©s, ce sont de vrais probl√®mes

‚è≠Ô∏è [Analyse Valgrind automatis√©e](/30-integration-continue/01.6-analyse-valgrind.md)
