ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 34.1.3 Output formatÃ©

## Introduction

Un outil CLI professionnel ne se contente pas de fonctionner correctement : il doit aussi prÃ©senter ses rÃ©sultats de maniÃ¨re claire, lisible et esthÃ©tique. Un output bien formatÃ© amÃ©liore l'expÃ©rience utilisateur et rend votre outil plus facile Ã  comprendre et Ã  utiliser.

Dans cette section, nous explorerons les diffÃ©rentes techniques pour crÃ©er des sorties formatÃ©es professionnelles en C.

---

## 1. Les bases de printf()

### 1.1 SpÃ©cificateurs de format essentiels

```c
#include <stdio.h>

int main() {
    int entier = 42;
    float flottant = 3.14159;
    char caractere = 'A';
    char *chaine = "Hello";
    void *pointeur = &entier;

    // Formats de base
    printf("Entier dÃ©cimal: %d\n", entier);
    printf("Entier hexadÃ©cimal: %x\n", entier);
    printf("Entier octal: %o\n", entier);
    printf("Flottant: %f\n", flottant);
    printf("Notation scientifique: %e\n", flottant);
    printf("CaractÃ¨re: %c\n", caractere);
    printf("ChaÃ®ne: %s\n", chaine);
    printf("Pointeur: %p\n", pointeur);

    return 0;
}
```

**Sortie :**
```
Entier dÃ©cimal: 42  
Entier hexadÃ©cimal: 2a  
Entier octal: 52  
Flottant: 3.141590  
Notation scientifique: 3.141590e+00  
CaractÃ¨re: A  
ChaÃ®ne: Hello  
Pointeur: 0x7ffd5c4e8a7c  
```

### 1.2 Largeur et prÃ©cision

```c
#include <stdio.h>

int main() {
    int num = 42;
    float pi = 3.14159265;

    // Largeur minimale
    printf("|%5d|\n", num);      // |   42|
    printf("|%-5d|\n", num);     // |42   |

    // Remplissage avec zÃ©ros
    printf("%05d\n", num);       // 00042

    // PrÃ©cision pour les flottants
    printf("%.2f\n", pi);        // 3.14
    printf("%.4f\n", pi);        // 3.1416

    // Largeur et prÃ©cision combinÃ©es
    printf("%8.2f\n", pi);       // "    3.14"
    printf("%-8.2f\n", pi);      // "3.14    "

    // ChaÃ®nes avec limitation
    printf("%.5s\n", "Hello World");  // "Hello"

    return 0;
}
```

### 1.3 Formatage dynamique

```c
#include <stdio.h>

int main() {
    int largeur = 10;
    int precision = 2;
    float nombre = 3.14159;

    // Utiliser * pour des valeurs dynamiques
    printf("%*.*f\n", largeur, precision, nombre);  // "      3.14"

    return 0;
}
```

---

## 2. Couleurs et styles dans le terminal

### 2.1 Codes ANSI de base

Les codes ANSI permettent d'ajouter des couleurs et des styles au texte dans le terminal.

```c
#include <stdio.h>

// Codes de couleur ANSI
#define RESET   "\033[0m"
#define RED     "\033[31m"
#define GREEN   "\033[32m"
#define YELLOW  "\033[33m"
#define BLUE    "\033[34m"
#define MAGENTA "\033[35m"
#define CYAN    "\033[36m"
#define WHITE   "\033[37m"

// Styles
#define BOLD    "\033[1m"
#define DIM     "\033[2m"
#define ITALIC  "\033[3m"
#define UNDERLINE "\033[4m"

int main() {
    printf(RED "Texte rouge\n" RESET);
    printf(GREEN "Texte vert\n" RESET);
    printf(BOLD "Texte gras\n" RESET);
    printf(BOLD RED "Texte gras et rouge\n" RESET);

    return 0;
}
```

### 2.2 Couleurs de fond

```c
#include <stdio.h>

#define BG_RED     "\033[41m"
#define BG_GREEN   "\033[42m"
#define BG_YELLOW  "\033[43m"
#define BG_BLUE    "\033[44m"
#define RESET      "\033[0m"

int main() {
    printf(BG_RED "Fond rouge" RESET "\n");
    printf(BG_GREEN "Fond vert" RESET "\n");

    return 0;
}
```

### 2.3 DÃ©tection du support des couleurs

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int terminal_supporte_couleurs() {
    // VÃ©rifier si stdout est un terminal
    if (!isatty(STDOUT_FILENO)) {
        return 0;
    }

    // VÃ©rifier la variable TERM
    const char *term = getenv("TERM");
    if (term == NULL) {
        return 0;
    }

    // VÃ©rifier si NO_COLOR est dÃ©fini
    if (getenv("NO_COLOR") != NULL) {
        return 0;
    }

    return 1;
}

void print_couleur(const char *couleur, const char *texte) {
    if (terminal_supporte_couleurs()) {
        printf("%s%s\033[0m\n", couleur, texte);
    } else {
        printf("%s\n", texte);
    }
}

int main() {
    print_couleur("\033[32m", "Texte vert (si supportÃ©)");
    return 0;
}
```

---

## 3. Messages de statut et logs

### 3.1 Niveaux de log standardisÃ©s

```c
#include <stdio.h>
#include <time.h>
#include <stdarg.h>

#define RED     "\033[31m"
#define GREEN   "\033[32m"
#define YELLOW  "\033[33m"
#define BLUE    "\033[34m"
#define RESET   "\033[0m"

typedef enum {
    LOG_DEBUG,
    LOG_INFO,
    LOG_SUCCESS,
    LOG_WARNING,
    LOG_ERROR
} LogLevel;

void log_message(LogLevel level, const char *format, ...) {
    // Horodatage
    time_t now = time(NULL);
    struct tm *t = localtime(&now);
    char timestamp[32];
    strftime(timestamp, sizeof(timestamp), "%Y-%m-%d %H:%M:%S", t);

    // PrÃ©fixe selon le niveau
    const char *prefix;
    const char *color;

    switch (level) {
        case LOG_DEBUG:
            prefix = "DEBUG";
            color = BLUE;
            break;
        case LOG_INFO:
            prefix = "INFO ";
            color = "";
            break;
        case LOG_SUCCESS:
            prefix = "OK   ";
            color = GREEN;
            break;
        case LOG_WARNING:
            prefix = "WARN ";
            color = YELLOW;
            break;
        case LOG_ERROR:
            prefix = "ERROR";
            color = RED;
            break;
        default:
            prefix = "LOG  ";
            color = "";
    }

    // Afficher le prÃ©fixe
    printf("[%s] %s%s%s ", timestamp, color, prefix, RESET);

    // Afficher le message avec arguments variables
    va_list args;
    va_start(args, format);
    vprintf(format, args);
    va_end(args);

    printf("\n");
}

int main() {
    log_message(LOG_DEBUG, "Mode debug activÃ©");
    log_message(LOG_INFO, "DÃ©marrage du programme");
    log_message(LOG_SUCCESS, "Connexion Ã©tablie avec succÃ¨s");
    log_message(LOG_WARNING, "Fichier de configuration manquant, utilisation des valeurs par dÃ©faut");
    log_message(LOG_ERROR, "Impossible d'ouvrir le fichier %s", "data.txt");

    return 0;
}
```

**Sortie :**
```
[2025-01-15 14:30:45] DEBUG Mode debug activÃ©
[2025-01-15 14:30:45] INFO  DÃ©marrage du programme
[2025-01-15 14:30:45] OK    Connexion Ã©tablie avec succÃ¨s
[2025-01-15 14:30:45] WARN  Fichier de configuration manquant, utilisation des valeurs par dÃ©faut
[2025-01-15 14:30:45] ERROR Impossible d'ouvrir le fichier data.txt
```

### 3.2 Symboles Unicode pour les statuts

```c
#include <stdio.h>

#define CHECK_MARK  "âœ“"
#define CROSS_MARK  "âœ—"
#define INFO_MARK   "â„¹"
#define WARNING     "âš "
#define ARROW       "â†’"

void print_status(int success, const char *message) {
    if (success) {
        printf("\033[32m%s\033[0m %s\n", CHECK_MARK, message);
    } else {
        printf("\033[31m%s\033[0m %s\n", CROSS_MARK, message);
    }
}

int main() {
    print_status(1, "Compilation rÃ©ussie");
    print_status(0, "Tests Ã©chouÃ©s");
    printf("%s %s Traitement en cours...\n", INFO_MARK, ARROW);
    printf("%s %s Attention: espace disque faible\n", WARNING, ARROW);

    return 0;
}
```

---

## 4. Tableaux formatÃ©s

### 4.1 Tableau simple avec alignement

```c
#include <stdio.h>
#include <string.h>

typedef struct {
    char nom[32];
    int age;
    float salaire;
} Personne;

void afficher_tableau(Personne *personnes, int count) {
    // En-tÃªte
    printf("+----------------------+-----+------------+\n");
    printf("| %-20s | %-3s | %-10s |\n", "Nom", "Age", "Salaire");
    printf("+----------------------+-----+------------+\n");

    // Lignes de donnÃ©es
    for (int i = 0; i < count; i++) {
        printf("| %-20s | %3d | %10.2f |\n",
               personnes[i].nom,
               personnes[i].age,
               personnes[i].salaire);
    }

    printf("+----------------------+-----+------------+\n");
}

int main() {
    Personne personnes[] = {
        {"Alice Dupont", 28, 45000.50},
        {"Bob Martin", 35, 52000.00},
        {"Charlie Durant", 42, 61500.75}
    };

    afficher_tableau(personnes, 3);
    return 0;
}
```

**Sortie :**
```
+----------------------+-----+------------+
| Nom                  | Age | Salaire    |
+----------------------+-----+------------+
| Alice Dupont         |  28 |   45000.50 |
| Bob Martin           |  35 |   52000.00 |
| Charlie Durant       |  42 |   61500.75 |
+----------------------+-----+------------+
```

### 4.2 Tableau avec couleurs alternÃ©es

```c
#include <stdio.h>

#define RESET  "\033[0m"
#define BG_GRAY "\033[48;5;240m"

typedef struct {
    char nom[32];
    int valeur;
} Item;

void afficher_tableau_colore(Item *items, int count) {
    printf("â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”\n");
    printf("â”‚ %-18s â”‚ %-6s â”‚\n", "Nom", "Valeur");
    printf("â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n");

    for (int i = 0; i < count; i++) {
        if (i % 2 == 0) {
            printf("%s", BG_GRAY);
        }
        printf("â”‚ %-18s â”‚ %6d â”‚%s\n",
               items[i].nom,
               items[i].valeur,
               RESET);
    }

    printf("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n");
}

int main() {
    Item items[] = {
        {"CPU", 45},
        {"RAM", 8192},
        {"Disque", 512},
        {"RÃ©seau", 1000}
    };

    afficher_tableau_colore(items, 4);
    return 0;
}
```

### 4.3 Tableau avec caractÃ¨res Unicode

```c
#include <stdio.h>
#include <wchar.h>
#include <locale.h>

void afficher_tableau_unicode() {
    setlocale(LC_ALL, "");

    wprintf(L"â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    wprintf(L"â•‘ %-18s â•‘ %-5s â•‘ %-10s â•‘\n", "Produit", "QtÃ©", "Prix");
    wprintf(L"â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•£\n");
    wprintf(L"â•‘ %-18s â•‘ %5d â•‘ %10.2f â•‘\n", "Clavier", 5, 49.99);
    wprintf(L"â•‘ %-18s â•‘ %5d â•‘ %10.2f â•‘\n", "Souris", 10, 29.99);
    wprintf(L"â•‘ %-18s â•‘ %5d â•‘ %10.2f â•‘\n", "Ã‰cran", 2, 299.99);
    wprintf(L"â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•£\n");
    wprintf(L"â•‘ Total                      â•‘ %10.2f â•‘\n", 899.93);
    wprintf(L"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
}
```

---

## 5. Barres de progression

### 5.1 Barre de progression simple

```c
#include <stdio.h>
#include <unistd.h>

void afficher_barre_progression(int pourcentage) {
    int largeur = 50;
    int rempli = (pourcentage * largeur) / 100;

    printf("\r[");
    for (int i = 0; i < largeur; i++) {
        if (i < rempli) {
            printf("â–ˆ");
        } else {
            printf(" ");
        }
    }
    printf("] %3d%%", pourcentage);
    fflush(stdout);
}

int main() {
    printf("TÃ©lÃ©chargement en cours...\n");

    for (int i = 0; i <= 100; i += 5) {
        afficher_barre_progression(i);
        usleep(100000);  // 100ms
    }

    printf("\nâœ“ TÃ©lÃ©chargement terminÃ©!\n");
    return 0;
}
```

### 5.2 Barre de progression avec couleur

```c
#include <stdio.h>
#include <unistd.h>

#define GREEN  "\033[32m"
#define YELLOW "\033[33m"
#define RED    "\033[31m"
#define RESET  "\033[0m"

void afficher_barre_coloree(int pourcentage, long octets, long total) {
    int largeur = 40;
    int rempli = (pourcentage * largeur) / 100;

    // Choisir la couleur selon le pourcentage
    const char *couleur;
    if (pourcentage < 50) {
        couleur = RED;
    } else if (pourcentage < 80) {
        couleur = YELLOW;
    } else {
        couleur = GREEN;
    }

    printf("\r%s", couleur);
    printf("[");
    for (int i = 0; i < largeur; i++) {
        if (i < rempli) {
            printf("=");
        } else if (i == rempli) {
            printf(">");
        } else {
            printf(" ");
        }
    }
    printf("]%s %3d%% (%ld/%ld Ko)", RESET, pourcentage, octets/1024, total/1024);
    fflush(stdout);
}

int main() {
    long total = 10485760;  // 10 MB

    for (long octets = 0; octets <= total; octets += total/20) {
        int pourcentage = (octets * 100) / total;
        afficher_barre_coloree(pourcentage, octets, total);
        usleep(100000);
    }

    printf("\n");
    return 0;
}
```

### 5.3 Spinner (indicateur rotatif)

```c
#include <stdio.h>
#include <unistd.h>

void afficher_spinner(const char *message, int iterations) {
    const char *frames[] = {"â ‹", "â ™", "â ¹", "â ¸", "â ¼", "â ´", "â ¦", "â §", "â ‡", "â "};
    int nb_frames = 10;

    for (int i = 0; i < iterations; i++) {
        printf("\r%s %s", frames[i % nb_frames], message);
        fflush(stdout);
        usleep(100000);
    }

    printf("\râœ“ %s\n", message);
}

int main() {
    afficher_spinner("Chargement des donnÃ©es...", 30);
    afficher_spinner("Traitement en cours...", 25);
    afficher_spinner("Finalisation...", 15);

    return 0;
}
```

---

## 6. Formatage de donnÃ©es

### 6.1 Tailles de fichiers lisibles

```c
#include <stdio.h>
#include <stdint.h>

void format_taille(uint64_t octets, char *buffer, size_t buffer_size) {
    const char *unites[] = {"o", "Ko", "Mo", "Go", "To"};
    int unite_index = 0;
    double taille = (double)octets;

    while (taille >= 1024.0 && unite_index < 4) {
        taille /= 1024.0;
        unite_index++;
    }

    if (unite_index == 0) {
        snprintf(buffer, buffer_size, "%lu %s", octets, unites[unite_index]);
    } else {
        snprintf(buffer, buffer_size, "%.2f %s", taille, unites[unite_index]);
    }
}

int main() {
    uint64_t tailles[] = {512, 1024, 1048576, 1073741824, 1099511627776ULL};
    char buffer[32];

    for (int i = 0; i < 5; i++) {
        format_taille(tailles[i], buffer, sizeof(buffer));
        printf("%15lu octets = %s\n", tailles[i], buffer);
    }

    return 0;
}
```

**Sortie :**
```
            512 octets = 512 o
           1024 octets = 1.00 Ko
        1048576 octets = 1.00 Mo
     1073741824 octets = 1.00 Go
  1099511627776 octets = 1.00 To
```

### 6.2 Dates et heures formatÃ©es

```c
#include <stdio.h>
#include <time.h>

void afficher_dates() {
    time_t now = time(NULL);
    struct tm *t = localtime(&now);
    char buffer[100];

    // Format ISO 8601
    strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M:%S", t);
    printf("ISO 8601:     %s\n", buffer);

    // Format franÃ§ais
    strftime(buffer, sizeof(buffer), "%d/%m/%Y Ã  %H:%M:%S", t);
    printf("FR:           %s\n", buffer);

    // Format complet
    strftime(buffer, sizeof(buffer), "%A %d %B %Y, %H:%M:%S", t);
    printf("Complet:      %s\n", buffer);

    // Timestamp Unix
    printf("Unix:         %ld\n", now);

    // Relatif
    time_t hier = now - 86400;
    struct tm *hier_tm = localtime(&hier);
    strftime(buffer, sizeof(buffer), "%Y-%m-%d", hier_tm);
    printf("Hier:         %s\n", buffer);
}
```

### 6.3 DurÃ©es lisibles

```c
#include <stdio.h>

void format_duree(long secondes, char *buffer, size_t size) {
    long jours = secondes / 86400;
    long heures = (secondes % 86400) / 3600;
    long minutes = (secondes % 3600) / 60;
    long secs = secondes % 60;

    if (jours > 0) {
        snprintf(buffer, size, "%ldj %ldh %ldm %lds", jours, heures, minutes, secs);
    } else if (heures > 0) {
        snprintf(buffer, size, "%ldh %ldm %lds", heures, minutes, secs);
    } else if (minutes > 0) {
        snprintf(buffer, size, "%ldm %lds", minutes, secs);
    } else {
        snprintf(buffer, size, "%lds", secs);
    }
}

int main() {
    long durees[] = {45, 125, 3665, 90125, 259265};
    char buffer[64];

    for (int i = 0; i < 5; i++) {
        format_duree(durees[i], buffer, sizeof(buffer));
        printf("%7lds = %s\n", durees[i], buffer);
    }

    return 0;
}
```

**Sortie :**
```
     45s = 45s
    125s = 2m 5s
   3665s = 1h 1m 5s
  90125s = 1j 1h 2m 5s
 259265s = 3j 0h 1m 5s
```

---

## 7. Formats de sortie structurÃ©s

### 7.1 JSON simple

```c
#include <stdio.h>
#include <string.h>

void echapper_json(const char *str, char *buffer, size_t size) {
    size_t j = 0;
    for (size_t i = 0; i < strlen(str) && j < size - 2; i++) {
        if (str[i] == '"' || str[i] == '\\') {
            buffer[j++] = '\\';
        }
        buffer[j++] = str[i];
    }
    buffer[j] = '\0';
}

void afficher_json_objet() {
    printf("{\n");
    printf("  \"nom\": \"Alice\",\n");
    printf("  \"age\": 28,\n");
    printf("  \"actif\": true,\n");
    printf("  \"email\": \"alice@example.com\"\n");
    printf("}\n");
}

void afficher_json_tableau() {
    printf("[\n");
    printf("  {\"id\": 1, \"nom\": \"Alice\"},\n");
    printf("  {\"id\": 2, \"nom\": \"Bob\"},\n");
    printf("  {\"id\": 3, \"nom\": \"Charlie\"}\n");
    printf("]\n");
}

int main() {
    printf("Objet JSON:\n");
    afficher_json_objet();

    printf("\nTableau JSON:\n");
    afficher_json_tableau();

    return 0;
}
```

### 7.2 CSV

```c
#include <stdio.h>
#include <string.h>

void afficher_csv_header() {
    printf("nom,age,ville,salaire\n");
}

void afficher_csv_ligne(const char *nom, int age, const char *ville, float salaire) {
    // GÃ©rer les champs avec virgules
    if (strchr(nom, ',') || strchr(ville, ',')) {
        printf("\"%s\",%d,\"%s\",%.2f\n", nom, age, ville, salaire);
    } else {
        printf("%s,%d,%s,%.2f\n", nom, age, ville, salaire);
    }
}

int main() {
    afficher_csv_header();
    afficher_csv_ligne("Alice", 28, "Paris", 45000.0);
    afficher_csv_ligne("Bob", 35, "Lyon", 52000.0);
    afficher_csv_ligne("Charlie, Jr.", 42, "Marseille", 61500.0);

    return 0;
}
```

### 7.3 YAML simple

```c
#include <stdio.h>

void afficher_yaml() {
    printf("---\n");
    printf("application:\n");
    printf("  nom: mon_app\n");
    printf("  version: 1.2.3\n");
    printf("  auteur: Alice Dupont\n");
    printf("\n");
    printf("configuration:\n");
    printf("  port: 8080\n");
    printf("  debug: true\n");
    printf("  serveurs:\n");
    printf("    - nom: prod-01\n");
    printf("      ip: 192.168.1.10\n");
    printf("    - nom: prod-02\n");
    printf("      ip: 192.168.1.11\n");
}
```

---

## 8. Interfaces interactives

### 8.1 Menu simple

```c
#include <stdio.h>

void afficher_menu() {
    printf("\n");
    printf("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    printf("â•‘       MENU PRINCIPAL           â•‘\n");
    printf("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n");
    printf("â•‘ 1. Nouveau projet              â•‘\n");
    printf("â•‘ 2. Ouvrir projet               â•‘\n");
    printf("â•‘ 3. ParamÃ¨tres                  â•‘\n");
    printf("â•‘ 4. Aide                        â•‘\n");
    printf("â•‘ 0. Quitter                     â•‘\n");
    printf("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("\nVotre choix: ");
}

int main() {
    int choix;

    do {
        afficher_menu();
        if (scanf("%d", &choix) != 1) {
            while (getchar() != '\n');  // Vider le buffer
            continue;
        }

        switch (choix) {
            case 1:
                printf("\nâ†’ CrÃ©ation d'un nouveau projet...\n");
                break;
            case 2:
                printf("\nâ†’ Ouverture d'un projet...\n");
                break;
            case 3:
                printf("\nâ†’ ParamÃ¨tres...\n");
                break;
            case 4:
                printf("\nâ†’ Aide...\n");
                break;
            case 0:
                printf("\nâœ“ Au revoir!\n");
                break;
            default:
                printf("\nâœ— Choix invalide!\n");
        }
    } while (choix != 0);

    return 0;
}
```

### 8.2 Liste sÃ©lectionnable avec flÃ¨ches

```c
#include <stdio.h>
#include <termios.h>
#include <unistd.h>

// Activer le mode raw du terminal
void activer_mode_raw() {
    struct termios term;
    tcgetattr(STDIN_FILENO, &term);
    term.c_lflag &= ~(ICANON | ECHO);
    tcsetattr(STDIN_FILENO, TCSANOW, &term);
}

// Restaurer le mode normal
void restaurer_mode_normal() {
    struct termios term;
    tcgetattr(STDIN_FILENO, &term);
    term.c_lflag |= (ICANON | ECHO);
    tcsetattr(STDIN_FILENO, TCSANOW, &term);
}

void afficher_liste(const char *items[], int count, int selection) {
    printf("\033[2J\033[H");  // Effacer l'Ã©cran
    printf("Utilisez â†‘â†“ pour sÃ©lectionner, EntrÃ©e pour valider\n\n");

    for (int i = 0; i < count; i++) {
        if (i == selection) {
            printf("  \033[7mâ†’ %s\033[0m\n", items[i]);  // InversÃ©
        } else {
            printf("    %s\n", items[i]);
        }
    }
}

int main() {
    const char *items[] = {
        "Option 1: DÃ©marrer le service",
        "Option 2: ArrÃªter le service",
        "Option 3: RedÃ©marrer le service",
        "Option 4: Afficher le statut",
        "Option 5: Quitter"
    };
    int count = 5;
    int selection = 0;

    activer_mode_raw();

    while (1) {
        afficher_liste(items, count, selection);

        char c = getchar();

        if (c == '\033') {  // SÃ©quence d'Ã©chappement
            getchar();  // [
            char arrow = getchar();

            if (arrow == 'A' && selection > 0) {  // FlÃ¨che haut
                selection--;
            } else if (arrow == 'B' && selection < count - 1) {  // FlÃ¨che bas
                selection++;
            }
        } else if (c == '\n') {  // EntrÃ©e
            break;
        }
    }

    restaurer_mode_normal();

    printf("\nVous avez sÃ©lectionnÃ©: %s\n", items[selection]);

    return 0;
}
```

---

## 9. Graphiques ASCII

### 9.1 Graphique Ã  barres horizontal

```c
#include <stdio.h>

void afficher_barre_horizontale(const char *label, int valeur, int max) {
    int largeur_max = 40;
    int largeur = (valeur * largeur_max) / max;

    printf("%-15s â”‚", label);
    for (int i = 0; i < largeur; i++) {
        printf("â–ˆ");
    }
    printf(" %d\n", valeur);
}

int main() {
    printf("Utilisation des ressources\n\n");

    afficher_barre_horizontale("CPU", 65, 100);
    afficher_barre_horizontale("RAM", 82, 100);
    afficher_barre_horizontale("Disque", 45, 100);
    afficher_barre_horizontale("RÃ©seau", 30, 100);

    return 0;
}
```

**Sortie :**
```
Utilisation des ressources

CPU             â”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 65  
RAM             â”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–Œ 82  
Disque          â”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 45  
RÃ©seau          â”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 30  
```

### 9.2 Graphique en ligne

```c
#include <stdio.h>
#include <math.h>

void afficher_graphique_ligne(float *valeurs, int count) {
    int hauteur = 20;

    // Trouver min et max
    float min = valeurs[0], max = valeurs[0];
    for (int i = 1; i < count; i++) {
        if (valeurs[i] < min) min = valeurs[i];
        if (valeurs[i] > max) max = valeurs[i];
    }

    // Afficher le graphique
    for (int ligne = hauteur; ligne >= 0; ligne--) {
        float seuil = min + (max - min) * ligne / hauteur;

        printf("%6.1f â”‚", seuil);

        for (int i = 0; i < count; i++) {
            if (valeurs[i] >= seuil) {
                if (i > 0 && valeurs[i-1] < seuil) {
                    printf("â•±");
                } else if (i < count-1 && valeurs[i+1] < seuil) {
                    printf("â•²");
                } else {
                    printf("â”€");
                }
            } else {
                printf(" ");
            }
        }
        printf("\n");
    }

    printf("       â””");
    for (int i = 0; i < count; i++) printf("â”€");
    printf("\n");
}

int main() {
    float valeurs[] = {10, 15, 13, 20, 25, 22, 28, 30, 27, 32, 35, 33};
    int count = sizeof(valeurs) / sizeof(valeurs[0]);

    printf("Ã‰volution des ventes\n\n");
    afficher_graphique_ligne(valeurs, count);

    return 0;
}
```

---

## 10. Bonnes pratiques

### 10.1 Sortie adaptative selon le contexte

```c
#include <stdio.h>
#include <unistd.h>

typedef enum {
    FORMAT_HUMAN,   // Pour les humains (couleurs, tableaux)
    FORMAT_MACHINE  // Pour les scripts (simple, parsable)
} FormatSortie;

FormatSortie detecter_format() {
    // Si stdout n'est pas un terminal, format machine
    if (!isatty(STDOUT_FILENO)) {
        return FORMAT_MACHINE;
    }
    return FORMAT_HUMAN;
}

void afficher_resultat(int code, const char *message, FormatSortie format) {
    if (format == FORMAT_HUMAN) {
        const char *symbole = code == 0 ? "\033[32mâœ“\033[0m" : "\033[31mâœ—\033[0m";
        printf("%s %s\n", symbole, message);
    } else {
        printf("%d %s\n", code, message);
    }
}

int main() {
    FormatSortie format = detecter_format();

    afficher_resultat(0, "OpÃ©ration rÃ©ussie", format);
    afficher_resultat(1, "Erreur dÃ©tectÃ©e", format);

    return 0;
}
```

### 10.2 Niveaux de verbositÃ©

```c
#include <stdio.h>
#include <string.h>

typedef enum {
    VERBOSITY_QUIET = 0,   // Silence total
    VERBOSITY_NORMAL = 1,  // Messages essentiels
    VERBOSITY_VERBOSE = 2, // DÃ©tails
    VERBOSITY_DEBUG = 3    // Tout
} Verbosity;

static Verbosity verbosity = VERBOSITY_NORMAL;

void print_quiet(const char *msg) {
    // Toujours affichÃ© (erreurs critiques)
    fprintf(stderr, "%s\n", msg);
}

void print_normal(const char *msg) {
    if (verbosity >= VERBOSITY_NORMAL) {
        printf("%s\n", msg);
    }
}

void print_verbose(const char *msg) {
    if (verbosity >= VERBOSITY_VERBOSE) {
        printf("â†’ %s\n", msg);
    }
}

void print_debug(const char *msg) {
    if (verbosity >= VERBOSITY_DEBUG) {
        printf("[DEBUG] %s\n", msg);
    }
}

int main(int argc, char *argv[]) {
    // Analyser -v, -vv, -vvv
    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "-v") == 0) {
            verbosity = VERBOSITY_VERBOSE;
        } else if (strcmp(argv[i], "-vv") == 0) {
            verbosity = VERBOSITY_DEBUG;
        } else if (strcmp(argv[i], "-q") == 0) {
            verbosity = VERBOSITY_QUIET;
        }
    }

    print_debug("Mode debug activÃ©");
    print_verbose("Chargement de la configuration");
    print_normal("DÃ©marrage du programme");

    return 0;
}
```

### 10.3 Sortie vers fichier ou stdout

```c
#include <stdio.h>
#include <string.h>

FILE *ouvrir_sortie(const char *fichier) {
    if (fichier == NULL || strcmp(fichier, "-") == 0) {
        return stdout;
    }

    FILE *fp = fopen(fichier, "w");
    if (fp == NULL) {
        perror("Erreur ouverture fichier");
        return stdout;
    }

    return fp;
}

void fermer_sortie(FILE *fp) {
    if (fp != stdout) {
        fclose(fp);
    }
}

int main(int argc, char *argv[]) {
    const char *fichier_sortie = argc > 1 ? argv[1] : NULL;

    FILE *out = ouvrir_sortie(fichier_sortie);

    fprintf(out, "Ligne 1\n");
    fprintf(out, "Ligne 2\n");
    fprintf(out, "Ligne 3\n");

    fermer_sortie(out);

    return 0;
}
```

---

## 11. RÃ©capitulatif

### Checklist de l'output professionnel

- âœ… **LisibilitÃ©** : Utiliser des tableaux, alignements, couleurs appropriÃ©es
- âœ… **Consistance** : Format uniforme dans tout le programme
- âœ… **AdaptabilitÃ©** : DÃ©tecter si stdout est un terminal
- âœ… **Progression** : Barres de progression pour opÃ©rations longues
- âœ… **Niveaux de log** : DEBUG, INFO, WARNING, ERROR
- âœ… **Formats structurÃ©s** : JSON, CSV pour l'interopÃ©rabilitÃ©
- âœ… **VerbositÃ© rÃ©glable** : Options -q, -v, -vv
- âœ… **Codes de couleur** : Respecter NO_COLOR si dÃ©fini
- âœ… **Localisation** : Support UTF-8 pour Unicode
- âœ… **Documentation** : Messages d'aide clairs

### Outils recommandÃ©s

| Besoin | Solution |
|--------|----------|
| Couleurs | Codes ANSI |
| Tableaux | Box drawing chars Unicode |
| Progression | Barres avec `\r` et `fflush()` |
| JSON | GÃ©nÃ©ration manuelle ou bibliothÃ¨que |
| Logging | Niveaux + timestamps |
| Formats de donnÃ©es | snprintf() avec formatage |

---

## Conclusion

Un output bien formatÃ© transforme un outil fonctionnel en outil professionnel. Les points clÃ©s Ã  retenir :

1. **printf()** est votre ami : maÃ®trisez ses spÃ©cificateurs de format
2. **Les couleurs** amÃ©liorent la lisibilitÃ© (mais restent optionnelles)
3. **Les tableaux** structurent l'information visuellement
4. **Les barres de progression** informent l'utilisateur
5. **Les formats structurÃ©s** (JSON, CSV) permettent l'automatisation
6. **L'adaptabilitÃ©** rend votre outil utilisable dans tous contextes

Un bon output ne se contente pas d'afficher des donnÃ©es : il guide l'utilisateur, l'informe clairement et rend l'interaction agrÃ©able. C'est la diffÃ©rence entre un script d'amateur et un outil professionnel.

â­ï¸ [Parser de logs haute performance](/34-etudes-cas-devops/02-parser-logs.md)
