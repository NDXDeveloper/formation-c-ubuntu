ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 13.1.4 Targets, properties et generators

## Introduction

Dans cette section, nous allons explorer trois concepts fondamentaux de CMake qui font toute sa puissance :
- **Targets** : Les "objets" de votre projet (exÃ©cutables, bibliothÃ¨ques)
- **Properties** : Les caractÃ©ristiques de ces targets (options de compilation, dÃ©pendances, etc.)
- **Generators** : Les systÃ¨mes de build que CMake peut gÃ©nÃ©rer (Makefile, Ninja, etc.)

Ces concepts sont au cÅ“ur de l'approche moderne de CMake et comprendre leur fonctionnement vous permettra de crÃ©er des projets robustes et maintenables.

---

## Partie 1 : Les Targets - Le concept fondamental de CMake

### Qu'est-ce qu'un target ?

Un **target** (cible en franÃ§ais) est une entitÃ© que CMake doit construire. C'est l'unitÃ© de base de tout projet CMake.

**Analogie** : Si votre projet CMake Ã©tait une usine, les targets seraient les produits finis que l'usine doit fabriquer.

### Les trois types de targets principaux

#### 1. Executable Target (ExÃ©cutable)

```cmake
add_executable(mon_app src/main.c src/utils.c)
```

**RÃ©sultat** : Un fichier binaire exÃ©cutable
- Linux : `mon_app` (sans extension)
- Windows : `mon_app.exe`
- macOS : `mon_app`

#### 2. Library Target (BibliothÃ¨que)

```cmake
# BibliothÃ¨que statique (.a / .lib)
add_library(ma_lib STATIC src/lib.c)

# BibliothÃ¨que dynamique (.so / .dll / .dylib)
add_library(ma_lib SHARED src/lib.c)

# Laisse CMake dÃ©cider
add_library(ma_lib src/lib.c)
```

**RÃ©sultat** : Une bibliothÃ¨que
- Linux : `libma_lib.a` (statique) ou `libma_lib.so` (dynamique)
- Windows : `ma_lib.lib` (statique) ou `ma_lib.dll` (dynamique)
- macOS : `libma_lib.a` (statique) ou `libma_lib.dylib` (dynamique)

#### 3. Interface Target (BibliothÃ¨que header-only)

```cmake
add_library(header_only INTERFACE)  
target_include_directories(header_only INTERFACE include/)  
```

**RÃ©sultat** : Pas de fichier binaire, seulement des headers
- UtilisÃ© pour les bibliothÃ¨ques "header-only" (tout dans les .h)
- Exemple : De nombreuses bibliothÃ¨ques C++ template-based

### Targets importÃ©s (Imported Targets)

Quand vous utilisez `find_package()`, CMake crÃ©e des **imported targets** :

```cmake
find_package(OpenSSL REQUIRED)
# CrÃ©e automatiquement les targets :
# - OpenSSL::SSL
# - OpenSSL::Crypto
```

Ces targets reprÃ©sentent des bibliothÃ¨ques dÃ©jÃ  installÃ©es sur votre systÃ¨me.

### Visualiser les relations entre targets

```cmake
# BibliothÃ¨que utilitaire
add_library(utils src/utils.c)

# BibliothÃ¨que rÃ©seau (dÃ©pend de utils)
add_library(network src/network.c)  
target_link_libraries(network PRIVATE utils)  

# Application principale (dÃ©pend de network et utils)
add_executable(mon_app src/main.c)  
target_link_libraries(mon_app network utils)  
```

**Graphe de dÃ©pendances** :
```
mon_app
  â”œâ”€> network
  â”‚    â””â”€> utils
  â””â”€> utils
```

CMake construit les targets dans le bon ordre automatiquement :
1. `utils` (aucune dÃ©pendance)
2. `network` (dÃ©pend de `utils`)
3. `mon_app` (dÃ©pend de `network` et `utils`)

---

## Partie 2 : Les Properties - Configurer les targets

### Concept de property

Chaque target possÃ¨de des **propriÃ©tÃ©s** (properties) qui dÃ©finissent comment il doit Ãªtre construit. Les properties sont comme les attributs d'un objet en programmation orientÃ©e objet.

### Les commandes target_*()

CMake fournit des commandes `target_*()` pour configurer les properties de maniÃ¨re moderne :

| Commande | Property modifiÃ©e | Description |
|----------|-------------------|-------------|
| `target_include_directories()` | `INCLUDE_DIRECTORIES` | Ajoute des rÃ©pertoires d'include |
| `target_link_libraries()` | `LINK_LIBRARIES` | Lie avec des bibliothÃ¨ques |
| `target_compile_definitions()` | `COMPILE_DEFINITIONS` | DÃ©finit des macros (-D) |
| `target_compile_options()` | `COMPILE_OPTIONS` | Ajoute des flags de compilation |
| `target_link_options()` | `LINK_OPTIONS` | Ajoute des flags de link |

### Les niveaux de visibilitÃ© (PRIVATE, PUBLIC, INTERFACE)

C'est un concept clÃ© de CMake moderne. Chaque property peut avoir trois niveaux de visibilitÃ© :

#### PRIVATE : Visible uniquement par le target lui-mÃªme

```cmake
add_library(ma_lib src/lib.c)

# Cette macro est utilisÃ©e UNIQUEMENT dans lib.c
target_compile_definitions(ma_lib PRIVATE INTERNAL_DEBUG)
```

**RÃ©sultat** : Seul `ma_lib` voit `INTERNAL_DEBUG`. Les targets qui utilisent `ma_lib` ne la voient pas.

#### PUBLIC : Visible par le target ET ceux qui l'utilisent

```cmake
add_library(ma_lib src/lib.c)

# Le header public est dans include/
target_include_directories(ma_lib PUBLIC include/)
```

**RÃ©sultat** :
- `ma_lib` peut inclure les fichiers de `include/`
- Tout target qui lie `ma_lib` peut aussi inclure ces fichiers automatiquement

#### INTERFACE : Visible UNIQUEMENT par ceux qui utilisent le target

```cmake
add_library(ma_lib src/lib.c)

# Cette option est nÃ©cessaire pour UTILISER ma_lib, pas pour la compiler
target_compile_definitions(ma_lib INTERFACE USE_MY_LIB)
```

**RÃ©sultat** : `ma_lib` ne voit pas `USE_MY_LIB`, mais les targets qui l'utilisent la voient.

### Exemple complet : Comprendre les visibilitÃ©s

```cmake
# ========================================
# CrÃ©ation d'une bibliothÃ¨que
# ========================================
add_library(math_lib
    src/math.c
    src/internal_utils.c
)

# Headers publics (API de la bibliothÃ¨que)
# â†’ Les utilisateurs de math_lib peuvent faire #include <math_lib/math.h>
target_include_directories(math_lib PUBLIC
    ${CMAKE_CURRENT_SOURCE_DIR}/include
)

# Headers privÃ©s (implÃ©mentation interne)
# â†’ Seul math_lib peut les voir
target_include_directories(math_lib PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/src
)

# Option de compilation privÃ©e
# â†’ UtilisÃ©e seulement dans math.c et internal_utils.c
target_compile_definitions(math_lib PRIVATE
    ENABLE_FAST_MATH
)

# Option de compilation publique
# â†’ Les utilisateurs de math_lib doivent aussi avoir cette dÃ©finition
target_compile_definitions(math_lib PUBLIC
    MATH_LIB_VERSION=2
)

# ========================================
# Application qui utilise la bibliothÃ¨que
# ========================================
add_executable(calculator src/main.c)  
target_link_libraries(calculator math_lib)  

# RÃ©sultat automatique :
# - calculator peut inclure include/math_lib/*.h (PUBLIC)
# - calculator a la dÃ©finition MATH_LIB_VERSION=2 (PUBLIC)
# - calculator NE voit PAS src/*.h (PRIVATE)
# - calculator NE voit PAS ENABLE_FAST_MATH (PRIVATE)
```

**Structure du projet correspondante :**
```
mon_projet/
â”œâ”€â”€ include/
â”‚   â””â”€â”€ math_lib/
â”‚       â””â”€â”€ math.h          # PUBLIC : API utilisable par calculator
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ math.c              # ImplÃ©mentation
â”‚   â”œâ”€â”€ internal_utils.c    # Utilitaires internes
â”‚   â””â”€â”€ internal.h          # PRIVATE : utilisÃ© uniquement par math_lib
â””â”€â”€ CMakeLists.txt
```

### Tableau rÃ©capitulatif des visibilitÃ©s

| VisibilitÃ© | Le target lui-mÃªme | Targets qui l'utilisent | Cas d'usage |
|------------|-------------------|------------------------|-------------|
| `PRIVATE` | âœ… Oui | âŒ Non | Headers internes, flags d'optimisation |
| `PUBLIC` | âœ… Oui | âœ… Oui | API publique, dÃ©pendances transitives |
| `INTERFACE` | âŒ Non | âœ… Oui | BibliothÃ¨ques header-only, flags requis pour l'utilisation |

### DÃ©finir et lire les properties manuellement

#### DÃ©finir une property

```cmake
set_target_properties(mon_app PROPERTIES
    OUTPUT_NAME "super_app"      # Le binaire s'appellera super_app
    C_STANDARD 11                # Utilise le standard C11
    C_STANDARD_REQUIRED ON       # Erreur si C11 non supportÃ©
)
```

#### Lire une property

```cmake
get_target_property(APP_OUTPUT mon_app OUTPUT_NAME)  
message(STATUS "Le binaire s'appellera : ${APP_OUTPUT}")  
```

### Properties courantes et utiles

#### Properties de compilation

```cmake
add_executable(mon_app src/main.c)

# Standard C
set_target_properties(mon_app PROPERTIES
    C_STANDARD 11
    C_STANDARD_REQUIRED ON
)

# Position Independent Code (nÃ©cessaire pour .so)
set_target_properties(ma_lib PROPERTIES
    POSITION_INDEPENDENT_CODE ON
)
```

#### Properties de sortie

```cmake
# Nom du fichier de sortie
set_target_properties(mon_app PROPERTIES
    OUTPUT_NAME "super_calculator"
)
# RÃ©sultat : super_calculator au lieu de mon_app

# RÃ©pertoire de sortie
set_target_properties(mon_app PROPERTIES
    RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/bin"
)
# RÃ©sultat : L'exÃ©cutable sera dans build/bin/ au lieu de build/
```

#### Properties de versioning (bibliothÃ¨ques)

```cmake
add_library(ma_lib SHARED src/lib.c)

set_target_properties(ma_lib PROPERTIES
    VERSION 2.1.0        # Version complÃ¨te
    SOVERSION 2          # Version majeure (ABI)
)
# RÃ©sultat sur Linux :
# - libma_lib.so.2.1.0 (fichier rÃ©el)
# - libma_lib.so.2 -> libma_lib.so.2.1.0 (symlink)
# - libma_lib.so -> libma_lib.so.2 (symlink)
```

---

## Partie 3 : Les Generators - Choisir le systÃ¨me de build

### Qu'est-ce qu'un generator ?

CMake ne compile pas directement votre code. Il **gÃ©nÃ¨re** des fichiers de build pour un autre outil (Make, Ninja, Visual Studio...). Le **generator** est l'outil que CMake va utiliser pour gÃ©nÃ©rer ces fichiers.

**Analogie** : CMake est un traducteur. Le generator est la langue cible de la traduction.

```
CMakeLists.txt â†’ [CMake + Generator] â†’ Makefile / build.ninja / *.vcxproj
```

### Lister les generators disponibles

```bash
cmake --help
```

Cherchez la section "Generators" :
```
Generators

The following generators are available on this platform (* marks default):
* Unix Makefiles               = Generates standard UNIX makefiles.
  Ninja                        = Generates build.ninja files.
  Ninja Multi-Config           = Generates build-<Config>.ninja files.
  Watcom WMake                 = Generates Watcom WMake makefiles.
  CodeBlocks - Ninja           = Generates CodeBlocks project files.
  CodeBlocks - Unix Makefiles  = Generates CodeBlocks project files.
  Eclipse CDT4 - Ninja         = Generates Eclipse CDT 4.0 project files.
  Eclipse CDT4 - Unix Makefiles= Generates Eclipse CDT 4.0 project files.
```

### Les generators principaux sur Linux

#### 1. Unix Makefiles (par dÃ©faut)

```bash
cmake -B build
# ou explicitement :
cmake -B build -G "Unix Makefiles"
```

**GÃ©nÃ¨re** : Un `Makefile` classique

**Compilation** :
```bash
make -C build
# ou
cmake --build build
```

**Avantages** :
- âœ… Standard, universel sur Linux
- âœ… Aucune installation supplÃ©mentaire
- âœ… Compatible avec tous les outils

**InconvÃ©nients** :
- âŒ Plus lent que Ninja sur gros projets
- âŒ Syntaxe complexe (si vous devez lire le Makefile gÃ©nÃ©rÃ©)

#### 2. Ninja (recommandÃ© pour la vitesse)

```bash
# Installation sur Ubuntu
sudo apt install ninja-build

# Utilisation
cmake -B build -G Ninja
```

**GÃ©nÃ¨re** : Un fichier `build.ninja`

**Compilation** :
```bash
ninja -C build
# ou
cmake --build build
```

**Avantages** :
- âœ… Beaucoup plus rapide que Make (parallÃ©lisation optimale)
- âœ… Sortie plus claire
- âœ… UtilisÃ© par Google, LLVM, Chromium

**InconvÃ©nients** :
- âŒ NÃ©cessite l'installation de Ninja
- âŒ Moins universel que Make

**Comparaison de vitesse (exemple LLVM) :**
| Generator | Temps de build |
|-----------|----------------|
| Unix Makefiles | 45 minutes |
| Ninja | 28 minutes |

âš¡ **Ninja est 60% plus rapide !**

#### 3. Ninja Multi-Config

```bash
cmake -B build -G "Ninja Multi-Config"
```

**Avantage** : Permet de builder Debug et Release sans reconfigurer :

```bash
cmake -B build -G "Ninja Multi-Config"  
cmake --build build --config Debug  
cmake --build build --config Release  
```

IdÃ©al pour les IDEs ou les workflows complexes.

### Choisir le bon generator

| Situation | Generator recommandÃ© |
|-----------|---------------------|
| DÃ©veloppement sur Linux | **Ninja** (plus rapide) |
| Serveur CI/CD | **Ninja** (meilleure performance) |
| CompatibilitÃ© maximale | Unix Makefiles |
| Multi-configuration | Ninja Multi-Config |
| DÃ©veloppement sur Windows | Visual Studio 17 2022 |
| DÃ©veloppement sur macOS | Xcode |

### Utiliser un generator dans vos commandes

#### MÃ©thode 1 : SpÃ©cifier avec -G

```bash
cmake -B build -G Ninja  
cmake --build build  
```

#### MÃ©thode 2 : DÃ©finir par dÃ©faut avec une variable d'environnement

```bash
# Dans ~/.bashrc
export CMAKE_GENERATOR="Ninja"

# Maintenant cmake utilise Ninja par dÃ©faut
cmake -B build
```

#### MÃ©thode 3 : Dans un script

```bash
#!/bin/bash
cmake -B build-make -G "Unix Makefiles"  
cmake -B build-ninja -G Ninja  

echo "Builds crÃ©Ã©s :"  
echo "  - build-make/  (Make)"  
echo "  - build-ninja/ (Ninja)"  
```

---

## Interaction entre Targets, Properties et Generators

Voici comment ces trois concepts travaillent ensemble :

### Exemple intÃ©grÃ©

```cmake
# ============================================
# 1. CRÃ‰ER LES TARGETS
# ============================================
add_library(json_parser STATIC src/parser.c)  
add_executable(json_tool src/main.c)  

# ============================================
# 2. CONFIGURER LES PROPERTIES DES TARGETS
# ============================================

# json_parser : bibliothÃ¨que de parsing
target_include_directories(json_parser PUBLIC include)  
target_compile_definitions(json_parser PRIVATE JSON_PARSER_VERSION=2)  
target_compile_options(json_parser PRIVATE -Wall -Wextra)  

# json_tool : outil en ligne de commande
target_link_libraries(json_tool json_parser m)  
target_compile_definitions(json_tool PRIVATE  
    TOOL_VERSION="${PROJECT_VERSION}"
)

# Property spÃ©ciale : nom de sortie
set_target_properties(json_tool PROPERTIES
    OUTPUT_NAME "jsontool"
)
```

**Compilation avec diffÃ©rents generators :**

```bash
# Avec Make (lent mais universel)
cmake -B build-make -G "Unix Makefiles"  
cmake --build build-make  
# RÃ©sultat : build-make/jsontool

# Avec Ninja (rapide)
cmake -B build-ninja -G Ninja  
cmake --build build-ninja  
# RÃ©sultat : build-ninja/jsontool
```

**Le code CMake est identique**, seul le generator change !

---

## Concepts avancÃ©s des targets

### Target Alias

CrÃ©er un alias pour un target :

```cmake
add_library(json_parser STATIC src/parser.c)

# CrÃ©er un alias (pratique pour les conventions de nommage)
add_library(MyProject::JsonParser ALIAS json_parser)

# Maintenant les deux noms fonctionnent
target_link_libraries(mon_app json_parser)
# ou
target_link_libraries(mon_app MyProject::JsonParser)
```

**UtilitÃ©** : Convention moderne pour les projets exportÃ©s (voir plus tard).

### Custom Targets

CrÃ©er un target personnalisÃ© qui n'est pas un exÃ©cutable ni une bibliothÃ¨que :

```cmake
# Target qui gÃ©nÃ¨re de la documentation
add_custom_target(docs
    COMMAND doxygen ${CMAKE_SOURCE_DIR}/Doxyfile
    WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
    COMMENT "GÃ©nÃ©ration de la documentation avec Doxygen"
)
```

**Utilisation** :
```bash
cmake --build build --target docs
```

### Object Libraries

Compile des fichiers sources en fichiers objets (.o) rÃ©utilisables :

```cmake
# CrÃ©er une bibliothÃ¨que d'objets
add_library(common_objs OBJECT
    src/utils.c
    src/logger.c
)

# RÃ©utiliser ces objets dans plusieurs targets
add_executable(app1 src/app1.c $<TARGET_OBJECTS:common_objs>)  
add_executable(app2 src/app2.c $<TARGET_OBJECTS:common_objs>)  
```

**Avantage** : Ã‰vite de recompiler utils.c et logger.c deux fois.

---

## Bonnes pratiques modernes

### 1. Utiliser les commandes target_*() plutÃ´t que les anciennes

âŒ **Ancien style (Ã©viter) :**
```cmake
include_directories(include)            # Affecte TOUS les targets  
link_libraries(m)                       # Affecte TOUS les targets  
add_definitions(-DVERSION=1)            # Affecte TOUS les targets  
```

âœ… **Style moderne (recommandÃ©) :**
```cmake
add_executable(mon_app src/main.c)  
target_include_directories(mon_app PRIVATE include)  # Affecte mon_app uniquement  
target_link_libraries(mon_app m)                     # Affecte mon_app uniquement  
target_compile_definitions(mon_app PRIVATE VERSION=1) # Affecte mon_app uniquement  
```

**Pourquoi ?** Meilleure isolation, moins d'effets de bord, scalabilitÃ©.

### 2. Toujours spÃ©cifier PRIVATE/PUBLIC/INTERFACE

âŒ **Mauvais :**
```cmake
target_include_directories(ma_lib include)  # Quelle visibilitÃ© ?
```

âœ… **Bon :**
```cmake
target_include_directories(ma_lib PUBLIC include)  # Clair et explicite
```

### 3. Utiliser Ninja pour la vitesse

```bash
# Configurer une fois avec Ninja
cmake -B build -G Ninja -DCMAKE_BUILD_TYPE=Release

# Builds ultra-rapides ensuite
cmake --build build
```

### 4. SÃ©parer les configurations Debug et Release avec des rÃ©pertoires diffÃ©rents

```bash
cmake -B build-debug -G Ninja -DCMAKE_BUILD_TYPE=Debug  
cmake -B build-release -G Ninja -DCMAKE_BUILD_TYPE=Release  
```

---

## Debugging : Afficher les properties d'un target

Pour voir toutes les properties d'un target :

```cmake
# Fonction utilitaire pour afficher les properties
function(print_target_properties target)
    message(STATUS "Properties de ${target}:")

    get_target_property(type ${target} TYPE)
    message(STATUS "  Type: ${type}")

    get_target_property(includes ${target} INCLUDE_DIRECTORIES)
    message(STATUS "  Include dirs: ${includes}")

    get_target_property(defs ${target} COMPILE_DEFINITIONS)
    message(STATUS "  Compile definitions: ${defs}")

    get_target_property(libs ${target} LINK_LIBRARIES)
    message(STATUS "  Link libraries: ${libs}")
endfunction()

# Utilisation
add_executable(mon_app src/main.c)  
target_include_directories(mon_app PRIVATE include)  
target_compile_definitions(mon_app PRIVATE DEBUG_MODE)  

print_target_properties(mon_app)
```

**Sortie** :
```
-- Properties de mon_app:
  Type: EXECUTABLE
  Include dirs: /home/user/projet/include
  Compile definitions: DEBUG_MODE
  Link libraries: m;pthread
```

---

## RÃ©sumÃ© en schÃ©ma

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       VOTRE PROJET                              â”‚
â”‚                                                                 â”‚
â”‚  CMakeLists.txt                                                 â”‚
â”‚    â”‚                                                            â”‚
â”‚    â”œâ”€ DÃ©finit les TARGETS                                       â”‚
â”‚    â”‚    â”œâ”€ add_executable(app ...)                              â”‚
â”‚    â”‚    â””â”€ add_library(lib ...)                                 â”‚
â”‚    â”‚                                                            â”‚
â”‚    â”œâ”€ Configure les PROPERTIES                                  â”‚
â”‚    â”‚    â”œâ”€ target_include_directories(... PUBLIC/PRIVATE)       â”‚
â”‚    â”‚    â”œâ”€ target_compile_definitions(...)                      â”‚
â”‚    â”‚    â””â”€ target_link_libraries(...)                           â”‚
â”‚    â”‚                                                            â”‚
â”‚    â””â”€ cmake -B build -G [GENERATOR]                             â”‚
â”‚                  â”‚                                              â”‚
â”‚                  â†“                                              â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                      â”‚
â”‚    â”‚  GENERATOR transforme en :          â”‚                      â”‚
â”‚    â”‚  â€¢ Makefile (Unix Makefiles)        â”‚                      â”‚
â”‚    â”‚  â€¢ build.ninja (Ninja)              â”‚                      â”‚
â”‚    â”‚  â€¢ *.vcxproj (Visual Studio)        â”‚                      â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â”‚
â”‚                  â”‚                                              â”‚
â”‚                  â†“                                              â”‚
â”‚    cmake --build build                                          â”‚
â”‚                  â”‚                                              â”‚
â”‚                  â†“                                              â”‚
â”‚    Binaires compilÃ©s : app, lib.a, lib.so                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Cas d'usage pratique complet

Projet complet illustrant targets, properties et generators :

```cmake
cmake_minimum_required(VERSION 3.15)  
project(HttpServer VERSION 1.0.0 LANGUAGES C)  

# ============================================
# OPTIONS
# ============================================
option(BUILD_SHARED "Compiler en bibliothÃ¨que partagÃ©e" ON)  
option(ENABLE_TLS "Activer le support TLS avec OpenSSL" ON)  

# ============================================
# DÃ‰PENDANCES
# ============================================
find_package(Threads REQUIRED)

if(ENABLE_TLS)
    find_package(OpenSSL REQUIRED)
endif()

# ============================================
# TARGET 1 : BibliothÃ¨que HTTP
# ============================================
if(BUILD_SHARED)
    add_library(http_lib SHARED src/http.c src/parser.c)
else()
    add_library(http_lib STATIC src/http.c src/parser.c)
endif()

# Alias moderne
add_library(HttpServer::Lib ALIAS http_lib)

# Properties publiques (API)
target_include_directories(http_lib PUBLIC
    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
    $<INSTALL_INTERFACE:include>
)

# Properties privÃ©es (implÃ©mentation)
target_compile_definitions(http_lib PRIVATE
    HTTP_SERVER_VERSION="${PROJECT_VERSION}"
)

target_compile_options(http_lib PRIVATE -Wall -Wextra -O3)

# DÃ©pendances
target_link_libraries(http_lib PUBLIC Threads::Threads)

if(ENABLE_TLS)
    target_link_libraries(http_lib PUBLIC OpenSSL::SSL OpenSSL::Crypto)
    target_compile_definitions(http_lib PUBLIC HTTP_TLS_ENABLED)
endif()

# ============================================
# TARGET 2 : Serveur exÃ©cutable
# ============================================
add_executable(httpd src/main.c)

target_link_libraries(httpd HttpServer::Lib)

set_target_properties(httpd PROPERTIES
    OUTPUT_NAME "httpd"
    RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/bin"
)

# ============================================
# INFORMATIONS DE BUILD
# ============================================
message(STATUS "")  
message(STATUS "Configuration HttpServer ${PROJECT_VERSION}")  
message(STATUS "  Generator:       ${CMAKE_GENERATOR}")  
message(STATUS "  Type de build:   ${CMAKE_BUILD_TYPE}")  
message(STATUS "  BibliothÃ¨que:    ${BUILD_SHARED}")  
message(STATUS "  Support TLS:     ${ENABLE_TLS}")  
message(STATUS "")  
```

**Utilisation avec diffÃ©rents generators et options :**

```bash
# Build 1 : Make, bibliothÃ¨que statique, sans TLS
cmake -B build1 -G "Unix Makefiles" \
    -DBUILD_SHARED=OFF \
    -DENABLE_TLS=OFF
cmake --build build1

# Build 2 : Ninja, bibliothÃ¨que partagÃ©e, avec TLS
cmake -B build2 -G Ninja \
    -DCMAKE_BUILD_TYPE=Release \
    -DBUILD_SHARED=ON \
    -DENABLE_TLS=ON
cmake --build build2

# Build 3 : Ninja Multi-Config
cmake -B build3 -G "Ninja Multi-Config"  
cmake --build build3 --config Debug  
cmake --build build3 --config Release  
```

---

## Conclusion

Les trois piliers de CMake moderne :

1. **Targets** : Les entitÃ©s Ã  construire (exÃ©cutables, bibliothÃ¨ques)
2. **Properties** : Les caractÃ©ristiques de ces targets (include dirs, compile flags, dÃ©pendances)
3. **Generators** : Les systÃ¨mes de build Ã  gÃ©nÃ©rer (Make, Ninja, Visual Studio)

**Principe fondamental** : Pensez en termes de **targets** et de leurs **relations** plutÃ´t qu'en termes de fichiers et de flags globaux.

Cette approche moderne rend vos projets :
- âœ… Plus maintenables (pas d'effets de bord)
- âœ… Plus portables (les properties sont abstraites)
- âœ… Plus scalables (gestion claire des dÃ©pendances)

---


â­ï¸ [Gestion des dÃ©pendances](/13-build-systems/01.5-gestion-dependances.md)
