ðŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 15.1.7 IntÃ©gration dans le workflow

## Introduction

ConnaÃ®tre les sanitizers est une chose, mais les **intÃ©grer efficacement** dans votre processus de dÃ©veloppement quotidien en est une autre. Cette section vous montre comment faire des sanitizers une partie **naturelle et automatique** de votre travail, du premier coup de code jusqu'Ã  la mise en production.

### Qu'est-ce qu'un workflow de dÃ©veloppement ?

Un **workflow** (flux de travail) est l'ensemble des Ã©tapes que vous suivez pour dÃ©velopper, tester et dÃ©ployer du code :

```
Ã‰crire du code â†’ Compiler â†’ Tester localement â†’ Commit â†’ CI/CD â†’ Review â†’ Merge â†’ Production
```

**L'objectif :** IntÃ©grer les sanitizers Ã  **chaque Ã©tape** pour dÃ©tecter les bugs le plus tÃ´t possible.

### Pourquoi l'intÃ©gration est importante ?

**Sans intÃ©gration :**
- ðŸ˜• Vous oubliez d'utiliser les sanitizers
- ðŸ› Les bugs passent inaperÃ§us
- ðŸ’¥ DÃ©couverte tardive (coÃ»teux Ã  corriger)

**Avec intÃ©gration :**
- âœ… DÃ©tection automatique Ã  chaque Ã©tape
- ðŸš€ Bugs corrigÃ©s immÃ©diatement
- ðŸ’ª Code plus robuste sans effort conscient

---

## Vue d'ensemble du workflow

### Les diffÃ©rentes Ã©tapes

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   WORKFLOW DE DÃ‰VELOPPEMENT                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

1. DÃ‰VELOPPEMENT LOCAL
   â”œâ”€â”€ Ã‰crire du code
   â”œâ”€â”€ Compiler avec sanitizers       â† ASan + UBSan
   â”œâ”€â”€ ExÃ©cuter et tester
   â””â”€â”€ ItÃ©rer

2. TESTS LOCAUX (avant commit)
   â”œâ”€â”€ Tests unitaires               â† ASan + UBSan
   â”œâ”€â”€ Tests d'intÃ©gration           â† ASan + UBSan
   â””â”€â”€ Tests de concurrence          â† TSan (si applicable)

3. PRÃ‰-COMMIT
   â”œâ”€â”€ Hooks Git                     â† Validation automatique
   â”œâ”€â”€ Formatage
   â””â”€â”€ VÃ©rifications rapides

4. CI/CD (aprÃ¨s push)
   â”œâ”€â”€ Build matrix                  â† Plusieurs configurations
   â”œâ”€â”€ Tests automatisÃ©s             â† ASan + UBSan
   â”œâ”€â”€ Tests de concurrence          â† TSan
   â””â”€â”€ Analyse de code

5. CODE REVIEW
   â”œâ”€â”€ Review humaine
   â””â”€â”€ Validation sanitizers OK

6. DÃ‰PLOIEMENT
   â”œâ”€â”€ Staging avec sanitizers       â† DerniÃ¨re vÃ©rification
   â””â”€â”€ Production sans sanitizers    â† Performance max
```

---

## Phase 1 : DÃ©veloppement local

### Configuration de l'environnement

**Objectif :** Avoir les sanitizers toujours prÃªts Ã  l'emploi.

#### Fichier de configuration : `.vimrc` ou `.bashrc`

**CrÃ©er des alias pour faciliter la compilation :**

```bash
# ~/.bashrc ou ~/.zshrc

# Alias de compilation avec sanitizers
alias gcc-san='gcc -fsanitize=address,undefined -g -O1 -Wall -Wextra'
alias gcc-tsan='gcc -fsanitize=thread -g -O1 -pthread -Wall -Wextra'
alias gcc-debug='gcc -g -O0 -Wall -Wextra'
alias gcc-release='gcc -O2 -DNDEBUG -Wall -Wextra'

# Fonction pour compiler et exÃ©cuter
crun() {
    gcc-san -o /tmp/a.out "$1" && /tmp/a.out
}

# Variables d'environnement pour sanitizers
export ASAN_OPTIONS="halt_on_error=1:detect_leaks=1"
export UBSAN_OPTIONS="halt_on_error=1:print_stacktrace=1"
export TSAN_OPTIONS="halt_on_error=1:history_size=7"
```

**Utilisation :**
```bash
# Compilation rapide avec sanitizers
gcc-san main.c -o prog

# Compilation et exÃ©cution
crun main.c
```

#### Configuration du projet

**Structure recommandÃ©e :**

```
mon_projet/
â”œâ”€â”€ src/                    # Code source
â”œâ”€â”€ tests/                  # Tests
â”œâ”€â”€ build/                  # Builds temporaires
â”œâ”€â”€ scripts/                # Scripts d'automatisation
â”‚   â”œâ”€â”€ build_san.sh       # Build avec sanitizers
â”‚   â”œâ”€â”€ build_tsan.sh      # Build avec TSan
â”‚   â””â”€â”€ run_tests.sh       # ExÃ©cution des tests
â”œâ”€â”€ .clang-format          # Style de code
â”œâ”€â”€ .gitignore
â”œâ”€â”€ Makefile               # SystÃ¨me de build
â””â”€â”€ README.md
```

### Makefile intÃ©grÃ©

**CrÃ©er un Makefile avec plusieurs targets :**

```makefile
# Makefile

CC = gcc
CFLAGS = -Wall -Wextra -std=c11
SANITIZER_FLAGS = -g -O1 -fno-omit-frame-pointer

# Sources
SRC = src/main.c src/utils.c
OBJ = $(SRC:.c=.o)

# Targets
.PHONY: all clean dev test test-tsan debug release

# Build par dÃ©faut : avec sanitizers
all: dev

# Build dÃ©veloppement : ASan + UBSan
dev:
	$(CC) $(CFLAGS) $(SANITIZER_FLAGS) \
		-fsanitize=address,undefined \
		-fno-sanitize-recover=all \
		$(SRC) -o build/prog_dev

# Build tests : ExÃ©cute les tests avec sanitizers
test: dev
	@echo "=== ExÃ©cution des tests avec ASan + UBSan ==="
	@export ASAN_OPTIONS=detect_leaks=1:halt_on_error=1; \
	 ./build/prog_dev --run-tests
	@echo "âœ… Tests rÃ©ussis"

# Build tests concurrence : TSan
test-tsan:
	$(CC) $(CFLAGS) $(SANITIZER_FLAGS) \
		-fsanitize=thread \
		-pthread \
		$(SRC) -o build/prog_tsan
	@echo "=== ExÃ©cution des tests avec TSan ==="
	@export TSAN_OPTIONS=halt_on_error=1; \
	 ./build/prog_tsan --run-tests
	@echo "âœ… Tests TSan rÃ©ussis"

# Build debug : Sans optimisation
debug:
	$(CC) $(CFLAGS) -g -O0 $(SRC) -o build/prog_debug

# Build release : Production
release:
	$(CC) $(CFLAGS) -O2 -DNDEBUG $(SRC) -o build/prog_release
	@echo "âœ… Build production crÃ©Ã©"

# Nettoyage
clean:
	rm -rf build/*

# VÃ©rification complÃ¨te avant commit
pre-commit: dev test test-tsan
	@echo "âœ… Toutes les vÃ©rifications sont passÃ©es"
```

**Utilisation quotidienne :**

```bash
# DÃ©veloppement
make dev
./build/prog_dev

# Tests rapides
make test

# Tests complets (avant commit)
make pre-commit

# Build production
make release
```

### Scripts d'automatisation

**Script : `scripts/build_san.sh`**

```bash
#!/bin/bash
# Build avec sanitizers et affichage colorÃ©

set -e  # ArrÃªt en cas d'erreur

GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m' # No Color

echo -e "${GREEN}ðŸ”¨ Compilation avec sanitizers...${NC}"

gcc -fsanitize=address,undefined \
    -fno-sanitize-recover=all \
    -g -O1 \
    -Wall -Wextra -Werror \
    -o build/prog_san \
    src/*.c

if [ $? -eq 0 ]; then
    echo -e "${GREEN}âœ… Compilation rÃ©ussie${NC}"
else
    echo -e "${RED}âŒ Erreur de compilation${NC}"
    exit 1
fi
```

**Script : `scripts/run_tests.sh`**

```bash
#!/bin/bash
# ExÃ©cution des tests avec sanitizers

set -e

GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m'

# Configuration des sanitizers
export ASAN_OPTIONS="detect_leaks=1:halt_on_error=1:abort_on_error=1"
export UBSAN_OPTIONS="halt_on_error=1:print_stacktrace=1"

echo -e "${YELLOW}ðŸ§ª ExÃ©cution des tests...${NC}"

# Compilation
./scripts/build_san.sh

# ExÃ©cution
echo -e "${YELLOW}ðŸ“‹ Tests unitaires...${NC}"
if ./build/prog_san --unit-tests; then
    echo -e "${GREEN}âœ… Tests unitaires OK${NC}"
else
    echo -e "${RED}âŒ Tests unitaires Ã©chouÃ©s${NC}"
    exit 1
fi

echo -e "${YELLOW}ðŸ“‹ Tests d'intÃ©gration...${NC}"
if ./build/prog_san --integration-tests; then
    echo -e "${GREEN}âœ… Tests d'intÃ©gration OK${NC}"
else
    echo -e "${RED}âŒ Tests d'intÃ©gration Ã©chouÃ©s${NC}"
    exit 1
fi

echo -e "${GREEN}ðŸŽ‰ Tous les tests sont passÃ©s !${NC}"
```

**Rendre les scripts exÃ©cutables :**
```bash
chmod +x scripts/*.sh
```

**Utilisation :**
```bash
./scripts/run_tests.sh
```

### Workflow quotidien recommandÃ©

**1. DÃ©but de session : Compilation avec sanitizers**

```bash
# Le matin, premiÃ¨re compilation
make dev
```

**2. DÃ©veloppement itÃ©ratif**

```bash
# Ã‰crire du code
vim src/feature.c

# Compiler et tester
make dev && ./build/prog_dev

# Si erreur sanitizer â†’ Corriger immÃ©diatement
# Recommencer
```

**3. Tests rÃ©guliers**

```bash
# Toutes les 15-30 minutes, ou aprÃ¨s chaque feature
make test
```

**4. Avant le dÃ©jeuner / fin de journÃ©e**

```bash
# VÃ©rification complÃ¨te
make pre-commit
```

---

## Phase 2 : Tests locaux (prÃ©-commit)

### Hooks Git

**Les hooks Git** permettent d'automatiser des vÃ©rifications avant chaque commit.

#### Installation d'un hook pre-commit

**CrÃ©er le fichier `.git/hooks/pre-commit` :**

```bash
#!/bin/bash
# Hook pre-commit : VÃ©rifie le code avant commit

set -e

echo "ðŸ” VÃ©rification pre-commit..."

# 1. Compilation avec sanitizers
echo "ðŸ“¦ Compilation avec sanitizers..."
if ! make dev > /dev/null 2>&1; then
    echo "âŒ Erreur de compilation"
    exit 1
fi

# 2. ExÃ©cution des tests
echo "ðŸ§ª ExÃ©cution des tests..."
if ! make test > /dev/null 2>&1; then
    echo "âŒ Tests Ã©chouÃ©s"
    exit 1
fi

# 3. VÃ©rification du formatage (optionnel)
echo "ðŸŽ¨ VÃ©rification du formatage..."
if command -v clang-format &> /dev/null; then
    clang-format --dry-run --Werror src/*.c
fi

# 4. Analyse statique rapide (optionnel)
echo "ðŸ”¬ Analyse statique..."
if command -v cppcheck &> /dev/null; then
    cppcheck --quiet --error-exitcode=1 src/
fi

echo "âœ… Toutes les vÃ©rifications sont passÃ©es"
echo "âœ… Commit autorisÃ©"
```

**Rendre le hook exÃ©cutable :**
```bash
chmod +x .git/hooks/pre-commit
```

**Test du hook :**
```bash
# Essayer de commit
git add .
git commit -m "Test commit"

# Le hook s'exÃ©cute automatiquement
# Commit bloquÃ© si tests Ã©chouent
```

#### Hook plus sophistiquÃ©

**Version avec timing et couleurs :**

```bash
#!/bin/bash
# Hook pre-commit avancÃ©

GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m'

START_TIME=$(date +%s)

echo -e "${YELLOW}ðŸ” Pre-commit checks...${NC}"

# Fonction pour mesurer le temps
check() {
    local name=$1
    shift
    echo -ne "${YELLOW}â³ ${name}...${NC} "

    if "$@" > /tmp/precommit_log 2>&1; then
        echo -e "${GREEN}âœ“${NC}"
        return 0
    else
        echo -e "${RED}âœ—${NC}"
        cat /tmp/precommit_log
        return 1
    fi
}

# VÃ©rifications
check "Compilation" make dev || exit 1
check "Tests unitaires" make test || exit 1

# Si code multi-threadÃ©
if grep -q "pthread" src/*.c; then
    check "Tests TSan" make test-tsan || exit 1
fi

# Temps total
END_TIME=$(date +%s)
DURATION=$((END_TIME - START_TIME))

echo -e "${GREEN}âœ… Toutes les vÃ©rifications OK (${DURATION}s)${NC}"
```

### StratÃ©gie de tests par type

**Tests rapides (Ã  chaque commit) :**
```bash
# Tests unitaires uniquement (~30 secondes)
make test
```

**Tests complets (commits importants) :**
```bash
# Tests unitaires + intÃ©gration + TSan (~2-5 minutes)
make pre-commit
```

**Tests exhaustifs (avant PR) :**
```bash
# Tous les tests, toutes les configurations
./scripts/full_test_suite.sh
```

---

## Phase 3 : IntÃ©gration Continue (CI/CD)

### GitHub Actions

**CrÃ©er `.github/workflows/ci.yml` :**

```yaml
name: CI avec Sanitizers

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  # Job 1 : Tests avec ASan + UBSan
  test-asan-ubsan:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential

      - name: Compile avec ASan + UBSan
        run: |
          gcc -fsanitize=address,undefined \
              -fno-sanitize-recover=all \
              -g -O1 -Wall -Wextra -Werror \
              -o prog src/*.c

      - name: Run tests
        run: |
          export ASAN_OPTIONS="detect_leaks=1:halt_on_error=1"
          export UBSAN_OPTIONS="halt_on_error=1:print_stacktrace=1"
          ./prog --run-tests

      - name: Upload logs on failure
        if: failure()
        uses: actions/upload-artifact@v3
        with:
          name: sanitizer-logs
          path: |
            *.log
            core.*

  # Job 2 : Tests avec TSan (si multi-threadÃ©)
  test-tsan:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Compile avec TSan
        run: |
          gcc -fsanitize=thread \
              -g -O1 -pthread \
              -Wall -Wextra -Werror \
              -o prog_tsan src/*.c

      - name: Run concurrency tests
        run: |
          export TSAN_OPTIONS="halt_on_error=1:history_size=7"
          ./prog_tsan --run-tests

  # Job 3 : Analyse statique
  static-analysis:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Install tools
        run: |
          sudo apt-get update
          sudo apt-get install -y cppcheck clang-tidy

      - name: Run cppcheck
        run: cppcheck --error-exitcode=1 --quiet src/

      - name: Run clang-tidy
        run: |
          clang-tidy src/*.c -- -Wall -Wextra

  # Job 4 : Build matrix (plusieurs configurations)
  build-matrix:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        compiler: [gcc, clang]
        sanitizer: [address,undefined, thread, leak]
        exclude:
          # TSan incompatible avec ASan
          - sanitizer: thread

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Install compiler
        run: |
          if [ "${{ matrix.compiler }}" = "clang" ]; then
            sudo apt-get install -y clang
          fi

      - name: Build
        run: |
          ${{ matrix.compiler }} \
            -fsanitize=${{ matrix.sanitizer }} \
            -g -O1 -o prog src/*.c

      - name: Test
        run: ./prog --run-tests
```

**Configuration expliquÃ©e :**
- **test-asan-ubsan** : Tests principaux (sur chaque commit)
- **test-tsan** : Tests de concurrence (sur chaque commit si multi-threadÃ©)
- **static-analysis** : Analyse statique complÃ©mentaire
- **build-matrix** : Tests avec plusieurs compilateurs et sanitizers

### GitLab CI

**CrÃ©er `.gitlab-ci.yml` :**

```yaml
stages:
  - build
  - test
  - analyze

variables:
  ASAN_OPTIONS: "detect_leaks=1:halt_on_error=1"
  UBSAN_OPTIONS: "halt_on_error=1:print_stacktrace=1"
  TSAN_OPTIONS: "halt_on_error=1:history_size=7"

# Template pour builds avec sanitizers
.sanitizer_build:
  image: gcc:latest
  before_script:
    - apt-get update && apt-get install -y make

# Build et test avec ASan + UBSan
test:asan:
  extends: .sanitizer_build
  stage: test
  script:
    - make dev
    - make test
  artifacts:
    when: on_failure
    paths:
      - build/
      - "*.log"

# Build et test avec TSan
test:tsan:
  extends: .sanitizer_build
  stage: test
  script:
    - make test-tsan
  only:
    - merge_requests
    - main

# Analyse statique
analyze:static:
  extends: .sanitizer_build
  stage: analyze
  script:
    - apt-get install -y cppcheck
    - cppcheck --error-exitcode=1 src/
  allow_failure: true

# Tests nightly (exhaustifs)
test:nightly:
  extends: .sanitizer_build
  stage: test
  script:
    - make pre-commit
    - make test-tsan
  only:
    - schedules
```

### Jenkins Pipeline

**CrÃ©er `Jenkinsfile` :**

```groovy
pipeline {
    agent any

    environment {
        ASAN_OPTIONS = 'detect_leaks=1:halt_on_error=1'
        UBSAN_OPTIONS = 'halt_on_error=1:print_stacktrace=1'
    }

    stages {
        stage('Build') {
            steps {
                sh 'make clean'
                sh 'make dev'
            }
        }

        stage('Test - ASan + UBSan') {
            steps {
                sh 'make test'
            }
        }

        stage('Test - TSan') {
            when {
                branch 'main'
            }
            steps {
                sh 'make test-tsan'
            }
        }

        stage('Static Analysis') {
            steps {
                sh 'cppcheck --xml --xml-version=2 src/ 2> cppcheck.xml'
            }
            post {
                always {
                    recordIssues(tools: [cppCheck(pattern: 'cppcheck.xml')])
                }
            }
        }
    }

    post {
        failure {
            archiveArtifacts artifacts: 'build/*, *.log', allowEmptyArchive: true
        }
        always {
            cleanWs()
        }
    }
}
```

### StratÃ©gie CI/CD par branche

**Branche `feature/*` (dÃ©veloppement) :**
```yaml
# Tests lÃ©gers uniquement
- ASan + UBSan
- Temps : ~2 minutes
```

**Branche `develop` :**
```yaml
# Tests standards
- ASan + UBSan
- TSan (si multi-threadÃ©)
- Analyse statique
- Temps : ~5 minutes
```

**Branche `main` / Pull Request :**
```yaml
# Tests complets
- ASan + UBSan (tous les tests)
- TSan (tous les tests)
- Analyse statique
- Build matrix (GCC + Clang)
- Temps : ~10-15 minutes
```

**Tests nightly (1Ã— par jour) :**
```yaml
# Tests exhaustifs
- Tous les sanitizers
- Toutes les configurations
- Tests de charge
- Temps : ~30-60 minutes
```

---

## Phase 4 : Code Review

### Checklist pour reviewers

**VÃ©rifications automatiques (avant review) :**
- âœ… CI/CD passÃ© (tous les jobs verts)
- âœ… Aucune erreur sanitizer dÃ©tectÃ©e
- âœ… Coverage de code maintenu ou amÃ©liorÃ©
- âœ… Analyse statique sans nouveaux warnings

**VÃ©rifications manuelles :**

```markdown
## Checklist Code Review

### Gestion mÃ©moire
- [ ] Pas de malloc sans free correspondant ?
- [ ] Pas de double free ?
- [ ] Pas d'utilisation aprÃ¨s free ?
- [ ] VÃ©rification des retours de malloc ?

### Concurrence (si applicable)
- [ ] Tous les accÃ¨s partagÃ©s sont protÃ©gÃ©s ?
- [ ] Pas de deadlock potentiel ?
- [ ] Ordre de lock cohÃ©rent ?

### Comportements indÃ©finis
- [ ] Pas de dÃ©bordement d'entiers possible ?
- [ ] Pas de division par zÃ©ro possible ?
- [ ] Pas de shift invalide ?

### Tests
- [ ] Tests unitaires ajoutÃ©s pour nouvelle feature ?
- [ ] Tests passent avec sanitizers activÃ©s ?
- [ ] Tests de concurrence si code multi-threadÃ© ?
```

### Commande pour reviewer

**Tester la PR localement avec sanitizers :**

```bash
# Checkout de la PR
git fetch origin pull/123/head:pr-123
git checkout pr-123

# Build et test avec sanitizers
make clean
make pre-commit

# Si multi-threadÃ©
make test-tsan

# Tests de charge (optionnel)
./scripts/stress_test.sh
```

---

## Phase 5 : Staging et prÃ©-production

### Environnement de staging avec sanitizers

**IdÃ©e :** Avoir un environnement de staging avec sanitizers activÃ©s.

**Avantages :**
- âœ… DÃ©tection de bugs qui n'apparaissent qu'avec donnÃ©es rÃ©elles
- âœ… Test en conditions proches de la production
- âœ… DerniÃ¨re barriÃ¨re avant production

**Configuration Docker pour staging :**

```dockerfile
# Dockerfile.staging
FROM ubuntu:22.04

RUN apt-get update && apt-get install -y \
    gcc \
    make \
    gdb

WORKDIR /app

COPY . .

# Build avec sanitizers
RUN make dev

# Variables d'environnement
ENV ASAN_OPTIONS="detect_leaks=1:abort_on_error=1:log_path=/logs/asan.log"
ENV UBSAN_OPTIONS="halt_on_error=1:log_path=/logs/ubsan.log"

# ExÃ©cution
CMD ["./build/prog_dev"]
```

**Docker Compose :**

```yaml
# docker-compose.staging.yml
version: '3.8'

services:
  app-staging:
    build:
      context: .
      dockerfile: Dockerfile.staging
    volumes:
      - ./logs:/logs
    environment:
      - ASAN_OPTIONS=detect_leaks=1:abort_on_error=1:log_path=/logs/asan.log
      - UBSAN_OPTIONS=halt_on_error=1:log_path=/logs/ubsan.log
    ports:
      - "8080:8080"
```

**Utilisation :**
```bash
# DÃ©ployer en staging avec sanitizers
docker-compose -f docker-compose.staging.yml up

# Surveiller les logs
tail -f logs/asan.log
tail -f logs/ubsan.log
```

### Tests de charge en staging

**Script de stress test :**

```bash
#!/bin/bash
# stress_test.sh

echo "ðŸ”¥ Stress test avec sanitizers..."

# Lancer le serveur avec sanitizers
./build/prog_dev &
PID=$!

# Attendre le dÃ©marrage
sleep 2

# Lancer des requÃªtes intensives
for i in {1..10000}; do
    curl -s http://localhost:8080/api/test > /dev/null &
done

# Attendre la fin
wait

# ArrÃªter le serveur
kill $PID

# VÃ©rifier les logs sanitizers
if grep -q "ERROR: " logs/*.log; then
    echo "âŒ Erreurs dÃ©tectÃ©es !"
    cat logs/*.log
    exit 1
else
    echo "âœ… Stress test rÃ©ussi"
fi
```

---

## Phase 6 : Production

### Build de production (sans sanitizers)

**Important :** La production doit **toujours** Ãªtre compilÃ©e sans sanitizers.

**Makefile target :**
```makefile
release:
	$(CC) -O2 -DNDEBUG -Wall -Wextra -Werror \
		-o build/prog_release \
		src/*.c
	strip build/prog_release  # Supprimer les symboles debug
```

**Dockerfile production :**

```dockerfile
# Dockerfile.production
FROM ubuntu:22.04 AS builder

RUN apt-get update && apt-get install -y gcc make

WORKDIR /build
COPY . .

# Build optimisÃ© (SANS sanitizers)
RUN make release

# Image finale (minimale)
FROM ubuntu:22.04

WORKDIR /app

# Copier uniquement le binaire
COPY --from=builder /build/build/prog_release /app/prog

# Utilisateur non-root
RUN useradd -m appuser
USER appuser

CMD ["./prog"]
```

### Monitoring en production

**MÃªme sans sanitizers, surveillez les indicateurs :**

```bash
# Surveillance mÃ©moire
watch -n 5 'ps aux | grep prog'

# Logs d'erreurs
tail -f /var/log/app/errors.log

# Core dumps (si crash)
ulimit -c unlimited
# Les core dumps sont analysables avec GDB
```

**Script d'analyse de core dump :**

```bash
#!/bin/bash
# analyze_core.sh

if [ -f core ]; then
    echo "ðŸ“Š Analyse du core dump..."

    # Recompiler avec symboles debug (pour analyse)
    make debug

    # Analyser avec GDB
    gdb -batch -ex "bt full" build/prog_debug core > crash_report.txt

    echo "ðŸ“„ Rapport gÃ©nÃ©rÃ© : crash_report.txt"
fi
```

---

## Workflow complet : RÃ©capitulatif

### Jour typique d'un dÃ©veloppeur

**Matin (9h) :**
```bash
# Pull des derniÃ¨res modifications
git pull origin main

# Build avec sanitizers
make dev

# VÃ©rification rapide
make test
```

**DÃ©veloppement (9h30 - 12h) :**
```bash
# Boucle de dÃ©veloppement
while true; do
    # Coder
    vim src/feature.c

    # Compiler et tester
    make dev && ./build/prog_dev --test-feature

    # Si erreur sanitizer â†’ Corriger immÃ©diatement
done

# Tests rÃ©guliers (toutes les 30 min)
make test
```

**Avant dÃ©jeuner (12h) :**
```bash
# VÃ©rification complÃ¨te
make pre-commit

# Si OK, commit
git add .
git commit -m "feat: nouvelle fonctionnalitÃ©"
```

**AprÃ¨s-midi (14h - 18h) :**
```bash
# Continuer le dÃ©veloppement
# ...

# Avant de push (fin de journÃ©e)
make pre-commit

# Si multi-threadÃ©, tester TSan
make test-tsan

# Push
git push origin feature/ma-feature
```

**CI/CD (automatique) :**
```
GitHub Actions lance automatiquement :
- Compilation avec ASan + UBSan
- ExÃ©cution des tests
- Analyse statique
- Tests TSan (si applicable)
```

**Code Review (lendemain) :**
```bash
# Reviewer teste localement
git checkout pr-123
make pre-commit

# Validation et merge
```

**Production (aprÃ¨s merge) :**
```bash
# Build de production (sans sanitizers)
make release

# DÃ©ploiement
docker build -f Dockerfile.production -t app:latest .
docker push app:latest
```

---

## Automatisation avancÃ©e

### Script tout-en-un

**`scripts/dev_workflow.sh` :**

```bash
#!/bin/bash
# Workflow de dÃ©veloppement automatisÃ©

set -e

GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Fonction d'aide
usage() {
    echo "Usage: $0 [commande]"
    echo ""
    echo "Commandes:"
    echo "  dev         - Build dÃ©veloppement avec sanitizers"
    echo "  test        - ExÃ©cuter les tests"
    echo "  check       - VÃ©rifications complÃ¨tes (pre-commit)"
    echo "  tsan        - Tests de concurrence (TSan)"
    echo "  release     - Build production"
    echo "  ci          - Simuler le CI en local"
    echo "  clean       - Nettoyer les builds"
    exit 1
}

# Commande dev
dev() {
    echo -e "${BLUE}ðŸ”¨ Build dÃ©veloppement...${NC}"
    make dev
    echo -e "${GREEN}âœ… Build dev crÃ©Ã© : build/prog_dev${NC}"
}

# Commande test
test() {
    echo -e "${BLUE}ðŸ§ª ExÃ©cution des tests...${NC}"
    make test
}

# Commande check (pre-commit)
check() {
    echo -e "${YELLOW}ðŸ” VÃ©rifications pre-commit...${NC}"

    dev
    test

    # Analyse statique
    if command -v cppcheck &> /dev/null; then
        echo -e "${BLUE}ðŸ”¬ Analyse statique...${NC}"
        cppcheck --quiet --error-exitcode=1 src/ || {
            echo -e "${RED}âŒ Erreurs d'analyse statique${NC}"
            exit 1
        }
    fi

    # Formatage
    if command -v clang-format &> /dev/null; then
        echo -e "${BLUE}ðŸŽ¨ VÃ©rification du formatage...${NC}"
        clang-format --dry-run --Werror src/*.c || {
            echo -e "${RED}âŒ Erreurs de formatage${NC}"
            echo "Correction : clang-format -i src/*.c"
            exit 1
        }
    fi

    echo -e "${GREEN}âœ… Toutes les vÃ©rifications OK${NC}"
}

# Commande tsan
tsan() {
    echo -e "${BLUE}ðŸ”€ Tests de concurrence (TSan)...${NC}"
    make test-tsan
}

# Commande release
release() {
    echo -e "${BLUE}ðŸ“¦ Build production...${NC}"
    make release

    # VÃ©rifier que pas de symboles sanitizers
    if nm build/prog_release | grep -q "__asan"; then
        echo -e "${RED}âŒ ERREUR : Sanitizers dÃ©tectÃ©s dans le build production !${NC}"
        exit 1
    fi

    echo -e "${GREEN}âœ… Build production crÃ©Ã© : build/prog_release${NC}"
}

# Commande ci (simule CI en local)
ci() {
    echo -e "${YELLOW}ðŸ¤– Simulation CI/CD en local...${NC}"

    echo -e "${BLUE}ðŸ“‹ Ã‰tape 1/5 : Build${NC}"
    dev

    echo -e "${BLUE}ðŸ“‹ Ã‰tape 2/5 : Tests ASan + UBSan${NC}"
    test

    echo -e "${BLUE}ðŸ“‹ Ã‰tape 3/5 : Tests TSan${NC}"
    if grep -q "pthread" src/*.c 2>/dev/null; then
        tsan
    else
        echo "Skipped (pas de code multi-threadÃ©)"
    fi

    echo -e "${BLUE}ðŸ“‹ Ã‰tape 4/5 : Analyse statique${NC}"
    if command -v cppcheck &> /dev/null; then
        cppcheck --quiet --error-exitcode=1 src/
    fi

    echo -e "${BLUE}ðŸ“‹ Ã‰tape 5/5 : Build production${NC}"
    release

    echo -e "${GREEN}ðŸŽ‰ CI simulÃ© avec succÃ¨s !${NC}"
}

# Commande clean
clean() {
    echo -e "${BLUE}ðŸ§¹ Nettoyage...${NC}"
    make clean
    echo -e "${GREEN}âœ… Nettoyage terminÃ©${NC}"
}

# Dispatch des commandes
case "$1" in
    dev)     dev ;;
    test)    test ;;
    check)   check ;;
    tsan)    tsan ;;
    release) release ;;
    ci)      ci ;;
    clean)   clean ;;
    *)       usage ;;
esac
```

**Utilisation :**
```bash
chmod +x scripts/dev_workflow.sh

# DÃ©veloppement quotidien
./scripts/dev_workflow.sh dev
./scripts/dev_workflow.sh test

# Avant commit
./scripts/dev_workflow.sh check

# Simuler CI localement
./scripts/dev_workflow.sh ci
```

### Configuration VS Code

**`.vscode/tasks.json` :**

```json
{
    "version": "2.0.0",
    "tasks": [
        {
            "label": "Build (Dev)",
            "type": "shell",
            "command": "make dev",
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "problemMatcher": ["$gcc"]
        },
        {
            "label": "Test",
            "type": "shell",
            "command": "make test",
            "group": "test"
        },
        {
            "label": "Pre-commit Check",
            "type": "shell",
            "command": "./scripts/dev_workflow.sh check",
            "problemMatcher": ["$gcc"]
        },
        {
            "label": "Build (Release)",
            "type": "shell",
            "command": "make release",
            "group": "build"
        }
    ]
}
```

**`.vscode/launch.json` :**

```json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Debug avec sanitizers",
            "type": "cppdbg",
            "request": "launch",
            "program": "${workspaceFolder}/build/prog_dev",
            "args": [],
            "stopAtEntry": false,
            "cwd": "${workspaceFolder}",
            "environment": [
                {
                    "name": "ASAN_OPTIONS",
                    "value": "detect_leaks=1:halt_on_error=0"
                },
                {
                    "name": "UBSAN_OPTIONS",
                    "value": "halt_on_error=0:print_stacktrace=1"
                }
            ],
            "externalConsole": false,
            "MIMode": "gdb",
            "preLaunchTask": "Build (Dev)"
        }
    ]
}
```

---

## MÃ©triques et suivi

### Dashboard de mÃ©triques

**MÃ©triques Ã  suivre :**

1. **Taux de dÃ©tection sanitizers**
   - Nombre de bugs dÃ©tectÃ©s par sanitizers / semaine
   - Ã‰volution dans le temps

2. **Temps de build**
   - Temps moyen de compilation avec sanitizers
   - Temps CI/CD

3. **Taux de rÃ©ussite CI/CD**
   - % de builds qui passent
   - Ã‰volution aprÃ¨s intÃ©gration sanitizers

4. **Couverture de code**
   - % de code testÃ© avec sanitizers

**Script de collecte de mÃ©triques :**

```bash
#!/bin/bash
# collect_metrics.sh

DATE=$(date +%Y-%m-%d)
METRICS_FILE="metrics/${DATE}.json"

# CrÃ©er le dossier si nÃ©cessaire
mkdir -p metrics

# Nombre de tests
NUM_TESTS=$(./build/prog_dev --count-tests)

# Temps de build
START=$(date +%s)
make dev > /dev/null 2>&1
END=$(date +%s)
BUILD_TIME=$((END - START))

# Temps de tests
START=$(date +%s)
make test > /dev/null 2>&1
TEST_TIME=$((END - START))

# GÃ©nÃ©rer JSON
cat > "$METRICS_FILE" << EOF
{
    "date": "$DATE",
    "build_time_seconds": $BUILD_TIME,
    "test_time_seconds": $TEST_TIME,
    "num_tests": $NUM_TESTS,
    "sanitizers": ["address", "undefined"]
}
EOF

echo "âœ… MÃ©triques enregistrÃ©es : $METRICS_FILE"
```

---

## RÃ©sumÃ©

### Points clÃ©s Ã  retenir

1. **IntÃ©grer les sanitizers Ã  chaque Ã©tape** du workflow
2. **Automatiser** avec Makefile, scripts, hooks Git
3. **CI/CD** : Tests avec sanitizers sur chaque commit
4. **Pre-commit hooks** : Validation avant commit
5. **Production** : Toujours compiler **sans** sanitizers

### Checklist d'intÃ©gration complÃ¨te

**Configuration initiale :**
- [ ] Makefile avec targets `dev`, `test`, `release`
- [ ] Scripts d'automatisation dans `scripts/`
- [ ] Hooks Git pre-commit
- [ ] CI/CD configurÃ© (GitHub Actions / GitLab CI)
- [ ] VS Code tasks et launch config (si applicable)

**Workflow quotidien :**
- [ ] Compiler avec sanitizers (`make dev`)
- [ ] Tester rÃ©guliÃ¨rement (`make test`)
- [ ] Pre-commit check (`make pre-commit`)
- [ ] CI/CD passe avant merge

**Production :**
- [ ] Build sans sanitizers (`make release`)
- [ ] VÃ©rification absence de symboles sanitizers
- [ ] Monitoring des erreurs en production

### Commandes essentielles

```bash
# DÃ©veloppement
make dev                    # Build avec sanitizers
make test                   # Tests rapides
make pre-commit            # Validation complÃ¨te

# CI/CD (local)
./scripts/dev_workflow.sh ci  # Simuler CI

# Production
make release               # Build optimisÃ©
```

### Prochaines Ã©tapes

Vous Ãªtes maintenant prÃªt Ã  :
- âœ… Utiliser les sanitizers efficacement
- âœ… Automatiser leur intÃ©gration
- âœ… DÃ©tecter les bugs le plus tÃ´t possible
- âœ… Livrer du code plus robuste

Dans les sections suivantes, vous dÃ©couvrirez :
- **Utilisation de GDB** : Combiner sanitizers et debugging
- **DÃ©tection de fuites avec Valgrind** : Outil complÃ©mentaire
- **Analyse statique de code** : DÃ©tecter les bugs sans exÃ©cution

---

**ðŸŽ¯ Un workflow bien intÃ©grÃ© transforme les sanitizers d'outils occasionnels en gardiens permanents de la qualitÃ© de votre code !**

â­ï¸ [Utilisation de GDB](/15-debogage-et-qualite/02-utilisation-gdb.md)
