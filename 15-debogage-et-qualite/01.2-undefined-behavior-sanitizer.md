üîù Retour au [Sommaire](/SOMMAIRE.md)

# 15.1.2 UndefinedBehaviorSanitizer (UBSan)

## Introduction

**UndefinedBehaviorSanitizer** (abr√©g√© **UBSan**) est un d√©tecteur automatique de **comportements ind√©finis** (undefined behavior) en C. C'est un sanitizer qui compl√®te parfaitement AddressSanitizer en d√©tectant une cat√©gorie diff√©rente de bugs.

### Qu'est-ce qu'un comportement ind√©fini ?

En C, certaines op√©rations sont consid√©r√©es comme ayant un **comportement ind√©fini** (undefined behavior ou UB). Cela signifie que le standard du langage C ne sp√©cifie pas ce qui doit se passer dans ces situations. Le programme peut :
- ‚úÖ Sembler fonctionner correctement
- ‚ùå Crasher de mani√®re impr√©visible
- ‚ùå Produire des r√©sultats al√©atoires
- ‚ùå Fonctionner diff√©remment selon le compilateur ou les options d'optimisation
- ‚ùå Cr√©er des failles de s√©curit√© exploitables

**Le plus dangereux :** Un programme avec un comportement ind√©fini peut fonctionner parfaitement pendant des mois, puis crasher de mani√®re inexplicable apr√®s une simple mise √† jour du compilateur ou un changement d'environnement.

### Pourquoi UBSan est crucial ?

Le comportement ind√©fini est l'une des sources de bugs les plus **insidieuses** en C :
- üêõ Difficile √† d√©tecter (le programme peut "marcher" en apparence)
- üî• Peut causer des bugs silencieux et dangereux
- üí£ Peut √™tre exploit√© pour des attaques de s√©curit√©
- üé≤ R√©sultats non reproductibles

**UBSan d√©tecte ces comportements ind√©finis au moment de l'ex√©cution** et vous alerte imm√©diatement.

---

## Les comportements ind√©finis d√©tect√©s par UBSan

### 1. **Integer Overflow (D√©bordement d'entiers sign√©s)**

Lorsqu'une op√©ration arithm√©tique d√©passe les limites d'un type entier sign√©.

```c
#include <stdio.h>
#include <limits.h>

int main() {
    int max = INT_MAX;  // 2147483647 (valeur maximale d'un int)

    int resultat = max + 1;  // ‚ùå COMPORTEMENT IND√âFINI

    printf("R√©sultat : %d\n", resultat);
    return 0;
}
```

**Pourquoi c'est un probl√®me ?**
- Le r√©sultat est **impr√©visible** (souvent -2147483648, mais pas garanti)
- Peut causer des bugs critiques (ex: calcul de taille de buffer, indices de tableau)
- Peut √™tre exploit√© pour contourner des v√©rifications de s√©curit√©

**Note importante :** Le d√©bordement d'entiers **non sign√©s** (unsigned) n'est **pas** un comportement ind√©fini. Il est bien d√©fini comme un modulo.

### 2. **Division par z√©ro**

```c
int main() {
    int a = 10;
    int b = 0;

    int resultat = a / b;  // ‚ùå COMPORTEMENT IND√âFINI

    return 0;
}
```

**Pourquoi c'est un probl√®me ?**
- Peut crasher le programme (SIGFPE)
- Peut retourner n'importe quelle valeur
- En virgule flottante, peut donner `inf` ou `NaN`

### 3. **Shift invalide (D√©calage de bits)**

```c
int main() {
    int x = 1;

    // ‚ùå D√©calage n√©gatif
    int y = x << -1;  // COMPORTEMENT IND√âFINI

    // ‚ùå D√©calage >= taille du type
    int z = x << 32;  // COMPORTEMENT IND√âFINI (int = 32 bits)

    // ‚ùå D√©calage d'un nombre n√©gatif
    int w = (-1) << 5;  // COMPORTEMENT IND√âFINI

    return 0;
}
```

### 4. **Conversion invalide (Integer conversion)**

Conversion d'un grand nombre vers un type plus petit qui ne peut pas le contenir.

```c
int main() {
    long grand_nombre = 1000000000000L;

    // ‚ùå Perte de donn√©es non d√©finie
    int petit = (int)grand_nombre;  // PEUT √™tre un comportement ind√©fini

    return 0;
}
```

### 5. **Null pointer dereference (D√©r√©f√©rencement de pointeur NULL)**

```c
int main() {
    int *ptr = NULL;

    *ptr = 42;  // ‚ùå COMPORTEMENT IND√âFINI (souvent segfault)

    return 0;
}
```

### 6. **Misaligned pointer (Pointeur mal align√©)**

Acc√®s √† une adresse m√©moire qui n'est pas correctement align√©e.

```c
int main() {
    char buffer[10];

    // Force un pointeur int √† une adresse impaire
    int *ptr = (int*)(buffer + 1);  // Alignement incorrect

    *ptr = 42;  // ‚ùå COMPORTEMENT IND√âFINI sur certaines architectures

    return 0;
}
```

### 7. **Out-of-bounds array access (d√©tection partielle)**

```c
int main() {
    int tab[5] = {1, 2, 3, 4, 5};

    // ‚ùå Acc√®s hors limites
    int valeur = tab[10];  // COMPORTEMENT IND√âFINI

    return 0;
}
```

**Note :** ASan est meilleur pour d√©tecter ce type d'erreur. UBSan peut en d√©tecter certaines, mais pas toutes.

### 8. **Variable non initialis√©e (d√©tection indirecte)**

L'utilisation d'une variable non initialis√©e est un comportement ind√©fini en C, mais **UBSan ne la d√©tecte pas directement**. Cette erreur est d√©tect√©e par d'autres outils :
- **Compilateur** : `-Wuninitialized` (GCC/Clang)
- **MemorySanitizer (MSan)** : disponible uniquement avec Clang (pas GCC)
- **Valgrind Memcheck** : d√©tection fiable √† l'ex√©cution

```c
int main() {
    int x;  // Non initialis√©e

    int y = x + 5;  // ‚ùå COMPORTEMENT IND√âFINI (non d√©tect√© par UBSan)
    // gcc -Wall d√©tecte : warning: 'x' is used uninitialized

    return 0;
}
```

### 9. **Invalid enum value (Valeur d'√©num√©ration invalide)**

```c
enum Couleur {
    ROUGE = 0,
    VERT = 1,
    BLEU = 2
};

int main() {
    enum Couleur c;

    // Force une valeur invalide
    int *ptr = (int*)&c;
    *ptr = 999;  // Pas une valeur valide de l'enum

    // ‚ùå Utilisation d'une valeur invalide
    switch(c) {
        case ROUGE: break;
        case VERT: break;
        case BLEU: break;
    }

    return 0;
}
```

### 10. **Signed integer truncation**

```c
int main() {
    int grand = 300;

    // ‚ùå Troncature lors de la conversion
    signed char petit = grand;  // char peut contenir -128 √† 127

    printf("%d\n", petit);  // R√©sultat ind√©fini
    return 0;
}
```

---

## Comment utiliser UndefinedBehaviorSanitizer ?

### Activation pendant la compilation

Pour activer UBSan, ajoutez l'option `-fsanitize=undefined` lors de la compilation :

```bash
gcc -fsanitize=undefined -g -o mon_programme mon_programme.c
```

**Options importantes :**
- `-fsanitize=undefined` : Active tous les contr√¥les UBSan
- `-g` : Ajoute les informations de d√©bogage
- `-fno-sanitize-recover=all` : Arr√™te √† la premi√®re erreur (recommand√© pour les tests)

### Exemple complet

**fichier : `overflow.c`**
```c
#include <stdio.h>
#include <limits.h>

int main() {
    int max = INT_MAX;
    printf("Valeur maximale d'un int : %d\n", max);

    // Provoque un d√©bordement
    int resultat = max + 1;

    printf("Apr√®s d√©bordement : %d\n", resultat);
    return 0;
}
```

**Compilation avec UBSan :**
```bash
gcc -fsanitize=undefined -g -o overflow overflow.c
```

**Ex√©cution :**
```bash
./overflow
```

---

## Interpr√©ter les rapports d'UBSan

Lorsqu'UBSan d√©tecte un comportement ind√©fini, il affiche un rapport.

### Exemple de rapport : Integer Overflow

**Programme :**
```c
#include <limits.h>

int main() {
    int x = INT_MAX;
    int y = x + 1;
    return 0;
}
```

**Rapport UBSan :**
```
overflow.c:5:13: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type 'int'
```

### D√©crypter le rapport

```
overflow.c:5:13: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type 'int'
‚îÇ          ‚îÇ  ‚îÇ                 ‚îÇ
‚îÇ          ‚îÇ  ‚îÇ                 ‚îî‚îÄ Explication d√©taill√©e
‚îÇ          ‚îÇ  ‚îî‚îÄ Type d'erreur
‚îÇ          ‚îî‚îÄ Colonne dans le code
‚îî‚îÄ Fichier et ligne
```

**Informations cl√©s :**
1. **Fichier et ligne** : `overflow.c:5:13` ‚Üí ligne 5, colonne 13
2. **Type d'erreur** : `signed integer overflow`
3. **D√©tails** : `2147483647 + 1 cannot be represented in type 'int'`

---

## Exemples d√©taill√©s avec correction

### Exemple 1 : D√©bordement d'entier

**Code probl√©matique :**
```c
#include <stdio.h>

int calculer_taille(int taille_element, int nombre_elements) {
    return taille_element * nombre_elements;  // ‚ùå Peut d√©border
}

int main() {
    int taille = calculer_taille(1000000, 5000);
    printf("Taille totale : %d octets\n", taille);
    return 0;
}
```

**Rapport UBSan :**
```
runtime error: signed integer overflow: 1000000 * 5000 cannot be represented in type 'int'
```

**Code corrig√© :**
```c
#include <stdio.h>
#include <limits.h>
#include <stdbool.h>

bool calculer_taille_safe(int taille_element, int nombre_elements, int *resultat) {
    // V√©rification avant la multiplication
    if (nombre_elements > 0 && taille_element > INT_MAX / nombre_elements) {
        return false;  // D√©bordement d√©tect√©
    }

    *resultat = taille_element * nombre_elements;
    return true;
}

int main() {
    int taille;

    if (calculer_taille_safe(1000000, 5000, &taille)) {
        printf("Taille totale : %d octets\n", taille);
    } else {
        printf("Erreur : d√©bordement d'entier\n");
    }

    return 0;
}
```

### Exemple 2 : Division par z√©ro

**Code probl√©matique :**
```c
#include <stdio.h>

int main() {
    int scores[] = {100, 85, 92, 0};
    int nombre_tests = 0;  // Oups, devrait √™tre 4

    int moyenne = (scores[0] + scores[1] + scores[2] + scores[3]) / nombre_tests;
    printf("Moyenne : %d\n", moyenne);

    return 0;
}
```

**Rapport UBSan :**
```
runtime error: division by zero
```

**Code corrig√© :**
```c
#include <stdio.h>

int main() {
    int scores[] = {100, 85, 92, 78};
    int nombre_tests = 4;  // ‚úÖ Valeur correcte

    if (nombre_tests == 0) {
        printf("Erreur : division par z√©ro\n");
        return 1;
    }

    int moyenne = (scores[0] + scores[1] + scores[2] + scores[3]) / nombre_tests;
    printf("Moyenne : %d\n", moyenne);

    return 0;
}
```

### Exemple 3 : Shift invalide

**Code probl√©matique :**
```c
#include <stdio.h>

int main() {
    int valeur = 1;
    int decalage = 32;  // Trop grand pour un int (32 bits)

    int resultat = valeur << decalage;  // ‚ùå COMPORTEMENT IND√âFINI
    printf("R√©sultat : %d\n", resultat);

    return 0;
}
```

**Rapport UBSan :**
```
runtime error: shift exponent 32 is too large for 32-bit type 'int'
```

**Code corrig√© :**
```c
#include <stdio.h>
#include <limits.h>

int main() {
    int valeur = 1;
    int decalage = 32;

    // V√©rification avant le shift
    if (decalage < 0 || decalage >= sizeof(int) * 8) {
        printf("Erreur : d√©calage invalide (%d)\n", decalage);
        return 1;
    }

    int resultat = valeur << decalage;
    printf("R√©sultat : %d\n", resultat);

    return 0;
}
```

---

## Options de configuration avanc√©es

### Activer des v√©rifications sp√©cifiques

Vous pouvez activer uniquement certains types de v√©rifications :

```bash
# Uniquement les d√©bordements d'entiers
gcc -fsanitize=signed-integer-overflow -g -o prog prog.c

# Uniquement les divisions par z√©ro
gcc -fsanitize=divide-by-zero -g -o prog prog.c

# Uniquement les shifts invalides
gcc -fsanitize=shift -g -o prog prog.c

# Uniquement les pointeurs NULL
gcc -fsanitize=null -g -o prog prog.c
```

### Combiner plusieurs v√©rifications

```bash
gcc -fsanitize=signed-integer-overflow,divide-by-zero,shift -g -o prog prog.c
```

### Liste compl√®te des options UBSan

| Option | Description |
|--------|-------------|
| `undefined` | Toutes les v√©rifications (recommand√©) |
| `signed-integer-overflow` | D√©bordement d'entiers sign√©s |
| `unsigned-integer-overflow` | D√©bordement d'entiers non sign√©s (rappel : pas UB) |
| `shift` | D√©calages de bits invalides |
| `divide-by-zero` | Division par z√©ro |
| `null` | D√©r√©f√©rencement de NULL |
| `return` | Fonction non-void sans return |
| `bounds` | Acc√®s hors limites (limit√©) |
| `alignment` | Pointeurs mal align√©s |
| `object-size` | Acc√®s au-del√† de la taille d'un objet |
| `float-divide-by-zero` | Division par z√©ro en virgule flottante |
| `integer-divide-by-zero` | Division enti√®re par z√©ro |
| `vla-bound` | Taille invalide pour VLA |
| `enum` | Valeurs d'enum invalides |

---

## Configuration via variables d'environnement

UBSan peut √™tre configur√© via `UBSAN_OPTIONS` :

### Arr√™ter √† la premi√®re erreur
```bash
UBSAN_OPTIONS=halt_on_error=1 ./mon_programme
```

### Ne pas arr√™ter (afficher toutes les erreurs)
```bash
UBSAN_OPTIONS=halt_on_error=0 ./mon_programme
```

### Imprimer la stack trace compl√®te
```bash
UBSAN_OPTIONS=print_stacktrace=1 ./mon_programme
```

### Sauvegarder les rapports dans un fichier
```bash
UBSAN_OPTIONS=log_path=ubsan_report.txt ./mon_programme
```

### Exemple combin√©
```bash
UBSAN_OPTIONS=halt_on_error=1:print_stacktrace=1 ./mon_programme
```

---

## Combiner ASan et UBSan

**Bonne nouvelle :** Vous pouvez utiliser ASan et UBSan en m√™me temps !

```bash
gcc -fsanitize=address,undefined -g -o mon_programme mon_programme.c
```

Cette combinaison est **fortement recommand√©e** car :
- **ASan** d√©tecte les erreurs m√©moire (use-after-free, buffer overflow, etc.)
- **UBSan** d√©tecte les comportements ind√©finis (overflow, division par z√©ro, etc.)

**Exemple complet :**
```bash
gcc -fsanitize=address,undefined \
    -fno-sanitize-recover=all \
    -g -O1 -Wall -Wextra \
    -o mon_programme mon_programme.c
```

**Options expliqu√©es :**
- `-fsanitize=address,undefined` : Active ASan et UBSan
- `-fno-sanitize-recover=all` : Arr√™te √† la premi√®re erreur
- `-g` : Symboles de d√©bogage
- `-O1` : Optimisation l√©g√®re
- `-Wall -Wextra` : Tous les warnings du compilateur

---

## Performance et Overhead

### Impact sur les performances

| Aspect | Impact |
|--------|--------|
| **Vitesse d'ex√©cution** | ~20-30% plus lent |
| **Utilisation m√©moire** | +5-10% |
| **Taille du binaire** | +10-20% |

**Comparaison avec ASan :**
- UBSan est **beaucoup plus rapide** qu'ASan (~30% vs ~100% de ralentissement)
- UBSan utilise **beaucoup moins de m√©moire** qu'ASan
- Vous pouvez laisser UBSan activ√© plus longtemps pendant le d√©veloppement

### Recommandations d'utilisation

**Pendant le d√©veloppement :**
```bash
# Compilation quotidienne avec UBSan
gcc -fsanitize=undefined -g -O1 -o debug_build main.c
```

**Pour les tests automatis√©s :**
```bash
# Combinaison ASan + UBSan
gcc -fsanitize=address,undefined -fno-sanitize-recover=all -g -o test_build main.c
```

**Pour la production :**
```bash
# Compilation normale (sans sanitizers)
gcc -O2 -DNDEBUG -o production_build main.c
```

---

## Bonnes pratiques

### 1. Utiliser UBSan syst√©matiquement en d√©veloppement

Ajoutez un target dans votre syst√®me de build :

**Makefile :**
```makefile
CFLAGS_DEBUG = -fsanitize=address,undefined -fno-sanitize-recover=all -g -O1 -Wall -Wextra

debug: CFLAGS += $(CFLAGS_DEBUG)  
debug: mon_programme  

test: debug
	./mon_programme --run-tests
```

**CMake :**
```cmake
# Option de compilation pour les sanitizers
option(ENABLE_SANITIZERS "Enable sanitizers" ON)

if(ENABLE_SANITIZERS)
    add_compile_options(-fsanitize=address,undefined)
    add_link_options(-fsanitize=address,undefined)
endif()
```

### 2. Int√©grer UBSan dans votre CI/CD

**GitHub Actions :**
```yaml
- name: Build avec sanitizers
  run: |
    gcc -fsanitize=address,undefined -fno-sanitize-recover=all \
        -g -O1 -Wall -Wextra -o tests tests.c

- name: Run tests
  run: |
    export UBSAN_OPTIONS=halt_on_error=1:print_stacktrace=1
    export ASAN_OPTIONS=halt_on_error=1
    ./tests
```

### 3. Ne jamais ignorer les warnings UBSan

Un comportement ind√©fini d√©tect√© doit **toujours** √™tre corrig√©, m√™me si le programme semble fonctionner.

### 4. Comprendre les faux positifs (rares)

UBSan produit tr√®s peu de faux positifs. Si vous pensez qu'un rapport est un faux positif :
1. Relisez attentivement le code
2. V√©rifiez la norme C (le standard est la r√©f√©rence)
3. Si c'est vraiment un faux positif, utilisez `__attribute__((no_sanitize("undefined")))` avec **extr√™me prudence**

---

## Cas pratique : D√©tecter un bug subtil

### Le probl√®me

Voici un bug r√©el qui peut passer inaper√ßu :

```c
#include <stdio.h>
#include <limits.h>

int calculer_moyenne(int *valeurs, int taille) {
    int somme = 0;

    for (int i = 0; i < taille; i++) {
        somme += valeurs[i];  // ‚ùå Peut d√©border si taille ou valeurs sont grandes
    }

    return somme / taille;
}

int main() {
    int notes[] = {INT_MAX, INT_MAX, INT_MAX};
    int moyenne = calculer_moyenne(notes, 3);

    printf("Moyenne : %d\n", moyenne);
    return 0;
}
```

**Sans UBSan :** Le programme compile et s'ex√©cute, mais donne un r√©sultat faux.

**Compilation normale :**
```bash
gcc -o bug bug.c
./bug
# Affiche un r√©sultat incorrect sans warning
```

**Avec UBSan :**
```bash
gcc -fsanitize=undefined -g -o bug bug.c
./bug
```

**Rapport :**
```
bug.c:7:14: runtime error: signed integer overflow: 2147483647 + 2147483647 cannot be represented in type 'int'
```

### La correction

```c
#include <stdio.h>
#include <limits.h>
#include <stdbool.h>

bool calculer_moyenne_safe(int *valeurs, int taille, double *resultat) {
    if (taille == 0) {
        return false;
    }

    // Utiliser des doubles pour √©viter les d√©bordements
    double somme = 0.0;

    for (int i = 0; i < taille; i++) {
        somme += valeurs[i];
    }

    *resultat = somme / taille;
    return true;
}

int main() {
    int notes[] = {INT_MAX, INT_MAX, INT_MAX};
    double moyenne;

    if (calculer_moyenne_safe(notes, 3, &moyenne)) {
        printf("Moyenne : %.2f\n", moyenne);
    } else {
        printf("Erreur de calcul\n");
    }

    return 0;
}
```

---

## Diff√©rences avec d'autres outils

### UBSan vs ASan

| Aspect | UBSan | ASan |
|--------|-------|------|
| **Cible** | Comportements ind√©finis | Erreurs m√©moire |
| **Exemples** | Overflow, division par 0 | Use-after-free, buffer overflow |
| **Performance** | ~30% plus lent | ~100% plus lent |
| **M√©moire** | +5-10% | +200-300% |
| **Combinable** | ‚úÖ Oui | ‚úÖ Avec UBSan (pas avec TSan) |

### UBSan vs Valgrind

| Aspect | UBSan | Valgrind |
|--------|-------|----------|
| **Recompilation** | Oui | Non |
| **Types d'erreurs** | Comportements ind√©finis | M√©moire + autres |
| **Vitesse** | ~30% overhead | ~1000% overhead |
| **Facilit√©** | Tr√®s simple | Simple |

---

## R√©sum√©

### Points cl√©s √† retenir

1. **UBSan d√©tecte les comportements ind√©finis** du langage C
2. **Activation simple** : `-fsanitize=undefined`
3. **Combiner avec ASan** : `-fsanitize=address,undefined`
4. **Overhead faible** : ~30% plus lent (acceptable en d√©veloppement)
5. **Indispensable** pour du code robuste et portable

### Commande √† retenir (d√©veloppement)
```bash
gcc -fsanitize=address,undefined -fno-sanitize-recover=all -g -O1 -Wall -Wextra -o programme programme.c
```

### Commande √† retenir (CI/CD)
```bash
gcc -fsanitize=address,undefined -fno-sanitize-recover=all -g -Wall -Wextra -Werror -o tests tests.c  
export UBSAN_OPTIONS=halt_on_error=1:print_stacktrace=1  
./tests
```

### Les comportements ind√©finis les plus courants

1. ‚ö†Ô∏è **Integer overflow** (le plus fr√©quent)
2. ‚ö†Ô∏è **Division par z√©ro**
3. ‚ö†Ô∏è **Shift invalide**
4. ‚ö†Ô∏è **Null pointer dereference**
5. ‚ö†Ô∏è **Conversion invalide**

### Prochaines √©tapes

Dans les sections suivantes, vous d√©couvrirez :
- **ThreadSanitizer (TSan)** : D√©tection de race conditions dans les programmes multi-thread√©s
- **LeakSanitizer (LSan)** : D√©tection de fuites m√©moire
- Comment **int√©grer tous les sanitizers** dans votre workflow de d√©veloppement

---

**üéØ UBSan est votre gardien contre les bugs les plus sournois du C. Utilisez-le syst√©matiquement pour √©crire du code portable et conforme aux standards !**

‚è≠Ô∏è [ThreadSanitizer (TSan)](/15-debogage-et-qualite/01.3-thread-sanitizer.md)
