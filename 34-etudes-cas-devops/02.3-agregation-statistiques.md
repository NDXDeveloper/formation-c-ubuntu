ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 34.2.3 AgrÃ©gation et statistiques

## Introduction

AprÃ¨s avoir appris Ã  lire efficacement de gros fichiers de logs (section 34.2.1) et Ã  extraire des informations avec des expressions rÃ©guliÃ¨res (section 34.2.2), nous pouvons maintenant agrÃ©ger ces donnÃ©es et produire des statistiques significatives.

Un parser de logs professionnel ne se contente pas de lire : il analyse, compte, trie et prÃ©sente des statistiques utiles pour comprendre ce qui se passe dans un systÃ¨me.

**Exemples de questions auxquelles rÃ©pondre :**
- Combien de requÃªtes par code HTTP (200, 404, 500, etc.) ?
- Quelles sont les 10 IPs les plus actives ?
- Quel est le temps de rÃ©ponse moyen/mÃ©dian/95e percentile ?
- Quelles URLs sont les plus appelÃ©es ?
- Quelle est la distribution des erreurs dans le temps ?

---

## 1. Structures de donnÃ©es pour l'agrÃ©gation

### 1.1 Compteurs simples

Pour compter des occurrences, on utilise des structures simples :

```c
#include <stdio.h>
#include <string.h>

typedef struct {
    int count_200;
    int count_404;
    int count_500;
    int count_autres;
} StatutsHTTP;

void incrementer_statut(StatutsHTTP *stats, int code) {
    switch (code) {
        case 200:
            stats->count_200++;
            break;
        case 404:
            stats->count_404++;
            break;
        case 500:
            stats->count_500++;
            break;
        default:
            stats->count_autres++;
            break;
    }
}

void afficher_stats(const StatutsHTTP *stats) {
    int total = stats->count_200 + stats->count_404 +
                stats->count_500 + stats->count_autres;

    printf("Statistiques des codes HTTP:\n");
    printf("  200 (OK):     %6d (%.1f%%)\n",
           stats->count_200,
           100.0 * stats->count_200 / total);
    printf("  404 (NotFound): %6d (%.1f%%)\n",
           stats->count_404,
           100.0 * stats->count_404 / total);
    printf("  500 (Error):  %6d (%.1f%%)\n",
           stats->count_500,
           100.0 * stats->count_500 / total);
    printf("  Autres:       %6d (%.1f%%)\n",
           stats->count_autres,
           100.0 * stats->count_autres / total);
    printf("  Total:        %6d\n", total);
}
```

### 1.2 Tables de hachage simples

Pour compter des chaÃ®nes variables (IPs, URLs), on utilise une table de hachage :

```c
#include <stdlib.h>
#include <string.h>

#define HASH_SIZE 10000

typedef struct Entry {
    char *cle;
    long long valeur;
    struct Entry *suivant;
} Entry;

typedef struct {
    Entry *buckets[HASH_SIZE];
} HashMap;

// Fonction de hachage simple
unsigned long hash(const char *str) {
    unsigned long hash = 5381;
    int c;

    while ((c = *str++)) {
        hash = ((hash << 5) + hash) + c;
    }

    return hash % HASH_SIZE;
}

HashMap *creer_hashmap() {
    HashMap *map = calloc(1, sizeof(HashMap));
    return map;
}

void incrementer(HashMap *map, const char *cle) {
    unsigned long index = hash(cle);
    Entry *entry = map->buckets[index];

    // Chercher si la clÃ© existe
    while (entry != NULL) {
        if (strcmp(entry->cle, cle) == 0) {
            entry->valeur++;
            return;
        }
        entry = entry->suivant;
    }

    // CrÃ©er une nouvelle entrÃ©e
    Entry *nouvelle = malloc(sizeof(Entry));
    nouvelle->cle = strdup(cle);
    nouvelle->valeur = 1;
    nouvelle->suivant = map->buckets[index];
    map->buckets[index] = nouvelle;
}

void liberer_hashmap(HashMap *map) {
    for (int i = 0; i < HASH_SIZE; i++) {
        Entry *entry = map->buckets[i];
        while (entry != NULL) {
            Entry *suivant = entry->suivant;
            free(entry->cle);
            free(entry);
            entry = suivant;
        }
    }
    free(map);
}

// ItÃ©rer sur tous les Ã©lÃ©ments
void parcourir_hashmap(HashMap *map, void (*callback)(const char*, long long)) {
    for (int i = 0; i < HASH_SIZE; i++) {
        Entry *entry = map->buckets[i];
        while (entry != NULL) {
            callback(entry->cle, entry->valeur);
            entry = entry->suivant;
        }
    }
}
```

**Utilisation :**
```c
void afficher_entry(const char *cle, long long valeur) {
    printf("  %s: %lld\n", cle, valeur);
}

int main() {
    HashMap *ips = creer_hashmap();

    // Compter les IPs
    incrementer(ips, "192.168.1.100");
    incrementer(ips, "10.0.0.5");
    incrementer(ips, "192.168.1.100");
    incrementer(ips, "172.16.0.1");
    incrementer(ips, "192.168.1.100");

    printf("IPs et leurs compteurs:\n");
    parcourir_hashmap(ips, afficher_entry);

    liberer_hashmap(ips);
    return 0;
}
```

### 1.3 Tableaux dynamiques pour le tri

Pour obtenir les "top N", il faut trier les rÃ©sultats :

```c
#include <stdlib.h>
#include <string.h>

typedef struct {
    char cle[256];
    long long valeur;
} Item;

typedef struct {
    Item *items;
    int taille;
    int capacite;
} ListeItems;

ListeItems *creer_liste() {
    ListeItems *liste = malloc(sizeof(ListeItems));
    liste->capacite = 100;
    liste->taille = 0;
    liste->items = malloc(liste->capacite * sizeof(Item));
    return liste;
}

void ajouter_item(ListeItems *liste, const char *cle, long long valeur) {
    if (liste->taille >= liste->capacite) {
        liste->capacite *= 2;
        liste->items = realloc(liste->items, liste->capacite * sizeof(Item));
    }

    strncpy(liste->items[liste->taille].cle, cle, sizeof(liste->items[0].cle) - 1);
    liste->items[liste->taille].valeur = valeur;
    liste->taille++;
}

// Fonction de comparaison pour qsort (ordre dÃ©croissant)
int comparer_items(const void *a, const void *b) {
    const Item *ia = (const Item *)a;
    const Item *ib = (const Item *)b;

    if (ib->valeur > ia->valeur) return 1;
    if (ib->valeur < ia->valeur) return -1;
    return 0;
}

void trier_liste(ListeItems *liste) {
    qsort(liste->items, liste->taille, sizeof(Item), comparer_items);
}

void liberer_liste(ListeItems *liste) {
    free(liste->items);
    free(liste);
}
```

---

## 2. Exemple complet : Analyse de logs Apache

### 2.1 Structure globale

Combinons tout pour analyser un fichier de logs Apache :

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <regex.h>

typedef struct {
    // Compteurs simples
    long long total_requetes;
    long long total_octets;

    // Codes HTTP
    HashMap *codes_http;

    // IPs
    HashMap *ips;

    // URLs
    HashMap *urls;

    // MÃ©thodes HTTP
    HashMap *methodes;

    // Temps de rÃ©ponse (pour calculs statistiques)
    double *temps_reponse;
    int nb_temps_reponse;
    int capacite_temps_reponse;

} StatistiquesLog;

StatistiquesLog *creer_stats() {
    StatistiquesLog *stats = calloc(1, sizeof(StatistiquesLog));

    stats->codes_http = creer_hashmap();
    stats->ips = creer_hashmap();
    stats->urls = creer_hashmap();
    stats->methodes = creer_hashmap();

    stats->capacite_temps_reponse = 10000;
    stats->temps_reponse = malloc(stats->capacite_temps_reponse * sizeof(double));

    return stats;
}

void liberer_stats(StatistiquesLog *stats) {
    liberer_hashmap(stats->codes_http);
    liberer_hashmap(stats->ips);
    liberer_hashmap(stats->urls);
    liberer_hashmap(stats->methodes);
    free(stats->temps_reponse);
    free(stats);
}

void ajouter_temps_reponse(StatistiquesLog *stats, double temps) {
    if (stats->nb_temps_reponse >= stats->capacite_temps_reponse) {
        stats->capacite_temps_reponse *= 2;
        stats->temps_reponse = realloc(stats->temps_reponse,
                                       stats->capacite_temps_reponse * sizeof(double));
    }
    stats->temps_reponse[stats->nb_temps_reponse++] = temps;
}
```

### 2.2 Parser une ligne de log

```c
typedef struct {
    char ip[16];
    char methode[8];
    char url[256];
    int code_http;
    long long octets;
    double temps_reponse;  // en microsecondes
} LigneLog;

int parser_ligne_apache(const char *ligne, LigneLog *entry) {
    regex_t regex;
    regmatch_t matches[7];

    // Pattern Apache avec temps de rÃ©ponse
    // Format: IP - - [date] "METHODE URL HTTP/1.1" CODE OCTETS TEMPS
    const char *pattern =
        "^([0-9.]+) "                          // IP
        "[^ ]+ [^ ]+ "
        "\\[[^\\]]+\\] "
        "\"([A-Z]+) "                          // MÃ©thode
        "([^ ]+) "                              // URL
        "[^\"]+\" "
        "([0-9]+) "                             // Code
        "([0-9]+) "                             // Octets
        "([0-9]+)";                             // Temps (microsec)

    if (regcomp(&regex, pattern, REG_EXTENDED) != 0) {
        return -1;
    }

    if (regexec(&regex, ligne, 7, matches, 0) != 0) {
        regfree(&regex);
        return -1;
    }

    // Extraire IP
    snprintf(entry->ip, sizeof(entry->ip), "%.*s",
             (int)(matches[1].rm_eo - matches[1].rm_so),
             ligne + matches[1].rm_so);

    // Extraire mÃ©thode
    snprintf(entry->methode, sizeof(entry->methode), "%.*s",
             (int)(matches[2].rm_eo - matches[2].rm_so),
             ligne + matches[2].rm_so);

    // Extraire URL
    snprintf(entry->url, sizeof(entry->url), "%.*s",
             (int)(matches[3].rm_eo - matches[3].rm_so),
             ligne + matches[3].rm_so);

    // Extraire code HTTP
    char code_str[8];
    snprintf(code_str, sizeof(code_str), "%.*s",
             (int)(matches[4].rm_eo - matches[4].rm_so),
             ligne + matches[4].rm_so);
    entry->code_http = atoi(code_str);

    // Extraire octets
    char octets_str[16];
    snprintf(octets_str, sizeof(octets_str), "%.*s",
             (int)(matches[5].rm_eo - matches[5].rm_so),
             ligne + matches[5].rm_so);
    entry->octets = atoll(octets_str);

    // Extraire temps de rÃ©ponse
    char temps_str[16];
    snprintf(temps_str, sizeof(temps_str), "%.*s",
             (int)(matches[6].rm_eo - matches[6].rm_so),
             ligne + matches[6].rm_so);
    entry->temps_reponse = atof(temps_str);

    regfree(&regex);
    return 0;
}
```

### 2.3 AgrÃ©ger les donnÃ©es

```c
void agreger_ligne(StatistiquesLog *stats, const LigneLog *entry) {
    // Compter la requÃªte
    stats->total_requetes++;
    stats->total_octets += entry->octets;

    // Compter par code HTTP
    char code_str[8];
    snprintf(code_str, sizeof(code_str), "%d", entry->code_http);
    incrementer(stats->codes_http, code_str);

    // Compter par IP
    incrementer(stats->ips, entry->ip);

    // Compter par URL
    incrementer(stats->urls, entry->url);

    // Compter par mÃ©thode
    incrementer(stats->methodes, entry->methode);

    // Enregistrer le temps de rÃ©ponse
    ajouter_temps_reponse(stats, entry->temps_reponse);
}
```

### 2.4 Traiter le fichier complet

```c
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

void analyser_fichier_log(const char *chemin, StatistiquesLog *stats) {
    // Ouvrir avec mmap pour performance
    int fd = open(chemin, O_RDONLY);
    if (fd == -1) {
        perror("open");
        return;
    }

    struct stat sb;
    fstat(fd, &sb);
    size_t taille = sb.st_size;

    char *data = mmap(NULL, taille, PROT_READ, MAP_PRIVATE, fd, 0);
    if (data == MAP_FAILED) {
        perror("mmap");
        close(fd);
        return;
    }

    madvise(data, taille, MADV_SEQUENTIAL);

    // Parser ligne par ligne
    const char *debut_ligne = data;
    const char *fin = data + taille;
    long long nb_lignes = 0;
    long long nb_erreurs = 0;

    for (const char *p = data; p < fin; p++) {
        if (*p == '\n') {
            size_t longueur = p - debut_ligne;

            if (longueur > 0) {
                // Copier la ligne (pour le parsing)
                char *ligne = malloc(longueur + 1);
                memcpy(ligne, debut_ligne, longueur);
                ligne[longueur] = '\0';

                // Parser et agrÃ©ger
                LigneLog entry;
                if (parser_ligne_apache(ligne, &entry) == 0) {
                    agreger_ligne(stats, &entry);
                } else {
                    nb_erreurs++;
                }

                free(ligne);
            }

            nb_lignes++;
            debut_ligne = p + 1;

            // Afficher progression
            if (nb_lignes % 100000 == 0) {
                printf("\rLignes traitÃ©es: %lld", nb_lignes);
                fflush(stdout);
            }
        }
    }

    printf("\rLignes traitÃ©es: %lld (erreurs: %lld)\n", nb_lignes, nb_erreurs);

    munmap(data, taille);
    close(fd);
}
```

---

## 3. Calculs statistiques avancÃ©s

### 3.1 Moyenne, min, max

```c
typedef struct {
    double min;
    double max;
    double moyenne;
} StatistiquesSimples;

StatistiquesSimples calculer_stats_simples(double *valeurs, int nb_valeurs) {
    StatistiquesSimples stats = {0};

    if (nb_valeurs == 0) return stats;

    stats.min = valeurs[0];
    stats.max = valeurs[0];
    double somme = 0;

    for (int i = 0; i < nb_valeurs; i++) {
        if (valeurs[i] < stats.min) stats.min = valeurs[i];
        if (valeurs[i] > stats.max) stats.max = valeurs[i];
        somme += valeurs[i];
    }

    stats.moyenne = somme / nb_valeurs;
    return stats;
}
```

### 3.2 MÃ©diane et percentiles

```c
#include <stdlib.h>

// Fonction de comparaison pour qsort
int comparer_doubles(const void *a, const void *b) {
    double da = *(const double *)a;
    double db = *(const double *)b;

    if (da < db) return -1;
    if (da > db) return 1;
    return 0;
}

double calculer_percentile(double *valeurs, int nb_valeurs, int percentile) {
    if (nb_valeurs == 0) return 0;

    // Copier et trier
    double *copie = malloc(nb_valeurs * sizeof(double));
    memcpy(copie, valeurs, nb_valeurs * sizeof(double));
    qsort(copie, nb_valeurs, sizeof(double), comparer_doubles);

    // Calculer l'index
    double index = (percentile / 100.0) * (nb_valeurs - 1);
    int index_inf = (int)index;
    int index_sup = index_inf + 1;

    double resultat;
    if (index_sup >= nb_valeurs) {
        resultat = copie[nb_valeurs - 1];
    } else {
        // Interpolation linÃ©aire
        double fraction = index - index_inf;
        resultat = copie[index_inf] + fraction * (copie[index_sup] - copie[index_inf]);
    }

    free(copie);
    return resultat;
}

double calculer_mediane(double *valeurs, int nb_valeurs) {
    return calculer_percentile(valeurs, nb_valeurs, 50);
}
```

### 3.3 Ã‰cart-type

```c
#include <math.h>

double calculer_ecart_type(double *valeurs, int nb_valeurs, double moyenne) {
    if (nb_valeurs <= 1) return 0;

    double somme_carres = 0;
    for (int i = 0; i < nb_valeurs; i++) {
        double diff = valeurs[i] - moyenne;
        somme_carres += diff * diff;
    }

    return sqrt(somme_carres / (nb_valeurs - 1));
}
```

### 3.4 Statistiques complÃ¨tes sur les temps de rÃ©ponse

```c
typedef struct {
    double min;
    double max;
    double moyenne;
    double mediane;
    double percentile_95;
    double percentile_99;
    double ecart_type;
} StatistiquesTemps;

StatistiquesTemps analyser_temps_reponse(StatistiquesLog *stats) {
    StatistiquesTemps result = {0};

    if (stats->nb_temps_reponse == 0) return result;

    // Stats simples
    StatistiquesSimples simples = calculer_stats_simples(
        stats->temps_reponse,
        stats->nb_temps_reponse
    );

    result.min = simples.min;
    result.max = simples.max;
    result.moyenne = simples.moyenne;

    // MÃ©diane et percentiles
    result.mediane = calculer_mediane(stats->temps_reponse, stats->nb_temps_reponse);
    result.percentile_95 = calculer_percentile(stats->temps_reponse,
                                               stats->nb_temps_reponse, 95);
    result.percentile_99 = calculer_percentile(stats->temps_reponse,
                                               stats->nb_temps_reponse, 99);

    // Ã‰cart-type
    result.ecart_type = calculer_ecart_type(stats->temps_reponse,
                                            stats->nb_temps_reponse,
                                            result.moyenne);

    return result;
}
```

---

## 4. Top N et classements

### 4.1 Extraire et trier le top N

```c
typedef struct {
    char cle[256];
    long long valeur;
} TopEntry;

// Convertir HashMap en liste triÃ©e
ListeItems *hashmap_vers_liste(HashMap *map) {
    ListeItems *liste = creer_liste();

    for (int i = 0; i < HASH_SIZE; i++) {
        Entry *entry = map->buckets[i];
        while (entry != NULL) {
            ajouter_item(liste, entry->cle, entry->valeur);
            entry = entry->suivant;
        }
    }

    trier_liste(liste);
    return liste;
}

void afficher_top_n(HashMap *map, const char *titre, int n) {
    ListeItems *liste = hashmap_vers_liste(map);

    printf("\n%s (Top %d):\n", titre, n);
    printf("â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n");
    printf("â”‚ %-38s â”‚ %-8s â”‚\n", "EntrÃ©e", "Compteur");
    printf("â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n");

    int limite = (liste->taille < n) ? liste->taille : n;
    for (int i = 0; i < limite; i++) {
        printf("â”‚ %-38s â”‚ %8lld â”‚\n",
               liste->items[i].cle,
               liste->items[i].valeur);
    }

    printf("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n");

    liberer_liste(liste);
}
```

### 4.2 Distribution par tranches

Pour analyser la distribution (par exemple, des temps de rÃ©ponse par tranches) :

```c
typedef struct {
    int tranches[10];  // 0-100ms, 100-200ms, ..., 900-1000ms, >1000ms
} DistributionTemps;

void calculer_distribution(double *valeurs, int nb_valeurs, DistributionTemps *dist) {
    memset(dist->tranches, 0, sizeof(dist->tranches));

    for (int i = 0; i < nb_valeurs; i++) {
        double ms = valeurs[i] / 1000.0;  // Convertir microsec en millisec

        if (ms < 1000) {
            int tranche = (int)(ms / 100);
            if (tranche < 10) {
                dist->tranches[tranche]++;
            }
        } else {
            dist->tranches[9]++;  // >1000ms
        }
    }
}

void afficher_distribution(const DistributionTemps *dist, int total) {
    printf("\nDistribution des temps de rÃ©ponse:\n");

    const char *labels[] = {
        "0-100ms", "100-200ms", "200-300ms", "300-400ms", "400-500ms",
        "500-600ms", "600-700ms", "700-800ms", "800-900ms", ">1000ms"
    };

    for (int i = 0; i < 10; i++) {
        int count = dist->tranches[i];
        double pourcentage = 100.0 * count / total;

        // Barre ASCII
        int largeur = (int)(pourcentage / 2);
        printf("  %-10s [", labels[i]);
        for (int j = 0; j < 50; j++) {
            printf(j < largeur ? "â–ˆ" : " ");
        }
        printf("] %6d (%.1f%%)\n", count, pourcentage);
    }
}
```

---

## 5. Rapport complet

### 5.1 Fonction de gÃ©nÃ©ration de rapport

```c
void generer_rapport(StatistiquesLog *stats) {
    printf("\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("                    RAPPORT D'ANALYSE                       \n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");

    // 1. Vue d'ensemble
    printf("\nğŸ“Š VUE D'ENSEMBLE\n");
    printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
    printf("  RequÃªtes totales:      %lld\n", stats->total_requetes);
    printf("  DonnÃ©es transfÃ©rÃ©es:   %.2f GB\n",
           stats->total_octets / (1024.0 * 1024.0 * 1024.0));
    printf("  Octets/requÃªte (moy):  %.0f octets\n",
           (double)stats->total_octets / stats->total_requetes);

    // 2. Codes HTTP
    printf("\nğŸŒ CODES HTTP\n");
    printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
    ListeItems *codes = hashmap_vers_liste(stats->codes_http);
    trier_liste(codes);

    for (int i = 0; i < codes->taille && i < 10; i++) {
        long long count = codes->items[i].valeur;
        double pct = 100.0 * count / stats->total_requetes;
        printf("  %s: %lld (%.1f%%)\n", codes->items[i].cle, count, pct);
    }
    liberer_liste(codes);

    // 3. Top IPs
    afficher_top_n(stats->ips, "ğŸ” TOP 10 IPs", 10);

    // 4. Top URLs
    afficher_top_n(stats->urls, "ğŸ” TOP 10 URLs", 10);

    // 5. MÃ©thodes HTTP
    printf("\nğŸ“¡ MÃ‰THODES HTTP\n");
    printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
    ListeItems *methodes = hashmap_vers_liste(stats->methodes);
    for (int i = 0; i < methodes->taille; i++) {
        long long count = methodes->items[i].valeur;
        double pct = 100.0 * count / stats->total_requetes;
        printf("  %s: %lld (%.1f%%)\n",
               methodes->items[i].cle, count, pct);
    }
    liberer_liste(methodes);

    // 6. Statistiques temps de rÃ©ponse
    if (stats->nb_temps_reponse > 0) {
        printf("\nâ±ï¸  TEMPS DE RÃ‰PONSE\n");
        printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");

        StatistiquesTemps temps = analyser_temps_reponse(stats);

        printf("  Min:           %.2f ms\n", temps.min / 1000.0);
        printf("  Moyenne:       %.2f ms\n", temps.moyenne / 1000.0);
        printf("  MÃ©diane (p50): %.2f ms\n", temps.mediane / 1000.0);
        printf("  p95:           %.2f ms\n", temps.percentile_95 / 1000.0);
        printf("  p99:           %.2f ms\n", temps.percentile_99 / 1000.0);
        printf("  Max:           %.2f ms\n", temps.max / 1000.0);
        printf("  Ã‰cart-type:    %.2f ms\n", temps.ecart_type / 1000.0);

        // Distribution
        DistributionTemps dist;
        calculer_distribution(stats->temps_reponse,
                             stats->nb_temps_reponse,
                             &dist);
        afficher_distribution(&dist, stats->nb_temps_reponse);
    }

    printf("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
}
```

---

## 6. Export des rÃ©sultats

### 6.1 Export JSON

```c
#include <stdio.h>

void exporter_json(StatistiquesLog *stats, const char *fichier) {
    FILE *fp = fopen(fichier, "w");
    if (fp == NULL) {
        perror("fopen");
        return;
    }

    fprintf(fp, "{\n");
    fprintf(fp, "  \"total_requetes\": %lld,\n", stats->total_requetes);
    fprintf(fp, "  \"total_octets\": %lld,\n", stats->total_octets);

    // Temps de rÃ©ponse
    if (stats->nb_temps_reponse > 0) {
        StatistiquesTemps temps = analyser_temps_reponse(stats);

        fprintf(fp, "  \"temps_reponse\": {\n");
        fprintf(fp, "    \"min\": %.2f,\n", temps.min);
        fprintf(fp, "    \"moyenne\": %.2f,\n", temps.moyenne);
        fprintf(fp, "    \"mediane\": %.2f,\n", temps.mediane);
        fprintf(fp, "    \"p95\": %.2f,\n", temps.percentile_95);
        fprintf(fp, "    \"p99\": %.2f,\n", temps.percentile_99);
        fprintf(fp, "    \"max\": %.2f\n", temps.max);
        fprintf(fp, "  },\n");
    }

    // Top 10 IPs
    fprintf(fp, "  \"top_ips\": [\n");
    ListeItems *ips = hashmap_vers_liste(stats->ips);
    int limite = (ips->taille < 10) ? ips->taille : 10;
    for (int i = 0; i < limite; i++) {
        fprintf(fp, "    {\"ip\": \"%s\", \"count\": %lld}%s\n",
                ips->items[i].cle,
                ips->items[i].valeur,
                (i < limite - 1) ? "," : "");
    }
    fprintf(fp, "  ]\n");
    liberer_liste(ips);

    fprintf(fp, "}\n");
    fclose(fp);

    printf("RÃ©sultats exportÃ©s dans %s\n", fichier);
}
```

### 6.2 Export CSV

```c
void exporter_csv(HashMap *map, const char *fichier, const char *colonne1, const char *colonne2) {
    FILE *fp = fopen(fichier, "w");
    if (fp == NULL) {
        perror("fopen");
        return;
    }

    // En-tÃªte
    fprintf(fp, "%s,%s\n", colonne1, colonne2);

    // DonnÃ©es triÃ©es
    ListeItems *liste = hashmap_vers_liste(map);

    for (int i = 0; i < liste->taille; i++) {
        fprintf(fp, "%s,%lld\n",
                liste->items[i].cle,
                liste->items[i].valeur);
    }

    liberer_liste(liste);
    fclose(fp);

    printf("DonnÃ©es exportÃ©es dans %s\n", fichier);
}
```

---

## 7. AgrÃ©gation par pÃ©riode temporelle

### 7.1 Compteurs par heure

```c
typedef struct {
    int compteurs[24];  // Une entrÃ©e par heure (0-23)
} StatistiquesHoraires;

int extraire_heure(const char *timestamp) {
    // Format: "15/Jan/2025:14:30:45"
    // Extraire l'heure (caractÃ¨res aprÃ¨s le ':')
    const char *p = strchr(timestamp, ':');
    if (p == NULL) return -1;

    return atoi(p + 1);
}

void agreger_par_heure(StatistiquesHoraires *stats, const char *timestamp) {
    int heure = extraire_heure(timestamp);
    if (heure >= 0 && heure < 24) {
        stats->compteurs[heure]++;
    }
}

void afficher_stats_horaires(const StatistiquesHoraires *stats) {
    printf("\nğŸ“… DISTRIBUTION HORAIRE\n");
    printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");

    int max_count = 0;
    for (int i = 0; i < 24; i++) {
        if (stats->compteurs[i] > max_count) {
            max_count = stats->compteurs[i];
        }
    }

    for (int h = 0; h < 24; h++) {
        int count = stats->compteurs[h];
        int largeur = (count * 50) / max_count;

        printf("  %02d:00 [", h);
        for (int i = 0; i < 50; i++) {
            printf(i < largeur ? "â–ˆ" : " ");
        }
        printf("] %d\n", count);
    }
}
```

### 7.2 AgrÃ©gation par jour/semaine/mois

```c
#include <time.h>

typedef struct {
    char date[11];      // YYYY-MM-DD
    long long count;
} StatistiqueJournaliere;

// Extraire la date d'un timestamp
void extraire_date(const char *timestamp, char *date_sortie) {
    // Format entrÃ©e: "15/Jan/2025:14:30:45"
    // Format sortie: "2025-01-15"

    char jour[3], mois[4], annee[5];
    sscanf(timestamp, "%2s/%3s/%4s", jour, mois, annee);

    // Conversion mois texte -> numÃ©ro
    const char *mois_noms[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
                                "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
    int mois_num = 1;
    for (int i = 0; i < 12; i++) {
        if (strcmp(mois, mois_noms[i]) == 0) {
            mois_num = i + 1;
            break;
        }
    }

    sprintf(date_sortie, "%s-%02d-%s", annee, mois_num, jour);
}
```

---

## 8. Analyse en temps rÃ©el (streaming)

### 8.1 FenÃªtre glissante

Pour analyser les N derniÃ¨res requÃªtes :

```c
#define TAILLE_FENETRE 1000

typedef struct {
    LigneLog buffer[TAILLE_FENETRE];
    int index_courant;
    int rempli;
} FenetreGlissante;

void ajouter_a_fenetre(FenetreGlissante *fenetre, const LigneLog *entry) {
    fenetre->buffer[fenetre->index_courant] = *entry;
    fenetre->index_courant = (fenetre->index_courant + 1) % TAILLE_FENETRE;

    if (!fenetre->rempli && fenetre->index_courant == 0) {
        fenetre->rempli = 1;
    }
}

double calculer_moyenne_fenetre(FenetreGlissante *fenetre) {
    int taille = fenetre->rempli ? TAILLE_FENETRE : fenetre->index_courant;
    if (taille == 0) return 0;

    double somme = 0;
    for (int i = 0; i < taille; i++) {
        somme += fenetre->buffer[i].temps_reponse;
    }

    return somme / taille;
}
```

### 8.2 DÃ©tection d'anomalies simples

```c
typedef struct {
    double seuil_temps_reponse;  // ms
    int seuil_erreurs_consecutives;

    // Ã‰tat
    int erreurs_consecutives;
    double temps_moy_recent;
} DetecteurAnomalies;

void verifier_anomalie(DetecteurAnomalies *detecteur, const LigneLog *entry) {
    // VÃ©rifier erreur HTTP
    if (entry->code_http >= 500) {
        detecteur->erreurs_consecutives++;

        if (detecteur->erreurs_consecutives >= detecteur->seuil_erreurs_consecutives) {
            printf("âš ï¸  ALERTE: %d erreurs 5xx consÃ©cutives!\n",
                   detecteur->erreurs_consecutives);
        }
    } else {
        detecteur->erreurs_consecutives = 0;
    }

    // VÃ©rifier temps de rÃ©ponse
    double temps_ms = entry->temps_reponse / 1000.0;
    if (temps_ms > detecteur->seuil_temps_reponse) {
        printf("âš ï¸  ALERTE: Temps de rÃ©ponse Ã©levÃ©: %.2f ms pour %s\n",
               temps_ms, entry->url);
    }
}
```

---

## 9. Optimisations pour gros volumes

### 9.1 Ã‰chantillonnage

Pour de trÃ¨s gros fichiers (>10 GB), traiter 1 ligne sur N :

```c
void analyser_avec_echantillonnage(const char *chemin,
                                   StatistiquesLog *stats,
                                   int taux_echantillonnage) {
    FILE *fp = fopen(chemin, "r");
    if (fp == NULL) return;

    char ligne[4096];
    long long nb_lignes = 0;

    while (fgets(ligne, sizeof(ligne), fp) != NULL) {
        nb_lignes++;

        // Ne traiter qu'une ligne sur N
        if (nb_lignes % taux_echantillonnage == 0) {
            LigneLog entry;
            if (parser_ligne_apache(ligne, &entry) == 0) {
                agreger_ligne(stats, &entry);
            }
        }
    }

    fclose(fp);

    // Extrapoler les rÃ©sultats
    stats->total_requetes *= taux_echantillonnage;
    stats->total_octets *= taux_echantillonnage;
}
```

### 9.2 Traitement parallÃ¨le

Pour exploiter plusieurs cÅ“urs CPU :

```c
#include <pthread.h>

typedef struct {
    const char *data_debut;
    const char *data_fin;
    StatistiquesLog *stats_locales;
} ThreadData;

void *traiter_chunk(void *arg) {
    ThreadData *td = (ThreadData *)arg;

    // Parser les lignes dans ce chunk
    const char *debut_ligne = td->data_debut;

    for (const char *p = td->data_debut; p < td->data_fin; p++) {
        if (*p == '\n') {
            size_t longueur = p - debut_ligne;

            if (longueur > 0) {
                char *ligne = malloc(longueur + 1);
                memcpy(ligne, debut_ligne, longueur);
                ligne[longueur] = '\0';

                LigneLog entry;
                if (parser_ligne_apache(ligne, &entry) == 0) {
                    agreger_ligne(td->stats_locales, &entry);
                }

                free(ligne);
            }

            debut_ligne = p + 1;
        }
    }

    return NULL;
}

void analyser_parallele(const char *chemin, int nb_threads) {
    // Mapper le fichier
    int fd = open(chemin, O_RDONLY);
    struct stat sb;
    fstat(fd, &sb);
    size_t taille = sb.st_size;

    char *data = mmap(NULL, taille, PROT_READ, MAP_PRIVATE, fd, 0);

    // Diviser en chunks
    pthread_t *threads = malloc(nb_threads * sizeof(pthread_t));
    ThreadData *thread_data = malloc(nb_threads * sizeof(ThreadData));

    size_t chunk_size = taille / nb_threads;

    for (int i = 0; i < nb_threads; i++) {
        thread_data[i].data_debut = data + (i * chunk_size);
        thread_data[i].data_fin = (i == nb_threads - 1) ?
                                  data + taille :
                                  data + ((i + 1) * chunk_size);
        thread_data[i].stats_locales = creer_stats();

        pthread_create(&threads[i], NULL, traiter_chunk, &thread_data[i]);
    }

    // Attendre et fusionner les rÃ©sultats
    StatistiquesLog *stats_globales = creer_stats();

    for (int i = 0; i < nb_threads; i++) {
        pthread_join(threads[i], NULL);
        // Fusionner thread_data[i].stats_locales dans stats_globales
        // (code de fusion Ã  implÃ©menter)
    }

    // GÃ©nÃ©rer le rapport
    generer_rapport(stats_globales);

    // Nettoyage
    free(threads);
    free(thread_data);
    munmap(data, taille);
    close(fd);
}
```

---

## 10. Exemple d'utilisation complet

### 10.1 Programme principal

```c
int main(int argc, char *argv[]) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <fichier.log> [options]\n", argv[0]);
        fprintf(stderr, "Options:\n");
        fprintf(stderr, "  --json <fichier>    Exporter en JSON\n");
        fprintf(stderr, "  --csv-ips <fichier> Exporter IPs en CSV\n");
        return 1;
    }

    const char *fichier_log = argv[1];
    const char *fichier_json = NULL;
    const char *fichier_csv_ips = NULL;

    // Parser les options
    for (int i = 2; i < argc; i++) {
        if (strcmp(argv[i], "--json") == 0 && i + 1 < argc) {
            fichier_json = argv[++i];
        } else if (strcmp(argv[i], "--csv-ips") == 0 && i + 1 < argc) {
            fichier_csv_ips = argv[++i];
        }
    }

    printf("Analyse de %s...\n", fichier_log);

    // CrÃ©er les structures
    StatistiquesLog *stats = creer_stats();

    // Analyser le fichier
    clock_t debut = clock();
    analyser_fichier_log(fichier_log, stats);
    clock_t fin = clock();

    double temps = (double)(fin - debut) / CLOCKS_PER_SEC;
    printf("Analyse terminÃ©e en %.2f secondes\n", temps);

    // GÃ©nÃ©rer le rapport
    generer_rapport(stats);

    // Exports optionnels
    if (fichier_json != NULL) {
        exporter_json(stats, fichier_json);
    }

    if (fichier_csv_ips != NULL) {
        exporter_csv(stats->ips, fichier_csv_ips, "ip", "count");
    }

    // Nettoyage
    liberer_stats(stats);

    return 0;
}
```

### 10.2 Compilation et utilisation

```bash
# Compiler
gcc -O3 -o logparser logparser.c -lm -lpthread

# Utiliser
./logparser access.log

# Avec exports
./logparser access.log --json stats.json --csv-ips ips.csv

# Benchmark sur gros fichier
time ./logparser /var/log/apache2/access.log
```

---

## 11. RÃ©capitulatif

### 11.1 Structures de donnÃ©es essentielles

| Structure | Usage | Performance |
|-----------|-------|-------------|
| HashMap | Compteurs par clÃ© unique | O(1) insertion/lookup |
| Tableau dynamique | Stockage pour tri | O(n log n) tri |
| Buffer circulaire | FenÃªtre glissante | O(1) insertion |
| Tableau de compteurs | Distribution par tranches | O(1) par catÃ©gorie |

### 11.2 Statistiques clÃ©s Ã  calculer

âœ… **Basiques :**
- Total de requÃªtes
- Total d'octets transfÃ©rÃ©s
- Distribution des codes HTTP

âœ… **AvancÃ©es :**
- Moyenne, mÃ©diane, percentiles (p95, p99)
- Ã‰cart-type
- Min/max

âœ… **Classements :**
- Top N IPs/URLs/User-Agents
- Distribution temporelle (horaire, journaliÃ¨re)

âœ… **Anomalies :**
- Pics de trafic
- SÃ©ries d'erreurs
- Temps de rÃ©ponse anormaux

### 11.3 Optimisations pour la performance

1. **Utiliser mmap()** pour lecture de fichiers
2. **RÃ©utiliser les regex** compilÃ©es
3. **HashMap efficace** pour les compteurs
4. **Ã‰chantillonnage** pour fichiers >10 GB
5. **Traitement parallÃ¨le** pour exploiter tous les cÅ“urs

---

## 12. Conclusion

L'agrÃ©gation et les statistiques transforment des milliers de lignes de logs en informations exploitables. Les points clÃ©s :

1. **Structures de donnÃ©es adaptÃ©es** : HashMap pour compter, tableaux pour trier
2. **Statistiques pertinentes** : Au-delÃ  de la moyenne, calculer mÃ©diane et percentiles
3. **Visualisation claire** : Rapports lisibles avec graphiques ASCII
4. **Exports standards** : JSON/CSV pour intÃ©gration avec d'autres outils
5. **Performance** : mmap, parallÃ©lisation pour gros volumes

Un bon parser de logs combine :
- Lecture efficace (section 34.2.1)
- Extraction prÃ©cise avec regex (section 34.2.2)
- AgrÃ©gation intelligente et statistiques (section 34.2.3)

Avec ces trois compÃ©tences, vous pouvez crÃ©er des outils d'analyse de logs professionnels capables de traiter des tÃ©raoctets de donnÃ©es et de fournir des insights prÃ©cieux sur le comportement de vos systÃ¨mes.

â­ï¸ [Agent de monitoring systÃ¨me](/34-etudes-cas-devops/03-agent-monitoring.md)
