üîù Retour au [Sommaire](/SOMMAIRE.md)

# 2.5.3 Configuration GCC/GDB/CMake/Valgrind

## Introduction

Maintenant que vous comprenez la structure d'un fichier `.devcontainer.json`, nous allons configurer les quatre outils essentiels pour le d√©veloppement C professionnel :

- **GCC** : Le compilateur qui transforme votre code en programme ex√©cutable
- **GDB** : Le d√©bogueur pour traquer et corriger les bugs
- **CMake** : Le syst√®me de build moderne pour g√©rer vos projets
- **Valgrind** : L'analyseur m√©moire pour d√©tecter les fuites et erreurs

L'objectif de cette section est de cr√©er un DevContainer **complet et fonctionnel** avec tous ces outils correctement configur√©s et int√©gr√©s √† VS Code.

**Analogie :** C'est comme √©quiper un atelier de menuiserie avec les bons outils, correctement rang√©s et r√©gl√©s. GCC est la scie principale, GDB est la loupe pour inspecter les d√©tails, CMake est le plan de travail organis√©, et Valgrind est le d√©tecteur de d√©fauts.

---

## Pr√©requis

Avant de commencer, assurez-vous d'avoir :

- Docker install√© et fonctionnel
- VS Code avec l'extension "Dev Containers"
- Un projet de test ou un nouveau dossier vide

### V√©rification de Docker

```bash
docker --version
# Docker version 24.x.x ou sup√©rieur

docker ps
# Devrait s'ex√©cuter sans erreur
```

---

## Structure du projet

Pour cette section, nous allons cr√©er la structure suivante :

```
mon-projet-c/
‚îú‚îÄ‚îÄ .devcontainer/
‚îÇ   ‚îî‚îÄ‚îÄ devcontainer.json
‚îú‚îÄ‚îÄ .vscode/
‚îÇ   ‚îú‚îÄ‚îÄ tasks.json
‚îÇ   ‚îú‚îÄ‚îÄ launch.json
‚îÇ   ‚îî‚îÄ‚îÄ c_cpp_properties.json
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îî‚îÄ‚îÄ main.c
‚îú‚îÄ‚îÄ include/
‚îÇ   ‚îî‚îÄ‚îÄ (fichiers .h)
‚îú‚îÄ‚îÄ build/
‚îÇ   ‚îî‚îÄ‚îÄ (fichiers g√©n√©r√©s par CMake)
‚îú‚îÄ‚îÄ CMakeLists.txt
‚îî‚îÄ‚îÄ README.md
```

---

## Partie 1 : Configuration de GCC

### Qu'est-ce que GCC ?

**GCC** (GNU Compiler Collection) est le compilateur standard sous Linux. Il transforme votre code source C (`.c`) en un programme ex√©cutable que l'ordinateur peut lancer.

### Installation de GCC dans le DevContainer

#### M√©thode 1 : Image pr√©-configur√©e (recommand√©e)

L'image Microsoft pour C/C++ contient d√©j√† GCC :

```json
{
    "name": "Projet C avec GCC",
    "image": "mcr.microsoft.com/devcontainers/cpp:ubuntu-22.04"
}
```

Cette image inclut :
- GCC 11.x
- G++ 11.x
- Make
- Les headers de la libc

#### M√©thode 2 : Installation manuelle

Si vous partez d'une image Ubuntu de base :

```json
{
    "name": "Projet C - GCC manuel",
    "image": "ubuntu:22.04",
    "postCreateCommand": "apt-get update && apt-get install -y build-essential"
}
```

Le paquet `build-essential` installe GCC, G++, Make et les biblioth√®ques essentielles.

#### M√©thode 3 : Version sp√©cifique de GCC

Pour installer une version pr√©cise de GCC :

```json
{
    "name": "Projet C - GCC 12",
    "image": "ubuntu:22.04",
    "postCreateCommand": "apt-get update && apt-get install -y gcc-12 g++-12 make && update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-12 100 && update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-12 100"
}
```

### Configuration de GCC dans VS Code

Pour que VS Code comprenne votre configuration GCC, cr√©ez ou modifiez le fichier `.vscode/c_cpp_properties.json` :

```json
{
    "configurations": [
        {
            "name": "Linux",
            "includePath": [
                "${workspaceFolder}/**",
                "${workspaceFolder}/include",
                "/usr/include/**",
                "/usr/local/include/**"
            ],
            "defines": [],
            "compilerPath": "/usr/bin/gcc",
            "cStandard": "c17",
            "cppStandard": "c++17",
            "intelliSenseMode": "linux-gcc-x64"
        }
    ],
    "version": 4
}
```

**Explications :**

| Param√®tre | Description |
|-----------|-------------|
| `includePath` | Dossiers o√π chercher les fichiers `.h` |
| `compilerPath` | Chemin vers le compilateur GCC |
| `cStandard` | Norme C √† utiliser (c11, c17, c23) |
| `intelliSenseMode` | Mode d'analyse pour Linux avec GCC |

### Variables d'environnement pour GCC

Dans le `devcontainer.json`, d√©finissez les options de compilation par d√©faut :

```json
{
    "remoteEnv": {
        "CC": "gcc",
        "CXX": "g++",
        "CFLAGS": "-Wall -Wextra -Werror -std=c17 -g",
        "LDFLAGS": ""
    }
}
```

**Signification des flags :**

| Flag | Description |
|------|-------------|
| `-Wall` | Active tous les avertissements courants |
| `-Wextra` | Active des avertissements suppl√©mentaires |
| `-Werror` | Traite les avertissements comme des erreurs |
| `-std=c17` | Utilise la norme C17 |
| `-g` | Inclut les symboles de d√©bogage (pour GDB) |

### T√¢che de compilation dans VS Code

Cr√©ez `.vscode/tasks.json` pour compiler facilement :

```json
{
    "version": "2.0.0",
    "tasks": [
        {
            "label": "GCC: Compiler le fichier actuel",
            "type": "shell",
            "command": "gcc",
            "args": [
                "-Wall",
                "-Wextra",
                "-std=c17",
                "-g",
                "${file}",
                "-o",
                "${fileDirname}/${fileBasenameNoExtension}"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "problemMatcher": ["$gcc"],
            "detail": "Compile le fichier C actuel avec GCC"
        },
        {
            "label": "GCC: Compiler tout le projet",
            "type": "shell",
            "command": "gcc",
            "args": [
                "-Wall",
                "-Wextra",
                "-std=c17",
                "-g",
                "${workspaceFolder}/src/*.c",
                "-I${workspaceFolder}/include",
                "-o",
                "${workspaceFolder}/build/programme"
            ],
            "problemMatcher": ["$gcc"],
            "detail": "Compile tous les fichiers .c du dossier src"
        }
    ]
}
```

**Utilisation :**
- `Ctrl+Shift+B` : Lance la t√¢che de build par d√©faut
- `Ctrl+Shift+P` ‚Üí "Tasks: Run Task" : Choisir une t√¢che sp√©cifique

---

## Partie 2 : Configuration de GDB

### Qu'est-ce que GDB ?

**GDB** (GNU Debugger) est l'outil qui vous permet de :
- Ex√©cuter votre programme pas √† pas
- Placer des **breakpoints** (points d'arr√™t)
- Inspecter les valeurs des variables
- Comprendre pourquoi votre programme plante

**Analogie :** C'est comme un m√©decin qui peut mettre un patient "en pause" pour examiner son √©tat interne √† tout moment.

### Installation de GDB

#### Avec l'image Microsoft (d√©j√† inclus)

```json
{
    "image": "mcr.microsoft.com/devcontainers/cpp:ubuntu-22.04"
}
```

GDB est d√©j√† install√© dans cette image.

#### Installation manuelle

```json
{
    "postCreateCommand": "apt-get update && apt-get install -y gdb"
}
```

### Configuration Docker essentielle pour GDB

**IMPORTANT :** GDB n√©cessite des permissions sp√©ciales pour fonctionner dans un conteneur Docker.

```json
{
    "runArgs": [
        "--cap-add=SYS_PTRACE",
        "--security-opt", "seccomp=unconfined"
    ]
}
```

**Explications :**

| Option | Pourquoi c'est n√©cessaire |
|--------|---------------------------|
| `--cap-add=SYS_PTRACE` | Permet √† GDB de s'attacher aux processus |
| `--security-opt seccomp=unconfined` | D√©sactive les restrictions de s√©curit√© qui bloquent le d√©bogage |

**Sans ces options**, vous aurez des erreurs comme :
```
Could not attach to process  
ptrace: Operation not permitted  
```

### Configuration de launch.json pour le d√©bogage

Cr√©ez `.vscode/launch.json` pour configurer le d√©bogueur VS Code :

```json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "GDB: D√©boguer le fichier actuel",
            "type": "cppdbg",
            "request": "launch",
            "program": "${fileDirname}/${fileBasenameNoExtension}",
            "args": [],
            "stopAtEntry": false,
            "cwd": "${workspaceFolder}",
            "environment": [],
            "externalConsole": false,
            "MIMode": "gdb",
            "setupCommands": [
                {
                    "description": "Activer le pretty-printing pour GDB",
                    "text": "-enable-pretty-printing",
                    "ignoreFailures": true
                },
                {
                    "description": "D√©finir le mode de d√©sassemblage sur Intel",
                    "text": "-gdb-set disassembly-flavor intel",
                    "ignoreFailures": true
                }
            ],
            "preLaunchTask": "GCC: Compiler le fichier actuel",
            "miDebuggerPath": "/usr/bin/gdb"
        },
        {
            "name": "GDB: D√©boguer le projet CMake",
            "type": "cppdbg",
            "request": "launch",
            "program": "${workspaceFolder}/build/mon_programme",
            "args": [],
            "stopAtEntry": false,
            "cwd": "${workspaceFolder}",
            "environment": [],
            "externalConsole": false,
            "MIMode": "gdb",
            "setupCommands": [
                {
                    "description": "Activer le pretty-printing pour GDB",
                    "text": "-enable-pretty-printing",
                    "ignoreFailures": true
                }
            ],
            "preLaunchTask": "CMake: Build",
            "miDebuggerPath": "/usr/bin/gdb"
        },
        {
            "name": "GDB: Attacher √† un processus",
            "type": "cppdbg",
            "request": "attach",
            "program": "${workspaceFolder}/build/mon_programme",
            "processId": "${command:pickProcess}",
            "MIMode": "gdb",
            "miDebuggerPath": "/usr/bin/gdb"
        }
    ]
}
```

**Param√®tres importants :**

| Param√®tre | Description |
|-----------|-------------|
| `program` | Chemin vers l'ex√©cutable √† d√©boguer |
| `args` | Arguments pass√©s au programme |
| `stopAtEntry` | S'arr√™ter au d√©but de `main()` si `true` |
| `preLaunchTask` | T√¢che √† ex√©cuter avant le d√©bogage (compilation) |
| `miDebuggerPath` | Chemin vers GDB |

### Utilisation du d√©bogueur

1. **Placer un breakpoint** : Cliquez dans la marge gauche √† c√¥t√© d'une ligne
2. **Lancer le d√©bogage** : `F5` ou menu Run ‚Üí Start Debugging
3. **Contr√¥les** :
   - `F10` : Step Over (ligne suivante, sans entrer dans les fonctions)
   - `F11` : Step Into (entrer dans la fonction)
   - `Shift+F11` : Step Out (sortir de la fonction)
   - `F5` : Continue (jusqu'au prochain breakpoint)

### Configuration avanc√©e de GDB

Pour des fonctionnalit√©s avanc√©es, cr√©ez un fichier `.gdbinit` √† la racine du projet :

```gdb
# Activer l'historique des commandes
set history save on  
set history size 10000  
set history filename ~/.gdb_history  

# Affichage am√©lior√©
set print pretty on  
set print array on  
set print array-indexes on  

# Pagination d√©sactiv√©e (pour les longues sorties)
set pagination off

# Confirmer avant de quitter
set confirm off

# D√©finir des alias utiles
define parray
    set $i = 0
    while $i < $arg1
        printf "[%d] = ", $i
        print $arg0[$i]
        set $i = $i + 1
    end
end  
document parray  
    Print array elements. Usage: parray array_name length
end
```

---

## Partie 3 : Configuration de CMake

### Qu'est-ce que CMake ?

**CMake** est un syst√®me de build moderne qui g√©n√®re automatiquement les fichiers de compilation (Makefile, Ninja, etc.) √† partir d'une description de haut niveau.

**Avantages par rapport √† un Makefile manuel :**
- Plus facile √† maintenir
- Portable entre diff√©rents syst√®mes
- D√©tection automatique des d√©pendances
- Int√©gration native avec les IDE

**Analogie :** Si le Makefile est une liste d'instructions d√©taill√©es pour construire une maison, CMake est l'architecte qui g√©n√®re ces instructions automatiquement √† partir d'un plan simplifi√©.

### Installation de CMake

#### Avec l'image Microsoft

```json
{
    "image": "mcr.microsoft.com/devcontainers/cpp:ubuntu-22.04"
}
```

CMake est d√©j√† inclus.

#### Installation manuelle

```json
{
    "postCreateCommand": "apt-get update && apt-get install -y cmake"
}
```

#### Version r√©cente de CMake

Les d√©p√¥ts Ubuntu ont parfois des versions anciennes. Pour une version r√©cente :

```json
{
    "postCreateCommand": "apt-get update && apt-get install -y wget && wget -qO- 'https://apt.kitware.com/keys/kitware-archive-latest.asc' | gpg --dearmor -o /usr/share/keyrings/kitware-archive-keyring.gpg && echo 'deb [signed-by=/usr/share/keyrings/kitware-archive-keyring.gpg] https://apt.kitware.com/ubuntu/ jammy main' | tee /etc/apt/sources.list.d/kitware.list && apt-get update && apt-get install -y cmake"
}
```

### Extensions VS Code pour CMake

Dans le `devcontainer.json` :

```json
{
    "customizations": {
        "vscode": {
            "extensions": [
                "ms-vscode.cpptools",
                "ms-vscode.cmake-tools",
                "twxs.cmake"
            ]
        }
    }
}
```

**Extensions :**

| Extension | Fonction |
|-----------|----------|
| `ms-vscode.cmake-tools` | Int√©gration CMake compl√®te dans VS Code |
| `twxs.cmake` | Coloration syntaxique pour CMakeLists.txt |

### Fichier CMakeLists.txt de base

Cr√©ez `CMakeLists.txt` √† la racine du projet :

```cmake
# Version minimale de CMake requise
cmake_minimum_required(VERSION 3.16)

# Nom du projet et langage
project(MonProjetC
    VERSION 1.0.0
    DESCRIPTION "Un projet C d'exemple"
    LANGUAGES C
)

# Standard C √† utiliser
set(CMAKE_C_STANDARD 17)  
set(CMAKE_C_STANDARD_REQUIRED ON)  
set(CMAKE_C_EXTENSIONS OFF)  

# Options de compilation
# Mode Debug par d√©faut si non sp√©cifi√©
if(NOT CMAKE_BUILD_TYPE)
    set(CMAKE_BUILD_TYPE Debug)
endif()

# Flags de compilation selon le mode
set(CMAKE_C_FLAGS_DEBUG "-g -O0 -Wall -Wextra -Werror -DDEBUG")  
set(CMAKE_C_FLAGS_RELEASE "-O2 -Wall -Wextra -DNDEBUG")  

# Afficher le mode de compilation
message(STATUS "Build type: ${CMAKE_BUILD_TYPE}")

# Dossier des headers
include_directories(${PROJECT_SOURCE_DIR}/include)

# Collecter tous les fichiers source
file(GLOB SOURCES "src/*.c")

# Cr√©er l'ex√©cutable
add_executable(${PROJECT_NAME} ${SOURCES})

# Optionnel : Lier des biblioth√®ques
# target_link_libraries(${PROJECT_NAME} m pthread)

# Afficher un r√©sum√©
message(STATUS "Project: ${PROJECT_NAME}")  
message(STATUS "Version: ${PROJECT_VERSION}")  
message(STATUS "C Standard: ${CMAKE_C_STANDARD}")  
```

### CMakeLists.txt avanc√© avec tests

```cmake
cmake_minimum_required(VERSION 3.16)

project(MonProjetC
    VERSION 1.0.0
    LANGUAGES C
)

# Options configurables
option(BUILD_TESTS "Build unit tests" ON)  
option(ENABLE_SANITIZERS "Enable AddressSanitizer and UBSan" OFF)  

# Standard C
set(CMAKE_C_STANDARD 17)  
set(CMAKE_C_STANDARD_REQUIRED ON)  

# Flags de base
add_compile_options(-Wall -Wextra)

# Sanitizers (optionnel)
if(ENABLE_SANITIZERS)
    add_compile_options(-fsanitize=address,undefined -fno-omit-frame-pointer)
    add_link_options(-fsanitize=address,undefined)
endif()

# Headers
include_directories(${PROJECT_SOURCE_DIR}/include)

# Biblioth√®que principale (pour r√©utilisation dans les tests)
file(GLOB LIB_SOURCES "src/*.c")  
list(REMOVE_ITEM LIB_SOURCES "${PROJECT_SOURCE_DIR}/src/main.c")  

add_library(${PROJECT_NAME}_lib STATIC ${LIB_SOURCES})

# Ex√©cutable principal
add_executable(${PROJECT_NAME} src/main.c)  
target_link_libraries(${PROJECT_NAME} ${PROJECT_NAME}_lib)  

# Tests (optionnel)
if(BUILD_TESTS)
    enable_testing()

    file(GLOB TEST_SOURCES "tests/*.c")
    foreach(TEST_SOURCE ${TEST_SOURCES})
        get_filename_component(TEST_NAME ${TEST_SOURCE} NAME_WE)
        add_executable(${TEST_NAME} ${TEST_SOURCE})
        target_link_libraries(${TEST_NAME} ${PROJECT_NAME}_lib)
        add_test(NAME ${TEST_NAME} COMMAND ${TEST_NAME})
    endforeach()
endif()

# Installation (optionnel)
install(TARGETS ${PROJECT_NAME} DESTINATION bin)
```

### Configuration CMake pour VS Code

Cr√©ez `.vscode/settings.json` (ou ajoutez dans le devcontainer.json) :

```json
{
    "cmake.configureOnOpen": true,
    "cmake.buildDirectory": "${workspaceFolder}/build",
    "cmake.generator": "Unix Makefiles",
    "cmake.configureSettings": {
        "CMAKE_BUILD_TYPE": "Debug",
        "CMAKE_EXPORT_COMPILE_COMMANDS": "ON"
    }
}
```

**Explications :**

| Param√®tre | Description |
|-----------|-------------|
| `configureOnOpen` | Configure automatiquement √† l'ouverture du projet |
| `buildDirectory` | Dossier pour les fichiers g√©n√©r√©s |
| `generator` | Type de fichiers de build (Makefile, Ninja) |
| `CMAKE_EXPORT_COMPILE_COMMANDS` | G√©n√®re un fichier pour IntelliSense |

### T√¢ches CMake pour VS Code

Ajoutez ces t√¢ches dans `.vscode/tasks.json` :

```json
{
    "version": "2.0.0",
    "tasks": [
        {
            "label": "CMake: Configure",
            "type": "shell",
            "command": "cmake",
            "args": [
                "-S", "${workspaceFolder}",
                "-B", "${workspaceFolder}/build",
                "-DCMAKE_BUILD_TYPE=Debug",
                "-DCMAKE_EXPORT_COMPILE_COMMANDS=ON"
            ],
            "group": "build",
            "problemMatcher": []
        },
        {
            "label": "CMake: Build",
            "type": "shell",
            "command": "cmake",
            "args": [
                "--build", "${workspaceFolder}/build",
                "--parallel"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "problemMatcher": ["$gcc"],
            "dependsOn": ["CMake: Configure"]
        },
        {
            "label": "CMake: Clean",
            "type": "shell",
            "command": "cmake",
            "args": [
                "--build", "${workspaceFolder}/build",
                "--target", "clean"
            ],
            "problemMatcher": []
        },
        {
            "label": "CMake: Rebuild",
            "type": "shell",
            "command": "cmake",
            "args": [
                "--build", "${workspaceFolder}/build",
                "--clean-first",
                "--parallel"
            ],
            "problemMatcher": ["$gcc"]
        }
    ]
}
```

### Workflow CMake typique

```bash
# 1. Cr√©er le dossier de build
mkdir -p build  
cd build  

# 2. Configurer le projet
cmake .. -DCMAKE_BUILD_TYPE=Debug

# 3. Compiler
cmake --build . --parallel

# 4. Ex√©cuter
./MonProjetC

# 5. Lancer les tests (si configur√©s)
ctest --output-on-failure
```

Avec VS Code et l'extension CMake Tools :
1. `Ctrl+Shift+P` ‚Üí "CMake: Configure"
2. `Ctrl+Shift+P` ‚Üí "CMake: Build" (ou `F7`)
3. `Ctrl+Shift+P` ‚Üí "CMake: Debug" (ou cliquez sur l'ic√¥ne de d√©bogage en bas)

---

## Partie 4 : Configuration de Valgrind

### Qu'est-ce que Valgrind ?

**Valgrind** est un outil d'analyse m√©moire qui d√©tecte :
- **Fuites m√©moire** : M√©moire allou√©e mais jamais lib√©r√©e
- **Acc√®s invalides** : Lecture/√©criture hors limites
- **Utilisation de m√©moire non initialis√©e**
- **Double free** : Lib√©rer deux fois la m√™me m√©moire
- **Erreurs de threads** : Race conditions, deadlocks

**Analogie :** C'est comme un inspecteur sanitaire qui v√©rifie que vous n'avez pas laiss√© de robinets ouverts, que vous n'avez pas mang√© de nourriture p√©rim√©e, et que vous avez bien rang√© apr√®s utilisation.

### Installation de Valgrind

#### Dans le devcontainer.json

```json
{
    "postCreateCommand": "apt-get update && apt-get install -y valgrind"
}
```

#### V√©rification de l'installation

```bash
valgrind --version
# valgrind-3.18.1 ou similaire
```

### Configuration de base

Valgrind n'a pas besoin de configuration complexe, mais quelques options sont utiles.

### Utilisation en ligne de commande

```bash
# V√©rification de base des fuites m√©moire
valgrind ./mon_programme

# V√©rification d√©taill√©e avec origine des erreurs
valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes ./mon_programme

# Avec log dans un fichier
valgrind --leak-check=full --log-file=valgrind.log ./mon_programme
```

### Options Valgrind importantes

| Option | Description |
|--------|-------------|
| `--leak-check=full` | D√©taille toutes les fuites |
| `--show-leak-kinds=all` | Montre tous les types de fuites |
| `--track-origins=yes` | Indique l'origine des valeurs non initialis√©es |
| `--verbose` | Mode verbeux |
| `--log-file=<file>` | Enregistre dans un fichier |
| `--suppressions=<file>` | Ignore certaines erreurs connues |

### T√¢che Valgrind dans VS Code

Ajoutez dans `.vscode/tasks.json` :

```json
{
    "version": "2.0.0",
    "tasks": [
        {
            "label": "Valgrind: V√©rifier les fuites m√©moire",
            "type": "shell",
            "command": "valgrind",
            "args": [
                "--leak-check=full",
                "--show-leak-kinds=all",
                "--track-origins=yes",
                "--verbose",
                "${workspaceFolder}/build/${workspaceFolderBasename}"
            ],
            "problemMatcher": [],
            "dependsOn": ["CMake: Build"],
            "detail": "Lance Valgrind pour d√©tecter les fuites m√©moire"
        },
        {
            "label": "Valgrind: Fichier actuel",
            "type": "shell",
            "command": "valgrind",
            "args": [
                "--leak-check=full",
                "--show-leak-kinds=all",
                "--track-origins=yes",
                "${fileDirname}/${fileBasenameNoExtension}"
            ],
            "problemMatcher": [],
            "dependsOn": ["GCC: Compiler le fichier actuel"],
            "detail": "Lance Valgrind sur le fichier compil√© actuel"
        },
        {
            "label": "Valgrind: G√©n√©rer rapport",
            "type": "shell",
            "command": "valgrind",
            "args": [
                "--leak-check=full",
                "--show-leak-kinds=all",
                "--track-origins=yes",
                "--log-file=${workspaceFolder}/valgrind-report.txt",
                "${workspaceFolder}/build/${workspaceFolderBasename}"
            ],
            "problemMatcher": [],
            "detail": "G√©n√®re un rapport Valgrind dans valgrind-report.txt"
        }
    ]
}
```

### Interpr√©ter les r√©sultats de Valgrind

#### Exemple de code avec probl√®mes

```c
#include <stdlib.h>
#include <stdio.h>

int main(void) {
    // Fuite m√©moire : allocation sans free
    int *leak = malloc(10 * sizeof(int));
    leak[0] = 42;

    // Acc√®s hors limites
    int *array = malloc(5 * sizeof(int));
    array[5] = 100;  // Erreur ! Index max = 4
    free(array);

    // Variable non initialis√©e
    int *uninit = malloc(sizeof(int));
    if (*uninit > 0) {  // Lecture d'une valeur non initialis√©e
        printf("Positif\n");
    }
    free(uninit);

    // leak n'est jamais lib√©r√© = fuite m√©moire
    return 0;
}
```

#### Sortie Valgrind

```
==12345== Memcheck, a memory error detector
==12345== Invalid write of size 4
==12345==    at 0x4005E7: main (exemple.c:12)
==12345==  Address 0x5204054 is 0 bytes after a block of size 20 alloc'd
==12345==    at 0x4C2FB0F: malloc (in /usr/lib/valgrind/...)
==12345==    by 0x4005D1: main (exemple.c:11)
==12345==
==12345== Conditional jump or move depends on uninitialised value(s)
==12345==    at 0x400600: main (exemple.c:17)
==12345==
==12345== LEAK SUMMARY:
==12345==    definitely lost: 40 bytes in 1 blocks
==12345==    indirectly lost: 0 bytes in 0 blocks
==12345==    possibly lost: 0 bytes in 0 blocks
==12345==    still reachable: 0 bytes in 0 blocks
==12345==    suppressed: 0 bytes in 0 blocks
```

**Comment lire ce rapport :**

1. **Invalid write** : √âcriture en dehors de la m√©moire allou√©e (ligne 12)
2. **uninitialised value** : Utilisation d'une variable non initialis√©e (ligne 17)
3. **definitely lost** : M√©moire allou√©e jamais lib√©r√©e (40 bytes = 10 int)

### Fichier de suppression

Certaines biblioth√®ques syst√®me g√©n√®rent des "fausses alertes". Cr√©ez `.valgrind-suppressions` :

```
{
   ignore_libc_cond
   Memcheck:Cond
   ...
   obj:/lib/x86_64-linux-gnu/libc-*.so
}
```

Utilisez-le avec :
```bash
valgrind --suppressions=.valgrind-suppressions ./programme
```

### Script Valgrind complet

Cr√©ez `.devcontainer/valgrind-check.sh` :

```bash
#!/bin/bash

# Script de v√©rification m√©moire avec Valgrind

PROGRAM="${1:-./build/MonProjetC}"  
REPORT="valgrind-report-$(date +%Y%m%d-%H%M%S).txt"  

echo "=== Analyse Valgrind de $PROGRAM ==="  
echo ""  

valgrind \
    --leak-check=full \
    --show-leak-kinds=all \
    --track-origins=yes \
    --verbose \
    --log-file="$REPORT" \
    "$PROGRAM"

echo ""  
echo "=== R√©sum√© ==="  

# Extraire les informations importantes
grep -E "(definitely|indirectly|possibly|still reachable|ERROR SUMMARY)" "$REPORT"

echo ""  
echo "Rapport complet : $REPORT"  

# V√©rifier s'il y a des erreurs
if grep -q "ERROR SUMMARY: 0 errors" "$REPORT"; then
    echo "‚úì Aucune erreur m√©moire d√©tect√©e"
    exit 0
else
    echo "‚úó Erreurs m√©moire d√©tect√©es, consultez le rapport"
    exit 1
fi
```

Rendez-le ex√©cutable :
```bash
chmod +x .devcontainer/valgrind-check.sh
```

---

## Configuration compl√®te du DevContainer

Voici le fichier `.devcontainer/devcontainer.json` complet int√©grant tous les outils :

```json
{
    // ============================================
    // IDENTIFICATION
    // ============================================
    "name": "Environnement C Complet - GCC/GDB/CMake/Valgrind",

    // ============================================
    // IMAGE DE BASE
    // ============================================
    "image": "mcr.microsoft.com/devcontainers/cpp:ubuntu-22.04",

    // ============================================
    // FEATURES
    // ============================================
    "features": {
        "ghcr.io/devcontainers/features/common-utils:2": {
            "installZsh": true,
            "installOhMyZsh": true,
            "upgradePackages": true
        }
    },

    // ============================================
    // EXTENSIONS VS CODE
    // ============================================
    "customizations": {
        "vscode": {
            "extensions": [
                // C/C++ essentiels
                "ms-vscode.cpptools",
                "ms-vscode.cpptools-extension-pack",

                // CMake
                "ms-vscode.cmake-tools",
                "twxs.cmake",

                // Makefile
                "ms-vscode.makefile-tools",

                // Qualit√© de code
                "usernamehw.errorlens",
                "oderwat.indent-rainbow",
                "streetsidesoftware.code-spell-checker",

                // Git
                "eamodio.gitlens",

                // Utilitaires
                "gruntfuggly.todo-tree",
                "mhutchie.git-graph"
            ],

            "settings": {
                // ========== C/C++ ==========
                "C_Cpp.default.cStandard": "c17",
                "C_Cpp.default.compilerPath": "/usr/bin/gcc",
                "C_Cpp.default.intelliSenseMode": "linux-gcc-x64",
                "C_Cpp.clang_format_fallbackStyle": "{ BasedOnStyle: LLVM, IndentWidth: 4, ColumnLimit: 80 }",
                "C_Cpp.errorSquiggles": "enabled",

                // ========== CMake ==========
                "cmake.configureOnOpen": true,
                "cmake.buildDirectory": "${workspaceFolder}/build",
                "cmake.generator": "Unix Makefiles",
                "cmake.configureSettings": {
                    "CMAKE_BUILD_TYPE": "Debug",
                    "CMAKE_EXPORT_COMPILE_COMMANDS": "ON"
                },

                // ========== √âditeur ==========
                "editor.formatOnSave": true,
                "editor.tabSize": 4,
                "editor.insertSpaces": true,
                "editor.rulers": [80, 120],
                "editor.renderWhitespace": "boundary",

                // ========== Fichiers ==========
                "files.eol": "\n",
                "files.trimTrailingWhitespace": true,
                "files.insertFinalNewline": true,
                "files.associations": {
                    "*.h": "c"
                },

                // ========== Terminal ==========
                "terminal.integrated.defaultProfile.linux": "zsh"
            }
        }
    },

    // ============================================
    // INSTALLATION DES OUTILS SUPPL√âMENTAIRES
    // ============================================
    "postCreateCommand": "sudo apt-get update && sudo apt-get install -y valgrind clang-format cppcheck && echo '‚úì Outils suppl√©mentaires install√©s'",

    // ============================================
    // VARIABLES D'ENVIRONNEMENT
    // ============================================
    "remoteEnv": {
        "CC": "gcc",
        "CXX": "g++",
        "CFLAGS": "-Wall -Wextra -std=c17",
        "CMAKE_EXPORT_COMPILE_COMMANDS": "ON"
    },

    // ============================================
    // OPTIONS DOCKER POUR GDB
    // ============================================
    "runArgs": [
        "--cap-add=SYS_PTRACE",
        "--security-opt", "seccomp=unconfined"
    ],

    // ============================================
    // UTILISATEUR
    // ============================================
    "remoteUser": "vscode"
}
```

---

## Fichiers de configuration VS Code complets

### .vscode/c_cpp_properties.json

```json
{
    "configurations": [
        {
            "name": "Linux",
            "includePath": [
                "${workspaceFolder}/**",
                "${workspaceFolder}/include",
                "/usr/include/**",
                "/usr/local/include/**"
            ],
            "defines": [
                "DEBUG"
            ],
            "compilerPath": "/usr/bin/gcc",
            "cStandard": "c17",
            "cppStandard": "c++17",
            "intelliSenseMode": "linux-gcc-x64",
            "configurationProvider": "ms-vscode.cmake-tools",
            "compileCommands": "${workspaceFolder}/build/compile_commands.json"
        }
    ],
    "version": 4
}
```

### .vscode/tasks.json (complet)

```json
{
    "version": "2.0.0",
    "tasks": [
        // ========== GCC ==========
        {
            "label": "GCC: Compiler fichier actuel",
            "type": "shell",
            "command": "gcc",
            "args": [
                "-Wall", "-Wextra", "-std=c17", "-g",
                "${file}",
                "-o", "${fileDirname}/${fileBasenameNoExtension}"
            ],
            "group": "build",
            "problemMatcher": ["$gcc"]
        },
        {
            "label": "GCC: Compiler avec sanitizers",
            "type": "shell",
            "command": "gcc",
            "args": [
                "-Wall", "-Wextra", "-std=c17", "-g",
                "-fsanitize=address,undefined",
                "-fno-omit-frame-pointer",
                "${file}",
                "-o", "${fileDirname}/${fileBasenameNoExtension}"
            ],
            "problemMatcher": ["$gcc"]
        },

        // ========== CMake ==========
        {
            "label": "CMake: Configure",
            "type": "shell",
            "command": "cmake",
            "args": [
                "-S", "${workspaceFolder}",
                "-B", "${workspaceFolder}/build",
                "-DCMAKE_BUILD_TYPE=Debug",
                "-DCMAKE_EXPORT_COMPILE_COMMANDS=ON"
            ],
            "problemMatcher": []
        },
        {
            "label": "CMake: Build",
            "type": "shell",
            "command": "cmake",
            "args": ["--build", "${workspaceFolder}/build", "--parallel"],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "problemMatcher": ["$gcc"],
            "dependsOn": ["CMake: Configure"]
        },
        {
            "label": "CMake: Clean",
            "type": "shell",
            "command": "cmake",
            "args": ["--build", "${workspaceFolder}/build", "--target", "clean"],
            "problemMatcher": []
        },
        {
            "label": "CMake: Release",
            "type": "shell",
            "command": "cmake",
            "args": [
                "-S", "${workspaceFolder}",
                "-B", "${workspaceFolder}/build-release",
                "-DCMAKE_BUILD_TYPE=Release"
            ],
            "problemMatcher": []
        },

        // ========== Valgrind ==========
        {
            "label": "Valgrind: V√©rifier fichier actuel",
            "type": "shell",
            "command": "valgrind",
            "args": [
                "--leak-check=full",
                "--show-leak-kinds=all",
                "--track-origins=yes",
                "${fileDirname}/${fileBasenameNoExtension}"
            ],
            "problemMatcher": [],
            "dependsOn": ["GCC: Compiler fichier actuel"]
        },
        {
            "label": "Valgrind: V√©rifier projet CMake",
            "type": "shell",
            "command": "valgrind",
            "args": [
                "--leak-check=full",
                "--show-leak-kinds=all",
                "--track-origins=yes",
                "${workspaceFolder}/build/${workspaceFolderBasename}"
            ],
            "problemMatcher": [],
            "dependsOn": ["CMake: Build"]
        },

        // ========== Analyse statique ==========
        {
            "label": "Cppcheck: Analyser le projet",
            "type": "shell",
            "command": "cppcheck",
            "args": [
                "--enable=all",
                "--std=c17",
                "--suppress=missingIncludeSystem",
                "-I", "${workspaceFolder}/include",
                "${workspaceFolder}/src"
            ],
            "problemMatcher": []
        }
    ]
}
```

### .vscode/launch.json (complet)

```json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "GDB: Fichier actuel",
            "type": "cppdbg",
            "request": "launch",
            "program": "${fileDirname}/${fileBasenameNoExtension}",
            "args": [],
            "stopAtEntry": false,
            "cwd": "${workspaceFolder}",
            "environment": [],
            "externalConsole": false,
            "MIMode": "gdb",
            "setupCommands": [
                {
                    "description": "Enable pretty-printing for gdb",
                    "text": "-enable-pretty-printing",
                    "ignoreFailures": true
                }
            ],
            "preLaunchTask": "GCC: Compiler fichier actuel",
            "miDebuggerPath": "/usr/bin/gdb"
        },
        {
            "name": "GDB: Projet CMake (Debug)",
            "type": "cppdbg",
            "request": "launch",
            "program": "${workspaceFolder}/build/${workspaceFolderBasename}",
            "args": [],
            "stopAtEntry": false,
            "cwd": "${workspaceFolder}",
            "environment": [],
            "externalConsole": false,
            "MIMode": "gdb",
            "setupCommands": [
                {
                    "description": "Enable pretty-printing for gdb",
                    "text": "-enable-pretty-printing",
                    "ignoreFailures": true
                }
            ],
            "preLaunchTask": "CMake: Build",
            "miDebuggerPath": "/usr/bin/gdb"
        },
        {
            "name": "GDB: Avec arguments",
            "type": "cppdbg",
            "request": "launch",
            "program": "${workspaceFolder}/build/${workspaceFolderBasename}",
            "args": ["arg1", "arg2", "arg3"],
            "stopAtEntry": true,
            "cwd": "${workspaceFolder}",
            "environment": [
                {"name": "DEBUG", "value": "1"}
            ],
            "externalConsole": false,
            "MIMode": "gdb",
            "miDebuggerPath": "/usr/bin/gdb"
        },
        {
            "name": "GDB: Attacher √† un processus",
            "type": "cppdbg",
            "request": "attach",
            "program": "${workspaceFolder}/build/${workspaceFolderBasename}",
            "processId": "${command:pickProcess}",
            "MIMode": "gdb",
            "miDebuggerPath": "/usr/bin/gdb"
        }
    ]
}
```

---

## V√©rification de l'installation

### Script de test

Cr√©ez un fichier `test-toolchain.sh` √† la racine :

```bash
#!/bin/bash

echo "=== Test de la toolchain ==="  
echo ""  

echo "1. GCC"  
gcc --version | head -1  
echo ""  

echo "2. GDB"  
gdb --version | head -1  
echo ""  

echo "3. CMake"  
cmake --version | head -1  
echo ""  

echo "4. Valgrind"  
valgrind --version  
echo ""  

echo "5. Make"  
make --version | head -1  
echo ""  

echo "6. clang-format"  
clang-format --version  
echo ""  

echo "7. cppcheck"  
cppcheck --version  
echo ""  

echo "=== Tous les outils sont install√©s ! ==="
```

### Test de compilation et d√©bogage

Cr√©ez `src/main.c` :

```c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[]) {
    printf("=== Test de l'environnement ===\n");

    // Test allocation m√©moire
    int *numbers = malloc(5 * sizeof(int));
    if (numbers == NULL) {
        fprintf(stderr, "Erreur d'allocation\n");
        return EXIT_FAILURE;
    }

    for (int i = 0; i < 5; i++) {
        numbers[i] = i * 10;
        printf("numbers[%d] = %d\n", i, numbers[i]);
    }

    // Lib√©ration correcte
    free(numbers);

    printf("=== Test r√©ussi ! ===\n");
    return EXIT_SUCCESS;
}
```

**V√©rifications :**

```bash
# Compiler avec GCC
gcc -Wall -Wextra -g -std=c17 src/main.c -o test_prog

# Ex√©cuter
./test_prog

# V√©rifier avec Valgrind
valgrind --leak-check=full ./test_prog
```

---

## D√©pannage

### GDB ne fonctionne pas

**Sympt√¥me :** Erreur "ptrace: Operation not permitted"

**Solution :** V√©rifiez que les `runArgs` sont pr√©sents dans `devcontainer.json` :

```json
{
    "runArgs": [
        "--cap-add=SYS_PTRACE",
        "--security-opt", "seccomp=unconfined"
    ]
}
```

Puis reconstruisez le conteneur : `Ctrl+Shift+P` ‚Üí "Dev Containers: Rebuild Container"

### CMake ne trouve pas le compilateur

**Sympt√¥me :** "No CMAKE_C_COMPILER could be found"

**Solution :** V√©rifiez que GCC est install√© :

```bash
which gcc  
gcc --version  
```

Si non install√©, ajoutez dans `postCreateCommand` :
```json
{
    "postCreateCommand": "apt-get update && apt-get install -y build-essential"
}
```

### Valgrind affiche des erreurs syst√®me

**Sympt√¥me :** Beaucoup d'erreurs dans les biblioth√®ques syst√®me

**Solution :** Utilisez un fichier de suppression ou ignorez les erreurs syst√®mes :

```bash
valgrind --gen-suppressions=all ./programme 2>&1 | grep -v "==" > suppressions.txt
```

### IntelliSense ne fonctionne pas

**Sympt√¥me :** Pas d'auto-compl√©tion, squiggles rouges partout

**Solutions :**

1. G√©n√©rez `compile_commands.json` avec CMake :
   ```bash
   cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON ..
   ```

2. V√©rifiez `.vscode/c_cpp_properties.json`

3. Rechargez VS Code : `Ctrl+Shift+P` ‚Üí "Developer: Reload Window"

---

## R√©capitulatif

√Ä ce stade, vous avez :

- ‚úÖ **GCC** configur√© avec les bons flags de compilation
- ‚úÖ **GDB** fonctionnel dans Docker avec les permissions correctes
- ‚úÖ **CMake** int√©gr√© √† VS Code avec configuration automatique
- ‚úÖ **Valgrind** pr√™t pour la d√©tection de fuites m√©moire
- ‚úÖ **Tasks.json** avec toutes les t√¢ches de build et analyse
- ‚úÖ **Launch.json** pour le d√©bogage dans VS Code
- ‚úÖ Un **DevContainer complet** pr√™t √† l'emploi

**Prochaine √©tape :** Dans la section 2.5.4, nous verrons comment int√©grer ce DevContainer avec VS Code et faciliter l'onboarding de nouveaux d√©veloppeurs.

---

## Points cl√©s √† retenir

1. **GCC** : Toujours compiler avec `-Wall -Wextra -g` en d√©veloppement
2. **GDB** : N√©cessite `--cap-add=SYS_PTRACE` dans Docker
3. **CMake** : Utilisez `CMAKE_EXPORT_COMPILE_COMMANDS=ON` pour IntelliSense
4. **Valgrind** : `--leak-check=full --track-origins=yes` pour le maximum d'informations
5. **tasks.json** : Automatise la compilation et l'analyse
6. **launch.json** : Configure le d√©bogage visuel dans VS Code
7. **c_cpp_properties.json** : Configure IntelliSense pour la compl√©tion
8. **Testez votre configuration** : Compilez, d√©boguez et analysez un programme de test
9. **Reconstruisez le conteneur** apr√®s modification du `devcontainer.json`
10. **Versionnez** tous les fichiers de configuration (`.devcontainer/`, `.vscode/`)

---


‚è≠Ô∏è [Int√©gration VS Code et onboarding](/02-configuration-environnement/05.4-integration-vscode.md)
