ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 15.5.4 Massif - Profiling de l'Utilisation de la MÃ©moire Heap

## Introduction

Massif est un outil de **profiling de mÃ©moire** de Valgrind qui enregistre l'Ã©volution de l'utilisation de la **heap** (tas) au fil du temps. Il vous permet de comprendre :
- Combien de mÃ©moire votre programme alloue
- Quelles fonctions sont responsables des allocations
- Comment la consommation mÃ©moire Ã©volue pendant l'exÃ©cution
- OÃ¹ se trouvent les pics de consommation

### Pourquoi Profiler la MÃ©moire ?

**ProblÃ¨mes courants liÃ©s Ã  la mÃ©moire :**

1. **Consommation excessive** : Votre programme utilise trop de RAM
2. **Croissance incontrÃ´lÃ©e** : La mÃ©moire augmente continuellement (potentielle fuite)
3. **Pics de mÃ©moire** : Allocations temporaires massives qui causent des OOM (Out Of Memory)
4. **Fragmentation** : Beaucoup de petites allocations qui gaspillent de la mÃ©moire

**Massif vs Memcheck :**

| Outil | Objectif | DÃ©tecte |
|-------|----------|---------|
| **Memcheck** | Correction du code | Fuites, accÃ¨s invalides, mÃ©moire non initialisÃ©e |
| **Massif** | Optimisation | Consommation excessive, pics, allocations inutiles |

**Analogie simple :**
- **Memcheck** = Le plombier qui trouve les fuites d'eau
- **Massif** = Le compteur d'eau qui vous dit combien vous consommez

---

## Comprendre la Heap (Tas)

Avant d'utiliser Massif, rappelons les bases de la gestion mÃ©moire en C.

### Stack vs Heap

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           MÃ‰MOIRE DU PROCESSUS          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Stack (Pile)                           â”‚  â† Allocations automatiques
â”‚  - Variables locales                    â”‚     (disparaissent Ã  la sortie)
â”‚  - ParamÃ¨tres de fonction               â”‚     Taille limitÃ©e (~8 MB)
â”‚  - Adresses de retour                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                ...                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Heap (Tas)                             â”‚  â† Allocations dynamiques
â”‚  - malloc() / calloc() / realloc()      â”‚     (malloc, new)
â”‚  - Taille flexible                      â”‚     ContrÃ´lÃ©e par le programmeur
â”‚  - Persiste jusqu'Ã  free()              â”‚     Massif profile ICI
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Massif profile uniquement la heap**, pas la stack !

### Fonctions d'Allocation Suivies

Massif surveille automatiquement :
- `malloc()`
- `calloc()`
- `realloc()`
- `memalign()`, `posix_memalign()`
- `new` (en C++)
- Et leurs variantes

---

## Installation et Utilisation de Base

### Installation

Massif est inclus dans Valgrind :

```bash
# VÃ©rifier l'installation
valgrind --tool=massif --version
```

### Compilation

Compilez normalement avec les symboles de dÃ©bogage :

```bash
gcc -g mon_programme.c -o mon_programme
```

**Note :** Pas besoin de flags spÃ©ciaux comme `-fsanitize=...`, Massif fonctionne sur le binaire standard.

### ExÃ©cution Basique

```bash
valgrind --tool=massif ./mon_programme
```

**Exemple complet :**

```bash
$ valgrind --tool=massif ./test_memory
==45678== Massif, a heap profiler
==45678== Copyright (C) 2003-2017, and GNU GPL'd, by Nicholas Nethercote
==45678== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info
==45678== Command: ./test_memory
==45678==
Programme terminÃ©
==45678==
```

Massif gÃ©nÃ¨re un fichier `massif.out.<pid>` :

```bash
$ ls massif.out.*
massif.out.45678
```

---

## Analyser les RÃ©sultats avec ms_print

### Vue d'Ensemble

Pour visualiser le profil mÃ©moire en mode texte :

```bash
ms_print massif.out.45678
```

**Exemple de sortie :**

```
--------------------------------------------------------------------------------
Command:            ./test_memory
Massif arguments:   (none)
ms_print arguments: massif.out.45678
--------------------------------------------------------------------------------


    MB
4.00 ^                                                                       #
     |                                                                       #
     |                                                                       #
     |                                                                       #
3.00 +                                                                       #
     |                                                                       #
     |                                                                       #
     |                                                                       #
2.00 +                                                                       #
     |                                                                       #
     |                                                              @@@@@@@@@#
     |                                                         @@@@@         #
1.00 +                                                    @@@@@              #
     |                                               @@@@@                   #
     |                                          @@@@@                        #
     |                                     @@@@@                             #
0.00 +----------------------------------------------------------------------->MB
     0                                                                   100.0

Number of snapshots: 50
 Detailed snapshots: [2, 11, 19, 32, 40 (peak)]
```

### Comprendre le Graphique

**Axes :**
- **Axe Y (vertical)** : MÃ©moire heap utilisÃ©e (en MB, KB, ou bytes)
- **Axe X (horizontal)** : Progression du programme (en instructions ou temps)

**Symboles :**
- `@` : Snapshot normal (Ã©chantillon)
- `#` : Snapshot dÃ©taillÃ© (avec dÃ©tails des allocations)
- `:` : Snapshots lÃ©gers

**Dans cet exemple :**
1. Le programme commence avec peu de mÃ©moire (~0 MB)
2. Augmentation progressive jusqu'Ã  1 MB
3. Croissance rapide jusqu'Ã  **4 MB** (pic Ã  droite)
4. Le **pic** est Ã  la fin de l'exÃ©cution

â¡ï¸ **Question immÃ©diate :** Pourquoi cette croissance ? Quelles fonctions allouent ?

---

## Snapshots DÃ©taillÃ©s

Massif prend des "photos" (snapshots) de la heap Ã  diffÃ©rents moments. Les snapshots dÃ©taillÃ©s montrent **qui a allouÃ© quoi**.

### Exemple de Snapshot DÃ©taillÃ©

AprÃ¨s le graphique, `ms_print` affiche les dÃ©tails :

```
--------------------------------------------------------------------------------
  n        time(i)         total(B)   useful-heap(B) extra-heap(B)    stacks(B)
--------------------------------------------------------------------------------
  0              0                0                0             0            0
  1        100,000           10,240           10,000           240            0
  2        250,000           50,480           50,000           480            0
...
 40      1,500,000        4,194,304        4,000,000       194,304            0  (peak)
```

**Colonnes importantes :**
- **n** : NumÃ©ro du snapshot
- **time(i)** : Moment du snapshot (en instructions exÃ©cutÃ©es)
- **total(B)** : MÃ©moire heap totale en bytes
- **useful-heap(B)** : MÃ©moire rÃ©ellement demandÃ©e par le programme
- **extra-heap(B)** : Overhead de l'allocateur (mÃ©tadonnÃ©es, alignement)
- **(peak)** : Snapshot au pic de consommation

**Formule :**
```
total(B) = useful-heap(B) + extra-heap(B)
```

### DÃ©tails d'Allocation au Peak

Le snapshot dÃ©taillÃ© au **peak** montre d'oÃ¹ vient la mÃ©moire :

```
--------------------------------------------------------------------------------
n        time(i)         total(B)   useful-heap(B) extra-heap(B)    stacks(B)
--------------------------------------------------------------------------------
40      1,500,000        4,194,304        4,000,000       194,304            0
99.99% (4,194,304B) (heap allocation functions) malloc/new/new[], --alloc-fns, etc.
->80.00% (3,355,443B) 0x108976: allocate_big_buffer (test.c:45)
| ->80.00% (3,355,443B) 0x1089A0: process_data (test.c:60)
|   ->80.00% (3,355,443B) 0x108A20: main (test.c:100)
|
->15.00% (629,145B) 0x108800: allocate_cache (test.c:30)
| ->15.00% (629,145B) 0x1089C5: init_system (test.c:70)
|   ->15.00% (629,145B) 0x108A15: main (test.c:95)
|
->04.99% (209,716B) in 1,024 places, all below massif's threshold (1.00%)
```

**InterprÃ©tation :**

1. **80% de la mÃ©moire** (3.35 MB) est allouÃ©e par `allocate_big_buffer()` ligne 45
   - AppelÃ©e depuis `process_data()` ligne 60
   - AppelÃ©e depuis `main()` ligne 100

2. **15% de la mÃ©moire** (629 KB) est allouÃ©e par `allocate_cache()` ligne 30
   - AppelÃ©e depuis `init_system()` ligne 70
   - AppelÃ©e depuis `main()` ligne 95

3. **5%** restants : Beaucoup de petites allocations (< 1% chacune)

â¡ï¸ **Conclusion :** `allocate_big_buffer()` est le **principal consommateur de mÃ©moire** !

---

## Visualisation Graphique avec massif-visualizer

### Installation

```bash
sudo apt install massif-visualizer  # Ubuntu/Debian
```

### Utilisation

```bash
massif-visualizer massif.out.45678
```

### Interface de massif-visualizer

L'outil offre une **interface graphique moderne** avec :

#### 1. **Graphique de Consommation MÃ©moire**

Une courbe lisse montrant l'Ã©volution de la heap au fil du temps :

```
  Memory (MB)
      ^
  4.0 |                                                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      |                                             â”Œâ”€â”€â”€â”€â”€â”˜         â”‚
  3.0 |                                       â”Œâ”€â”€â”€â”€â”€â”˜               â”‚
      |                                 â”Œâ”€â”€â”€â”€â”€â”˜                     â”‚
  2.0 |                           â”Œâ”€â”€â”€â”€â”€â”˜                           â”‚
      |                     â”Œâ”€â”€â”€â”€â”€â”˜                                 â”‚
  1.0 |               â”Œâ”€â”€â”€â”€â”€â”˜                                       â”‚
      |         â”Œâ”€â”€â”€â”€â”€â”˜                                             â”‚
  0.0 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>
      0         20        40        60        80        100    Time (%)
```

**FonctionnalitÃ©s :**
- **Zoom** : Examiner une pÃ©riode spÃ©cifique
- **SÃ©lection** : Cliquer sur un point pour voir les dÃ©tails
- **LÃ©gende** : Fonctions colorÃ©es par contribution

#### 2. **Call Tree (Arbre d'Appels)**

Visualisation hiÃ©rarchique des allocations :

```
main (100%)
â”œâ”€â”€ process_data (80%)
â”‚   â””â”€â”€ allocate_big_buffer (80%)  â† Gros consommateur !
â”œâ”€â”€ init_system (15%)
â”‚   â””â”€â”€ allocate_cache (15%)
â””â”€â”€ autres (5%)
```

**Code couleur :**
- ğŸ”´ **Rouge** : Allocation majeure (> 50%)
- ğŸŸ¡ **Jaune** : Allocation importante (10-50%)
- ğŸŸ¢ **Vert** : Allocation mineure (< 10%)

#### 3. **DÃ©tails des Snapshots**

Tableau listant tous les snapshots avec :
- Moment exact
- MÃ©moire totale
- MÃ©moire utile
- Overhead
- Marqueur du peak

---

## Options AvancÃ©es de Massif

### 1. Changer la RÃ©solution Temporelle

Par dÃ©faut, Massif prend des snapshots basÃ©s sur les instructions exÃ©cutÃ©es. Vous pouvez changer la mÃ©trique :

**Mesurer en temps rÃ©el (ms) :**

```bash
valgrind --tool=massif --time-unit=ms ./programme
```

**Mesurer en bytes allouÃ©s :**

```bash
valgrind --tool=massif --time-unit=B ./programme
```

**Comparaison :**

| UnitÃ© | Description | Use case |
|-------|-------------|----------|
| `i` (dÃ©faut) | Instructions CPU | Reproductible, indÃ©pendant du hardware |
| `ms` | Millisecondes | Proche du temps rÃ©el |
| `B` | Bytes allouÃ©s | Focus sur les gros allocateurs |

### 2. Profiler la Stack en Plus de la Heap

Par dÃ©faut, Massif ne profile que la heap. Pour inclure la stack :

```bash
valgrind --tool=massif --stacks=yes ./programme
```

**âš ï¸ Attention :** Cela augmente significativement l'overhead et la taille du fichier de sortie.

### 3. Ajuster le Seuil de DÃ©tail

Massif ignore les allocations reprÃ©sentant moins de 1% du total. Pour voir plus de dÃ©tails :

```bash
valgrind --tool=massif --threshold=0.1 ./programme
```

**Valeurs typiques :**
- `1.0` (dÃ©faut) : Seuil Ã  1% (rapide, lÃ©ger)
- `0.1` : Seuil Ã  0.1% (dÃ©taillÃ©)
- `0.01` : Seuil Ã  0.01% (trÃ¨s dÃ©taillÃ©, lent)

### 4. Forcer des Snapshots DÃ©taillÃ©s

Pour prendre un snapshot dÃ©taillÃ© Ã  un moment prÃ©cis dans votre code :

```c
#include <valgrind/valgrind.h>

void ma_fonction() {
    // ... code ...

    // Forcer un snapshot dÃ©taillÃ© ICI
    VALGRIND_MONITOR_COMMAND("detailed_snapshot");

    // ... suite du code ...
}
```

**Compilation :**
```bash
gcc -g mon_programme.c -o mon_programme
# Les macros Valgrind sont des no-op si Valgrind n'est pas utilisÃ©
```

### 5. Augmenter la Profondeur du Call Stack

Par dÃ©faut, Massif affiche les 30 premiers niveaux de la pile d'appels. Pour voir plus :

```bash
valgrind --tool=massif --max-snapshots=100 --depth=50 ./programme
```

---

## Exemples Pratiques d'Analyse et d'Optimisation

### ProblÃ¨me 1 : Croissance MÃ©moire IncontrÃ´lÃ©e

**SymptÃ´me :** Le graphique montre une croissance constante de la mÃ©moire.

**Code problÃ©matique :**

```c
#include <stdlib.h>
#include <string.h>

typedef struct {
    char *data;
    int size;
} Buffer;

Buffer *buffers[1000];
int buffer_count = 0;

void process_data(const char *input) {
    Buffer *buf = malloc(sizeof(Buffer));
    buf->size = strlen(input);
    buf->data = malloc(buf->size + 1);
    strcpy(buf->data, input);

    buffers[buffer_count++] = buf;
    // âŒ PROBLÃˆME : Jamais libÃ©rÃ© !
}

int main() {
    for (int i = 0; i < 1000; i++) {
        char data[100];
        sprintf(data, "Data item %d", i);
        process_data(data);
    }
    return 0;  // âŒ MÃ©moire jamais libÃ©rÃ©e
}
```

**Profiling Massif :**

```bash
$ valgrind --tool=massif ./leak_example
$ ms_print massif.out.XXXXX
```

**Graphique :**
```
    MB
1.0 ^                                                                       #
    |                                                                    ####
    |                                                                 ####
    |                                                             #####
0.8 +                                                         #####
    |                                                     #####
    |                                                 #####
    |                                             #####
0.6 +                                         #####
    |                                     #####
    |                                 #####
    |                             #####
0.4 +                         #####
    |                     #####
    |                 #####
    |             #####
0.2 +         #####
    |     #####
    | #####
    |#
0.0 +---------------------------------------------------------------------->
```

â¡ï¸ **Croissance linÃ©aire continue = fuite de mÃ©moire probable !**

**DÃ©tails du snapshot peak :**
```
->99.99% (1,048,576B) 0x108800: process_data (leak.c:15)
  ->99.99% (1,048,576B) 0x1089C5: main (leak.c:25)
```

**Solution : LibÃ©rer la mÃ©moire**

```c
void cleanup() {
    for (int i = 0; i < buffer_count; i++) {
        free(buffers[i]->data);  // âœ… LibÃ©rer data
        free(buffers[i]);        // âœ… LibÃ©rer Buffer
    }
    buffer_count = 0;
}

int main() {
    for (int i = 0; i < 1000; i++) {
        char data[100];
        sprintf(data, "Data item %d", i);
        process_data(data);
    }

    cleanup();  // âœ… Nettoyer avant de quitter
    return 0;
}
```

**RÃ©sultat aprÃ¨s correction :**
```
    MB
1.0 ^                    #
    |                   # #
    |                  #   #
    |                 #     #
0.8 +                #       #
    |               #         #
    |              #           #
    |             #             #
0.6 +            #               #
    |           #                 #
    |          #                   #
    |         #                     #
0.4 +        #                       #
    |       #                         #
    |      #                           #
    |     #                             #
0.2 +    #                               #
    |   #                                 #
    |  #                                   #
    | #                                     #
0.0 +#---------------------------------------#------------------------->
```

âœ… **MÃ©moire libÃ©rÃ©e Ã  la fin = comportement correct !**

### ProblÃ¨me 2 : Pic de MÃ©moire Temporaire

**SymptÃ´me :** Un pic massif de mÃ©moire pendant un court moment.

**Code problÃ©matique :**

```c
void process_file(const char *filename) {
    // âŒ Charger tout le fichier en mÃ©moire d'un coup
    FILE *f = fopen(filename, "rb");
    fseek(f, 0, SEEK_END);
    long size = ftell(f);  // Ex: 500 MB !
    fseek(f, 0, SEEK_SET);

    char *buffer = malloc(size);  // âŒ Allocation massive
    fread(buffer, 1, size, f);
    fclose(f);

    // Traitement...
    process_buffer(buffer, size);

    free(buffer);
}
```

**Graphique Massif :**
```
    MB
500 ^                       ##
    |                      #  #
    |                     #    #
    |                    #      #
400 +                   #        #
    |                  #          #
    |                 #            #
    |                #              #
300 +               #                #
    |              #                  #
    |             #                    #
    |            #                      #
200 +           #                        #
    |          #                          #
    |         #                            #
    |        #                              #
100 +       #                                #
    |      #                                  #
    |     #                                    #
    |    #                                      #
0.0 +####----------------------------------------####--------------->
```

â¡ï¸ **Pic Ã©norme = risque de OOM (Out Of Memory) !**

**Solution : Traitement par Blocs (Streaming)**

```c
#define BUFFER_SIZE (1024 * 1024)  // 1 MB

void process_file_streaming(const char *filename) {
    FILE *f = fopen(filename, "rb");
    char buffer[BUFFER_SIZE];  // âœ… Buffer fixe de 1 MB
    size_t bytes_read;

    // âœ… Lire et traiter par blocs
    while ((bytes_read = fread(buffer, 1, BUFFER_SIZE, f)) > 0) {
        process_buffer(buffer, bytes_read);
    }

    fclose(f);
}
```

**Graphique aprÃ¨s optimisation :**
```
    MB
2.0 ^################################################################
    |
    |
    |
1.5 +
    |
    |
    |
1.0 +
    |
    |
    |
0.5 +
    |
    |
    |
0.0 +-------------------------------------------------------------->
```

âœ… **Consommation constante de 1 MB au lieu de 500 MB !**

### ProblÃ¨me 3 : Trop de Petites Allocations

**Code inefficace :**

```c
typedef struct Node {
    int data;
    struct Node *next;
} Node;

Node *create_list(int n) {
    Node *head = NULL;
    for (int i = 0; i < n; i++) {
        Node *node = malloc(sizeof(Node));  // âŒ n allocations !
        node->data = i;
        node->next = head;
        head = node;
    }
    return head;
}

int main() {
    Node *list = create_list(100000);  // 100,000 malloc !
    // ...
}
```

**Snapshot Massif :**
```
->99.00% (2,400,000B) in 100,000 places, all below massif's threshold (1.00%)
```

â¡ï¸ 100,000 petites allocations de 24 bytes chacune = **fragmentation** !

**Solution : Memory Pool**

```c
#define POOL_SIZE 1000

typedef struct {
    Node nodes[POOL_SIZE];
    int next_free;
} NodePool;

NodePool pool = {0};

Node *allocate_node() {
    if (pool.next_free >= POOL_SIZE) {
        return NULL;  // Pool plein
    }
    return &pool.nodes[pool.next_free++];
}

Node *create_list_pooled(int n) {
    Node *head = NULL;
    for (int i = 0; i < n; i++) {
        Node *node = allocate_node();  // âœ… Pas de malloc !
        node->data = i;
        node->next = head;
        head = node;
    }
    return head;
}
```

**Avantages :**
- **1 seule allocation** (le pool) au lieu de 100,000
- **Pas de fragmentation**
- **Plus rapide** (pas d'appels systÃ¨me rÃ©pÃ©tÃ©s)
- **Meilleure localitÃ© cache**

---

## DÃ©tection de Patterns ProblÃ©matiques

### Pattern 1 : "Escalier" (Staircase)

**Graphique :**
```
    MB
4.0 ^                                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    |                               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
3.0 +                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    |         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
2.0 +â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    |
1.0 +
    |
0.0 +------------------------------------------------>
```

**InterprÃ©tation :**
- Allocations par paliers
- MÃ©moire jamais libÃ©rÃ©e
- **Probable fuite de mÃ©moire progressive**

**Action :** VÃ©rifier que chaque `malloc()` a un `free()` correspondant.

### Pattern 2 : "Dents de Scie" (Sawtooth)

**Graphique :**
```
    MB
2.0 ^    â•±â•²    â•±â•²    â•±â•²    â•±â•²    â•±â•²
    |   â•±  â•²  â•±  â•²  â•±  â•²  â•±  â•²  â•±  â•²
1.0 +  â•±    â•²â•±    â•²â•±    â•²â•±    â•²â•±    â•²
    | â•±                              â•²
0.0 +â•±â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•²â”€â”€>
```

**InterprÃ©tation :**
- Cycles d'allocation/libÃ©ration
- **Comportement normal** pour un programme qui traite des donnÃ©es par lots
- Les "dents" montrent les allocations temporaires

**Action :** Rien si la consommation retourne Ã  un niveau bas. Sinon, vÃ©rifier les fuites.

### Pattern 3 : "Plateau" (Plateau)

**Graphique :**
```
    MB
2.0 ^            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    |           â•±
1.0 +          â•±
    |         â•±
0.0 +â”€â”€â”€â”€â”€â”€â”€â”€â•±â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>
```

**InterprÃ©tation :**
- Allocation initiale puis consommation stable
- **Comportement normal** pour des caches, buffers persistants
- Pas de fuite si la mÃ©moire est utilisÃ©e

**Action :** VÃ©rifier que la taille du plateau est raisonnable.

### Pattern 4 : "Pic" (Spike)

**Graphique :**
```
    MB
5.0 ^                    â•±â•²
    |                   â•±  â•²
4.0 +                  â•±    â•²
    |                 â•±      â•²
3.0 +                â•±        â•²
    |               â•±          â•²
2.0 +              â•±            â•²
    |             â•±              â•²
1.0 +            â•±                â•²
    |           â•±                  â•²
0.0 +â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•±â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•²â”€â”€â”€â”€â”€â”€â”€â”€>
```

**InterprÃ©tation :**
- Allocation temporaire massive
- **Risque de OOM** si le pic est trop haut
- La mÃ©moire est bien libÃ©rÃ©e aprÃ¨s

**Action :** Si le pic est problÃ©matique, optimiser avec du streaming ou des buffers rÃ©utilisables.

---

## StratÃ©gies d'Optimisation MÃ©moire

### 1. RÃ©utilisation de Buffers

**Avant :**
```c
for (int i = 0; i < 1000; i++) {
    char *buffer = malloc(BUF_SIZE);  // âŒ 1000 allocations
    process(buffer);
    free(buffer);
}
```

**AprÃ¨s :**
```c
char *buffer = malloc(BUF_SIZE);  // âœ… 1 allocation
for (int i = 0; i < 1000; i++) {
    process(buffer);  // RÃ©utiliser
}
free(buffer);
```

### 2. Allocation GroupÃ©e

**Avant :**
```c
int *a = malloc(N * sizeof(int));     // 3 allocations
int *b = malloc(N * sizeof(int));
int *c = malloc(N * sizeof(int));
```

**AprÃ¨s :**
```c
int *memory = malloc(3 * N * sizeof(int));  // âœ… 1 allocation
int *a = memory;
int *b = memory + N;
int *c = memory + 2 * N;
// LibÃ©ration: free(memory) seulement
```

### 3. Small String Optimization (SSO)

Pour les petites chaÃ®nes, Ã©viter malloc :

```c
typedef struct {
    size_t length;
    union {
        char small[16];       // ChaÃ®nes <= 15 caractÃ¨res
        char *large;          // ChaÃ®nes > 15 caractÃ¨res
    } data;
    bool is_large;
} String;

String create_string(const char *str) {
    String s;
    s.length = strlen(str);

    if (s.length < 16) {
        strcpy(s.data.small, str);  // âœ… Pas de malloc
        s.is_large = false;
    } else {
        s.data.large = strdup(str);  // malloc seulement si nÃ©cessaire
        s.is_large = true;
    }

    return s;
}
```

### 4. Lazy Allocation

N'allouer que quand c'est vraiment nÃ©cessaire :

```c
typedef struct {
    int *data;
    int capacity;
    int size;
} DynamicArray;

void push(DynamicArray *arr, int value) {
    if (arr->data == NULL) {
        // âœ… PremiÃ¨re allocation seulement au premier push
        arr->capacity = 10;
        arr->data = malloc(arr->capacity * sizeof(int));
        arr->size = 0;
    }

    if (arr->size >= arr->capacity) {
        arr->capacity *= 2;
        arr->data = realloc(arr->data, arr->capacity * sizeof(int));
    }

    arr->data[arr->size++] = value;
}
```

---

## Comparaison avec Autres Outils

| Outil | Type | Objectif | Overhead | DÃ©tails |
|-------|------|----------|----------|---------|
| **Massif** | Profiler | Consommation mÃ©moire | 10-30x | Snapshots, graphiques |
| **Memcheck** | DÃ©tecteur | Fuites, erreurs | 10-50x | PrÃ©cis, dÃ©taillÃ© |
| **Heaptrack** | Profiler | Allocations/fuites | 2-5x | Plus rapide que Massif |
| **gperftools** | Profiler | Heap profiling | 1-3x | TrÃ¨s lÃ©ger, production |
| **Sanitizers** | DÃ©tecteur | Erreurs mÃ©moire | 2-3x | Compile-time, rapide |

**Recommandations :**
1. **DÃ©veloppement** : Massif (complet, Ã©ducatif)
2. **CI/CD** : ASan (AddressSanitizer, rapide)
3. **Production** : gperftools/heaptrack (lÃ©ger)
4. **Debugging fuites** : Memcheck (le plus prÃ©cis)

---

## IntÃ©gration dans le Workflow

### Script de Profiling Automatique

```bash
#!/bin/bash
# scripts/memory_profile.sh

PROG="./mon_programme"
OUT="massif.out.latest"

echo "Profiling mÃ©moire avec Massif..."
valgrind --tool=massif \
    --massif-out-file=$OUT \
    --threshold=0.5 \
    $PROG

echo ""
echo "=== RÃ©sumÃ© textuel ==="
ms_print $OUT | head -100

echo ""
echo "=== Peak Memory Usage ==="
ms_print $OUT | grep "peak" | head -1

echo ""
echo "Visualisation graphique: massif-visualizer $OUT"
```

### Comparaison Avant/AprÃ¨s

Pour mesurer l'impact d'une optimisation :

```bash
# Version avant optimisation
git checkout main
make clean && make
valgrind --tool=massif --massif-out-file=before.out ./prog

# Version aprÃ¨s optimisation
git checkout optimization-branch
make clean && make
valgrind --tool=massif --massif-out-file=after.out ./prog

# Comparer les peaks
echo "BEFORE:"
ms_print before.out | grep "peak"
echo "AFTER:"
ms_print after.out | grep "peak"
```

### Alertes CI/CD sur Consommation Excessive

```yaml
# .github/workflows/memory-check.yml
name: Memory Profiling

on: [pull_request]

jobs:
  memory-profile:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2

      - name: Install Valgrind
        run: sudo apt-get install -y valgrind

      - name: Build
        run: make

      - name: Profile Memory
        run: |
          valgrind --tool=massif --massif-out-file=massif.out ./test_suite

          # Extraire le peak
          PEAK=$(ms_print massif.out | grep "peak" | awk '{print $6}')
          PEAK_MB=$(echo "$PEAK / 1048576" | bc)

          echo "Peak memory usage: ${PEAK_MB} MB"

          # Alerte si > 100 MB
          if [ $PEAK_MB -gt 100 ]; then
            echo "âŒ Memory usage too high: ${PEAK_MB} MB"
            exit 1
          fi

      - name: Upload Massif Output
        uses: actions/upload-artifact@v2
        with:
          name: massif-profile
          path: massif.out
```

---

## Limitations de Massif

### 1. Ralentissement Important

Massif peut ralentir votre programme de **10x Ã  30x**.

**Solutions :**
- Profiler sur des jeux de donnÃ©es rÃ©duits
- Utiliser heaptrack pour du profiling plus lÃ©ger en dÃ©veloppement
- Utiliser gperftools en production

### 2. Ne Profile Pas Tout

Massif profile **uniquement la heap** (malloc/free). Il ne voit pas :
- Allocations sur la stack (variables locales)
- Memory-mapped files (mmap)
- Allocations dans les bibliothÃ¨ques qui n'utilisent pas malloc standard

**Solution :** Utiliser `--stacks=yes` pour inclure la stack (mais overhead ++).

### 3. Snapshots LimitÃ©s

Massif ne prend qu'un nombre limitÃ© de snapshots (par dÃ©faut ~100).

**ProblÃ¨me :** Pour les programmes longs, certains dÃ©tails peuvent Ãªtre manquÃ©s.

**Solution :** Augmenter `--max-snapshots=200` ou profiler des segments spÃ©cifiques.

### 4. Pas de Temps RÃ©el

Par dÃ©faut, Massif mesure en instructions CPU, pas en temps rÃ©el.

**ConsÃ©quence :** Les I/O, sleep, ou attentes rÃ©seau ne sont pas reflÃ©tÃ©s.

**Solution :** Utiliser `--time-unit=ms` pour mesurer en temps rÃ©el.

---

## Conseils et Bonnes Pratiques

### âœ… Ã€ Faire

1. **Profiler rÃ©guliÃ¨rement** : IntÃ©grer dans le cycle de dÃ©veloppement
2. **Comparer les versions** : Mesurer l'impact des optimisations
3. **Chercher les patterns** : Escalier = fuite, pic = buffer trop gros
4. **Optimiser les hotspots** : 80% de la mÃ©moire dans 20% du code
5. **Utiliser la visualisation** : massif-visualizer > ms_print texte

### âŒ Ã€ Ã‰viter

1. **Profiler du code debug** : Utilisez `-O2` pour des rÃ©sultats rÃ©alistes
2. **Ignorer les petites allocations** : Elles peuvent s'accumuler
3. **Optimiser prÃ©maturÃ©ment** : Profiler d'abord, optimiser ensuite
4. **NÃ©gliger les fuites lentes** : Une petite fuite Ã— 1 million d'itÃ©rations = gros problÃ¨me
5. **Oublier de valider** : Les optimisations peuvent introduire des bugs

---

## Workflow Complet d'Optimisation MÃ©moire

```
1. Mesure initiale
   valgrind --tool=massif ./programme
                â†“
2. Visualisation
   massif-visualizer massif.out.XXX
                â†“
3. Identifier les problÃ¨mes
   - Croissance incontrÃ´lÃ©e ?
   - Pics excessifs ?
   - Trop de petites allocations ?
                â†“
4. Analyse dÃ©taillÃ©e
   - Quelles fonctions allouent ?
   - Pourquoi autant de mÃ©moire ?
   - Est-ce nÃ©cessaire ?
                â†“
5. Optimisation ciblÃ©e
   - RÃ©utiliser les buffers
   - Memory pools
   - Streaming au lieu de tout charger
                â†“
6. Re-profiling
   valgrind --tool=massif ./programme_optimise
                â†“
7. Comparaison
   - Peak memory: avant vs aprÃ¨s
   - Patterns: fuite corrigÃ©e ?
   - Validation: tests passent ?
                â†“
8. Documentation
   - Commenter les optimisations
   - Expliquer les trade-offs
```

---

## RÃ©sumÃ©

### âœ… Ce que Massif fait bien
- Visualiser l'Ã©volution de la consommation mÃ©moire
- Identifier les fonctions qui allouent le plus
- DÃ©tecter les fuites de mÃ©moire progressives
- Comprendre les pics de consommation
- Profiler sans modifier le code source

### âš ï¸ Limites Ã  connaÃ®tre
- Ralentissement important (10-30x)
- Ne profile que la heap (pas la stack par dÃ©faut)
- Snapshots limitÃ©s pour les programmes longs
- Pas de temps rÃ©el (instructions CPU par dÃ©faut)

### ğŸ¯ Quand utiliser Massif ?
- Programme consommant trop de RAM
- Croissance mÃ©moire inexpliquÃ©e
- OOM (Out Of Memory) en production
- Optimisation de la consommation mÃ©moire
- Validation qu'une fuite est corrigÃ©e

### ğŸ’¡ Conseils finaux
1. **Combiner avec Memcheck** : Massif trouve les gros allocateurs, Memcheck trouve les fuites prÃ©cises
2. **Utiliser la visualisation** : Les graphiques rÃ©vÃ¨lent des patterns invisibles en texte
3. **Profiler le code rÃ©el** : Avec les optimisations de production
4. **Documenter les findings** : Les insights sont utiles pour toute l'Ã©quipe
5. **Automatiser** : IntÃ©grer dans les tests de performance

### ğŸ“š Pour aller plus loin
- Documentation officielle : `man massif`
- Guide Valgrind : https://valgrind.org/docs/manual/ms-manual.html
- Section 9 : Allocation Dynamique (malloc/free)
- Section 24 : Gestion avancÃ©e de la mÃ©moire
- Section 15.4 : DÃ©tection de fuites avec Valgrind/Memcheck

---

**ğŸ’¡ Citation :**
> "Memory is like money: easy to spend, hard to get back, and you never have enough."

**ğŸ“ Massif vous aide Ã  devenir un gestionnaire responsable de la mÃ©moire de vos programmes !**

â­ï¸ [Analyse statique de code](/15-debogage-et-qualite/06-analyse-statique.md)
