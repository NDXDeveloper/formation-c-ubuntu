üîù Retour au [Sommaire](/SOMMAIRE.md)

# 34.3.2 Export Prometheus

## Introduction

Maintenant que nous savons collecter des m√©triques syst√®me (section 34.3.1), nous devons les **exposer** pour qu'un syst√®me de monitoring puisse les r√©cup√©rer. **Prometheus** est le standard de facto dans l'√©cosyst√®me Cloud Native et DevOps moderne.

Dans cette section, nous allons apprendre √† :
1. Comprendre le format d'exposition Prometheus
2. Cr√©er un serveur HTTP simple en C
3. Exposer nos m√©triques au format Prometheus
4. Int√©grer tout cela dans un agent de monitoring

---

## Qu'est-ce que Prometheus ?

### Architecture Pull-based

Prometheus utilise une architecture **pull** (par opposition √† push) :

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Prometheus ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ scrape ‚îÄ‚îÄ‚îÄ‚îÄ>  ‚îÇ Agent (C)    ‚îÇ
‚îÇ   Server    ‚îÇ     (HTTP GET)     ‚îÇ /metrics     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚îÇ
     ‚îÇ stockage
     ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   TSDB      ‚îÇ  (Time Series Database)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Principe :**
- Prometheus **interroge** (scrape) p√©riodiquement vos applications
- Sur un endpoint HTTP (typiquement `/metrics`)
- Les m√©triques sont expos√©es dans un format texte simple
- Intervalle configurable (ex: toutes les 15 secondes)

### Avantages pour notre agent C

- **Simplicit√©** : Pas besoin de connexion sortante, juste un serveur HTTP
- **D√©couplage** : L'agent ne se pr√©occupe pas de o√π envoyer les donn√©es
- **Standardisation** : Compatible avec tout l'√©cosyst√®me Prometheus (Grafana, AlertManager, etc.)
- **Pull = Fiabilit√©** : Prometheus d√©tecte si l'agent ne r√©pond plus

---

## Le format d'exposition Prometheus

### Principes de base

Le format Prometheus est un **format texte** tr√®s simple, lisible par un humain.

**Structure g√©n√©rale :**
```
# HELP nom_metrique Description de la m√©trique
# TYPE nom_metrique type
nom_metrique{label1="valeur1",label2="valeur2"} valeur timestamp
```

**Exemple concret :**
```
# HELP node_cpu_usage_percent Current CPU usage percentage
# TYPE node_cpu_usage_percent gauge
node_cpu_usage_percent 45.23

# HELP node_memory_total_bytes Total memory in bytes
# TYPE node_memory_total_bytes gauge
node_memory_total_bytes 16777216000

# HELP node_memory_used_bytes Used memory in bytes
# TYPE node_memory_used_bytes gauge
node_memory_used_bytes 8388608000
```

### Types de m√©triques

Prometheus d√©finit 4 types de m√©triques :

#### 1. **Counter** (compteur)
- Valeur qui ne fait qu'**augmenter** (ou se r√©initialise √† 0)
- Exemples : nombre de requ√™tes HTTP, bytes transf√©r√©s totaux
- Ne diminue jamais (sauf red√©marrage)

```
# TYPE http_requests_total counter
http_requests_total{method="GET",status="200"} 1234567
```

#### 2. **Gauge** (jauge)
- Valeur qui peut **monter ou descendre**
- Exemples : temp√©rature, utilisation CPU, m√©moire disponible
- Repr√©sente un √©tat instantan√©

```
# TYPE node_cpu_usage_percent gauge
node_cpu_usage_percent 67.5
```

#### 3. **Histogram** (histogramme)
- Distribution de valeurs dans des buckets
- Utilis√© pour latences, tailles de r√©ponse
- Complexe, pas couvert ici

#### 4. **Summary** (r√©sum√©)
- Similaire √† histogram, avec quantiles
- √âgalement complexe

**Pour notre agent de monitoring, nous utiliserons principalement des `gauge` et `counter`.**

### Labels (√©tiquettes)

Les labels permettent de **dimensionner** les m√©triques :

```
node_network_receive_bytes_total{interface="eth0"} 123456789  
node_network_receive_bytes_total{interface="lo"} 987654321  
node_network_receive_bytes_total{interface="wlan0"} 456789123  
```

**Bonnes pratiques :**
- Noms de labels en snake_case
- Valeurs de labels stables (pas de cardinalit√© explosive)
- Labels pertinents pour le filtrage dans Prometheus

### Conventions de nommage

**Format recommand√© :** `namespace_subsystem_metric_unit`

Exemples :
- `node_cpu_usage_percent` : m√©trique syst√®me (node) pour le CPU
- `node_memory_available_bytes` : m√©moire disponible en bytes
- `node_disk_read_bytes_total` : total des bytes lus sur disque
- `node_network_transmit_bytes_total` : bytes transmis r√©seau

**R√®gles :**
- Noms en snake_case (minuscules avec underscores)
- Suffixe avec l'unit√© (`_bytes`, `_seconds`, `_percent`)
- `_total` pour les counters cumulatifs
- Pas de caract√®res sp√©ciaux sauf underscore

---

## Serveur HTTP minimal en C

Pour exposer nos m√©triques, nous avons besoin d'un serveur HTTP simple.

### Approche avec les sockets POSIX

Nous allons cr√©er un serveur TCP qui r√©pond aux requ√™tes HTTP GET sur `/metrics`.

#### Structure du serveur

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define SERVER_PORT 8080
#define BUFFER_SIZE 4096

int create_server_socket(int port) {
    int server_fd;
    struct sockaddr_in address;
    int opt = 1;

    // Cr√©er le socket
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        perror("socket failed");
        return -1;
    }

    // Option pour r√©utiliser l'adresse imm√©diatement
    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt))) {
        perror("setsockopt");
        close(server_fd);
        return -1;
    }

    // Configuration de l'adresse
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;  // √âcouter sur toutes les interfaces
    address.sin_port = htons(port);

    // Bind
    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {
        perror("bind failed");
        close(server_fd);
        return -1;
    }

    // Listen
    if (listen(server_fd, 10) < 0) {
        perror("listen");
        close(server_fd);
        return -1;
    }

    printf("Serveur HTTP d√©marr√© sur le port %d\n", port);
    return server_fd;
}
```

**Explications :**
- `socket()` : Cr√©e un socket TCP (SOCK_STREAM)
- `setsockopt()` : Permet de r√©utiliser le port imm√©diatement apr√®s fermeture
- `bind()` : Associe le socket au port
- `listen()` : Met le socket en mode √©coute
- `INADDR_ANY` : √âcoute sur toutes les interfaces r√©seau (0.0.0.0)

#### Boucle d'acceptation des connexions

```c
void run_server(int server_fd) {
    struct sockaddr_in client_address;
    socklen_t client_len = sizeof(client_address);
    char buffer[BUFFER_SIZE];

    printf("En attente de connexions...\n");

    while (1) {
        // Accepter une connexion
        int client_fd = accept(server_fd,
                               (struct sockaddr *)&client_address,
                               &client_len);

        if (client_fd < 0) {
            perror("accept");
            continue;
        }

        // Lire la requ√™te HTTP
        ssize_t bytes_read = read(client_fd, buffer, BUFFER_SIZE - 1);
        if (bytes_read > 0) {
            buffer[bytes_read] = '\0';

            // V√©rifier si c'est une requ√™te GET /metrics
            if (strncmp(buffer, "GET /metrics", 12) == 0) {
                handle_metrics_request(client_fd);
            } else {
                handle_not_found(client_fd);
            }
        }

        close(client_fd);
    }
}
```

**Points cl√©s :**
- `accept()` bloque jusqu'√† ce qu'un client se connecte
- On lit la requ√™te HTTP dans un buffer
- On v√©rifie le path demand√©
- On ferme la connexion apr√®s la r√©ponse (HTTP/1.0 style)

#### R√©ponses HTTP

Fonction pour r√©pondre 404 :

```c
void handle_not_found(int client_fd) {
    const char *response =
        "HTTP/1.1 404 Not Found\r\n"
        "Content-Type: text/plain\r\n"
        "Content-Length: 13\r\n"
        "\r\n"
        "404 Not Found";

    write(client_fd, response, strlen(response));
}
```

Fonction pour r√©pondre avec les m√©triques :

```c
void handle_metrics_request(int client_fd) {
    char metrics[8192];  // Buffer pour les m√©triques

    // G√©n√©rer les m√©triques au format Prometheus
    generate_metrics(metrics, sizeof(metrics));

    // Calculer la longueur
    size_t metrics_len = strlen(metrics);

    // Construire la r√©ponse HTTP
    char response_header[512];
    snprintf(response_header, sizeof(response_header),
             "HTTP/1.1 200 OK\r\n"
             "Content-Type: text/plain; version=0.0.4; charset=utf-8\r\n"
             "Content-Length: %zu\r\n"
             "\r\n",
             metrics_len);

    // Envoyer header + m√©triques
    write(client_fd, response_header, strlen(response_header));
    write(client_fd, metrics, metrics_len);
}
```

**Remarques :**
- `Content-Type: text/plain; version=0.0.4` est le type MIME Prometheus
- `Content-Length` doit √™tre exact
- `\r\n\r\n` s√©pare les headers du body

---

## G√©n√©ration des m√©triques au format Prometheus

### Fonction de g√©n√©ration

Voici comment formater nos m√©triques syst√®me :

```c
#include <time.h>

void generate_metrics(char *buffer, size_t buffer_size) {
    system_metrics_t metrics;
    int offset = 0;

    // Collecter les m√©triques syst√®me
    if (collect_all_metrics(&metrics) != 0) {
        snprintf(buffer, buffer_size, "# Erreur de collecte\n");
        return;
    }

    // Timestamp optionnel (millisecondes depuis epoch)
    long long timestamp_ms = (long long)time(NULL) * 1000;

    // === CPU ===
    offset += snprintf(buffer + offset, buffer_size - offset,
        "# HELP node_cpu_usage_percent CPU usage percentage\n"
        "# TYPE node_cpu_usage_percent gauge\n"
        "node_cpu_usage_percent %.2f\n\n",
        metrics.cpu_usage_percent);

    // === M√©moire ===
    offset += snprintf(buffer + offset, buffer_size - offset,
        "# HELP node_memory_total_bytes Total memory in bytes\n"
        "# TYPE node_memory_total_bytes gauge\n"
        "node_memory_total_bytes %llu\n\n",
        metrics.memory_total_kb * 1024ULL);

    offset += snprintf(buffer + offset, buffer_size - offset,
        "# HELP node_memory_used_bytes Used memory in bytes\n"
        "# TYPE node_memory_used_bytes gauge\n"
        "node_memory_used_bytes %llu\n\n",
        metrics.memory_used_kb * 1024ULL);

    offset += snprintf(buffer + offset, buffer_size - offset,
        "# HELP node_memory_available_bytes Available memory in bytes\n"
        "# TYPE node_memory_available_bytes gauge\n"
        "node_memory_available_bytes %llu\n\n",
        metrics.memory_available_kb * 1024ULL);

    // === Load Average ===
    offset += snprintf(buffer + offset, buffer_size - offset,
        "# HELP node_load1 1m load average\n"
        "# TYPE node_load1 gauge\n"
        "node_load1 %.2f\n\n",
        metrics.load_1min);

    offset += snprintf(buffer + offset, buffer_size - offset,
        "# HELP node_load5 5m load average\n"
        "# TYPE node_load5 gauge\n"
        "node_load5 %.2f\n\n",
        metrics.load_5min);

    offset += snprintf(buffer + offset, buffer_size - offset,
        "# HELP node_load15 15m load average\n"
        "# TYPE node_load15 gauge\n"
        "node_load15 %.2f\n\n",
        metrics.load_15min);
}
```

**Points importants :**
1. Conversion des unit√©s : kB ‚Üí bytes (√ó 1024)
2. Format `%.2f` pour les floats (2 d√©cimales)
3. Double `\n` entre les groupes de m√©triques (lisibilit√©)
4. Utilisation de `snprintf` pour √©viter les buffer overflows

### M√©triques avec labels

Pour les m√©triques r√©seau ou disque avec plusieurs instances :

```c
void generate_network_metrics(char *buffer, size_t buffer_size, int *offset) {
    interface_stats_t interfaces[16];
    int num_interfaces = 0;

    if (read_all_interfaces(interfaces, 16, &num_interfaces) != 0) {
        return;
    }

    // Header une seule fois
    *offset += snprintf(buffer + *offset, buffer_size - *offset,
        "# HELP node_network_receive_bytes_total Network received bytes\n"
        "# TYPE node_network_receive_bytes_total counter\n");

    // Une ligne par interface
    for (int i = 0; i < num_interfaces; i++) {
        *offset += snprintf(buffer + *offset, buffer_size - *offset,
            "node_network_receive_bytes_total{interface=\"%s\"} %llu\n",
            interfaces[i].interface,
            interfaces[i].stats.rx_bytes);
    }

    *offset += snprintf(buffer + *offset, buffer_size - *offset, "\n");

    // Transmission
    *offset += snprintf(buffer + *offset, buffer_size - *offset,
        "# HELP node_network_transmit_bytes_total Network transmitted bytes\n"
        "# TYPE node_network_transmit_bytes_total counter\n");

    for (int i = 0; i < num_interfaces; i++) {
        *offset += snprintf(buffer + *offset, buffer_size - *offset,
            "node_network_transmit_bytes_total{interface=\"%s\"} %llu\n",
            interfaces[i].interface,
            interfaces[i].stats.tx_bytes);
    }

    *offset += snprintf(buffer + *offset, buffer_size - *offset, "\n");
}
```

**Structure :**
- HELP et TYPE d√©clar√©s une seule fois
- Ensuite une ligne par valeur avec ses labels
- Labels entre accolades : `{key="value"}`
- Guillemets √©chapp√©s si n√©cessaire

---

## Exemple complet : Agent de monitoring

Voici un agent complet qui combine tout :

### metrics.h

```c
#ifndef METRICS_H
#define METRICS_H

typedef struct {
    double cpu_usage_percent;
    unsigned long long memory_total_kb;
    unsigned long long memory_used_kb;
    unsigned long long memory_available_kb;
    double load_1min;
    double load_5min;
    double load_15min;
} system_metrics_t;

// Collecte les m√©triques
int collect_all_metrics(system_metrics_t *metrics);

// G√©n√®re le format Prometheus
void generate_metrics(char *buffer, size_t buffer_size);

#endif
```

### metrics.c

```c
#include "metrics.h"
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <sys/sysinfo.h>

// Structures internes (de la section 34.3.1)
typedef struct {
    unsigned long long user;
    unsigned long long nice;
    unsigned long long system;
    unsigned long long idle;
    unsigned long long iowait;
    unsigned long long irq;
    unsigned long long softirq;
    unsigned long long steal;
} cpu_stats_t;

static int read_cpu_stats(cpu_stats_t *stats) {
    FILE *fp = fopen("/proc/stat", "r");
    if (fp == NULL) return -1;

    char buffer[256];
    if (fgets(buffer, sizeof(buffer), fp) == NULL) {
        fclose(fp);
        return -1;
    }

    int parsed = sscanf(buffer, "cpu %llu %llu %llu %llu %llu %llu %llu %llu",
                        &stats->user, &stats->nice, &stats->system, &stats->idle,
                        &stats->iowait, &stats->irq, &stats->softirq, &stats->steal);

    fclose(fp);
    return (parsed < 8) ? -1 : 0;
}

static double calculate_cpu_usage(cpu_stats_t *prev, cpu_stats_t *curr) {
    unsigned long long prev_idle = prev->idle + prev->iowait;
    unsigned long long curr_idle = curr->idle + curr->iowait;

    unsigned long long prev_total = prev->user + prev->nice + prev->system +
                                    prev->idle + prev->iowait + prev->irq +
                                    prev->softirq + prev->steal;
    unsigned long long curr_total = curr->user + curr->nice + curr->system +
                                    curr->idle + curr->iowait + curr->irq +
                                    curr->softirq + curr->steal;

    unsigned long long total_diff = curr_total - prev_total;
    unsigned long long idle_diff = curr_idle - prev_idle;

    if (total_diff == 0) return 0.0;

    return 100.0 * (total_diff - idle_diff) / total_diff;
}

int collect_all_metrics(system_metrics_t *metrics) {
    cpu_stats_t prev_cpu, curr_cpu;
    struct sysinfo info;

    // CPU
    if (read_cpu_stats(&prev_cpu) != 0) return -1;
    sleep(1);
    if (read_cpu_stats(&curr_cpu) != 0) return -1;
    metrics->cpu_usage_percent = calculate_cpu_usage(&prev_cpu, &curr_cpu);

    // M√©moire et load via sysinfo
    if (sysinfo(&info) != 0) return -1;

    metrics->memory_total_kb = info.totalram / 1024;
    metrics->memory_available_kb = info.freeram / 1024;
    metrics->memory_used_kb = metrics->memory_total_kb - metrics->memory_available_kb;

    metrics->load_1min = info.loads[0] / 65536.0;
    metrics->load_5min = info.loads[1] / 65536.0;
    metrics->load_15min = info.loads[2] / 65536.0;

    return 0;
}

void generate_metrics(char *buffer, size_t buffer_size) {
    system_metrics_t metrics;
    int offset = 0;

    if (collect_all_metrics(&metrics) != 0) {
        snprintf(buffer, buffer_size, "# Error collecting metrics\n");
        return;
    }

    offset += snprintf(buffer + offset, buffer_size - offset,
        "# HELP node_cpu_usage_percent CPU usage percentage\n"
        "# TYPE node_cpu_usage_percent gauge\n"
        "node_cpu_usage_percent %.2f\n\n",
        metrics.cpu_usage_percent);

    offset += snprintf(buffer + offset, buffer_size - offset,
        "# HELP node_memory_total_bytes Total memory in bytes\n"
        "# TYPE node_memory_total_bytes gauge\n"
        "node_memory_total_bytes %llu\n\n",
        metrics.memory_total_kb * 1024ULL);

    offset += snprintf(buffer + offset, buffer_size - offset,
        "# HELP node_memory_used_bytes Used memory in bytes\n"
        "# TYPE node_memory_used_bytes gauge\n"
        "node_memory_used_bytes %llu\n\n",
        metrics.memory_used_kb * 1024ULL);

    offset += snprintf(buffer + offset, buffer_size - offset,
        "# HELP node_load1 1m load average\n"
        "# TYPE node_load1 gauge\n"
        "node_load1 %.2f\n\n",
        metrics.load_1min);

    offset += snprintf(buffer + offset, buffer_size - offset,
        "# HELP node_load5 5m load average\n"
        "# TYPE node_load5 gauge\n"
        "node_load5 %.2f\n\n",
        metrics.load_5min);

    offset += snprintf(buffer + offset, buffer_size - offset,
        "# HELP node_load15 15m load average\n"
        "# TYPE node_load15 gauge\n"
        "node_load15 %.2f\n",
        metrics.load_15min);
}
```

### http_server.c

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <signal.h>
#include "metrics.h"

#define SERVER_PORT 8080
#define BUFFER_SIZE 4096

static volatile int keep_running = 1;

void signal_handler(int sig) {
    (void)sig;  // Unused
    keep_running = 0;
}

int create_server_socket(int port) {
    int server_fd;
    struct sockaddr_in address;
    int opt = 1;

    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        perror("socket failed");
        return -1;
    }

    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt))) {
        perror("setsockopt");
        close(server_fd);
        return -1;
    }

    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(port);

    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {
        perror("bind failed");
        close(server_fd);
        return -1;
    }

    if (listen(server_fd, 10) < 0) {
        perror("listen");
        close(server_fd);
        return -1;
    }

    printf("Serveur HTTP d√©marr√© sur le port %d\n", port);
    printf("M√©triques disponibles sur: http://localhost:%d/metrics\n", port);
    return server_fd;
}

void handle_metrics_request(int client_fd) {
    char metrics[8192];

    generate_metrics(metrics, sizeof(metrics));

    size_t metrics_len = strlen(metrics);

    char response_header[512];
    snprintf(response_header, sizeof(response_header),
             "HTTP/1.1 200 OK\r\n"
             "Content-Type: text/plain; version=0.0.4; charset=utf-8\r\n"
             "Content-Length: %zu\r\n"
             "\r\n",
             metrics_len);

    write(client_fd, response_header, strlen(response_header));
    write(client_fd, metrics, metrics_len);
}

void handle_not_found(int client_fd) {
    const char *response =
        "HTTP/1.1 404 Not Found\r\n"
        "Content-Type: text/plain\r\n"
        "Content-Length: 13\r\n"
        "\r\n"
        "404 Not Found";

    write(client_fd, response, strlen(response));
}

void run_server(int server_fd) {
    struct sockaddr_in client_address;
    socklen_t client_len = sizeof(client_address);
    char buffer[BUFFER_SIZE];

    while (keep_running) {
        int client_fd = accept(server_fd,
                               (struct sockaddr *)&client_address,
                               &client_len);

        if (client_fd < 0) {
            if (keep_running) {
                perror("accept");
            }
            continue;
        }

        ssize_t bytes_read = read(client_fd, buffer, BUFFER_SIZE - 1);
        if (bytes_read > 0) {
            buffer[bytes_read] = '\0';

            if (strncmp(buffer, "GET /metrics", 12) == 0) {
                handle_metrics_request(client_fd);
            } else {
                handle_not_found(client_fd);
            }
        }

        close(client_fd);
    }
}

int main(void) {
    signal(SIGINT, signal_handler);
    signal(SIGTERM, signal_handler);

    int server_fd = create_server_socket(SERVER_PORT);
    if (server_fd < 0) {
        return EXIT_FAILURE;
    }

    run_server(server_fd);

    close(server_fd);
    printf("\nServeur arr√™t√© proprement\n");
    return EXIT_SUCCESS;
}
```

### Compilation et ex√©cution

```bash
# Compiler
gcc -Wall -Wextra -O2 -o monitoring_agent http_server.c metrics.c

# Lancer l'agent
./monitoring_agent

# Dans un autre terminal, tester
curl http://localhost:8080/metrics
```

**R√©sultat attendu :**
```
# HELP node_cpu_usage_percent CPU usage percentage
# TYPE node_cpu_usage_percent gauge
node_cpu_usage_percent 23.45

# HELP node_memory_total_bytes Total memory in bytes
# TYPE node_memory_total_bytes gauge
node_memory_total_bytes 16777216000

# HELP node_memory_used_bytes Used memory in bytes
# TYPE node_memory_used_bytes gauge
node_memory_used_bytes 8388608000

# HELP node_load1 1m load average
# TYPE node_load1 gauge
node_load1 1.23

# HELP node_load5 5m load average
# TYPE node_load5 gauge
node_load5 0.98

# HELP node_load15 15m load average
# TYPE node_load15 gauge
node_load15 0.76
```

---

## Configuration de Prometheus pour scraper l'agent

### prometheus.yml

Cr√©ez un fichier de configuration Prometheus :

```yaml
global:
  scrape_interval: 15s      # Interroger toutes les 15 secondes
  evaluation_interval: 15s  # √âvaluer les r√®gles toutes les 15s

scrape_configs:
  - job_name: 'monitoring_agent'
    static_configs:
      - targets: ['localhost:8080']
        labels:
          instance: 'server-01'
          environment: 'production'
```

### Lancer Prometheus (avec Docker)

```bash
docker run -d \
  --name prometheus \
  -p 9090:9090 \
  -v $(pwd)/prometheus.yml:/etc/prometheus/prometheus.yml \
  prom/prometheus
```

### V√©rification

1. Acc√©dez √† http://localhost:9090
2. Allez dans **Status ‚Üí Targets**
3. V√©rifiez que votre agent appara√Æt comme **UP**
4. Dans **Graph**, requ√™tez : `node_cpu_usage_percent`

---

## Bonnes pratiques d'export

### 1. Noms de m√©triques coh√©rents

Suivez les conventions Prometheus :

```c
// ‚úÖ Bon
node_cpu_usage_percent  
node_memory_available_bytes  
node_disk_read_bytes_total  

// ‚ùå Mauvais
CpuUsage                     // Pas de snake_case  
memory_avail                 // Pas d'unit√©  
diskReads                    // camelCase interdit  
total_disk_reads_bytes       // 'total' au d√©but, pas √† la fin  
```

### 2. Types de m√©triques appropri√©s

```c
// Gauge : valeurs qui montent ET descendent
node_cpu_usage_percent gauge  
node_memory_available_bytes gauge  

// Counter : valeurs cumulatives (ne font qu'augmenter)
node_network_receive_bytes_total counter  
node_disk_reads_completed_total counter  
```

### 3. Unit√©s de base

Toujours utiliser les **unit√©s de base** :
- Temps : **secondes** (pas millisecondes)
- Taille : **bytes** (pas kB, MB)
- Pourcentage : 0-100 (pas 0-1)

```c
// ‚úÖ Bon
node_uptime_seconds 86400  
node_memory_total_bytes 16777216000  

// ‚ùå Mauvais
node_uptime_hours 24  
node_memory_total_mb 16000  
```

### 4. Labels vs noms de m√©triques

Utilisez des **labels** pour les dimensions :

```c
// ‚úÖ Bon : un nom de m√©trique, plusieurs labels
node_network_receive_bytes_total{interface="eth0"} 123  
node_network_receive_bytes_total{interface="wlan0"} 456  

// ‚ùå Mauvais : une m√©trique par interface
node_network_eth0_receive_bytes_total 123  
node_network_wlan0_receive_bytes_total 456  
```

### 5. Gestion des erreurs

Si une m√©trique ne peut pas √™tre collect√©e :

```c
void generate_metrics(char *buffer, size_t buffer_size) {
    system_metrics_t metrics;

    if (collect_all_metrics(&metrics) != 0) {
        // Option 1 : Ne pas exposer les m√©triques en erreur
        snprintf(buffer, buffer_size,
                 "# Metrics collection failed\n");
        return;

        // Option 2 : Exposer une m√©trique d'erreur
        snprintf(buffer, buffer_size,
                 "# HELP node_scrape_error Scrape error status\n"
                 "# TYPE node_scrape_error gauge\n"
                 "node_scrape_error 1\n");
        return;
    }

    // M√©triques normales...
}
```

### 6. M√©trique de sant√© (health check)

Ajoutez toujours une m√©trique `up` :

```c
offset += snprintf(buffer + offset, buffer_size - offset,
    "# HELP node_exporter_up Agent is running\n"
    "# TYPE node_exporter_up gauge\n"
    "node_exporter_up 1\n\n");
```

Prometheus peut alerter si cette m√©trique dispara√Æt ou passe √† 0.

### 7. M√©tadonn√©es de l'agent

Exposez des informations sur l'agent lui-m√™me :

```c
offset += snprintf(buffer + offset, buffer_size - offset,
    "# HELP node_exporter_build_info Build information\n"
    "# TYPE node_exporter_build_info gauge\n"
    "node_exporter_build_info{version=\"1.0.0\",commit=\"abc123\"} 1\n\n");
```

---

## Optimisations

### 1. Cache des m√©triques

Pour √©viter de recalculer √† chaque requ√™te :

```c
static char cached_metrics[8192];  
static time_t last_update = 0;  
static const int CACHE_TTL = 5;  // 5 secondes  

void handle_metrics_request(int client_fd) {
    time_t now = time(NULL);

    // R√©g√©n√©rer si cache expir√©
    if (now - last_update >= CACHE_TTL) {
        generate_metrics(cached_metrics, sizeof(cached_metrics));
        last_update = now;
    }

    // Utiliser le cache
    size_t metrics_len = strlen(cached_metrics);

    char response_header[512];
    snprintf(response_header, sizeof(response_header),
             "HTTP/1.1 200 OK\r\n"
             "Content-Type: text/plain; version=0.0.4\r\n"
             "Content-Length: %zu\r\n"
             "\r\n",
             metrics_len);

    write(client_fd, response_header, strlen(response_header));
    write(client_fd, cached_metrics, metrics_len);
}
```

**Avantages :**
- R√©duit la charge CPU si Prometheus scrape fr√©quemment
- √âvite les lectures r√©p√©titives de `/proc`

**Attention :** Le TTL doit √™tre **inf√©rieur** √† l'intervalle de scrape Prometheus.

### 2. Pr√©-allocation des buffers

```c
// Allouer une seule fois au d√©marrage
static char metrics_buffer[16384];

void generate_metrics_optimized(void) {
    // R√©utiliser le buffer global
    generate_metrics(metrics_buffer, sizeof(metrics_buffer));
}
```

### 3. √âviter les allocations dans la boucle

```c
// ‚ùå Mauvais : malloc dans la boucle
void run_server(int server_fd) {
    while (1) {
        char *buffer = malloc(4096);  // Allocation r√©p√©t√©e
        // ...
        free(buffer);
    }
}

// ‚úÖ Bon : buffer sur la pile
void run_server(int server_fd) {
    char buffer[4096];  // Une seule fois
    while (1) {
        // R√©utiliser buffer
    }
}
```

---

## D√©bogage

### V√©rifier le format

Utilisez `promtool` pour valider :

```bash
# Installer promtool (dans le package prometheus)
sudo apt install prometheus

# Valider le format
curl -s http://localhost:8080/metrics | promtool check metrics
```

R√©sultat attendu : `SUCCESS`

### Logs de Prometheus

Si l'agent n'appara√Æt pas dans Prometheus :

```bash
# Voir les logs Docker
docker logs prometheus

# Chercher des erreurs de scrape
# "context deadline exceeded" = timeout
# "connection refused" = agent non joignable
```

### Test manuel

```bash
# Tester avec curl
curl -v http://localhost:8080/metrics

# V√©rifier les headers
# Content-Type doit √™tre: text/plain; version=0.0.4

# Mesurer le temps de r√©ponse
time curl -s http://localhost:8080/metrics > /dev/null
```

---

## Extension : Endpoint /health

En bonus, ajoutez un endpoint de sant√© :

```c
void handle_health_request(int client_fd) {
    const char *response =
        "HTTP/1.1 200 OK\r\n"
        "Content-Type: text/plain\r\n"
        "Content-Length: 2\r\n"
        "\r\n"
        "OK";

    write(client_fd, response, strlen(response));
}

// Dans run_server()
if (strncmp(buffer, "GET /metrics", 12) == 0) {
    handle_metrics_request(client_fd);
} else if (strncmp(buffer, "GET /health", 11) == 0) {
    handle_health_request(client_fd);
} else {
    handle_not_found(client_fd);
}
```

Utile pour les health checks de load balancers ou orchestrateurs (Kubernetes).

---

## Visualisation avec Grafana

Une fois Prometheus configur√©, ajoutez Grafana pour la visualisation :

### 1. Lancer Grafana

```bash
docker run -d \
  --name grafana \
  -p 3000:3000 \
  grafana/grafana
```

### 2. Configuration

1. Acc√©dez √† http://localhost:3000 (login: admin/admin)
2. Ajoutez Prometheus comme **Data Source** (URL: http://prometheus:9090)
3. Cr√©ez un dashboard avec des panels :
   - **CPU Usage** : Query `node_cpu_usage_percent`
   - **Memory Usage** : Query `node_memory_used_bytes / node_memory_total_bytes * 100`
   - **Load Average** : Query `node_load1`, `node_load5`, `node_load15`

### 3. Expressions PromQL utiles

```promql
# Utilisation m√©moire en %
100 * node_memory_used_bytes / node_memory_total_bytes

# D√©bit r√©seau en MB/s (avec rate sur 1 minute)
rate(node_network_receive_bytes_total[1m]) / 1024 / 1024

# CPU par c≈ìur (si collect√©)
node_cpu_usage_percent{core="0"}
```

---

## R√©sum√©

L'export Prometheus en C n√©cessite :

1. **Serveur HTTP simple**
   - Socket TCP avec `bind()` et `listen()`
   - Accepter les connexions avec `accept()`
   - R√©pondre avec HTTP/1.1

2. **Format Prometheus**
   - Texte simple avec HELP, TYPE, et valeurs
   - Conventions de nommage strictes
   - Labels pour les dimensions

3. **Int√©gration**
   - Endpoint `/metrics` exposant les donn√©es
   - Configuration Prometheus pour scraper
   - Visualisation avec Grafana

4. **Bonnes pratiques**
   - Types de m√©triques appropri√©s (gauge/counter)
   - Unit√©s de base (bytes, seconds)
   - Cache pour performances
   - Gestion d'erreurs robuste

Votre agent C peut maintenant s'int√©grer dans n'importe quelle infrastructure de monitoring moderne bas√©e sur Prometheus !

---

## Pour aller plus loin

- **Librairies HTTP** : Utiliser `libmicrohttpd` pour un serveur plus robuste
- **TLS/HTTPS** : S√©curiser l'endpoint avec OpenSSL
- **M√©triques suppl√©mentaires** : Temp√©rature CPU, processus par utilisateur, etc.
- **Exporters existants** : √âtudier le code de `node_exporter` (√©crit en Go)
- **Push Gateway** : Pour les jobs batch qui ne peuvent pas √™tre scrap√©s

**Ressources :**
- Documentation Prometheus : https://prometheus.io/docs/
- Format d'exposition : https://prometheus.io/docs/instrumenting/exposition_formats/
- PromQL : https://prometheus.io/docs/prometheus/latest/querying/basics/

‚è≠Ô∏è [Daemonisation](/34-etudes-cas-devops/03.3-daemonisation.md)
