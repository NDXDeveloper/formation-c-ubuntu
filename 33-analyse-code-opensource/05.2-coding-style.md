üîù Retour au [Sommaire](/SOMMAIRE.md)

# 33.5.2 Comprendre le coding style

## Introduction

**Le code, c'est comme l'√©criture manuscrite : chacun a son style**

Imaginez recevoir une lettre manuscrite o√π chaque mot utilise une police diff√©rente, certains mots sont en majuscules, d'autres en minuscules, sans coh√©rence. Difficile √† lire, n'est-ce pas ? C'est exactement ce qui se passe quand plusieurs d√©veloppeurs travaillent sur un projet sans style de code unifi√©.

Le **coding style** (ou **style de code**) est l'ensemble des conventions qui d√©finissent comment le code doit √™tre format√© et organis√©. Dans les projets open-source √©tablis, respecter le style existant n'est pas optionnel - **c'est une exigence**.

**Pourquoi le coding style est crucial ?**
- ‚úÖ **Lisibilit√©** : Code coh√©rent = code facile √† lire
- ‚úÖ **Maintenance** : Changements clairement visibles dans les diffs
- ‚úÖ **Review** : Les reviewers se concentrent sur la logique, pas le formatage
- ‚úÖ **Professionnalisme** : Montre que vous respectez les conventions du projet
- ‚úÖ **Acceptance** : Une PR mal format√©e peut √™tre rejet√©e imm√©diatement

**Ce que vous apprendrez** :
- Comment identifier le style d'un projet
- Les diff√©rents styles courants en C
- Les √©l√©ments de style √† observer
- Comment configurer vos outils
- Comment adapter votre code au style du projet

---

## üéØ Pourquoi le style de code compte autant ?

### L'exemple qui parle

Voici le **m√™me code** √©crit dans deux styles diff√©rents :

**Style A (K&R)** :
```c
int calculate_sum(int *array, int size)
{
    int sum = 0;
    for (int i = 0; i < size; i++) {
        sum += array[i];
    }
    return sum;
}
```

**Style B (Allman)** :
```c
int calculate_sum(int *array, int size)
{
    int sum = 0;
    for (int i = 0; i < size; i++)
    {
        sum += array[i];
    }
    return sum;
}
```

**Maintenant, imaginez un projet avec 50 000 lignes** o√π la moiti√© utilise le style A et l'autre moiti√© le style B. Cauchemar !

---

### Ce que disent les mainteneurs

Voici des commentaires r√©els de mainteneurs de projets open-source :

> **Linus Torvalds (Linux Kernel)** :
> "If you want to be a kernel hacker, follow the kernel coding style. Period."

> **Maintainer Git** :
> "We reject patches that don't follow our coding standards, even if the code works perfectly."

> **Maintainer Redis** :
> "Code style consistency is more important than any individual preference."

**Message clair** : Le style du projet > Votre style personnel.

---

## üîç O√π trouver le style guide ?

### M√©thode 1 : Fichiers de documentation

La plupart des projets s√©rieux documentent leur style. Cherchez ces fichiers :

#### **CONTRIBUTING.md**

Fichier le plus important. Contient souvent une section "Code Style".

```bash
# Chercher le fichier
cat CONTRIBUTING.md | grep -i "style\|format\|coding"
```

**Exemple (Git)** :
```
CONTRIBUTING.md:
- Follow the coding guidelines in Documentation/CodingGuidelines
- Use tabs for indentation
- Keep lines under 80 characters
```

---

#### **CodingStyle ou CODING_STYLE**

Fichier d√©di√© au style de code.

```bash
# Fichiers possibles
ls -la | grep -i "style\|coding"

# Exemples de noms
CODING_STYLE  
CodingStyle.md  
docs/coding-style.txt  
Documentation/CodingGuidelines  
.editorconfig
```

---

#### **.clang-format**

Fichier de configuration pour l'outil `clang-format`.

```bash
# Si ce fichier existe, le style est automatisable !
ls -la .clang-format
```

**Exemple (.clang-format)** :
```yaml
BasedOnStyle: LLVM  
IndentWidth: 4  
UseTab: Never  
ColumnLimit: 80  
BreakBeforeBraces: Linux  
```

Vous pouvez utiliser ce fichier directement :
```bash
clang-format -i myfile.c
```

---

#### **.editorconfig**

Fichier de configuration multi-√©diteur.

**Exemple (.editorconfig)** :
```ini
[*.c]
indent_style = tab  
indent_size = 8  
end_of_line = lf  
charset = utf-8  
trim_trailing_whitespace = true  
insert_final_newline = true  
```

La plupart des IDE modernes reconnaissent ce fichier automatiquement.

---

### M√©thode 2 : README et Wiki

Regardez :
- Le README principal
- Le wiki du projet (si sur GitHub/GitLab)
- La section "Contributing" du site web

---

### M√©thode 3 : Lire le code existant

**Si aucune documentation n'existe**, apprenez par l'exemple.

```bash
# Ouvrir quelques fichiers sources
vim src/main.c  
vim src/utils.c  
vim src/core.c  
```

**Observez** :
- L'indentation (espaces ou tabs ?)
- La position des accolades
- Le nommage des variables
- Les commentaires
- La longueur des lignes

**R√®gle d'or** : Imitez le style du fichier que vous modifiez.

---

## üìã Les √©l√©ments de style √† observer

### 1. Indentation

**Question** : Espaces ou tabs ? Combien ?

#### **Espaces**
```c
int foo(void)
{
¬∑¬∑¬∑¬∑int x = 42;  // 4 espaces
¬∑¬∑¬∑¬∑return x;
}
```

**Avantages** :
- ‚úÖ Rendu identique partout
- ‚úÖ Contr√¥le pr√©cis de l'alignement

**Projets utilisant des espaces** : Redis (4 espaces), curl (2 espaces)

---

#### **Tabs**
```c
int foo(void)
{
‚Üí   int x = 42;  // 1 tab (√©quivaut souvent √† 8 espaces)
‚Üí   return x;
}
```

**Avantages** :
- ‚úÖ Plus compact (1 caract√®re au lieu de 4 ou 8)
- ‚úÖ Chaque d√©veloppeur peut configurer la largeur

**Projets utilisant des tabs** : Linux Kernel (tabs de 8), Git (tabs de 8), Nginx

---

#### **Comment d√©tecter ?**

```bash
# Afficher les caract√®res invisibles avec cat -A
cat -A src/main.c | head -20

# Si vous voyez ^I ‚Üí ce sont des tabs
# Si vous voyez des espaces ‚Üí ce sont des espaces
```

**Exemple** :
```bash
$ cat -A main.c
int main(void)$
{$
^Iint x = 42;$    ‚Üê ^I = tab
    return x;$    ‚Üê espaces visibles
}$
```

---

### 2. Position des accolades

Il existe plusieurs conventions :

#### **Style K&R (Kernighan & Ritchie)**

Accolade ouvrante sur la m√™me ligne (sauf pour les fonctions).

```c
// Fonctions : accolade sur nouvelle ligne
int foo(void)
{
    if (condition) {        // Accolade sur m√™me ligne
        do_something();
    } else {
        do_other();
    }

    for (int i = 0; i < 10; i++) {
        process(i);
    }
}
```

**Utilis√© par** : Linux Kernel, Git, beaucoup de projets C

---

#### **Style Allman (BSD)**

Toutes les accolades sur une nouvelle ligne.

```c
int foo(void)
{
    if (condition)
    {
        do_something();
    }
    else
    {
        do_other();
    }

    for (int i = 0; i < 10; i++)
    {
        process(i);
    }
}
```

**Utilis√© par** : Certains projets C++ et C#, moins courant en C pur

---

#### **Style GNU**

Accolades toujours indent√©es de 2 espaces.

```c
int foo(void)
  {
    if (condition)
      {
        do_something();
      }
    else
      {
        do_other();
      }
  }
```

**Utilis√© par** : Projets GNU (GCC, Emacs, etc.)

---

#### **Comment d√©tecter ?**

Regardez simplement quelques fonctions dans le code existant.

```bash
# Afficher les 50 premi√®res lignes
head -50 src/main.c
```

---

### 3. Nommage des identificateurs

#### **Fonctions**

**snake_case** (le plus courant en C) :
```c
int calculate_total(void);  
void process_user_input(void);  
```

**camelCase** (rare en C) :
```c
int calculateTotal(void);  
void processUserInput(void);  
```

**PascalCase** (tr√®s rare en C, plut√¥t C++) :
```c
int CalculateTotal(void);  
void ProcessUserInput(void);  
```

---

#### **Variables**

**snake_case** (standard C) :
```c
int user_count;  
char *file_name;  
double average_score;  
```

**camelCase** (moins courant) :
```c
int userCount;  
char *fileName;  
double averageScore;  
```

---

#### **Constantes et macros**

**SCREAMING_SNAKE_CASE** (convention presque universelle) :
```c
#define MAX_BUFFER_SIZE 1024
#define DEFAULT_TIMEOUT 30

const int MAX_USERS = 100;
```

---

#### **Types (struct, enum, typedef)**

**Plusieurs conventions** :

**Suffixe _t (tr√®s courant)** :
```c
typedef struct user {
    char *name;
    int age;
} user_t;

typedef enum {
    STATUS_OK,
    STATUS_ERROR
} status_t;
```

**Sans typedef (Linux Kernel)** :
```c
struct user {
    char *name;
    int age;
};
/* Le kernel n'utilise pas typedef pour les structures */
```

**PascalCase (style Windows/C++)** :
```c
typedef struct {
    char *name;
    int age;
} User;
```

---

#### **Comment d√©tecter ?**

```bash
# Chercher les d√©finitions de fonctions
grep -n "^[a-z_]*(" src/*.c | head -20

# Chercher les typedefs
grep -n "typedef" src/*.h | head -20
```

---

### 4. Longueur des lignes

**Question** : Combien de caract√®res maximum par ligne ?

**Standards courants** :
- **80 caract√®res** : Traditionnel (Linux Kernel, Git)
- **100 caract√®res** : Plus moderne (certains projets)
- **120 caract√®res** : Rare en C

**Pourquoi limiter ?**
- ‚úÖ Lisibilit√© (pas de scroll horizontal)
- ‚úÖ Diff c√¥te √† c√¥te
- ‚úÖ Code review sur petits √©crans
- ‚úÖ Tradition UNIX (terminaux 80x24)

**Comment d√©tecter ?**

```bash
# Trouver les lignes les plus longues
awk 'length > max { max = length; line = $0 } END { print max, line }' src/main.c
```

---

### 5. Espaces autour des op√©rateurs

**Question** : Espaces ou pas ?

#### **Style standard C (avec espaces)** :
```c
int x = 10 + 20 * 30;  
if (x == 42 && y != 0) {  
    z = x / y;
}

for (int i = 0; i < n; i++) {
    array[i] = i * 2;
}
```

#### **Style compact (sans espaces)** :
```c
int x=10+20*30;  
if (x==42 && y!=0) {  
    z=x/y;
}

for (int i=0; i<n; i++) {
    array[i]=i*2;
}
```

**Presque tous les projets utilisent des espaces**. Le style compact est difficile √† lire.

---

#### **Cas particuliers** :

**Pointeurs** (position de `*`) :

```c
// Style A : * coll√© au type
int *ptr;  
char *str;  

// Style B : * coll√© au nom
int* ptr;  
char* str;  

// Style C : * au milieu
int * ptr;  
char * str;  
```

**Linux Kernel utilise le Style A** :
```c
int *ptr, *ptr2;  // Les deux sont des pointeurs
```

**Pourquoi ?** Parce que `int* ptr, ptr2;` d√©clare `ptr` comme pointeur mais `ptr2` comme int !

---

### 6. Commentaires

#### **Style de commentaires**

**Commentaires mono-ligne** :
```c
// Style C99 (accept√© par la plupart des projets)
int x = 42;  // Variable importante

/* Style C89 traditionnel */
int y = 10;  /* Autre variable */
```

**Commentaires multi-lignes** :

**Style Linux Kernel** :
```c
/*
 * Ceci est un commentaire
 * sur plusieurs lignes
 */
```

**Style Doxygen** :
```c
/**
 * @brief Calculate the sum of an array
 * @param array The input array
 * @param size The size of the array
 * @return The sum of all elements
 */
int calculate_sum(int *array, int size);
```

**Style simple** :
```c
/*
   Ceci est un commentaire
   sur plusieurs lignes
*/
```

---

#### **O√π commenter ?**

**Linux Kernel (tr√®s comment√©)** :
```c
/*
 * Allocate a new buffer. Returns NULL on failure.
 * The caller is responsible for freeing the buffer.
 */
void *alloc_buffer(size_t size)
{
    void *buf;

    /* Try to allocate from the pool first */
    buf = pool_alloc(size);
    if (buf)
        return buf;

    /* Fallback to malloc */
    return malloc(size);
}
```

**Git (commentaires mod√©r√©s)** :
```c
int parse_commit(struct commit *item)
{
    if (item->object.parsed)
        return 0;  // Already parsed

    // Read the commit object
    read_object_file(&item->object.oid, &type, &size);
    // ...
}
```

---

### 7. Organisation des includes

**Ordre typique** :

```c
// 1. Headers syst√®me
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 2. Headers syst√®me sp√©cifiques (POSIX, etc.)
#include <unistd.h>
#include <sys/types.h>

// 3. Headers de biblioth√®ques externes
#include <curl/curl.h>
#include <json-c/json.h>

// 4. Headers du projet
#include "config.h"
#include "utils.h"
#include "main.h"
```

**Linux Kernel (ordre strict)** :
```c
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/init.h>

#include "internal.h"
```

---

### 8. D√©clarations de variables

**Question** : O√π d√©clarer les variables ?

#### **Style C89 (anciennes bases de code)**
```c
int foo(void)
{
    int x;
    int y;
    char *str;

    x = 10;
    y = 20;
    str = malloc(100);
    // ...
}
```

Toutes les variables **au d√©but de la fonction**.

---

#### **Style C99/moderne**
```c
int foo(void)
{
    int x = 10;

    // Faire des choses avec x

    int y = calculate(x);  // D√©clar√© quand n√©cessaire

    for (int i = 0; i < 10; i++) {  // D√©clar√© dans le for
        process(i);
    }
}
```

Variables d√©clar√©es **quand n√©cessaire**.

**Projets modernes** (Redis, curl) : Style C99  
**Projets anciens** (Linux Kernel en partie) : M√©lange C89/C99  

---

## üìö Les styles de code courants en C

### Style 1 : Linux Kernel

**Le plus influent** dans le monde C.

**Document officiel** : `Documentation/process/coding-style.rst`

**Caract√©ristiques** :
```c
// ‚úÖ Tabs pour indentation (largeur 8)
// ‚úÖ Accolades K&R
// ‚úÖ snake_case pour tout
// ‚úÖ Lignes max 80 caract√®res
// ‚úÖ Pas de typedef pour les structures
// ‚úÖ goto pour le cleanup

int calculate_sum(int *array, int size)
{
        int sum = 0;  // ‚Üê Tab de largeur 8
        int i;

        if (!array)
                goto out;

        for (i = 0; i < size; i++) {
                sum += array[i];
        }

out:
        return sum;
}
```

**Principes** :
- "Emulate Linus's style"
- Simple et coh√©rent
- Privil√©gie la lisibilit√©

---

### Style 2 : GNU

**Utilis√© par** : GCC, Emacs, grep, sed, etc.

**Document officiel** : https://www.gnu.org/prep/standards/

**Caract√©ristiques** :
```c
// ‚úÖ Espaces pour indentation (2 espaces)
// ‚úÖ Accolades indent√©es de 2
// ‚úÖ snake_case
// ‚úÖ Commentaires verbeux

int  
calculate_sum (int *array, int size)  
  {
    int sum = 0;
    int i;

    /* Check if the array pointer is valid.
       We return zero for null pointers. */
    if (array == NULL)
      return 0;

    /* Iterate through the array and accumulate the sum. */
    for (i = 0; i < size; i++)
      {
        sum += array[i];
      }

    return sum;
  }
```

**Particularit√©s** :
- Type de retour sur ligne s√©par√©e
- Espaces autour des parenth√®ses de fonction
- Tr√®s comment√©

**Opinion personnelle** : Peu utilis√© en dehors des projets GNU.

---

### Style 3 : K&R (Kernighan & Ritchie)

**Le style "original" du C**, du livre "The C Programming Language".

**Caract√©ristiques** :
```c
// ‚úÖ 4 espaces ou tabs
// ‚úÖ Accolades K&R (fonction sur nouvelle ligne, reste sur m√™me ligne)
// ‚úÖ snake_case ou camelCase
// ‚úÖ Compact et lisible

int calculate_sum(int *array, int size)
{
    int sum = 0;
    for (int i = 0; i < size; i++) {
        sum += array[i];
    }
    return sum;
}
```

**Utilis√© par** : Git, Redis, beaucoup de projets modernes.

**Avantages** :
- Compact
- Facile √† lire
- Bon compromis

---

### Style 4 : Google C++ Style Guide (adapt√© au C)

**Document** : https://google.github.io/styleguide/cppguide.html

**Caract√©ristiques** :
```c
// ‚úÖ 2 espaces pour indentation
// ‚úÖ Accolades K&R (ouvrante sur m√™me ligne, y compris fonctions)
// ‚úÖ PascalCase pour fonctions, snake_case pour variables
// ‚úÖ kConstantCase pour constantes
// ‚úÖ Max 80 caract√®res

int CalculateSum(int* array, int size) {
  int sum = 0;
  for (int i = 0; i < size; i++) {
    sum += array[i];
  }
  return sum;
}
```

**Utilis√© par** : Projets Google (Chromium, etc.)

---

### Comparaison visuelle

Le **m√™me code** dans chaque style :

**Linux Kernel** :
```c
int foo(void)
{
        if (condition) {
                do_work();
        }
}
```

**GNU** :
```c
int  
foo (void)  
  {
    if (condition)
      {
        do_work ();
      }
  }
```

**K&R** :
```c
int foo(void)
{
    if (condition) {
        do_work();
    }
}
```

---

## üõ†Ô∏è Configurer vos outils

### 1. clang-format (Automatisation)

**Le meilleur outil** pour formater automatiquement votre code.

#### **Installation**
```bash
# Ubuntu/Debian
sudo apt install clang-format

# macOS
brew install clang-format

# V√©rifier l'installation
clang-format --version
```

---

#### **Utilisation basique**

```bash
# Formatter un fichier (affiche sur stdout)
clang-format myfile.c

# Formatter en place (modifie le fichier)
clang-format -i myfile.c

# Formatter plusieurs fichiers
clang-format -i src/*.c src/*.h
```

---

#### **Utiliser le .clang-format du projet**

Si le projet a un `.clang-format`, il sera utilis√© automatiquement :

```bash
cd /path/to/project  
clang-format -i myfile.c  # Utilise automatiquement .clang-format  
```

---

#### **Cr√©er votre .clang-format**

Si le projet n'a pas de `.clang-format`, cr√©ez-en un bas√© sur le style observ√© :

```bash
# G√©n√©rer un fichier bas√© sur un style pr√©d√©fini
clang-format -style=llvm -dump-config > .clang-format

# Styles disponibles : LLVM, Google, Chromium, Mozilla, WebKit, GNU
clang-format -style=google -dump-config > .clang-format
```

**Exemple de .clang-format** :
```yaml
# Based on Linux Kernel style
BasedOnStyle: LLVM  
IndentWidth: 8  
UseTab: ForIndentation  
BreakBeforeBraces: Linux  
AllowShortIfStatementsOnASingleLine: false  
IndentCaseLabels: false  
ColumnLimit: 80  
```

---

#### **Int√©gration dans l'√©diteur**

**VS Code** :
```json
// settings.json
{
    "editor.formatOnSave": true,
    "C_Cpp.clang_format_path": "/usr/bin/clang-format",
    "C_Cpp.clang_format_style": "file"
}
```

**Vim** :
```vim
" .vimrc
" Formatter avec F7
map <F7> :py3f /usr/share/clang/clang-format.py<cr>
```

**Emacs** :
```elisp
;; .emacs
(load "/usr/share/emacs/site-lisp/clang-format.el")
(global-set-key [f7] 'clang-format-region)
```

---

### 2. EditorConfig

**Fichier .editorconfig** : Configurations multi-√©diteur.

**Exemple** :
```ini
# .editorconfig
root = true

[*]
end_of_line = lf  
insert_final_newline = true  
charset = utf-8  

[*.c]
indent_style = tab  
indent_size = 8  
trim_trailing_whitespace = true  

[*.h]
indent_style = tab  
indent_size = 8  
```

**√âditeurs support√©s** : VS Code, Vim, Emacs, Sublime, IntelliJ, etc.

---

### 3. Configuration de l'√©diteur

#### **VS Code**

```json
// .vscode/settings.json
{
    "editor.tabSize": 8,
    "editor.insertSpaces": false,  // Use tabs
    "editor.detectIndentation": false,
    "editor.rulers": [80],
    "files.trimTrailingWhitespace": true,
    "files.insertFinalNewline": true
}
```

---

#### **Vim**

```vim
" .vimrc ou .vim/ftplugin/c.vim
set tabstop=8  
set shiftwidth=8  
set noexpandtab  
set textwidth=80  
set colorcolumn=80  
```

---

#### **Emacs**

```elisp
;; .emacs
(setq-default c-basic-offset 8
              tab-width 8
              indent-tabs-mode t)
(setq c-default-style "linux")
```

---

## üéØ Comment adapter votre code

### Processus en 5 √©tapes

#### **√âtape 1 : Identifier le style du projet**

```bash
# 1. Chercher la documentation
cat CONTRIBUTING.md  
cat CODING_STYLE  
ls -la .clang-format  

# 2. Observer le code existant
head -100 src/main.c
```

Notez :
- Indentation : espaces ou tabs ? Combien ?
- Accolades : K&R, Allman, GNU ?
- Nommage : snake_case, camelCase ?
- Ligne max : 80 ou 100 ?
- Commentaires : // ou /* */ ?

---

#### **√âtape 2 : Configurer votre √©diteur**

Cr√©ez une configuration locale pour ce projet :

```bash
# VS Code
mkdir -p .vscode  
cat > .vscode/settings.json << EOF  
{
    "editor.tabSize": 8,
    "editor.insertSpaces": false,
    "editor.rulers": [80]
}
EOF

# Vim
cat > .vim/ftplugin/c.vim << EOF  
set tabstop=8  
set shiftwidth=8  
set noexpandtab  
EOF  
```

---

#### **√âtape 3 : √âcrire votre code**

√âcrivez votre code **normalement**, puis formatez-le.

```c
// Votre code (style personnel)
int foo(void){  
int x=10;  
if(x>5){  
return x*2;  
}
return 0;
}
```

---

#### **√âtape 4 : Formatter avec clang-format**

```bash
clang-format -i myfile.c
```

**R√©sultat** (style du projet appliqu√©) :
```c
int foo(void)
{
        int x = 10;
        if (x > 5) {
                return x * 2;
        }
        return 0;
}
```

---

#### **√âtape 5 : V√©rifier avec git diff**

```bash
git diff myfile.c
```

Assurez-vous que **seules vos modifications logiques** apparaissent, pas des changements de formatage sur tout le fichier.

**‚ùå MAUVAIS** : Vous avez reformat√© 500 lignes du fichier  
**‚úÖ BON** : Seules vos 10 lignes ajout√©es apparaissent  

---

## ‚ö†Ô∏è Pi√®ges √† √©viter

### Pi√®ge 1 : Reformatter du code existant

**‚ùå NE FAITES PAS √áA** :
```bash
# MAUVAIS : Reformatter tout le fichier
clang-format -i entire_file.c  
git add entire_file.c  
git commit -m "Fix bug in parse()"  
```

**Probl√®me** : Votre PR montre 500+ lignes chang√©es, mais seulement 5 lignes sont votre contribution r√©elle. Review impossible.

**‚úÖ BON** :
```bash
# Modifier uniquement ce que vous avez ajout√©/chang√©
# Formatter seulement vos nouvelles lignes
```

**Si vous voulez reformatter** : Faites-le dans un commit/PR **s√©par√©** d√©di√© au reformatage.

---

### Pi√®ge 2 : Ignorer les espaces de fin

Les **trailing whitespaces** (espaces en fin de ligne) sont souvent interdits.

**D√©tecter** :
```bash
git diff --check

# Si √ßa affiche quelque chose, vous avez des trailing whitespaces
```

**Corriger** :
```bash
# Vim
:%s/\s\+$//e

# sed
sed -i 's/[[:space:]]*$//' myfile.c

# VS Code : files.trimTrailingWhitespace: true
```

---

### Pi√®ge 3 : Oublier la newline finale

Beaucoup de projets exigent une **ligne vide √† la fin du fichier**.

**V√©rifier** :
```bash
# Doit afficher une ligne vide √† la fin
tail -1 myfile.c | od -c
```

**Corriger** :
```bash
# Ajouter une newline si manquante
echo >> myfile.c

# VS Code : files.insertFinalNewline: true
```

---

### Pi√®ge 4 : M√©langer tabs et espaces

**Pire cauchemar** : Un fichier avec tabs ET espaces.

**D√©tecter** :
```bash
# Afficher les caract√®res invisibles
cat -A myfile.c | grep -E "^I.*    |    .*^I"

# Ou dans vim
:set list
```

**Corriger** (si le projet utilise des tabs) :
```bash
# Convertir les espaces d'indentation en tabs
unexpand -t 8 --first-only myfile.c > temp && mv temp myfile.c
```

---

### Pi√®ge 5 : Lignes trop longues

Si le projet limite √† 80 caract√®res, respectez-le.

**D√©tecter** :
```bash
# Lignes > 80 caract√®res
awk 'length > 80 { print NR, length, $0 }' myfile.c
```

**Corriger** : Coupez les longues lignes.

**Avant** :
```c
int result = calculate_very_long_function_name(argument1, argument2, argument3, argument4);
```

**Apr√®s** :
```c
int result = calculate_very_long_function_name(argument1,
                                                argument2,
                                                argument3,
                                                argument4);
```

Ou :
```c
int result = calculate_very_long_function_name(
    argument1, argument2, argument3, argument4
);
```

---

## üìù Checklist avant de soumettre

Avant de faire votre Pull Request, v√©rifiez :

```markdown
## Style de code - Checklist

### Formatage
- [ ] Indentation correcte (espaces ou tabs selon le projet)
- [ ] Accolades au bon endroit
- [ ] Lignes < 80 caract√®res (ou limite du projet)
- [ ] Pas de trailing whitespaces
- [ ] Newline finale pr√©sente
- [ ] Pas de m√©lange tabs/espaces

### Nommage
- [ ] Fonctions en snake_case (ou style du projet)
- [ ] Variables en snake_case
- [ ] Constantes en SCREAMING_SNAKE_CASE
- [ ] Types coh√©rents avec le projet (suffixe _t ou non)

### Commentaires
- [ ] Style de commentaire correct (// ou /* */)
- [ ] Commentaires sur les parties complexes
- [ ] Pas de commentaires √©vidents ("// Increment i")
- [ ] Documentation des fonctions si requis

### Organisation
- [ ] Includes dans le bon ordre
- [ ] D√©clarations de variables appropri√©es (C89 vs C99)
- [ ] Pas de code mort (comment√©)
- [ ] Respect des conventions du fichier modifi√©

### V√©rifications automatiques
- [ ] clang-format ex√©cut√© (si .clang-format existe)
- [ ] git diff --check passe
- [ ] Compilation sans warnings avec -Wall -Wextra
- [ ] Tests passent
```

---

## üéì Exemples de corrections de style

### Exemple 1 : Correction pour Linux Kernel

**Votre code initial** :
```c
int parseInput(char* input, int size) {
  int result=0;
  for(int i=0;i<size;i++)
  {
    if(input[i]=='x'){
      result++;
    }
  }
  return result;
}
```

**Apr√®s correction (style Linux Kernel)** :
```c
int parse_input(char *input, int size)
{
        int result = 0;
        int i;

        for (i = 0; i < size; i++) {
                if (input[i] == 'x')
                        result++;
        }

        return result;
}
```

**Changements** :
- ‚úÖ `parseInput` ‚Üí `parse_input` (snake_case)
- ‚úÖ `char*` ‚Üí `char *` (espace avant *)
- ‚úÖ Tabs de largeur 8
- ‚úÖ Accolades K&R
- ‚úÖ Espaces autour des op√©rateurs
- ‚úÖ D√©claration de `i` au d√©but (style C89)

---

### Exemple 2 : Correction pour Git

**Votre code initial** :
```c
int CalculateHash(const char* str){
  unsigned long hash = 5381;
  int c;
  while(c=*str++)
    hash = ((hash << 5) + hash) + c;
  return hash;
}
```

**Apr√®s correction (style Git)** :
```c
int calculate_hash(const char *str)
{
        unsigned long hash = 5381;
        int c;

        while ((c = *str++))
                hash = ((hash << 5) + hash) + c;

        return hash;
}
```

**Changements** :
- ‚úÖ `CalculateHash` ‚Üí `calculate_hash`
- ‚úÖ Accolades sur nouvelles lignes
- ‚úÖ Parenth√®ses autour de l'assignation dans la condition
- ‚úÖ Indentation coh√©rente

---

### Exemple 3 : Correction pour Redis

**Votre code initial** :
```c
void processCommand(client *c){
  if(!c) return;

  if(c->argc<2){
    addReplyError(c,"Wrong number of arguments");
    return;
  }

  execute(c);
}
```

**Apr√®s correction (style Redis)** :
```c
void processCommand(client *c) {
    if (c == NULL) return;

    if (c->argc < 2) {
        addReplyError(c, "Wrong number of arguments");
        return;
    }

    execute(c);
}
```

**Changements** :
- ‚úÖ Accolade ouvrante sur m√™me ligne (K&R)
- ‚úÖ 4 espaces d'indentation
- ‚úÖ `!c` ‚Üí `c == NULL` (plus explicite)
- ‚úÖ Espaces autour des op√©rateurs
- ‚úÖ Espace apr√®s les virgules

---

## üîó Ressources pour approfondir

### Guides de style officiels

- **Linux Kernel** : https://www.kernel.org/doc/html/latest/process/coding-style.html
- **GNU** : https://www.gnu.org/prep/standards/html_node/Writing-C.html
- **Google** : https://google.github.io/styleguide/cppguide.html
- **Git** : https://github.com/git/git/blob/master/Documentation/CodingGuidelines

### Outils

- **clang-format** : https://clang.llvm.org/docs/ClangFormat.html
- **EditorConfig** : https://editorconfig.org/
- **uncrustify** : http://uncrustify.sourceforge.net/ (alternative √† clang-format)

### Articles

- **"Why Coding Style Matters"** : https://www.kernel.org/doc/html/latest/process/coding-style.html#why-coding-style-matters
- **"Linux kernel coding style"** par Linus Torvalds

---

## üí° Conseils finaux

### 1. "When in Rome, do as the Romans do"

**Le style du projet > votre pr√©f√©rence personnelle**

M√™me si vous d√©testez les tabs de largeur 8, si le projet les utilise, vous devez les utiliser.

---

### 2. Automatisez autant que possible

```bash
# Hook Git pre-commit pour formatter automatiquement
cat > .git/hooks/pre-commit << 'EOF'
#!/bin/bash
files=$(git diff --cached --name-only --diff-filter=ACM | grep '\.c$\|\.h$')  
if [ -n "$files" ]; then  
    clang-format -i $files
    git add $files
fi  
EOF  
chmod +x .git/hooks/pre-commit  
```

---

### 3. Posez des questions

Si vous n'√™tes pas s√ªr du style √† utiliser :

```markdown
Hi! I'm working on fixing #123. I noticed that some files use tabs  
and others use spaces. Which style should I follow for my changes?  
```

**Mieux vaut demander** que de faire reformatter par le reviewer.

---

### 4. Commencez petit

Pour votre premi√®re contribution, **ne vous inqui√©tez pas trop du style**.

1. ‚úÖ √âcrivez du code qui fonctionne
2. ‚úÖ Formatez avec clang-format si disponible
3. ‚úÖ Le reviewer corrigera les d√©tails de style
4. ‚úÖ Apprenez de ses commentaires

**Avec le temps**, le style deviendra naturel.

---

### 5. Cr√©ez un template

Gardez un fichier template pour chaque style que vous utilisez :

```bash
~/.code-templates/
    ‚îú‚îÄ‚îÄ linux-kernel-template.c
    ‚îú‚îÄ‚îÄ git-template.c
    ‚îú‚îÄ‚îÄ redis-template.c
    ‚îî‚îÄ‚îÄ my-projects-template.c
```

Copiez le template appropri√© quand vous commencez un nouveau fichier.

---

## üéØ R√©capitulatif

**Points cl√©s √† retenir** :

1. ‚úÖ **Le style du projet est sacr√©** - Respectez-le m√™me si ce n'est pas votre pr√©f√©rence
2. ‚úÖ **Cherchez la documentation** - CONTRIBUTING.md, CODING_STYLE, .clang-format
3. ‚úÖ **Observez le code existant** - Imitez ce que vous voyez
4. ‚úÖ **Utilisez des outils** - clang-format, EditorConfig, git diff --check
5. ‚úÖ **Ne reformattez pas tout** - Seulement vos modifications
6. ‚úÖ **V√©rifiez avant de soumettre** - Utilisez la checklist
7. ‚úÖ **Demandez en cas de doute** - Les mainteneurs pr√©f√®rent guider que rejeter

**La formule du succ√®s** :

```
Code bien format√© =
    Style du projet respect√©
    + Outils automatis√©s
    + Attention aux d√©tails
    - Changements de formatage non n√©cessaires
```

---

## üöÄ Prochaines √©tapes

Maintenant que vous savez comment respecter le style de code :

- **Section 33.5.3** : Soumettre une Pull Request de qualit√©
- **Section 33.5.1** : Retour sur comment trouver un bon premier issue

**Vous √™tes pr√™t !** Le style de code n'est plus un obstacle. Concentrez-vous sur la **qualit√© de votre contribution**, le formatage suivra naturellement. üéØ

---

**üí° Conseil final** : Cr√©ez un script `check-style.sh` pour vos projets :

```bash
#!/bin/bash
# check-style.sh

echo "üîç V√©rification du style..."

# Trailing whitespaces
git diff --check  
if [ $? -ne 0 ]; then  
    echo "‚ùå Trailing whitespaces d√©tect√©s"
    exit 1
fi

# clang-format
if [ -f .clang-format ]; then
    clang-format --dry-run --Werror src/*.c
    if [ $? -ne 0 ]; then
        echo "‚ùå Formatage incorrect"
        exit 1
    fi
fi

echo "‚úÖ Style OK"
```

Lancez-le avant chaque commit ! üöÄ

‚è≠Ô∏è [Soumettre une Pull Request](/33-analyse-code-opensource/05.3-soumettre-pr.md)
