ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 15.3.2 Debugging Distant

## Introduction

Le **debugging distant** (remote debugging) permet de dÃ©boguer un programme qui s'exÃ©cute sur une machine diffÃ©rente de celle oÃ¹ vous utilisez GDB. C'est comme contrÃ´ler un robot Ã  distance : votre cerveau (GDB) est sur votre ordinateur, mais le corps (le programme) est ailleurs.

### Pourquoi utiliser le debugging distant ?

Plusieurs situations nÃ©cessitent cette approche :

1. **Serveurs de production** : Vous ne pouvez pas installer un environnement de dÃ©veloppement complet
2. **SystÃ¨mes embarquÃ©s** : Raspberry Pi, Arduino, routeurs avec peu de ressources
3. **Conteneurs Docker** : DÃ©boguer une application dans un conteneur sans l'alourdir
4. **Machines virtuelles** : VM de test ou d'intÃ©gration
5. **ProblÃ¨mes spÃ©cifiques Ã  l'environnement** : Un bug qui n'apparaÃ®t que sur certaines machines

### Avantages

- âœ… Pas besoin d'installer GDB complet sur la machine cible (juste `gdbserver`)
- âœ… Utiliser votre environnement de dÃ©veloppement confortable (IDE, extensions)
- âœ… DÃ©boguer sur des systÃ¨mes avec peu de ressources
- âœ… Analyser des problÃ¨mes en production sans perturber le service

---

## Architecture du debugging distant

### Le modÃ¨le Client-Serveur

Le debugging distant utilise une architecture en deux parties :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Machine Locale     â”‚                   â”‚  Machine Distante    â”‚
â”‚  (DÃ©veloppeur)      â”‚                   â”‚  (Cible)             â”‚
â”‚                     â”‚                   â”‚                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   RÃ©seau/TCP      â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚     GDB      â”‚â—„â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â–ºâ”‚  gdbserver    â”‚   â”‚
â”‚  â”‚   (client)   â”‚   â”‚   Port 1234       â”‚  â”‚  (serveur)    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚                   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚         â”‚           â”‚                   â”‚          â”‚           â”‚
â”‚    Interface        â”‚                   â”‚     â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”     â”‚
â”‚    utilisateur      â”‚                   â”‚     â”‚Programme â”‚     â”‚
â”‚    (commandes)      â”‚                   â”‚     â”‚  cible   â”‚     â”‚
â”‚                     â”‚                   â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Composants :**
- **GDB (client)** : Sur votre machine locale, interface complÃ¨te avec toutes les fonctionnalitÃ©s
- **gdbserver (serveur)** : Sur la machine distante, programme lÃ©ger qui contrÃ´le le processus Ã  dÃ©boguer
- **Connexion rÃ©seau** : Communication via TCP/IP (gÃ©nÃ©ralement sur un port comme 1234)

---

## Installation et Configuration

### Sur la machine distante (cible)

#### Installation de gdbserver

```bash
# Ubuntu/Debian
sudo apt-get update  
sudo apt-get install gdbserver  

# Fedora/CentOS/RHEL
sudo dnf install gdb-gdbserver

# VÃ©rification
gdbserver --version
```

### Sur la machine locale (dÃ©veloppeur)

Vous avez besoin de GDB complet (normalement dÃ©jÃ  installÃ©) :

```bash
# VÃ©rification
gdb --version

# Installation si nÃ©cessaire (Ubuntu/Debian)
sudo apt-get install gdb
```

### Compilation du programme

**Important** : Le programme doit Ãªtre compilÃ© avec les symboles de dÃ©bogage (`-g`) :

```bash
gcc -g -o mon_programme mon_programme.c
```

---

## Utilisation basique : Premier debugging distant

### Ã‰tape 1 : CrÃ©er un programme de test

Sur la machine distante, crÃ©ez ce programme simple :

```c
// hello_remote.c
#include <stdio.h>
#include <unistd.h>

void fonction_calcul(int a, int b) {
    int resultat = a + b;
    printf("RÃ©sultat : %d\n", resultat);
}

int main() {
    printf("DÃ©but du programme distant\n");

    for (int i = 0; i < 5; i++) {
        printf("ItÃ©ration %d\n", i);
        fonction_calcul(i, i * 2);
        sleep(2);
    }

    printf("Fin du programme\n");
    return 0;
}
```

Compilez-le :

```bash
gcc -g -o hello_remote hello_remote.c
```

### Ã‰tape 2 : Lancer gdbserver sur la machine distante

Il existe deux modes de lancement :

#### Mode 1 : Lancer le programme directement

```bash
gdbserver :1234 ./hello_remote
```

Signification :
- `:1234` : Ã‰couter sur le port 1234 (toutes les interfaces rÃ©seau)
- `./hello_remote` : Le programme Ã  dÃ©boguer

**Alternative** : SpÃ©cifier une interface prÃ©cise :

```bash
gdbserver 192.168.1.100:1234 ./hello_remote
```

**Sortie typique :**
```
Process ./hello_remote created; pid = 12345  
Listening on port 1234  
```

Le programme est en pause, en attente de connexion GDB.

#### Mode 2 : Attacher Ã  un processus existant

Si le programme tourne dÃ©jÃ  :

```bash
# Trouver le PID
ps aux | grep mon_programme

# Attacher gdbserver
gdbserver :1234 --attach <PID>
```

### Ã‰tape 3 : Se connecter depuis GDB (machine locale)

Sur votre machine de dÃ©veloppement :

```bash
gdb ./hello_remote
```

Dans GDB, connectez-vous au serveur distant :

```gdb
(gdb) target remote 192.168.1.100:1234
```

Remplacez `192.168.1.100` par l'IP de la machine distante.

**Sortie :**
```
Remote debugging using 192.168.1.100:1234  
Reading symbols from ./hello_remote...  
```

Vous Ãªtes maintenant connectÃ© ! Le programme est en pause au point d'entrÃ©e.

### Ã‰tape 4 : DÃ©boguer normalement

Utilisez les commandes GDB habituelles :

```gdb
(gdb) break main                 # Point d'arrÃªt dans main
(gdb) break fonction_calcul      # Point d'arrÃªt dans fonction_calcul
(gdb) continue                   # Reprendre l'exÃ©cution
(gdb) next                       # Instruction suivante
(gdb) print i                    # Afficher la variable i
(gdb) backtrace                  # Pile d'appels
```

### Ã‰tape 5 : Terminer la session

```gdb
(gdb) quit
```

Sur la machine distante, gdbserver se termine automatiquement.

---

## Debugging distant via SSH (SÃ©curisÃ©)

Exposer gdbserver directement sur Internet est **dangereux**. La meilleure pratique est d'utiliser un **tunnel SSH**.

### Principe du tunnel SSH

Le tunnel SSH crÃ©e un "tuyau" chiffrÃ© entre votre machine et le serveur distant :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     SSH Tunnel     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Votre PC    â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚  Serveur distantâ”‚
â”‚ localhost:   â”‚  (chiffrÃ©)         â”‚  localhost:1234 â”‚
â”‚ 1234         â”‚                    â”‚  gdbserver      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Vous vous connectez Ã  `localhost:1234` sur votre machine, mais le trafic est redirigÃ© vers le serveur.

### Configuration du tunnel SSH

#### Ã‰tape 1 : CrÃ©er le tunnel

Sur votre machine locale :

```bash
ssh -L 1234:localhost:1234 user@serveur-distant.com
```

Explication :
- `-L 1234:localhost:1234` : Redirige le port local 1234 vers le port 1234 du serveur
- `user@serveur-distant.com` : Vos identifiants SSH

Gardez cette session SSH ouverte.

#### Ã‰tape 2 : Lancer gdbserver sur le serveur

Dans la session SSH, sur le serveur :

```bash
gdbserver localhost:1234 ./mon_programme
```

âš ï¸ **Important** : Utilisez `localhost:1234` (pas `:1234` ou une IP publique) pour limiter l'accÃ¨s.

#### Ã‰tape 3 : Se connecter avec GDB

Dans un **autre terminal** sur votre machine locale :

```bash
gdb ./mon_programme
```

Puis dans GDB :

```gdb
(gdb) target remote localhost:1234
```

Vous Ãªtes maintenant connectÃ© de maniÃ¨re sÃ©curisÃ©e !

### Tunnel SSH permanent

Pour Ã©viter de ressaisir la commande, crÃ©ez un alias dans `~/.ssh/config` :

```
# ~/.ssh/config
Host debug-server
    HostName serveur-distant.com
    User votre_user
    LocalForward 1234 localhost:1234
```

Ensuite, lancez simplement :

```bash
ssh debug-server
```

---

## Cas d'usage avancÃ©s

### 1. Debugging dans un conteneur Docker

#### MÃ©thode A : Avec gdbserver dans le conteneur

**Dockerfile :**

```dockerfile
FROM ubuntu:22.04

RUN apt-get update && apt-get install -y \
    gdbserver \
    gcc

WORKDIR /app  
COPY mon_programme.c .  
RUN gcc -g -o mon_programme mon_programme.c  

EXPOSE 1234

CMD ["gdbserver", ":1234", "./mon_programme"]
```

**Lancement :**

```bash
docker build -t mon-app-debug .  
docker run -p 1234:1234 mon-app-debug  
```

**Connexion depuis l'hÃ´te :**

```bash
gdb ./mon_programme
(gdb) target remote localhost:1234
```

#### MÃ©thode B : Attacher Ã  un conteneur existant

```bash
# Copier gdbserver dans le conteneur
docker cp /usr/bin/gdbserver mon_conteneur:/usr/bin/

# Trouver le PID du processus dans le conteneur
docker exec mon_conteneur ps aux

# Lancer gdbserver
docker exec -it mon_conteneur gdbserver :1234 --attach <PID>

# Se connecter depuis l'hÃ´te
gdb ./mon_programme
(gdb) target remote localhost:1234
```

### 2. Debugging sur Raspberry Pi ou systÃ¨me embarquÃ©

Le Raspberry Pi a peu de ressources, idÃ©al pour le debugging distant.

**Sur le Raspberry Pi :**

```bash
# Installation
sudo apt-get install gdbserver

# Compilation croisÃ©e (ou directement sur le Pi)
gcc -g -o app_embedded app.c

# Lancement
gdbserver :2345 ./app_embedded
```

**Sur votre PC de dÃ©veloppement :**

```bash
# Cross-compilation (si nÃ©cessaire)
arm-linux-gnueabihf-gcc -g -o app_embedded app.c

# Debugging
gdb ./app_embedded
(gdb) target remote 192.168.1.50:2345
```

### 3. Debugging multi-processus

Pour dÃ©boguer un programme qui fait des `fork()` :

**Sur la machine distante :**

```bash
gdbserver --multi :1234 ./mon_programme
```

Le mode `--multi` permet de suivre les processus enfants.

**Dans GDB :**

```gdb
(gdb) target extended-remote 192.168.1.100:1234
(gdb) set detach-on-fork off           # Ne pas dÃ©tacher les enfants
(gdb) set follow-fork-mode child       # Ou 'parent'
(gdb) run
```

Vous pouvez basculer entre processus :

```gdb
(gdb) info inferiors                    # Liste des processus
(gdb) inferior 2                        # Basculer sur le processus 2
```

### 4. Debugging multi-thread

Les threads sont gÃ©rÃ©s automatiquement :

```gdb
(gdb) info threads                      # Lister tous les threads
(gdb) thread 3                          # Basculer sur le thread 3
(gdb) thread apply all backtrace       # Backtrace de tous les threads
```

---

## Commandes spÃ©cifiques au debugging distant

### Connexion et dÃ©connexion

```gdb
# Connexion standard
(gdb) target remote <IP>:<PORT>

# Connexion extended (multi-processus)
(gdb) target extended-remote <IP>:<PORT>

# DÃ©connexion sans tuer le processus
(gdb) detach

# DÃ©connexion et fermeture
(gdb) disconnect
```

### Transfert de fichiers

Parfois, GDB a besoin de fichiers (bibliothÃ¨ques, symboles) de la machine distante :

```gdb
# Configurer le chemin des bibliothÃ¨ques distantes
(gdb) set sysroot /chemin/local/vers/sysroot

# TÃ©lÃ©charger automatiquement les bibliothÃ¨ques
(gdb) set sysroot target:

# DÃ©sactiver le tÃ©lÃ©chargement
(gdb) set sysroot
```

### Gestion des chemins

Si les chemins diffÃ¨rent entre les machines :

```gdb
# Remapper les chemins sources
(gdb) set substitute-path /chemin/distant /chemin/local
```

Exemple :

```gdb
(gdb) set substitute-path /home/server/app /home/dev/mon_projet
```

---

## Workflow typique en dÃ©veloppement

### ScÃ©nario : Bug en environnement de test

**ProblÃ¨me :** Votre application fonctionne en local mais crash sur le serveur de test.

**Solution :**

1. **PrÃ©parer l'environnement de test**

```bash
# SSH sur le serveur de test
ssh test-server

# S'assurer que le programme est compilÃ© avec -g
gcc -g -o myapp myapp.c

# Lancer gdbserver
gdbserver localhost:1234 ./myapp
```

2. **CrÃ©er un tunnel SSH depuis votre poste**

```bash
# Nouveau terminal local
ssh -L 1234:localhost:1234 test-server
```

3. **DÃ©boguer depuis votre IDE (VS Code, CLion, etc.)**

Dans VS Code, crÃ©ez une configuration de lancement (`.vscode/launch.json`) :

```json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Debug Remote",
            "type": "cppdbg",
            "request": "launch",
            "program": "${workspaceFolder}/myapp",
            "miDebuggerServerAddress": "localhost:1234",
            "miDebuggerPath": "/usr/bin/gdb",
            "cwd": "${workspaceFolder}",
            "setupCommands": [
                {
                    "text": "set substitute-path /remote/path /local/path"
                }
            ]
        }
    ]
}
```

4. **Lancer le debugging** : F5 dans VS Code

Vous pouvez maintenant utiliser l'interface graphique pour dÃ©boguer !

---

## Troubleshooting : ProblÃ¨mes courants

### ProblÃ¨me 1 : "Connection refused"

**SymptÃ´me :**
```
(gdb) target remote 192.168.1.100:1234
192.168.1.100:1234: Connection refused.
```

**Causes possibles :**
- gdbserver n'est pas lancÃ© sur la machine distante
- Firewall bloque le port
- Mauvaise adresse IP ou port

**Solutions :**

```bash
# VÃ©rifier que gdbserver Ã©coute
netstat -tulpn | grep 1234

# Tester la connectivitÃ© rÃ©seau
telnet 192.168.1.100 1234

# Ouvrir le firewall (Ubuntu)
sudo ufw allow 1234/tcp

# Ouvrir le firewall (CentOS/Fedora)
sudo firewall-cmd --add-port=1234/tcp --permanent  
sudo firewall-cmd --reload  
```

### ProblÃ¨me 2 : "Remote 'g' packet reply is too long"

**SymptÃ´me :**
```
Remote 'g' packet reply is too long
```

**Cause :** IncompatibilitÃ© d'architecture (32-bit vs 64-bit, ou ARM vs x86).

**Solution :**

Assurez-vous que :
1. Le binaire local et distant sont identiques (mÃªme compilation)
2. L'architecture correspond

```bash
# VÃ©rifier l'architecture du binaire
file ./mon_programme

# Compiler pour l'architecture correcte
gcc -m32 -g -o mon_programme mon_programme.c  # Pour 32-bit
```

### ProblÃ¨me 3 : Symboles de dÃ©bogage manquants

**SymptÃ´me :**
```
(gdb) break main
No symbol table is loaded.
```

**Cause :** Programme compilÃ© sans `-g` ou symboles strippÃ©s.

**Solution :**

```bash
# Recompiler avec symboles
gcc -g -o mon_programme mon_programme.c

# VÃ©rifier la prÃ©sence des symboles
file ./mon_programme
# Doit afficher "not stripped"

# Si stripped, impossible de rÃ©cupÃ©rer les symboles
```

### ProblÃ¨me 4 : "Cannot access memory at address 0x..."

**Cause :** Vous essayez d'accÃ©der Ã  de la mÃ©moire invalide (mÃªme comportement qu'en local).

**Solution :** VÃ©rifier vos pointeurs et allocation mÃ©moire.

### ProblÃ¨me 5 : Latence rÃ©seau importante

**SymptÃ´me :** Le debugging est trÃ¨s lent.

**Solutions :**

```gdb
# DÃ©sactiver la pagination
(gdb) set pagination off

# Limiter les tÃ©lÃ©chargements de symboles
(gdb) set auto-solib-add off
```

---

## SÃ©curitÃ© et bonnes pratiques

### 1. Ne jamais exposer gdbserver publiquement

âŒ **Dangereux :**
```bash
gdbserver 0.0.0.0:1234 ./programme
```

Cela expose gdbserver sur toutes les interfaces, accessible depuis Internet.

âœ… **SÃ©curisÃ© :**
```bash
# Ã‰couter uniquement sur localhost
gdbserver localhost:1234 ./programme

# Ou utiliser un tunnel SSH
ssh -L 1234:localhost:1234 serveur
```

### 2. Utiliser un port non standard

Au lieu de 1234, utilisez un port alÃ©atoire (entre 10000 et 65535) :

```bash
gdbserver :54321 ./programme
```

### 3. Restreindre l'accÃ¨s par firewall

```bash
# Autoriser seulement une IP spÃ©cifique
sudo ufw allow from 192.168.1.50 to any port 1234
```

### 4. Limiter la durÃ©e de la session

gdbserver peut donner un contrÃ´le complet de la machine. Tuez-le aprÃ¨s utilisation :

```bash
# Timeout automatique (20 minutes)
timeout 1200 gdbserver :1234 ./programme
```

### 5. Ne jamais dÃ©boguer en production sans prÃ©caution

Le debugging arrÃªte le programme. Si vous devez absolument dÃ©boguer en production :
- Utilisez des breakpoints conditionnels
- Limitez la durÃ©e
- Informez l'Ã©quipe
- PrÃ©parez un rollback

---

## Alternatives et outils complÃ©mentaires

### 1. rr (Record and Replay)

Pour les bugs difficiles Ã  reproduire, `rr` enregistre l'exÃ©cution entiÃ¨re puis permet de la rejouer :

```bash
# Sur la machine distante
rr record ./mon_programme

# Copier la trace localement
scp -r ~/.local/share/rr/traces/mon_programme-X ./

# DÃ©boguer localement
rr replay ./mon_programme-X
```

### 2. LLDB (Alternative Ã  GDB)

LLDB a aussi un mode distant :

```bash
# Sur la machine distante
lldb-server platform --listen "*:1234"

# Localement
lldb
(lldb) platform select remote-linux
(lldb) platform connect connect://192.168.1.100:1234
```

### 3. Debugging via VS Code Remote

L'extension "Remote - SSH" de VS Code permet de dÃ©boguer directement via SSH sans gdbserver :

```json
// .vscode/launch.json
{
    "type": "cppdbg",
    "request": "launch",
    "program": "/remote/path/to/program",
    "cwd": "/remote/path",
    "MIMode": "gdb",
    "pipeTransport": {
        "pipeProgram": "ssh",
        "pipeArgs": ["-T", "user@remote-server"],
        "debuggerPath": "/usr/bin/gdb"
    }
}
```

---

## RÃ©sumÃ© des commandes essentielles

### Configuration initiale

```bash
# Installation gdbserver (machine distante)
sudo apt-get install gdbserver

# Compilation avec symboles
gcc -g -o programme programme.c
```

### Lancement de gdbserver

```bash
# Mode standard
gdbserver :1234 ./programme

# Attacher Ã  un processus existant
gdbserver :1234 --attach <PID>

# Mode multi-processus
gdbserver --multi :1234 ./programme
```

### Connexion GDB

```gdb
# Connexion simple
(gdb) target remote IP:PORT

# Connexion extended
(gdb) target extended-remote IP:PORT

# Via tunnel SSH
(gdb) target remote localhost:1234
```

### Tunnel SSH

```bash
# CrÃ©er le tunnel
ssh -L 1234:localhost:1234 user@serveur

# Avec alias SSH config
Host debug-server
    LocalForward 1234 localhost:1234
```

---

## Conclusion

Le debugging distant est une compÃ©tence **essentielle** pour tout dÃ©veloppeur systÃ¨me, DevOps ou embarquÃ©. Il permet de :

- âœ… DÃ©boguer sur des serveurs de production (avec prÃ©caution)
- âœ… Analyser des bugs spÃ©cifiques Ã  certains environnements
- âœ… Travailler sur des systÃ¨mes avec peu de ressources
- âœ… Utiliser votre environnement de dÃ©veloppement confortable

**Points clÃ©s Ã  retenir :**

1. **Architecture client-serveur** : GDB (local) â†” gdbserver (distant)
2. **Toujours utiliser un tunnel SSH** en production
3. **Compiler avec `-g`** pour avoir les symboles de dÃ©bogage
4. **Utiliser `--multi`** pour les programmes multi-processus
5. **SÃ©curiser l'accÃ¨s** : localhost, firewall, timeout

Avec le debugging distant, vous pouvez dÃ©sormais traquer les bugs n'importe oÃ¹, que ce soit sur un serveur Ã  l'autre bout du monde ou dans un Raspberry Pi sur votre bureau ! ğŸŒğŸ”

â­ï¸ [Scripts GDB](/15-debogage-et-qualite/03.3-scripts-gdb.md)
