üîù Retour au [Sommaire](/SOMMAIRE.md)

# 15.1.3 ThreadSanitizer (TSan)

## Introduction

**ThreadSanitizer** (abr√©g√© **TSan**) est un d√©tecteur automatique de **bugs de concurrence** (race conditions et autres probl√®mes li√©s aux threads) dans les programmes multi-thread√©s. C'est un sanitizer sp√©cialis√© dans la d√©tection de probl√®mes qui surviennent lorsque plusieurs threads acc√®dent simultan√©ment aux m√™mes donn√©es.

### Qu'est-ce qu'un bug de concurrence ?

Lorsque vous √©crivez un programme qui utilise plusieurs threads (fils d'ex√©cution parall√®les), ces threads peuvent acc√©der aux m√™mes variables ou zones m√©moire **en m√™me temps**. Si cet acc√®s n'est pas correctement synchronis√©, des bugs tr√®s difficiles √† d√©tecter peuvent appara√Ætre.

**Caract√©ristiques des bugs de concurrence :**
- üé≤ **Non d√©terministes** : Ils ne se produisent pas toujours
- üêõ **Difficiles √† reproduire** : Peuvent appara√Ætre une fois sur 1000 ex√©cutions
- üí£ **Silencieux** : Le programme peut sembler fonctionner correctement
- üî• **Dangereux** : Peuvent causer des crashs al√©atoires ou des corruptions de donn√©es
- ‚è±Ô∏è **D√©pendent du timing** : Changent selon la charge du syst√®me

**Exemple simple d'un bug de concurrence :**
```c
#include <pthread.h>
#include <stdio.h>

int compteur = 0;  // Variable partag√©e

void* incrementer(void* arg) {
    for (int i = 0; i < 1000000; i++) {
        compteur++;  // ‚ùå RACE CONDITION : Acc√®s concurrent non prot√©g√©
    }
    return NULL;
}

int main() {
    pthread_t thread1, thread2;

    pthread_create(&thread1, NULL, incrementer, NULL);
    pthread_create(&thread2, NULL, incrementer, NULL);

    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);

    printf("Compteur final : %d\n", compteur);
    // Devrait √™tre 2000000, mais sera al√©atoire (ex: 1547823)
    return 0;
}
```

**Sans TSan**, ce programme compile et s'ex√©cute, mais donne des r√©sultats incorrects et al√©atoires. **Avec TSan**, l'erreur est d√©tect√©e imm√©diatement.

### Pourquoi ThreadSanitizer est crucial ?

Les bugs de concurrence sont parmi les plus difficiles √† d√©boguer :
- üîç **Impossibles √† trouver par inspection visuelle** du code
- üéØ **Ne se manifestent pas syst√©matiquement** lors des tests
- üöÄ **Peuvent rester cach√©s en production** pendant des mois
- üí• **Peuvent causer des corruptions de donn√©es critiques**

**TSan d√©tecte ces probl√®mes automatiquement** pendant l'ex√©cution de votre programme.

---

## Les probl√®mes d√©tect√©s par ThreadSanitizer

### 1. **Data Race (Race Condition)**

Une race condition se produit lorsque :
- Deux threads (ou plus) acc√®dent √† la m√™me variable
- Au moins un des acc√®s est une **√©criture**
- Les acc√®s ne sont **pas synchronis√©s** (pas de mutex, pas d'atomique)

```c
#include <pthread.h>

int solde_compte = 1000;  // Variable partag√©e

void* retirer_argent(void* montant) {
    int m = *(int*)montant;

    // ‚ùå RACE CONDITION : Lecture et √©criture non synchronis√©es
    if (solde_compte >= m) {
        solde_compte -= m;  // Modification non prot√©g√©e
    }

    return NULL;
}

int main() {
    pthread_t t1, t2;
    int montant = 600;

    // Les deux threads essaient de retirer 600‚Ç¨ simultan√©ment
    pthread_create(&t1, NULL, retirer_argent, &montant);
    pthread_create(&t2, NULL, retirer_argent, &montant);

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    printf("Solde final : %d\n", solde_compte);
    // Peut √™tre n√©gatif ! (devrait √™tre au minimum 400)
    return 0;
}
```

### 2. **Thread Leak (Fuite de thread)**

Un thread est cr√©√© mais jamais joint ni d√©tach√©.

```c
#include <pthread.h>

void* fonction_thread(void* arg) {
    // Fait quelque chose
    return NULL;
}

int main() {
    pthread_t thread;
    pthread_create(&thread, NULL, fonction_thread, NULL);

    // ‚ùå OUBLI : Pas de pthread_join() ni pthread_detach()

    return 0;  // Thread leak !
}
```

### 3. **Mutex Misuse (Mauvaise utilisation des mutex)**

#### Double unlock
```c
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

void fonction() {
    pthread_mutex_lock(&mutex);
    // Code critique
    pthread_mutex_unlock(&mutex);
    pthread_mutex_unlock(&mutex);  // ‚ùå ERREUR : Double unlock
}
```

#### Unlock d'un mutex non verrouill√©
```c
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

void fonction() {
    pthread_mutex_unlock(&mutex);  // ‚ùå ERREUR : Unlock sans lock
}
```

#### Lock oubli√©
```c
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

void fonction() {
    pthread_mutex_lock(&mutex);
    // Code critique
    // ‚ùå OUBLI : Pas de pthread_mutex_unlock()
}
```

### 4. **Deadlock (Interblocage)**

TSan peut d√©tecter certains deadlocks potentiels (mais pas tous).

```c
pthread_mutex_t mutex1 = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t mutex2 = PTHREAD_MUTEX_INITIALIZER;

void* thread1_func(void* arg) {
    pthread_mutex_lock(&mutex1);
    sleep(1);  // Simule du travail
    pthread_mutex_lock(&mutex2);  // ‚ùå Peut bloquer ici

    // Section critique

    pthread_mutex_unlock(&mutex2);
    pthread_mutex_unlock(&mutex1);
    return NULL;
}

void* thread2_func(void* arg) {
    pthread_mutex_lock(&mutex2);  // Ordre invers√© !
    sleep(1);
    pthread_mutex_lock(&mutex1);  // ‚ùå Peut bloquer ici

    // Section critique

    pthread_mutex_unlock(&mutex1);
    pthread_mutex_unlock(&mutex2);
    return NULL;
}
```

### 5. **Signal-unsafe call**

Appel d'une fonction non signal-safe depuis un handler de signal.

```c
#include <signal.h>
#include <stdlib.h>

void signal_handler(int sig) {
    malloc(100);  // ‚ùå ERREUR : malloc n'est pas signal-safe
}
```

---

## Comment utiliser ThreadSanitizer ?

### Activation pendant la compilation

Pour activer TSan, ajoutez l'option `-fsanitize=thread` :

```bash
gcc -fsanitize=thread -g -o mon_programme mon_programme.c -pthread
```

**Options importantes :**
- `-fsanitize=thread` : Active ThreadSanitizer
- `-g` : Ajoute les informations de d√©bogage
- `-pthread` : Lie la biblioth√®que pthread
- `-O1` : Niveau d'optimisation recommand√© (pas `-O0` ni `-O2`)

### ‚ö†Ô∏è IMPORTANT : Incompatibilit√© avec ASan

**TSan ne peut PAS √™tre combin√© avec AddressSanitizer !**

```bash
# ‚ùå ERREUR : Ne fonctionne pas
gcc -fsanitize=address,thread -o prog prog.c

# ‚úÖ CORRECT : Utilisez TSan seul
gcc -fsanitize=thread -g -o prog prog.c -pthread
```

**Vous devez choisir :**
- Soit TSan (pour les bugs de concurrence)
- Soit ASan (pour les erreurs m√©moire)

**Recommandation :** Faites deux builds s√©par√©s et testez avec les deux.

### Exemple complet

**fichier : `race.c`**
```c
#include <pthread.h>
#include <stdio.h>

int compteur_global = 0;

void* incrementer(void* arg) {
    for (int i = 0; i < 100000; i++) {
        compteur_global++;  // Acc√®s concurrent non synchronis√©
    }
    return NULL;
}

int main() {
    pthread_t t1, t2;

    pthread_create(&t1, NULL, incrementer, NULL);
    pthread_create(&t2, NULL, incrementer, NULL);

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    printf("Compteur : %d\n", compteur_global);
    return 0;
}
```

**Compilation avec TSan :**
```bash
gcc -fsanitize=thread -g -O1 -o race race.c -pthread
```

**Ex√©cution :**
```bash
./race
```

---

## Interpr√©ter les rapports de ThreadSanitizer

### Exemple de rapport : Data Race

**Programme avec race condition :**
```c
#include <pthread.h>

int x = 0;

void* thread1(void* arg) {
    x = 1;
    return NULL;
}

void* thread2(void* arg) {
    x = 2;
    return NULL;
}

int main() {
    pthread_t t1, t2;
    pthread_create(&t1, NULL, thread1, NULL);
    pthread_create(&t2, NULL, thread2, NULL);
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    return 0;
}
```

**Rapport TSan :**
```
==================
WARNING: ThreadSanitizer: data race (pid=12345)
  Write of size 4 at 0x7f8a1234abcd by thread T1:
    #0 thread1 race.c:6 (race+0x123456)

  Previous write of size 4 at 0x7f8a1234abcd by thread T2:
    #0 thread2 race.c:11 (race+0x123789)

  Location is global 'x' of size 4 at 0x7f8a1234abcd (race+0x000abc)

  Thread T1 (tid=12346, running) created by main thread at:
    #0 pthread_create <null> (race+0x456789)
    #1 main race.c:17 (race+0x987654)

  Thread T2 (tid=12347, running) created by main thread at:
    #0 pthread_create <null> (race+0x456789)
    #1 main race.c:18 (race+0x987654)

SUMMARY: ThreadSanitizer: data race race.c:6 in thread1
==================
```

### D√©crypter le rapport

#### 1. **Type de probl√®me**
```
WARNING: ThreadSanitizer: data race
```
‚Üí Une **race condition** a √©t√© d√©tect√©e.

#### 2. **Premi√®re op√©ration conflictuelle**
```
Write of size 4 at 0x7f8a1234abcd by thread T1:
    #0 thread1 race.c:6
```
‚Üí Le **thread T1** a √©crit 4 octets (un `int`) √† la ligne 6 du fichier `race.c`.

#### 3. **Deuxi√®me op√©ration conflictuelle**
```
Previous write of size 4 at 0x7f8a1234abcd by thread T2:
    #0 thread2 race.c:11
```
‚Üí Le **thread T2** a √©galement √©crit √† la m√™me adresse, ligne 11.

#### 4. **Variable concern√©e**
```
Location is global 'x' of size 4 at 0x7f8a1234abcd
```
‚Üí La variable globale **'x'** est la source du probl√®me.

#### 5. **Origine des threads**
```
Thread T1 created by main thread at:
    #1 main race.c:17
Thread T2 created by main thread at:
    #1 main race.c:18
```
‚Üí Les threads ont √©t√© cr√©√©s aux lignes 17 et 18.

---

## Exemples d√©taill√©s avec correction

### Exemple 1 : Race condition sur un compteur

**Code probl√©matique :**
```c
#include <pthread.h>
#include <stdio.h>

int compteur = 0;

void* incrementer(void* arg) {
    for (int i = 0; i < 1000000; i++) {
        compteur++;  // ‚ùå RACE CONDITION
    }
    return NULL;
}

int main() {
    pthread_t threads[4];

    for (int i = 0; i < 4; i++) {
        pthread_create(&threads[i], NULL, incrementer, NULL);
    }

    for (int i = 0; i < 4; i++) {
        pthread_join(threads[i], NULL);
    }

    printf("Compteur final : %d (attendu : 4000000)\n", compteur);
    return 0;
}
```

**Rapport TSan :** Signale une data race sur la variable `compteur`.

**Correction avec mutex :**
```c
#include <pthread.h>
#include <stdio.h>

int compteur = 0;
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

void* incrementer(void* arg) {
    for (int i = 0; i < 1000000; i++) {
        pthread_mutex_lock(&mutex);
        compteur++;  // ‚úÖ Prot√©g√© par mutex
        pthread_mutex_unlock(&mutex);
    }
    return NULL;
}

int main() {
    pthread_t threads[4];

    for (int i = 0; i < 4; i++) {
        pthread_create(&threads[i], NULL, incrementer, NULL);
    }

    for (int i = 0; i < 4; i++) {
        pthread_join(threads[i], NULL);
    }

    printf("Compteur final : %d\n", compteur);
    pthread_mutex_destroy(&mutex);
    return 0;
}
```

**Correction avec atomiques (C11, plus performant) :**
```c
#include <pthread.h>
#include <stdio.h>
#include <stdatomic.h>

atomic_int compteur = 0;

void* incrementer(void* arg) {
    for (int i = 0; i < 1000000; i++) {
        atomic_fetch_add(&compteur, 1);  // ‚úÖ Op√©ration atomique
    }
    return NULL;
}

int main() {
    pthread_t threads[4];

    for (int i = 0; i < 4; i++) {
        pthread_create(&threads[i], NULL, incrementer, NULL);
    }

    for (int i = 0; i < 4; i++) {
        pthread_join(threads[i], NULL);
    }

    printf("Compteur final : %d\n", compteur);
    return 0;
}
```

### Exemple 2 : Race condition sur une structure

**Code probl√©matique :**
```c
#include <pthread.h>
#include <stdio.h>
#include <string.h>

typedef struct {
    int solde;
    char nom[50];
} Compte;

Compte compte = {1000, "Alice"};

void* modifier_compte(void* arg) {
    // ‚ùå RACE CONDITION : Acc√®s concurrent non synchronis√©
    compte.solde -= 100;
    strcpy(compte.nom, "Bob");
    return NULL;
}

int main() {
    pthread_t t1, t2;

    pthread_create(&t1, NULL, modifier_compte, NULL);
    pthread_create(&t2, NULL, modifier_compte, NULL);

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    printf("Solde : %d, Nom : %s\n", compte.solde, compte.nom);
    return 0;
}
```

**Correction :**
```c
#include <pthread.h>
#include <stdio.h>
#include <string.h>

typedef struct {
    int solde;
    char nom[50];
} Compte;

Compte compte = {1000, "Alice"};
pthread_mutex_t mutex_compte = PTHREAD_MUTEX_INITIALIZER;

void* modifier_compte(void* arg) {
    pthread_mutex_lock(&mutex_compte);
    // ‚úÖ Section critique prot√©g√©e
    compte.solde -= 100;
    strcpy(compte.nom, "Bob");
    pthread_mutex_unlock(&mutex_compte);
    return NULL;
}

int main() {
    pthread_t t1, t2;

    pthread_create(&t1, NULL, modifier_compte, NULL);
    pthread_create(&t2, NULL, modifier_compte, NULL);

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    printf("Solde : %d, Nom : %s\n", compte.solde, compte.nom);
    pthread_mutex_destroy(&mutex_compte);
    return 0;
}
```

### Exemple 3 : Deadlock potentiel

**Code probl√©matique :**
```c
#include <pthread.h>
#include <stdio.h>

pthread_mutex_t mutex_a = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t mutex_b = PTHREAD_MUTEX_INITIALIZER;

void* fonction1(void* arg) {
    pthread_mutex_lock(&mutex_a);
    sleep(1);  // Simule du travail
    pthread_mutex_lock(&mutex_b);  // ‚ùå Risque de deadlock

    printf("Fonction 1 : section critique\n");

    pthread_mutex_unlock(&mutex_b);
    pthread_mutex_unlock(&mutex_a);
    return NULL;
}

void* fonction2(void* arg) {
    pthread_mutex_lock(&mutex_b);  // ‚ùå Ordre invers√©
    sleep(1);
    pthread_mutex_lock(&mutex_a);  // ‚ùå Risque de deadlock

    printf("Fonction 2 : section critique\n");

    pthread_mutex_unlock(&mutex_a);
    pthread_mutex_unlock(&mutex_b);
    return NULL;
}

int main() {
    pthread_t t1, t2;

    pthread_create(&t1, NULL, fonction1, NULL);
    pthread_create(&t2, NULL, fonction2, NULL);

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    return 0;
}
```

**Correction : Toujours verrouiller dans le m√™me ordre**
```c
#include <pthread.h>
#include <stdio.h>

pthread_mutex_t mutex_a = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t mutex_b = PTHREAD_MUTEX_INITIALIZER;

void* fonction1(void* arg) {
    // ‚úÖ Ordre coh√©rent : toujours A puis B
    pthread_mutex_lock(&mutex_a);
    pthread_mutex_lock(&mutex_b);

    printf("Fonction 1 : section critique\n");

    pthread_mutex_unlock(&mutex_b);
    pthread_mutex_unlock(&mutex_a);
    return NULL;
}

void* fonction2(void* arg) {
    // ‚úÖ M√™me ordre : A puis B
    pthread_mutex_lock(&mutex_a);
    pthread_mutex_lock(&mutex_b);

    printf("Fonction 2 : section critique\n");

    pthread_mutex_unlock(&mutex_b);
    pthread_mutex_unlock(&mutex_a);
    return NULL;
}

int main() {
    pthread_t t1, t2;

    pthread_create(&t1, NULL, fonction1, NULL);
    pthread_create(&t2, NULL, fonction2, NULL);

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    return 0;
}
```

---

## Configuration via variables d'environnement

TSan peut √™tre configur√© via `TSAN_OPTIONS` :

### Arr√™ter √† la premi√®re erreur
```bash
TSAN_OPTIONS="halt_on_error=1" ./mon_programme
```

### Continuer apr√®s les erreurs (afficher toutes les races)
```bash
TSAN_OPTIONS="halt_on_error=0" ./mon_programme
```

### D√©sactiver la d√©tection de deadlock
```bash
TSAN_OPTIONS="detect_deadlocks=0" ./mon_programme
```

### Sauvegarder le rapport dans un fichier
```bash
TSAN_OPTIONS="log_path=tsan_report.txt" ./mon_programme
```

### Augmenter la taille de l'historique (plus de pr√©cision)
```bash
TSAN_OPTIONS="history_size=7" ./mon_programme  # Default: 5, Max: 7
```

### Exemple combin√©
```bash
TSAN_OPTIONS="halt_on_error=0:detect_deadlocks=1:history_size=7" ./mon_programme
```

---

## Limitations et contraintes

### 1. **Incompatibilit√© avec ASan**

TSan et ASan ne peuvent **pas** √™tre utilis√©s ensemble.

**Solution :** Cr√©ez deux builds s√©par√©s :
```bash
# Build 1 : Avec TSan (pour tester la concurrence)
gcc -fsanitize=thread -g -O1 -o prog_tsan prog.c -pthread

# Build 2 : Avec ASan (pour tester la m√©moire)
gcc -fsanitize=address -g -O1 -o prog_asan prog.c -pthread
```

### 2. **Performance impact**

| Aspect | Impact |
|--------|--------|
| **Vitesse** | 5-15√ó plus lent |
| **M√©moire** | 5-10√ó plus de RAM |
| **Taille binaire** | +50-100% |

**TSan est plus lourd** qu'ASan ou UBSan. Il est r√©serv√© aux tests, pas au d√©veloppement quotidien.

### 3. **D√©tection non exhaustive**

TSan ne d√©tecte **pas tous les bugs de concurrence** :
- ‚ùå Ne d√©tecte pas tous les deadlocks (seulement les cycles simples)
- ‚ùå Peut manquer certaines races sur du code tr√®s optimis√©
- ‚ùå Ne d√©tecte pas les erreurs de logique m√©tier

**TSan est tr√®s bon, mais pas infaillible.**

### 4. **Faux positifs (rares)**

TSan produit tr√®s peu de faux positifs, mais cela peut arriver avec :
- Code assembleur inline
- Synchronisation custom (lock-free programming)
- Certaines biblioth√®ques tierces

**Solution :** Utilisez les annotations TSan pour les supprimer (voir documentation avanc√©e).

### 5. **N√©cessite du code multi-thread√©**

TSan ne sert √† rien sur un programme mono-thread. Il faut que votre programme utilise :
- `pthread` (POSIX threads)
- `std::thread` (C++)
- Ou tout autre m√©canisme de threading

---

## Performance et bonnes pratiques

### Quand utiliser TSan ?

**‚úÖ Utilisez TSan pour :**
- Tests de r√©gression automatis√©s sur code concurrent
- Validation avant release d'un programme multi-thread√©
- Debugging de crashs al√©atoires sur programmes threaded
- Code review de nouvelles fonctionnalit√©s concurrentes

**‚ùå N'utilisez pas TSan pour :**
- D√©veloppement quotidien (trop lent)
- Code mono-thread (inutile)
- Production (overhead trop important)

### Workflow recommand√©

**Phase de d√©veloppement :**
```bash
# Compilation normale avec warnings
gcc -Wall -Wextra -pthread -g -O1 -o prog prog.c
```

**Tests locaux avant commit :**
```bash
# Build avec ASan pour la m√©moire
gcc -fsanitize=address,undefined -g -O1 -o prog_asan prog.c -pthread
./prog_asan

# Build avec TSan pour la concurrence
gcc -fsanitize=thread -g -O1 -o prog_tsan prog.c -pthread
./prog_tsan
```

**Pipeline CI/CD :**
```bash
# Tests avec ASan
gcc -fsanitize=address,undefined -g -o tests_asan tests.c -pthread
./tests_asan

# Tests avec TSan
gcc -fsanitize=thread -g -o tests_tsan tests.c -pthread
./tests_tsan
```

### Makefile exemple

```makefile
CC = gcc
CFLAGS = -Wall -Wextra -g -O1 -pthread

# Build normal
prog: main.c
	$(CC) $(CFLAGS) -o prog main.c

# Build avec ASan
asan: main.c
	$(CC) $(CFLAGS) -fsanitize=address,undefined -o prog_asan main.c

# Build avec TSan
tsan: main.c
	$(CC) $(CFLAGS) -fsanitize=thread -o prog_tsan main.c

# Tester avec les deux sanitizers
test: asan tsan
	@echo "=== Test avec ASan ==="
	./prog_asan
	@echo "=== Test avec TSan ==="
	./prog_tsan

clean:
	rm -f prog prog_asan prog_tsan
```

### CMake exemple

```cmake
cmake_minimum_required(VERSION 3.10)
project(MonProjet C)

set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -pthread -Wall -Wextra")

add_executable(prog main.c)

# Target avec TSan
add_executable(prog_tsan main.c)
target_compile_options(prog_tsan PRIVATE -fsanitize=thread -g -O1)
target_link_options(prog_tsan PRIVATE -fsanitize=thread)

# Target avec ASan
add_executable(prog_asan main.c)
target_compile_options(prog_asan PRIVATE -fsanitize=address,undefined -g -O1)
target_link_options(prog_asan PRIVATE -fsanitize=address,undefined)
```

---

## Int√©gration dans le CI/CD

### GitHub Actions

```yaml
name: Tests avec Sanitizers

on: [push, pull_request]

jobs:
  test-tsan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Install dependencies
        run: sudo apt-get update && sudo apt-get install -y build-essential

      - name: Build avec TSan
        run: gcc -fsanitize=thread -g -O1 -pthread -o tests_tsan tests.c

      - name: Run tests avec TSan
        run: |
          export TSAN_OPTIONS="halt_on_error=1:history_size=7"
          ./tests_tsan

  test-asan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Build avec ASan
        run: gcc -fsanitize=address,undefined -g -O1 -pthread -o tests_asan tests.c

      - name: Run tests avec ASan
        run: |
          export ASAN_OPTIONS="halt_on_error=1"
          ./tests_asan
```

### GitLab CI

```yaml
stages:
  - test

test_tsan:
  stage: test
  script:
    - gcc -fsanitize=thread -g -O1 -pthread -o tests_tsan tests.c
    - export TSAN_OPTIONS="halt_on_error=1"
    - ./tests_tsan

test_asan:
  stage: test
  script:
    - gcc -fsanitize=address,undefined -g -O1 -pthread -o tests_asan tests.c
    - export ASAN_OPTIONS="halt_on_error=1"
    - ./tests_asan
```

---

## Comparaison avec d'autres outils

### TSan vs Helgrind (Valgrind)

| Aspect | TSan | Helgrind |
|--------|------|----------|
| **Recompilation** | Oui | Non |
| **Vitesse** | ~5-15√ó plus lent | ~20-50√ó plus lent |
| **Pr√©cision** | Tr√®s bonne | Bonne |
| **Faux positifs** | Tr√®s peu | Peu |
| **D√©tection deadlock** | Oui (limit√©) | Oui |
| **Facilit√©** | Tr√®s simple | Simple |

**Recommandation :** TSan est plus rapide et plus pr√©cis. Utilisez-le en priorit√©.

### TSan vs ASan/UBSan

| Aspect | TSan | ASan/UBSan |
|--------|------|------------|
| **Cible** | Bugs de concurrence | M√©moire / Comportement ind√©fini |
| **Combinable** | ‚ùå Pas avec ASan | ‚úÖ ASan + UBSan OK |
| **Overhead** | ~10√ó | ~2√ó (ASan) |
| **Usage** | Tests seulement | Dev + Tests |

---

## Cas pratique : Bug r√©el

### Le probl√®me

Voici un bug subtil de race condition sur un cache :

```c
#include <pthread.h>
#include <stdio.h>
#include <stdbool.h>

typedef struct {
    int valeur;
    bool valide;
} Cache;

Cache cache = {0, false};

int fonction_couteuse() {
    // Simule un calcul co√ªteux
    return 42;
}

int obtenir_valeur() {
    // ‚ùå RACE CONDITION : V√©rification et utilisation non atomiques
    if (!cache.valide) {
        cache.valeur = fonction_couteuse();
        cache.valide = true;
    }
    return cache.valeur;
}

void* thread_func(void* arg) {
    for (int i = 0; i < 1000; i++) {
        int val = obtenir_valeur();
        printf("Valeur : %d\n", val);
    }
    return NULL;
}

int main() {
    pthread_t threads[4];

    for (int i = 0; i < 4; i++) {
        pthread_create(&threads[i], NULL, thread_func, NULL);
    }

    for (int i = 0; i < 4; i++) {
        pthread_join(threads[i], NULL);
    }

    return 0;
}
```

**Probl√®me :** Plusieurs threads peuvent voir `cache.valide == false` en m√™me temps et tous appeler `fonction_couteuse()`.

**Compilation avec TSan :**
```bash
gcc -fsanitize=thread -g -O1 -pthread -o cache cache.c
./cache
```

**TSan d√©tecte imm√©diatement** la race condition sur `cache.valide` et `cache.valeur`.

### La correction

```c
#include <pthread.h>
#include <stdio.h>
#include <stdbool.h>

typedef struct {
    int valeur;
    bool valide;
} Cache;

Cache cache = {0, false};
pthread_mutex_t cache_mutex = PTHREAD_MUTEX_INITIALIZER;

int fonction_couteuse() {
    return 42;
}

int obtenir_valeur() {
    pthread_mutex_lock(&cache_mutex);

    // ‚úÖ V√©rification et utilisation dans une section critique
    if (!cache.valide) {
        cache.valeur = fonction_couteuse();
        cache.valide = true;
    }

    int resultat = cache.valeur;
    pthread_mutex_unlock(&cache_mutex);

    return resultat;
}

void* thread_func(void* arg) {
    for (int i = 0; i < 1000; i++) {
        int val = obtenir_valeur();
        printf("Valeur : %d\n", val);
    }
    return NULL;
}

int main() {
    pthread_t threads[4];

    for (int i = 0; i < 4; i++) {
        pthread_create(&threads[i], NULL, thread_func, NULL);
    }

    for (int i = 0; i < 4; i++) {
        pthread_join(threads[i], NULL);
    }

    pthread_mutex_destroy(&cache_mutex);
    return 0;
}
```

---

## R√©sum√©

### Points cl√©s √† retenir

1. **TSan d√©tecte les race conditions** et autres bugs de concurrence
2. **Activation** : `-fsanitize=thread`
3. **Incompatible avec ASan** : Faites deux builds s√©par√©s
4. **Overhead important** : 5-15√ó plus lent, r√©serv√© aux tests
5. **Indispensable** pour tout code multi-thread√©

### Commande √† retenir
```bash
gcc -fsanitize=thread -g -O1 -pthread -o programme programme.c
```

### Configuration recommand√©e
```bash
TSAN_OPTIONS="halt_on_error=1:detect_deadlocks=1" ./programme
```

### Workflow complet

**Pour d√©velopper :**
```bash
gcc -Wall -Wextra -pthread -g -O1 -o prog prog.c
```

**Pour tester (avant commit) :**
```bash
# Test m√©moire
gcc -fsanitize=address,undefined -g -O1 -o prog_asan prog.c -pthread
./prog_asan

# Test concurrence
gcc -fsanitize=thread -g -O1 -o prog_tsan prog.c -pthread
./prog_tsan
```

### Les bugs de concurrence les plus courants

1. ‚ö†Ô∏è **Data race** sur variables partag√©es (le plus fr√©quent)
2. ‚ö†Ô∏è **Missing lock** (oubli de mutex)
3. ‚ö†Ô∏è **Deadlock** (interblocage)
4. ‚ö†Ô∏è **Double unlock** ou unlock sans lock
5. ‚ö†Ô∏è **Thread leak** (thread non joint)

### Prochaines √©tapes

Dans la section suivante, vous d√©couvrirez :
- **LeakSanitizer (LSan)** : D√©tection de fuites m√©moire
- Comment **compiler avec tous les sanitizers** appropri√©s
- **Int√©gration compl√®te** des sanitizers dans votre workflow

---

**üéØ TSan est votre meilleur alli√© pour √©crire du code concurrent robuste. Ne livrez jamais de code multi-thread√© sans l'avoir test√© avec TSan !**

‚è≠Ô∏è [LeakSanitizer (LSan)](/15-debogage-et-qualite/01.4-leak-sanitizer.md)
