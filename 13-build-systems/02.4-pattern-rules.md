üîù Retour au [Sommaire](/SOMMAIRE.md)

# 13.2.4 Pattern Rules et Automatic Variables

## Introduction

Les **pattern rules** (r√®gles √† motifs) sont l'une des fonctionnalit√©s les plus puissantes de Make. Elles permettent d'√©crire des r√®gles g√©n√©riques qui s'appliquent √† de nombreux fichiers, √©vitant ainsi des centaines de lignes de code r√©p√©titives. Combin√©es aux **variables automatiques**, elles rendent vos Makefiles concis, maintenables et √©l√©gants.

## Le Probl√®me : Code R√©p√©titif

Imaginez un projet avec 10 fichiers source. Sans pattern rules, votre Makefile ressemblerait √† ceci :

```makefile
# ‚ùå Code r√©p√©titif et difficile √† maintenir
main.o: main.c
	gcc -c main.c -o main.o

utils.o: utils.c
	gcc -c utils.c -o utils.o

config.o: config.c
	gcc -c config.c -o config.o

network.o: network.c
	gcc -c network.c -o network.o

# ... 6 autres r√®gles identiques
```

**Probl√®mes** :
- R√©p√©tition massive
- Difficile √† modifier (changer les flags = modifier 10 lignes)
- Erreurs de copier-coller
- Non scalable (100 fichiers = 100 r√®gles)

## La Solution : Pattern Rules

Une **pattern rule** utilise le symbole `%` comme joker (wildcard) pour correspondre √† un motif :

```makefile
# ‚úÖ Une seule r√®gle pour tous les .c ‚Üí .o
%.o: %.c
	gcc -c $< -o $@
```

**Explication** :
- `%.o` : Cible (n'importe quel fichier se terminant par `.o`)
- `%.c` : D√©pendance (le fichier `.c` correspondant)
- `$<` : Variable automatique = premi√®re d√©pendance (`main.c`, `utils.c`, etc.)
- `$@` : Variable automatique = cible (`main.o`, `utils.o`, etc.)

Cette **unique r√®gle** remplace toutes les r√®gles r√©p√©titives pr√©c√©dentes !

## Anatomie d'une Pattern Rule

```makefile
%.cible: %.d√©pendance
	commande avec $< et $@
```

### Le Symbole `%`

Le `%` correspond √† n'importe quelle s√©quence de caract√®res. C'est le **stem** (radical).

**Exemples de correspondance** :

| Pattern | Fichier | Stem (%) |
|---------|---------|----------|
| `%.o` | `main.o` | `main` |
| `%.o` | `network.o` | `network` |
| `test_%.c` | `test_utils.c` | `utils` |
| `lib%.a` | `libmath.a` | `math` |

**Important** : Le stem doit √™tre **identique** dans la cible et la d√©pendance.

## Rappel : Variables Automatiques

Dans le contexte des pattern rules, les variables automatiques sont essentielles :

| Variable | Signification | Exemple (pour `main.o: main.c utils.h`) |
|----------|---------------|------------------------------------------|
| `$@` | Nom de la cible | `main.o` |
| `$<` | Premi√®re d√©pendance | `main.c` |
| `$^` | Toutes les d√©pendances (sans doublons) | `main.c utils.h` |
| `$+` | Toutes les d√©pendances (avec doublons) | `main.c utils.h` |
| `$?` | D√©pendances plus r√©centes que la cible | `main.c` (si modifi√©) |
| `$*` | Le stem (partie captur√©e par `%`) | `main` |

### Modificateurs de Variables Automatiques

Vous pouvez extraire des parties sp√©cifiques :

```makefile
$(@D)   # R√©pertoire de la cible : obj/
$(@F)   # Nom du fichier de la cible : main.o
$(<D)   # R√©pertoire de la d√©pendance : src/
$(<F)   # Nom du fichier de la d√©pendance : main.c
```

## Exemples de Pattern Rules

### Exemple 1 : Compilation C Basique

```makefile
CC = gcc
CFLAGS = -Wall -Wextra -std=c11

# Pattern rule : .c ‚Üí .o
%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@
```

**Utilisation** :
- Make voit que `main.o` est n√©cessaire
- Il cherche une r√®gle pour cr√©er `main.o`
- Il trouve la pattern rule `%.o: %.c`
- Il remplace `%` par `main` : `main.o: main.c`
- Il ex√©cute : `gcc -Wall -Wextra -std=c11 -c main.c -o main.o`

### Exemple 2 : Avec R√©pertoires

```makefile
SRCDIR = src
OBJDIR = obj

CC = gcc
CFLAGS = -Wall -Iinclude

# Pattern rule : src/*.c ‚Üí obj/*.o
$(OBJDIR)/%.o: $(SRCDIR)/%.c
	$(CC) $(CFLAGS) -c $< -o $@
```

**Fonctionnement** :
- Besoin de `obj/main.o`
- Pattern : `obj/%.o` correspond avec `%=main`
- D√©pendance : `src/main.c`
- Commande : `gcc -Wall -Iinclude -c src/main.c -o obj/main.o`

### Exemple 3 : Compilation avec Headers

```makefile
OBJDIR = obj
SRCDIR = src
INCDIR = include

CC = gcc
CFLAGS = -Wall -I$(INCDIR)

# Pattern rule avec headers
$(OBJDIR)/%.o: $(SRCDIR)/%.c $(INCDIR)/%.h
	@mkdir -p $(OBJDIR)
	$(CC) $(CFLAGS) -c $< -o $@
	@echo "‚úì Compil√© $*"
```

**Remarques** :
- `$*` donne le stem (`main`, `utils`, etc.)
- `@mkdir -p` cr√©e le r√©pertoire si n√©cessaire (le `@` masque la commande)
- Headers list√©s comme d√©pendances ‚Üí recompilation si header modifi√©

### Exemple 4 : Plusieurs Patterns

```makefile
# Compilation C
%.o: %.c
	gcc -c $< -o $@

# Compilation C++
%.o: %.cpp
	g++ -c $< -o $@

# G√©n√©ration de documentation
%.html: %.md
	markdown $< > $@

# Compression
%.gz: %
	gzip -c $< > $@
```

## Static Pattern Rules

Les **static pattern rules** permettent de limiter la pattern rule √† une liste sp√©cifique de cibles.

### Syntaxe

```makefile
cibles: pattern-cible: pattern-d√©pendances
	commandes
```

### Exemple

```makefile
# Liste de fichiers objets
OBJECTS = main.o utils.o config.o

# Static pattern rule (appliqu√©e SEULEMENT √† OBJECTS)
$(OBJECTS): %.o: %.c
	gcc -c $< -o $@
```

**Avantage** : Plus explicite et plus rapide (Make n'a pas √† chercher toutes les correspondances possibles).

### Exemple Avanc√© avec R√©pertoires

```makefile
SRCDIR = src
OBJDIR = obj

SOURCES = $(wildcard $(SRCDIR)/*.c)
OBJECTS = $(patsubst $(SRCDIR)/%.c,$(OBJDIR)/%.o,$(SOURCES))

# Static pattern rule
$(OBJECTS): $(OBJDIR)/%.o: $(SRCDIR)/%.c
	@mkdir -p $(OBJDIR)
	gcc -c $< -o $@
```

## Pattern Rules Avanc√©es

### 1. Patterns avec Plusieurs D√©pendances

```makefile
INCDIR = include

# Chaque .o d√©pend de son .c ET de common.h
%.o: %.c $(INCDIR)/common.h
	gcc -c -I$(INCDIR) $< -o $@
```

### 2. Patterns avec Variables

```makefile
# Headers correspondant au stem
%.o: %.c %.h config.h
	gcc -c $< -o $@

# main.o d√©pendra de : main.c main.h config.h
# utils.o d√©pendra de : utils.c utils.h config.h
```

### 3. Patterns Cha√Æn√©s

```makefile
# .c ‚Üí .i (pr√©processeur)
%.i: %.c
	gcc -E $< -o $@

# .i ‚Üí .s (assembleur)
%.s: %.i
	gcc -S $< -o $@

# .s ‚Üí .o (objet)
%.o: %.s
	gcc -c $< -o $@
```

Make peut automatiquement cha√Æner ces r√®gles si n√©cessaire.

## R√®gles Implicites de Make

Make poss√®de des **r√®gles implicites** int√©gr√©es (built-in rules) qui sont essentiellement des pattern rules pr√©d√©finies.

### R√®gles Implicites Courantes

```makefile
# D√©j√† d√©finies par Make :
%.o: %.c
	$(CC) $(CFLAGS) $(CPPFLAGS) -c $< -o $@

%.o: %.cpp
	$(CXX) $(CXXFLAGS) $(CPPFLAGS) -c $< -o $@

%: %.o
	$(CC) $(LDFLAGS) $< $(LDLIBS) -o $@
```

### Voir les R√®gles Implicites

```bash
# Afficher toutes les r√®gles implicites
make -p
```

### Surcharger les R√®gles Implicites

Vous pouvez red√©finir une r√®gle implicite :

```makefile
# Red√©finir la compilation C par d√©faut
%.o: %.c
	@echo "Compilation personnalis√©e de $<"
	gcc -Wall -Wextra -O2 -c $< -o $@
```

### D√©sactiver les R√®gles Implicites

```makefile
# En d√©but de Makefile
MAKEFLAGS += --no-builtin-rules --no-builtin-variables

# Ou via une cible sp√©ciale
.SUFFIXES:
```

## Variables Automatiques : Cas d'Usage

### 1. Debugging Informatif

```makefile
%.o: %.c
	@echo "=== Compilation ==="
	@echo "Cible    : $@"
	@echo "Source   : $<"
	@echo "D√©pend.  : $^"
	@echo "Stem     : $*"
	@echo "Dir src  : $(<D)"
	@echo "Dir cible: $(@D)"
	$(CC) $(CFLAGS) -c $< -o $@
```

### 2. Cr√©ation Automatique de R√©pertoires

```makefile
$(OBJDIR)/%.o: $(SRCDIR)/%.c
	@mkdir -p $(@D)  # Cr√©e le r√©pertoire de la cible
	$(CC) $(CFLAGS) -c $< -o $@
```

### 3. Logs de Compilation

```makefile
LOGDIR = logs

%.o: %.c
	@mkdir -p $(LOGDIR)
	$(CC) $(CFLAGS) -c $< -o $@ 2> $(LOGDIR)/$*.log
	@echo "Log: $(LOGDIR)/$*.log"
```

### 4. Archivage S√©lectif

```makefile
# N'archive que les .o modifi√©s
libmylib.a: $(OBJECTS)
	ar rcs $@ $?
```

## Patterns Multiples (GNU Make 4.3+)

Depuis GNU Make 4.3, vous pouvez sp√©cifier plusieurs cibles dans une pattern rule avec `&:` :

```makefile
# Ancienne m√©thode (cr√©e deux r√®gles s√©par√©es)
%.tab.c %.tab.h: %.y
	bison -d $<

# Nouvelle m√©thode (r√®gle unique pour les deux cibles)
%.tab.c %.tab.h &: %.y
	bison -d $<
```

**Diff√©rence** : Avec `&:`, Make sait que la commande g√©n√®re **les deux** fichiers en une seule ex√©cution.

## G√©n√©ration Automatique de D√©pendances

Un probl√®me classique : g√©rer les d√©pendances sur les headers sans les lister manuellement.

### Solution : Fichiers .d

GCC peut g√©n√©rer automatiquement les d√©pendances avec `-MMD` :

```makefile
OBJDIR = obj
SRCDIR = src

CC = gcc
CFLAGS = -Wall -MMD -MP

# Pattern rule avec g√©n√©ration de .d
$(OBJDIR)/%.o: $(SRCDIR)/%.c
	@mkdir -p $(OBJDIR)
	$(CC) $(CFLAGS) -c $< -o $@

# Inclusion des d√©pendances
-include $(OBJDIR)/*.d
```

**Explication** :
- `-MMD` : G√©n√®re un fichier `.d` avec les d√©pendances
- `-MP` : Ajoute des cibles phony pour les headers (√©vite les erreurs si un header est supprim√©)
- `-include` : Inclut les fichiers `.d` (le `-` ignore les erreurs si les fichiers n'existent pas)

**Contenu d'un fichier .d** (g√©n√©r√© automatiquement) :

```makefile
# obj/main.d
obj/main.o: src/main.c include/utils.h include/config.h

include/utils.h:

include/config.h:
```

### Exemple Complet

```makefile
CC = gcc
CFLAGS = -Wall -Wextra -Iinclude -MMD -MP

SRCDIR = src
OBJDIR = obj
BINDIR = bin

SOURCES = $(wildcard $(SRCDIR)/*.c)
OBJECTS = $(patsubst $(SRCDIR)/%.c,$(OBJDIR)/%.o,$(SOURCES))
DEPS = $(OBJECTS:.o=.d)

TARGET = $(BINDIR)/programme

all: $(TARGET)

$(TARGET): $(OBJECTS) | $(BINDIR)
	$(CC) -o $@ $^

$(OBJDIR)/%.o: $(SRCDIR)/%.c | $(OBJDIR)
	$(CC) $(CFLAGS) -c $< -o $@

$(OBJDIR) $(BINDIR):
	mkdir -p $@

.PHONY: clean
clean:
	rm -rf $(OBJDIR) $(BINDIR)

# Inclusion automatique des d√©pendances
-include $(DEPS)
```

## Ordre d'Ex√©cution des Pattern Rules

Make utilise l'ordre suivant pour trouver une r√®gle :

1. **R√®gle explicite** (priorit√© maximale)
2. **Static pattern rule**
3. **Pattern rule d√©finie par l'utilisateur**
4. **R√®gle implicite** (built-in)

```makefile
# R√®gle explicite
main.o: main.c
	gcc -DSPECIAL -c main.c -o main.o

# Pattern rule
%.o: %.c
	gcc -c $< -o $@
```

**R√©sultat** : Pour `main.o`, Make utilisera la r√®gle explicite (priorit√© sup√©rieure). Pour `utils.o`, il utilisera la pattern rule.

## Exemple : Projet Multi-Sources

```makefile
# ============================================
# Configuration
# ============================================
CC := gcc
CFLAGS := -Wall -Wextra -std=c11 -O2 -Iinclude -MMD -MP
LDFLAGS := -Llib
LDLIBS := -lm

# R√©pertoires
SRCDIR := src
OBJDIR := obj
BINDIR := bin
INCDIR := include

# Fichiers
SOURCES := $(wildcard $(SRCDIR)/*.c)
OBJECTS := $(patsubst $(SRCDIR)/%.c,$(OBJDIR)/%.o,$(SOURCES))
DEPS := $(OBJECTS:.o=.d)
TARGET := $(BINDIR)/programme

# ============================================
# R√®gles
# ============================================
.PHONY: all clean info

all: $(TARGET)

# Linkage
$(TARGET): $(OBJECTS) | $(BINDIR)
	@echo "üîó Linkage de $@..."
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)
	@echo "‚úì Build termin√© : $@"

# Pattern rule : Compilation
$(OBJDIR)/%.o: $(SRCDIR)/%.c | $(OBJDIR)
	@echo "üî® Compilation de $*..."
	$(CC) $(CFLAGS) -c $< -o $@

# Cr√©ation des r√©pertoires
$(OBJDIR) $(BINDIR):
	@mkdir -p $@

# Nettoyage
clean:
	@echo "üßπ Nettoyage..."
	rm -rf $(OBJDIR) $(BINDIR)

# Informations
info:
	@echo "Sources : $(words $(SOURCES)) fichiers"
	@echo "  $(SOURCES)"
	@echo "Objects : $(words $(OBJECTS)) fichiers"
	@echo "  $(OBJECTS)"
	@echo "Target  : $(TARGET)"

# Inclusion des d√©pendances
-include $(DEPS)
```

## Patterns Sp√©ciaux

### 1. Pattern Match-Anything

```makefile
# R√®gle pour TOUS les fichiers (dangereux !)
%:
	@echo "Pas de r√®gle pour cr√©er $@"
```

### 2. Pattern avec Sous-R√©pertoires

```makefile
# Compile tous les .c dans n'importe quel sous-r√©pertoire
obj/%.o: src/%.c
	@mkdir -p $(dir $@)
	$(CC) $(CFLAGS) -c $< -o $@

# Exemple : obj/network/client.o ‚Üê src/network/client.c
```

### 3. Pattern pour Tests

```makefile
# Compile et ex√©cute automatiquement les tests
test_%: test_%.c
	$(CC) $(CFLAGS) $< -o $@
	./$@
	@rm -f $@
```

## Astuces et Optimisations

### 1. Parall√©lisation

Les pattern rules fonctionnent parfaitement avec la compilation parall√®le :

```bash
# Compile jusqu'√† 8 fichiers en parall√®le
make -j8
```

### 2. Affichage Condens√©

```makefile
# Mode silencieux avec messages propres
%.o: %.c
	@echo "CC $*"
	@$(CC) $(CFLAGS) -c $< -o $@
```

### 3. Colorisation (optionnel)

```makefile
# Couleurs ANSI
RED = \033[0;31m
GREEN = \033[0;32m
NC = \033[0m  # No Color

%.o: %.c
	@echo "$(GREEN)Compiling $*...$(NC)"
	@$(CC) $(CFLAGS) -c $< -o $@
```

## Erreurs Courantes

### 1. Pattern Trop G√©n√©rique

```makefile
# ‚ùå PROBL√àME : Correspond √† TOUT
%: %.c
	gcc $< -o $@

# ‚úÖ SOLUTION : √ätre plus sp√©cifique
bin/%: src/%.c
	gcc $< -o $@
```

### 2. Oublier les D√©pendances sur Headers

```makefile
# ‚ùå PROBL√àME : Si utils.h change, ne recompile pas
%.o: %.c
	gcc -c $< -o $@

# ‚úÖ SOLUTION : Utiliser -MMD ou lister les headers
%.o: %.c
	gcc -MMD -c $< -o $@
```

### 3. Mauvais Ordre de Recherche

```makefile
# Pattern trop g√©n√©rique d√©finie avant
%: %.c
	gcc $< -o $@

# Cette pattern plus sp√©cifique ne sera jamais utilis√©e
%.o: %.c
	gcc -c $< -o $@

# ‚úÖ SOLUTION : D√©finir les patterns sp√©cifiques en premier
```

### 4. Oublier `|` pour Order-Only Prerequisites

```makefile
# ‚ùå PROBL√àME : Recompile si obj/ est modifi√© (touch)
$(OBJDIR)/%.o: %.c $(OBJDIR)
	gcc -c $< -o $@

# ‚úÖ SOLUTION : Utiliser | pour les r√©pertoires
$(OBJDIR)/%.o: %.c | $(OBJDIR)
	gcc -c $< -o $@
```

## Debugging de Pattern Rules

### Commandes Utiles

```bash
# Voir quelle r√®gle Make utilise
make -d

# Mode dry-run (affiche sans ex√©cuter)
make -n

# Afficher toutes les r√®gles (implicites + utilisateur)
make -p

# Afficher pourquoi Make reconstruit
make --debug=b
```

### Ajout de Traces

```makefile
%.o: %.c
	@echo "=== Pattern rule invoqu√©e ==="
	@echo "Cible: $@"
	@echo "Source: $<"
	@echo "Stem: $*"
	@echo "PWD: $(shell pwd)"
	$(CC) $(CFLAGS) -c $< -o $@
```

## R√©capitulatif : Variables Automatiques

| Variable | Valeur | Utilisation Typique |
|----------|--------|---------------------|
| `$@` | Cible compl√®te | Fichier de sortie |
| `$<` | Premi√®re d√©pendance | Fichier source |
| `$^` | Toutes d√©pendances | Linkage |
| `$?` | D√©pendances modifi√©es | Archivage incr√©mental |
| `$*` | Stem | Logs, affichage |
| `$(@D)` | R√©pertoire cible | `mkdir -p` |
| `$(<D)` | R√©pertoire source | Chemins complexes |

## R√©sum√©

| Concept | Syntaxe | Usage |
|---------|---------|-------|
| Pattern rule | `%.o: %.c` | R√®gle g√©n√©rique |
| Static pattern | `$(OBJS): %.o: %.c` | R√®gle limit√©e √† une liste |
| Variable cible | `$@` | Nom du fichier de sortie |
| Variable source | `$<` | Premier fichier d'entr√©e |
| Variable tous | `$^` | Tous les fichiers d'entr√©e |
| Variable stem | `$*` | Partie captur√©e par `%` |
| Modificateur dir | `$(@D)` | R√©pertoire du fichier |

## Bonnes Pratiques

1. ‚úÖ **Utiliser pattern rules** pour √©viter la r√©p√©tition
2. ‚úÖ **G√©n√©rer les d√©pendances automatiquement** avec `-MMD -MP`
3. ‚úÖ **Combiner avec variables automatiques** (`$@`, `$<`, `$^`)
4. ‚úÖ **Utiliser static pattern rules** pour les listes sp√©cifiques
5. ‚úÖ **Cr√©er les r√©pertoires avec** `| $(DIR)` (order-only)
6. ‚úÖ **Tester avec** `make -n` avant d'ex√©cuter
7. ‚úÖ **Documenter les patterns complexes**

## Prochaines √âtapes

Vous ma√Ætrisez maintenant les fondamentaux de GNU Make ! Les sections suivantes du chapitre couvriront :

- **13.3** : Comparaison Make vs CMake
- **13.4** : Autres syst√®mes de build (Ninja, Meson)
- **Chapitre 14** : Cr√©ation et gestion de biblioth√®ques

Avec les pattern rules et variables automatiques, vous pouvez maintenant √©crire des Makefiles professionnels, concis et maintenables pour des projets de toute taille.

---

**üìö R√©f√©rences :**
- `man make` : Section "Pattern Rules"
- [GNU Make Manual - Pattern Rules](https://www.gnu.org/software/make/manual/html_node/Pattern-Rules.html)
- [GNU Make Manual - Automatic Variables](https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html)

‚è≠Ô∏è [Comparaison Make vs CMake](/13-build-systems/03-make-vs-cmake.md)
