üîù Retour au [Sommaire](/SOMMAIRE.md)

# 30.1.6 Analyse Valgrind automatis√©e

## Introduction

**Valgrind** est une suite d'outils d'analyse dynamique consid√©r√©e comme le "gold standard" pour d√©tecter les probl√®mes de m√©moire et de performance dans les programmes C. Contrairement aux sanitizers qui n√©cessitent une recompilation, Valgrind **analyse directement votre binaire** sans modifier le code source.

Dans un pipeline CI/CD, l'automatisation de Valgrind permet de d√©tecter avec une **pr√©cision maximale** les fuites m√©moire, corruptions et probl√®mes de concurrence avant qu'ils n'atteignent la production.

---

## Qu'est-ce que Valgrind ?

### D√©finition

Valgrind est un **framework d'instrumentation** qui ex√©cute votre programme dans un environnement virtualis√© pour surveiller chaque acc√®s m√©moire, allocation et op√©ration syst√®me. C'est comme avoir un microscope ultra-puissant pour observer votre programme en action.

### Les outils Valgrind

Valgrind est compos√© de plusieurs outils sp√©cialis√©s :

#### 1. Memcheck (Le plus utilis√©) üî¥

**D√©tecte :**
- Fuites m√©moire (memory leaks)
- Utilisation de m√©moire non initialis√©e
- Acc√®s hors limites (buffer overflows)
- Use-after-free
- Double free
- D√©bordements de pile (stack overflow)

**Utilisation :** Tests quotidiens en CI

#### 2. Helgrind üîµ

**D√©tecte :**
- Race conditions
- Utilisation incorrecte de mutex
- Deadlocks potentiels

**Utilisation :** Programmes multi-thread

#### 3. Cachegrind & Callgrind üü¢

**Analyse :**
- Utilisation du cache CPU
- Appels de fonctions
- Profiling de performance

**Utilisation :** Optimisation de performance

#### 4. Massif üü°

**Analyse :**
- Utilisation de la m√©moire heap au fil du temps
- Profiling de consommation m√©moire

**Utilisation :** Optimisation m√©moire

---

## Valgrind vs Sanitizers : Quand utiliser quoi ?

| Crit√®re | Sanitizers | Valgrind |
|---------|-----------|----------|
| **Vitesse** | ‚úÖ 2-3x overhead | ‚ùå 20-50x overhead |
| **Pr√©cision** | ‚úÖ Tr√®s bonne | ‚úÖ Excellente |
| **Recompilation** | ‚ùå N√©cessaire | ‚úÖ Pas n√©cessaire |
| **Portabilit√©** | ‚úÖ Multiplateforme | ‚ö†Ô∏è Linux/macOS surtout |
| **CI quotidienne** | ‚úÖ Recommand√© | ‚ö†Ô∏è Trop lent |
| **Analyse approfondie** | ‚ö†Ô∏è Limit√©e | ‚úÖ Tr√®s compl√®te |

**Strat√©gie recommand√©e :**
- **CI rapide** : Sanitizers (ASan, UBSan) sur chaque commit
- **CI nocturne** : Valgrind pour analyse approfondie hebdomadaire
- **Debugging local** : Valgrind quand les sanitizers ne suffisent pas

---

## Installation de Valgrind

### Sur Ubuntu (dans le workflow)

```yaml
- name: Installer Valgrind
  run: |
    sudo apt-get update
    sudo apt-get install -y valgrind
```

### V√©rifier l'installation

```yaml
- name: V√©rifier la version de Valgrind
  run: valgrind --version
```

Sortie typique :
```
valgrind-3.19.0
```

---

## Memcheck : L'outil principal

### Syntaxe de base

```bash
valgrind --tool=memcheck ./mon_programme
```

**Options utiles :**

```bash
valgrind --tool=memcheck \
         --leak-check=full \
         --show-leak-kinds=all \
         --track-origins=yes \
         --verbose \
         ./mon_programme
```

**Explications :**

- `--tool=memcheck` : Utilise l'outil Memcheck (par d√©faut)
- `--leak-check=full` : Rapport d√©taill√© des fuites
- `--show-leak-kinds=all` : Affiche tous les types de fuites
- `--track-origins=yes` : Trace l'origine des valeurs non initialis√©es
- `--verbose` : Mode verbeux

---

## Exemple : D√©tecter une fuite m√©moire

### Code avec fuite

**leak.c**
```c
#include <stdlib.h>
#include <stdio.h>

void allocate_memory(void) {
    int *ptr = malloc(100 * sizeof(int));
    // Oups ! Pas de free()
    printf("Allocated 400 bytes\n");
}

int main(void) {
    for (int i = 0; i < 5; i++) {
        allocate_memory();
    }
    printf("Done\n");
    return 0;
}
```

### Compilation

```bash
gcc -g -o leak leak.c
```

**Note :** L'option `-g` est **essentielle** pour avoir des rapports lisibles avec num√©ros de ligne.

### Ex√©cution avec Valgrind

```bash
valgrind --leak-check=full ./leak
```

### Rapport Valgrind

```
==12345== Memcheck, a memory error detector
==12345== Command: ./leak
Allocated 400 bytes
Allocated 400 bytes
Allocated 400 bytes
Allocated 400 bytes
Allocated 400 bytes
Done

==12345== HEAP SUMMARY:
==12345==     in use at exit: 2,000 bytes in 5 blocks
==12345==   total heap usage: 6 allocs, 1 frees, 3,024 bytes allocated
==12345==
==12345== 2,000 bytes in 5 blocks are definitely lost in loss record 1 of 1
==12345==    at 0x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==12345==    by 0x108678: allocate_memory (leak.c:5)
==12345==    by 0x1086B5: main (leak.c:12)
==12345==
==12345== LEAK SUMMARY:
==12345==    definitely lost: 2,000 bytes in 5 blocks
==12345==    indirectly lost: 0 bytes in 0 blocks
==12345==      possibly lost: 0 bytes in 0 blocks
==12345==    still reachable: 0 bytes in 0 blocks
==12345==         suppressed: 0 bytes in 0 blocks
```

---

## Interpr√©ter un rapport Memcheck

### Les types de fuites

Valgrind classe les fuites en 4 cat√©gories :

#### 1. Definitely lost (D√©finitivement perdue) üî¥

```
definitely lost: 2,000 bytes in 5 blocks
```

**Signification :** M√©moire allou√©e sans aucune r√©f√©rence restante. **Vraie fuite √† corriger.**

#### 2. Indirectly lost (Indirectement perdue) üü†

```
indirectly lost: 500 bytes in 10 blocks
```

**Signification :** M√©moire accessible uniquement via de la m√©moire "definitely lost". Corriger la fuite principale corrigera celle-ci.

#### 3. Possibly lost (Possiblement perdue) üü°

```
possibly lost: 100 bytes in 2 blocks
```

**Signification :** Pointeurs internes (milieu d'un bloc). Peut √™tre intentionnel ou une fuite. √Ä investiguer.

#### 4. Still reachable (Toujours accessible) üü¢

```
still reachable: 1,024 bytes in 1 block
```

**Signification :** M√©moire accessible au moment de la sortie. Pas vraiment une fuite (sera lib√©r√©e par l'OS), mais une bonne pratique de faire `free()`.

### Heap Summary

```
HEAP SUMMARY:
    in use at exit: 2,000 bytes in 5 blocks
  total heap usage: 6 allocs, 1 frees, 3,024 bytes allocated
```

- **in use at exit** : M√©moire non lib√©r√©e √† la fin
- **total heap usage** : 6 allocations, 1 seul free
- **bytes allocated** : Total allou√© (inclut allocations internes)

---

## Workflow de base avec Valgrind

Voici un workflow minimal pour ex√©cuter Valgrind en CI :

```yaml
name: Analyse Valgrind

on: [push, pull_request]

jobs:
  valgrind:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout du code
      uses: actions/checkout@v4

    - name: Installer Valgrind
      run: |
        sudo apt-get update
        sudo apt-get install -y valgrind gcc cmake

    - name: Configurer le projet
      run: cmake -B build -DCMAKE_BUILD_TYPE=Debug

    - name: Compiler
      run: cmake --build build

    - name: Lancer Valgrind
      run: |
        valgrind --leak-check=full \
                 --error-exitcode=1 \
                 ./build/mon_app
```

**Option importante :** `--error-exitcode=1` fait √©chouer le workflow si Valgrind d√©tecte des erreurs.

---

## Valgrind avec CTest

CTest int√®gre nativement Valgrind. Voici comment l'utiliser :

### Configuration CMake

**CMakeLists.txt**
```cmake
enable_testing()

add_executable(test_app tests/test.c)
add_test(NAME test_app COMMAND test_app)
```

### Workflow avec CTest + Valgrind

```yaml
name: Tests avec Valgrind

on: [push, pull_request]

jobs:
  valgrind-tests:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4

    - name: Installer les outils
      run: |
        sudo apt-get update
        sudo apt-get install -y valgrind cmake gcc

    - name: Configurer
      run: cmake -B build -DCMAKE_BUILD_TYPE=Debug

    - name: Compiler
      run: cmake --build build

    - name: Lancer les tests avec Valgrind
      run: |
        cd build
        ctest -T memcheck --verbose

    - name: Afficher les r√©sultats Valgrind
      if: always()
      run: |
        if [ -f build/Testing/Temporary/MemoryChecker.*.log ]; then
          cat build/Testing/Temporary/MemoryChecker.*.log
        fi
```

**Commande CTest :**
- `ctest -T memcheck` : Lance les tests avec Valgrind (Memcheck)
- Les rapports sont dans `Testing/Temporary/MemoryChecker.*.log`

---

## Options Valgrind avanc√©es

### G√©n√©ration de rapport XML

Pour un parsing automatique des r√©sultats :

```yaml
- name: Valgrind avec rapport XML
  run: |
    valgrind --leak-check=full \
             --xml=yes \
             --xml-file=valgrind-report.xml \
             --error-exitcode=1 \
             ./build/mon_app

- name: Uploader le rapport
  if: always()
  uses: actions/upload-artifact@v4
  with:
    name: valgrind-report
    path: valgrind-report.xml
```

### Fichier de suppressions

Pour ignorer les faux positifs connus :

**valgrind.supp**
```
{
   Ignore_libc_malloc
   Memcheck:Leak
   fun:malloc
   obj:/lib/x86_64-linux-gnu/libc.so.6
}
```

**Utilisation :**
```yaml
- name: Valgrind avec suppressions
  run: |
    valgrind --leak-check=full \
             --suppressions=valgrind.supp \
             ./build/mon_app
```

### Limiter les rapports

```bash
valgrind --leak-check=full \
         --show-leak-kinds=definite \  # Seulement les vraies fuites
         --errors-for-leak-kinds=definite \
         ./mon_app
```

---

## Exemple : Use-after-free

### Code avec bug

```c
#include <stdlib.h>
#include <stdio.h>

int main(void) {
    int *ptr = malloc(sizeof(int));
    *ptr = 42;
    printf("Value: %d\n", *ptr);

    free(ptr);

    // Bug : utilisation apr√®s lib√©ration
    *ptr = 99;
    printf("New value: %d\n", *ptr);

    return 0;
}
```

### Rapport Valgrind

```
==12345== Invalid write of size 4
==12345==    at 0x108678: main (use_after_free.c:11)
==12345==  Address 0x5204040 is 0 bytes inside a block of size 4 free'd
==12345==    at 0x4C30D3B: free (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==12345==    by 0x108670: main (use_after_free.c:9)
==12345==  Block was alloc'd at
==12345==    at 0x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==12345==    by 0x108650: main (use_after_free.c:5)
```

**Le rapport montre :**
1. Type d'erreur : `Invalid write of size 4`
2. O√π l'erreur se produit : ligne 11
3. O√π la m√©moire a √©t√© lib√©r√©e : ligne 9
4. O√π elle a √©t√© allou√©e : ligne 5

---

## Exemple : Buffer overflow

### Code avec bug

```c
#include <stdlib.h>
#include <string.h>

int main(void) {
    char *buffer = malloc(10);
    strcpy(buffer, "This is a very long string");  // D√©passe 10 !
    free(buffer);
    return 0;
}
```

### Rapport Valgrind

```
==12345== Invalid write of size 1
==12345==    at 0x4C32CF2: strcpy (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==12345==    by 0x108678: main (overflow.c:6)
==12345==  Address 0x520404a is 0 bytes after a block of size 10 alloc'd
==12345==    at 0x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==12345==    by 0x108670: main (overflow.c:5)
```

---

## Workflow complet avec options avanc√©es

```yaml
name: Analyse Valgrind Compl√®te

on:
  schedule:
    - cron: '0 2 * * *'  # Tous les jours √† 2h du matin
  workflow_dispatch:      # Possibilit√© de lancer manuellement

jobs:
  valgrind-full-analysis:
    runs-on: ubuntu-latest
    timeout-minutes: 60  # Valgrind est lent !

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Installer Valgrind et outils
      run: |
        sudo apt-get update
        sudo apt-get install -y valgrind gcc cmake

    - name: Configurer en Debug avec symboles
      run: |
        cmake -B build \
          -DCMAKE_BUILD_TYPE=Debug \
          -DCMAKE_C_FLAGS="-g -O0"

    - name: Compiler
      run: cmake --build build

    - name: Cr√©er le r√©pertoire de rapports
      run: mkdir -p valgrind-reports

    - name: Lancer Memcheck (fuites m√©moire)
      continue-on-error: true
      run: |
        valgrind --tool=memcheck \
                 --leak-check=full \
                 --show-leak-kinds=all \
                 --track-origins=yes \
                 --verbose \
                 --log-file=valgrind-reports/memcheck.log \
                 ./build/mon_app

    - name: Lancer avec tests CTest
      continue-on-error: true
      run: |
        cd build
        ctest -T memcheck --verbose

    - name: Afficher le r√©sum√© Memcheck
      if: always()
      run: |
        echo "=== R√©sum√© Valgrind Memcheck ==="
        if [ -f valgrind-reports/memcheck.log ]; then
          grep "LEAK SUMMARY" -A 5 valgrind-reports/memcheck.log || echo "Pas de fuites d√©tect√©es"
        fi

    - name: V√©rifier les erreurs
      run: |
        if grep -q "ERROR SUMMARY: [1-9]" valgrind-reports/memcheck.log; then
          echo "‚ùå Erreurs d√©tect√©es par Valgrind"
          exit 1
        else
          echo "‚úÖ Aucune erreur d√©tect√©e"
        fi

    - name: Uploader tous les rapports
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: valgrind-reports
        path: |
          valgrind-reports/
          build/Testing/Temporary/MemoryChecker.*.log
```

**Points cl√©s :**

- `schedule: cron:` : Ex√©cution automatique nocturne (Valgrind est lent)
- `timeout-minutes: 60` : Limite le temps d'ex√©cution
- `continue-on-error: true` : Continue m√™me si Valgrind trouve des erreurs
- Upload des rapports pour analyse ult√©rieure

---

## Helgrind : D√©tecter les race conditions

Pour les programmes multi-thread, utilisez Helgrind :

```yaml
- name: Analyser les race conditions avec Helgrind
  run: |
    valgrind --tool=helgrind \
             --log-file=helgrind-report.log \
             ./build/mon_app_multithread
```

### Exemple de code avec race condition

```c
#include <pthread.h>
#include <stdio.h>

int counter = 0;  // Variable partag√©e non prot√©g√©e

void *increment(void *arg) {
    for (int i = 0; i < 100000; i++) {
        counter++;  // Race condition !
    }
    return NULL;
}

int main(void) {
    pthread_t t1, t2;
    pthread_create(&t1, NULL, increment, NULL);
    pthread_create(&t2, NULL, increment, NULL);
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    printf("Counter: %d\n", counter);
    return 0;
}
```

### Rapport Helgrind

```
==12345== Possible data race during write of size 4 at 0x601044 by thread #2
==12345==    at 0x108678: increment (race.c:7)
==12345==  This conflicts with a previous write of size 4 by thread #1
==12345==    at 0x108678: increment (race.c:7)
==12345==  Address 0x601044 is 0 bytes inside data symbol "counter"
```

---

## Cachegrind : Profiling de cache

Pour analyser l'utilisation du cache CPU :

```yaml
- name: Analyser les performances du cache
  run: |
    valgrind --tool=cachegrind \
             --cachegrind-out-file=cachegrind.out \
             ./build/mon_app

    # Annoter le code source avec les statistiques
    cg_annotate cachegrind.out > cachegrind-report.txt
```

**Sortie typique :**
```
I   refs:      10,000,000
I1  misses:        10,234
LLi misses:         1,234
D   refs:       5,000,000
D1  misses:       234,567
LLd misses:        12,345
```

**Utile pour :** Optimiser les structures de donn√©es pour une meilleure localit√© du cache.

---

## Callgrind : Profiling d'appels de fonction

Pour identifier les fonctions co√ªteuses :

```yaml
- name: Profiling avec Callgrind
  run: |
    valgrind --tool=callgrind \
             --callgrind-out-file=callgrind.out \
             ./build/mon_app

    # G√©n√©rer un rapport texte
    callgrind_annotate callgrind.out > callgrind-report.txt
```

**Visualisation graphique :**

Vous pouvez aussi utiliser **KCachegrind** (en local, pas en CI) pour visualiser les r√©sultats graphiquement.

---

## Massif : Profiling de m√©moire heap

Pour analyser l'√©volution de la consommation m√©moire :

```yaml
- name: Profiling m√©moire avec Massif
  run: |
    valgrind --tool=massif \
             --massif-out-file=massif.out \
             ./build/mon_app

    # Visualiser le graphique en texte
    ms_print massif.out > massif-report.txt
```

**Sortie typique :**
```
    KB
19.71^                                                                       #
     |                                                                       #
     |                                                                       #
     |                                                                       #
     |                                                                      :#
     |                                                                     @:#
     |                                                                    :@:#
     |                                                                   ::@:#
     |                                                                  @::@:#
```

**Utile pour :** D√©tecter les pics de consommation m√©moire et optimiser.

---

## Matrice de workflows : Tous les outils

```yaml
name: Analyse Valgrind Compl√®te

on:
  schedule:
    - cron: '0 3 * * 0'  # Dimanche √† 3h (analyse hebdomadaire)

jobs:
  valgrind-analysis:
    name: ${{ matrix.tool }}
    runs-on: ubuntu-latest
    timeout-minutes: 90

    strategy:
      fail-fast: false
      matrix:
        tool:
          - name: memcheck
            command: --tool=memcheck --leak-check=full --show-leak-kinds=all

          - name: helgrind
            command: --tool=helgrind

          - name: cachegrind
            command: --tool=cachegrind

          - name: callgrind
            command: --tool=callgrind

          - name: massif
            command: --tool=massif

    steps:
    - uses: actions/checkout@v4

    - name: Installer Valgrind
      run: |
        sudo apt-get update
        sudo apt-get install -y valgrind gcc cmake

    - name: Configurer
      run: cmake -B build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_C_FLAGS="-g -O0"

    - name: Compiler
      run: cmake --build build

    - name: Ex√©cuter ${{ matrix.tool.name }}
      run: |
        valgrind ${{ matrix.tool.command }} \
                 --log-file=${{ matrix.tool.name }}-report.log \
                 ./build/mon_app

    - name: Uploader le rapport
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: valgrind-${{ matrix.tool.name }}
        path: ${{ matrix.tool.name }}-report.log
```

---

## Optimisation : Valgrind seulement si n√©cessaire

Pour ne pas ralentir votre CI quotidienne :

```yaml
name: CI avec Valgrind conditionnel

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  # Tests rapides avec sanitizers (toujours)
  quick-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Tests avec ASan
        run: |
          cmake -B build -DCMAKE_C_FLAGS="-fsanitize=address -g"
          cmake --build build
          cd build && ctest

  # Valgrind seulement sur main ou si demand√©
  valgrind-analysis:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || contains(github.event.head_commit.message, '[valgrind]')
    steps:
      - uses: actions/checkout@v4
      - name: Analyse Valgrind
        run: |
          sudo apt-get install -y valgrind
          cmake -B build -DCMAKE_BUILD_TYPE=Debug
          cmake --build build
          valgrind --leak-check=full ./build/mon_app
```

**D√©clencheurs :**
- Toujours sur la branche `main`
- Sur les autres branches si le commit contient `[valgrind]`

---

## Gestion des faux positifs

### Cr√©er un fichier de suppressions

**valgrind.supp**
```
# Supprimer les fuites de la libc (faux positifs connus)
{
   libc_dlopen_leak
   Memcheck:Leak
   ...
   fun:__libc_dlopen_mode
}

# Supprimer les fuites de pthread
{
   pthread_create_leak
   Memcheck:Leak
   ...
   fun:pthread_create@@GLIBC_*
}
```

**Utilisation dans le workflow :**

```yaml
- name: Valgrind avec suppressions
  run: |
    valgrind --leak-check=full \
             --suppressions=valgrind.supp \
             --gen-suppressions=all \
             ./build/mon_app
```

**Option `--gen-suppressions=all`** : G√©n√®re automatiquement les suppressions pour vous.

---

## Interpr√©ter "ERROR SUMMARY"

√Ä la fin de chaque rapport Valgrind :

```
ERROR SUMMARY: 5 errors from 3 contexts (suppressed: 0 from 0)
```

**Signification :**
- **5 errors** : Nombre total d'erreurs d√©tect√©es
- **3 contexts** : Nombre de sources diff√©rentes d'erreurs
- **suppressed: 0** : Aucune erreur supprim√©e par les fichiers .supp

**Objectif en CI :** `ERROR SUMMARY: 0 errors`

---

## Badge de statut Valgrind

Ajoutez un badge dans votre README pour afficher le statut :

```markdown
![Valgrind](https://github.com/username/repo/actions/workflows/valgrind.yml/badge.svg)
```

---

## Bonnes pratiques

### 1. Compiler avec symboles de debug

```bash
-g -O0  # Symboles complets, pas d'optimisation
```

Sans `-g`, Valgrind ne peut pas afficher les num√©ros de ligne.

### 2. D√©sactiver les optimisations

```bash
-O0  # Facilite le debugging
```

`-O2` ou `-O3` peuvent masquer certains bugs.

### 3. Utiliser --error-exitcode

```bash
valgrind --error-exitcode=1 ./app
```

Fait √©chouer le script CI si des erreurs sont d√©tect√©es.

### 4. Limiter l'analyse aux vraies fuites

```bash
--show-leak-kinds=definite --errors-for-leak-kinds=definite
```

Ignore "still reachable" qui n'est g√©n√©ralement pas probl√©matique.

### 5. Tester avec des donn√©es r√©alistes

Valgrind d√©tecte les erreurs **pendant l'ex√©cution**. Assurez-vous que vos tests couvrent tous les chemins de code.

### 6. Combiner avec les sanitizers

**Strat√©gie recommand√©e :**

| Fr√©quence | Outil | Utilisation |
|-----------|-------|-------------|
| Chaque commit | ASan + UBSan | Tests rapides |
| Quotidien | TSan | Si multi-thread |
| Hebdomadaire | Valgrind | Analyse approfondie |

### 7. Timeout appropri√©

```yaml
timeout-minutes: 60  # Valgrind est 20-50x plus lent
```

---

## Erreurs courantes et solutions

### Erreur : "Valgrind: command not found"

**Solution :**
```yaml
- name: Installer Valgrind
  run: sudo apt-get install -y valgrind
```

### Erreur : Rapports illisibles (pas de symboles)

**Solution :** Compiler avec `-g` :
```bash
gcc -g -o app main.c
```

### Valgrind trop lent

**Solutions :**
1. Ex√©cuter en nocturne ou hebdomadaire
2. Limiter aux tests critiques
3. Utiliser `--leak-check=no` si seuls les acc√®s invalides comptent

### Trop de faux positifs

**Solution :** Cr√©er un fichier de suppressions (voir section pr√©c√©dente)

### Tests qui timeout

**Solution :**
```yaml
timeout-minutes: 120  # Augmenter la limite
```

---

## Debugging avec Valgrind en local

Avant de mettre en CI, testez localement :

```bash
# 1. Compiler avec symboles
gcc -g -O0 -o app main.c

# 2. Lancer Valgrind
valgrind --leak-check=full \
         --show-leak-kinds=all \
         --track-origins=yes \
         --verbose \
         --log-file=valgrind.log \
         ./app

# 3. Consulter le rapport
cat valgrind.log
```

---

## Int√©gration avec d'autres outils

### Avec Codecov (couverture de code)

```yaml
- name: Tests avec couverture
  run: |
    cmake -B build -DCMAKE_C_FLAGS="-g -O0 --coverage"
    cmake --build build
    valgrind --leak-check=full ./build/tests
    gcov build/CMakeFiles/mon_app.dir/src/*.c
```

### Avec clang-tidy (analyse statique)

```yaml
- name: Analyse statique puis dynamique
  run: |
    clang-tidy src/*.c
    cmake -B build
    cmake --build build
    valgrind --leak-check=full ./build/mon_app
```

---

## Template de workflow production-ready

Voici un workflow complet et optimis√© :

```yaml
name: Analyse Valgrind Hebdomadaire

on:
  schedule:
    - cron: '0 2 * * 0'  # Dimanche √† 2h
  workflow_dispatch:

jobs:
  valgrind-memcheck:
    name: Valgrind Memcheck
    runs-on: ubuntu-22.04
    timeout-minutes: 90

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Cache Valgrind
      uses: actions/cache@v4
      with:
        path: /usr/bin/valgrind
        key: valgrind-3.19

    - name: Installer les d√©pendances
      run: |
        sudo apt-get update
        sudo apt-get install -y valgrind gcc cmake

    - name: V√©rifier Valgrind
      run: valgrind --version

    - name: Configurer le build
      run: |
        cmake -B build \
          -DCMAKE_BUILD_TYPE=Debug \
          -DCMAKE_C_FLAGS="-g -O0"

    - name: Compiler
      run: cmake --build build -j$(nproc)

    - name: Ex√©cuter Valgrind Memcheck
      id: valgrind
      continue-on-error: true
      run: |
        valgrind --tool=memcheck \
                 --leak-check=full \
                 --show-leak-kinds=all \
                 --track-origins=yes \
                 --error-exitcode=1 \
                 --log-file=valgrind-memcheck.log \
                 ./build/mon_app || echo "VALGRIND_FAILED=true" >> $GITHUB_ENV

    - name: Analyser les r√©sultats
      run: |
        echo "=== HEAP SUMMARY ==="
        grep "HEAP SUMMARY" -A 5 valgrind-memcheck.log

        echo ""
        echo "=== LEAK SUMMARY ==="
        grep "LEAK SUMMARY" -A 5 valgrind-memcheck.log

        echo ""
        echo "=== ERROR SUMMARY ==="
        grep "ERROR SUMMARY" valgrind-memcheck.log

    - name: V√©rifier les erreurs critiques
      run: |
        if grep -q "definitely lost: [1-9]" valgrind-memcheck.log; then
          echo "‚ùå Fuites m√©moire d√©tect√©es !"
          exit 1
        fi

        if grep -q "ERROR SUMMARY: [1-9]" valgrind-memcheck.log; then
          echo "‚ùå Erreurs m√©moire d√©tect√©es !"
          exit 1
        fi

        echo "‚úÖ Aucune fuite ou erreur d√©tect√©e"

    - name: Uploader le rapport complet
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: valgrind-report
        path: valgrind-memcheck.log
        retention-days: 30

    - name: Cr√©er une issue si √©chec
      if: failure()
      uses: actions/github-script@v7
      with:
        script: |
          github.rest.issues.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: '‚ö†Ô∏è Valgrind a d√©tect√© des probl√®mes m√©moire',
            body: 'Le workflow Valgrind hebdomadaire a √©chou√©. Consultez les artifacts pour les d√©tails.',
            labels: ['bug', 'memory-leak']
          })
```

---

## R√©sum√©

**Valgrind : L'analyse la plus pr√©cise**

**Outils principaux :**
- **Memcheck** : Fuites et erreurs m√©moire (le plus important)
- **Helgrind** : Race conditions (multi-thread)
- **Cachegrind** : Profiling cache
- **Callgrind** : Profiling appels de fonction
- **Massif** : Profiling consommation m√©moire

**Commande minimale :**
```bash
valgrind --leak-check=full --error-exitcode=1 ./app
```

**Strat√©gie CI recommand√©e :**
- **Quotidien** : Sanitizers (rapides)
- **Hebdomadaire** : Valgrind (pr√©cis mais lent)

---

## Prochaines √©tapes

Maintenant que vous avez automatis√© Valgrind, vous pouvez :

- Mesurer la **couverture de code** avec gcov/lcov
- Configurer l'**analyse statique** avec clang-tidy/cppcheck
- Cr√©er des **rapports de tests** pour la PR
- Publier des **artifacts** de release

Ces sujets sont couverts dans les sections suivantes.

---

## Ressources compl√©mentaires

- [Valgrind Quick Start](https://valgrind.org/docs/manual/quick-start.html)
- [Memcheck Manual](https://valgrind.org/docs/manual/mc-manual.html)
- [Helgrind Manual](https://valgrind.org/docs/manual/hg-manual.html)
- [Valgrind FAQ](https://valgrind.org/docs/manual/faq.html)

---

**üéØ Points cl√©s √† retenir :**

- ‚úÖ Valgrind est le "gold standard" pour la d√©tection de bugs m√©moire
- ‚úÖ Memcheck est l'outil principal (fuites, use-after-free, buffer overflow)
- ‚úÖ Overhead de 20-50x : utiliser en analyse nocturne/hebdomadaire
- ‚úÖ Compiler avec `-g -O0` pour des rapports lisibles
- ‚úÖ `--error-exitcode=1` pour faire √©chouer la CI si erreurs
- ‚úÖ CTest int√®gre Valgrind avec `ctest -T memcheck`
- ‚úÖ Combiner avec sanitizers : ASan quotidien, Valgrind hebdomadaire
- ‚úÖ Objectif : `ERROR SUMMARY: 0 errors` et `definitely lost: 0 bytes`

‚è≠Ô∏è [Code coverage et Codecov](/30-integration-continue/01.7-code-coverage-codecov.md)
