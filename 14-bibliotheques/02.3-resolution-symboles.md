ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 14.2.3 RÃ©solution de symboles au runtime

## Introduction

Lorsque vous exÃ©cutez un programme qui utilise des bibliothÃ¨ques partagÃ©es, un processus complexe et fascinant se dÃ©roule en coulisses : la **rÃ©solution de symboles au runtime**. Contrairement aux bibliothÃ¨ques statiques oÃ¹ tout est copiÃ© dans l'exÃ©cutable Ã  la compilation, les bibliothÃ¨ques dynamiques nÃ©cessitent un mÃ©canisme pour "connecter" les appels de fonctions aux bonnes adresses mÃ©moire **pendant l'exÃ©cution** du programme.

Dans cette section, nous allons dÃ©couvrir comment fonctionne ce mÃ©canisme, qui y participe, et comment vous pouvez le contrÃ´ler.

---

## Qu'est-ce qu'un symbole ?

### DÃ©finition

Un **symbole** est simplement un **nom** dans votre code :
- Nom de fonction (ex: `printf`, `malloc`, `addition`)
- Nom de variable globale (ex: `errno`, `global_counter`)

### Types de symboles

```c
// DiffÃ©rents types de symboles

// 1. Symbole de fonction dÃ©fini localement
int addition(int a, int b) {
    return a + b;
}

// 2. Symbole de fonction externe (dÃ©fini ailleurs)
extern int multiplication(int a, int b);

// 3. Symbole de variable globale
int global_counter = 0;

// 4. Symbole externe (de la libc par exemple)
extern int printf(const char *format, ...);
```

### Table des symboles

Chaque fichier objet (`.o`) et bibliothÃ¨que contient une **table des symboles** qui liste :
- Les symboles **dÃ©finis** (fournis par ce fichier)
- Les symboles **non dÃ©finis** (rÃ©fÃ©rencÃ©s mais fournis ailleurs)

**Visualisation avec `nm` :**
```bash
nm -D /lib/x86_64-linux-gnu/libc.so.6 | head
```

Sortie exemple :
```
000000000001d3a0 T printf          â† T = dÃ©fini dans .text (code)
                 U malloc          â† U = undefined (rÃ©fÃ©rencÃ©)
0000000000001500 W strcpy          â† W = weak (peut Ãªtre Ã©crasÃ©)
```

**LÃ©gende des symboles :**
- `T` : Symbole dÃ©fini dans la section `.text` (code)
- `D` : Symbole dÃ©fini dans la section `.data` (donnÃ©es initialisÃ©es)
- `B` : Symbole dÃ©fini dans la section `.bss` (donnÃ©es non initialisÃ©es)
- `U` : Symbole non dÃ©fini (undefined) - doit Ãªtre rÃ©solu
- `W` : Symbole faible (weak) - peut Ãªtre remplacÃ©

---

## Les acteurs de la rÃ©solution

### 1. Le loader dynamique (`ld.so` ou `ld-linux.so`)

C'est le **chef d'orchestre** de la rÃ©solution de symboles. Il :
- Charge les bibliothÃ¨ques partagÃ©es en mÃ©moire
- RÃ©sout les symboles non dÃ©finis
- Met Ã  jour les adresses dans le programme

**Localisation :**
```bash
# Sur Linux 64-bit
ls -l /lib64/ld-linux-x86-64.so.2
```

**Comment le voir en action :**
```bash
# Afficher quel loader est utilisÃ©
readelf -l programme | grep interpreter
```

Sortie :
```
[Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
```

### 2. La PLT (Procedure Linkage Table)

**Table de liaison de procÃ©dures** - Un mÃ©canisme de redirection pour les appels de fonctions.

### 3. La GOT (Global Offset Table)

**Table de dÃ©calage globale** - Contient les adresses rÃ©elles des fonctions/variables.

### 4. Le programme lui-mÃªme

Contient des rÃ©fÃ©rences Ã  rÃ©soudre vers des fonctions externes.

---

## Le processus de rÃ©solution : Vue d'ensemble

### SchÃ©ma conceptuel

```
ExÃ©cution de : ./programme
        â”‚
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. Kernel lance le loader dynamique        â”‚
â”‚    /lib64/ld-linux-x86-64.so.2             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. Le loader lit les dÃ©pendances           â”‚
â”‚    (via NEEDED entries dans l'ELF)         â”‚
â”‚    - libmath.so.1                          â”‚
â”‚    - libc.so.6                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. Chargement des bibliothÃ¨ques en mÃ©moire â”‚
â”‚    Programme     : 0x00400000              â”‚
â”‚    libmath.so.1  : 0x7f1234000000          â”‚
â”‚    libc.so.6     : 0x7f1235000000          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4. RÃ©solution des symboles                 â”‚
â”‚    addition()  â†’ 0x7f1234001234            â”‚
â”‚    printf()    â†’ 0x7f1235005678            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 5. Mise Ã  jour de la GOT                   â”‚
â”‚    (adresses rÃ©elles des fonctions)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 6. Transfert du contrÃ´le Ã  main()          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## PLT et GOT : Le mÃ©canisme technique

### ProblÃ¨me Ã  rÃ©soudre

Quand vous Ã©crivez :
```c
printf("Hello\n");
```

Le compilateur ne connaÃ®t pas l'adresse de `printf()` car elle est dans `libc.so.6`, qui sera chargÃ©e Ã  une adresse diffÃ©rente Ã  chaque exÃ©cution (grÃ¢ce Ã  ASLR).

**Question :** Comment faire l'appel ?

### Solution : PLT + GOT

#### La PLT (Procedure Linkage Table)

C'est un **stub** (bout de code intermÃ©diaire) pour chaque fonction externe.

```
Code du programme :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ call printf      â”‚ â”€â”€â”
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
                       â”‚
                       â”‚  Redirige vers la PLT
                       â”‚
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PLT entry pour printf:       â”‚
â”‚   jmp *GOT[printf]           â”‚ â† Saute Ã  l'adresse dans la GOT
â”‚   push index                 â”‚
â”‚   jmp resolver               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â”‚  Lit l'adresse
                       â”‚
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ GOT (Global Offset Table):   â”‚
â”‚   GOT[printf] = 0x7f...      â”‚ â† Adresse rÃ©elle de printf()
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â”‚  Saute vers
                       â”‚
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Code rÃ©el de printf()        â”‚
â”‚ dans libc.so.6               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Lazy Binding (Liaison paresseuse)

Par dÃ©faut, Linux utilise le **lazy binding** : les symboles sont rÃ©solus **Ã  la premiÃ¨re utilisation**, pas au dÃ©marrage.

#### Premier appel (symbole non rÃ©solu)

```
1. programme appelle printf()
2. PLT: jmp *GOT[printf]
3. GOT[printf] contient... l'adresse de la PLT elle-mÃªme ! (boucle)
4. PLT: push index de printf
5. PLT: jmp vers le resolver du loader
6. Loader: rÃ©sout printf(), trouve son adresse
7. Loader: met Ã  jour GOT[printf] avec la vraie adresse
8. Loader: saute vers printf()
9. printf() s'exÃ©cute
```

#### Appels suivants (symbole rÃ©solu)

```
1. programme appelle printf()
2. PLT: jmp *GOT[printf]
3. GOT[printf] contient maintenant la vraie adresse !
4. Saut direct vers printf()
5. printf() s'exÃ©cute
```

**Avantage :** Si une fonction n'est jamais appelÃ©e, elle n'est jamais rÃ©solue (gain de temps au dÃ©marrage).

### Visualisation des PLT/GOT

```bash
# Voir la PLT d'un programme
objdump -d programme | grep @plt

# Voir la section GOT
readelf -r programme | grep -A 20 "Relocation section '.rela.plt'"
```

Sortie exemple :
```
0000000000003fd8  000300000007 R_X86_64_JUMP_SLOT 0000000000000000 printf@GLIBC_2.2.5 + 0
0000000000003fe0  000400000007 R_X86_64_JUMP_SLOT 0000000000000000 addition + 0
```

---

## Les deux modes de binding

### 1. Lazy Binding (mode par dÃ©faut)

**RÃ©solution Ã  la premiÃ¨re utilisation.**

```bash
# Comportement par dÃ©faut
gcc main.c -lmath -o programme
./programme
```

**Avantages :**
- âœ… DÃ©marrage plus rapide
- âœ… Fonctions non utilisÃ©es jamais rÃ©solues

**InconvÃ©nients :**
- âŒ LÃ©gÃ¨re latence au premier appel
- âŒ Erreurs de symbole dÃ©tectÃ©es tard (Ã  l'utilisation)

### 2. Eager Binding (rÃ©solution immÃ©diate)

**RÃ©solution de tous les symboles au dÃ©marrage.**

#### Option 1 : Variable d'environnement

```bash
LD_BIND_NOW=1 ./programme
```

#### Option 2 : Compilation avec `-z now`

```bash
gcc main.c -lmath -Wl,-z,now -o programme
```

**Avantages :**
- âœ… Erreurs dÃ©tectÃ©es immÃ©diatement
- âœ… Pas de latence au premier appel
- âœ… Plus sÃ©curisÃ© (protÃ¨ge contre certaines attaques)

**InconvÃ©nients :**
- âŒ DÃ©marrage plus lent
- âŒ RÃ©sout mÃªme les fonctions jamais utilisÃ©es

### Comparaison de performance

```bash
# Mesurer le temps de dÃ©marrage

# Lazy binding (dÃ©faut)
time ./programme

# Eager binding
time LD_BIND_NOW=1 ./programme
```

Pour un programme avec 100 bibliothÃ¨ques, la diffÃ©rence peut Ãªtre de **plusieurs millisecondes**.

---

## Ordre de recherche des bibliothÃ¨ques

### OÃ¹ le loader cherche-t-il les `.so` ?

Le loader dynamique cherche dans cet ordre :

1. **RPATH** (compilation)
2. **LD_LIBRARY_PATH** (environnement)
3. **RUNPATH** (compilation)
4. **`/etc/ld.so.cache`** (cache systÃ¨me)
5. **RÃ©pertoires par dÃ©faut** (`/lib`, `/usr/lib`)

### 1. RPATH (hardcodÃ© dans l'exÃ©cutable)

DÃ©fini Ã  la compilation avec `-Wl,-rpath` :

```bash
gcc main.c -L/opt/mylib -lmath -Wl,-rpath,/opt/mylib -o programme
```

**VÃ©rification :**
```bash
readelf -d programme | grep RPATH
```

Sortie :
```
 0x000000000000000f (RPATH)              Library rpath: [/opt/mylib]
```

**CaractÃ©ristiques :**
- âœ… PrioritÃ© maximale
- âœ… Portable avec le binaire
- âŒ Difficile Ã  changer sans recompilation

### 2. LD_LIBRARY_PATH (variable d'environnement)

DÃ©finie avant l'exÃ©cution :

```bash
export LD_LIBRARY_PATH=/home/user/mylibs:/opt/libs
./programme
```

Ou en une ligne :
```bash
LD_LIBRARY_PATH=/home/user/mylibs ./programme
```

**CaractÃ©ristiques :**
- âœ… Flexible, facile Ã  changer
- âœ… Utile pour le dÃ©veloppement
- âŒ Peut casser d'autres programmes
- âš ï¸ IgnorÃ© pour les binaires setuid (sÃ©curitÃ©)

**Voir la valeur actuelle :**
```bash
echo $LD_LIBRARY_PATH
```

### 3. RUNPATH (alternative moderne Ã  RPATH)

DÃ©fini avec `-Wl,-rpath` et `--enable-new-dtags` :

```bash
gcc main.c -L/opt/mylib -lmath -Wl,-rpath,/opt/mylib -Wl,--enable-new-dtags -o programme
```

**DiffÃ©rence avec RPATH :**
- RUNPATH est consultÃ© **aprÃ¨s** `LD_LIBRARY_PATH`
- RPATH est consultÃ© **avant** `LD_LIBRARY_PATH`

### 4. Cache systÃ¨me (`/etc/ld.so.cache`)

Mis Ã  jour par `ldconfig` :

```bash
sudo ldconfig
```

**Voir le cache :**
```bash
ldconfig -p | grep libmath
```

### 5. RÃ©pertoires par dÃ©faut

- `/lib`
- `/lib64`
- `/usr/lib`
- `/usr/lib64`
- `/usr/local/lib`

**Configuration :**
```bash
cat /etc/ld.so.conf
cat /etc/ld.so.conf.d/*
```

### Ordre de prioritÃ© complet

```
1. RPATH (si dÃ©fini)
   â†“ pas trouvÃ©
2. LD_LIBRARY_PATH (si dÃ©fini)
   â†“ pas trouvÃ©
3. RUNPATH (si dÃ©fini)
   â†“ pas trouvÃ©
4. /etc/ld.so.cache
   â†“ pas trouvÃ©
5. /lib, /usr/lib, etc.
   â†“ pas trouvÃ©
âŒ Erreur: cannot open shared object file
```

---

## Variables d'environnement utiles

### `LD_LIBRARY_PATH`

Ajoute des rÃ©pertoires de recherche :

```bash
LD_LIBRARY_PATH=/path/to/libs:$LD_LIBRARY_PATH ./programme
```

### `LD_PRELOAD`

**Force le chargement d'une bibliothÃ¨que en premier.**

C'est une technique puissante pour intercepter des fonctions !

**Exemple : Intercepter `malloc()`**

**Fichier `mymalloc.c` :**
```c
#define _GNU_SOURCE
#include <stdio.h>
#include <dlfcn.h>

void *malloc(size_t size) {
    // Obtenir le vrai malloc
    static void *(*real_malloc)(size_t) = NULL;
    if (!real_malloc) {
        real_malloc = dlsym(RTLD_NEXT, "malloc");
    }

    // Logger l'appel
    printf("malloc(%zu) appelÃ©\n", size);

    // Appeler le vrai malloc
    return real_malloc(size);
}
```

**Compilation :**
```bash
gcc -shared -fPIC mymalloc.c -ldl -o mymalloc.so
```

**Utilisation :**
```bash
LD_PRELOAD=./mymalloc.so ./programme
```

Maintenant, chaque appel Ã  `malloc()` passera par votre fonction !

**Cas d'usage :**
- Debugging (tracer les appels)
- Profiling (mesurer les performances)
- Testing (mocker des fonctions)
- Hacking (modifier le comportement d'un programme)

### `LD_DEBUG`

Active le mode debug du loader pour voir ce qu'il fait :

```bash
# Voir toutes les bibliothÃ¨ques chargÃ©es
LD_DEBUG=libs ./programme

# Voir toutes les rÃ©solutions de symboles
LD_DEBUG=symbols ./programme

# Voir les relocations
LD_DEBUG=reloc ./programme

# Voir tout
LD_DEBUG=all ./programme 2>&1 | less
```

Exemple de sortie :
```
     17845:	symbol=printf;  lookup in file=./programme [0]
     17845:	symbol=printf;  lookup in file=/lib/x86_64-linux-gnu/libc.so.6 [0]
     17845:	binding file ./programme [0] to /lib/x86_64-linux-gnu/libc.so.6 [0]: normal symbol `printf'
```

**Options utiles :**
- `libs` : BibliothÃ¨ques chargÃ©es
- `symbols` : RÃ©solution de symboles
- `bindings` : Liaisons effectuÃ©es
- `files` : Traitement des fichiers
- `reloc` : Relocations
- `all` : Tout (verbeux !)

### `LD_BIND_NOW`

Force la rÃ©solution immÃ©diate (pas de lazy binding) :

```bash
LD_BIND_NOW=1 ./programme
```

---

## Chargement dynamique explicite avec `dlopen()`

### DiffÃ©rence avec le linking implicite

**Linking implicite** (ce qu'on a vu jusqu'ici) :
```bash
gcc main.c -lmath -o programme
```
Les bibliothÃ¨ques sont listÃ©es dans l'exÃ©cutable et chargÃ©es automatiquement.

**Chargement explicite** (dlopen) :
```c
// On charge la bibliothÃ¨que dans le code
void *handle = dlopen("libmath.so.1", RTLD_LAZY);
```

### API dlopen

```c
#include <dlfcn.h>

// Charger une bibliothÃ¨que
void *dlopen(const char *filename, int flag);

// Obtenir l'adresse d'un symbole
void *dlsym(void *handle, const char *symbol);

// DÃ©charger une bibliothÃ¨que
int dlclose(void *handle);

// Obtenir l'erreur de la derniÃ¨re opÃ©ration
char *dlerror(void);
```

### Exemple complet

**BibliothÃ¨que `libmath.so` :**
```c
// math_utils.c
int addition(int a, int b) {
    return a + b;
}
```

**Compilation :**
```bash
gcc -fPIC -shared math_utils.c -o libmath.so
```

**Programme principal :**
```c
// main.c
#include <stdio.h>
#include <dlfcn.h>

int main() {
    void *handle;
    int (*addition)(int, int);
    char *error;

    // 1. Charger la bibliothÃ¨que
    handle = dlopen("./libmath.so", RTLD_LAZY);
    if (!handle) {
        fprintf(stderr, "Erreur dlopen: %s\n", dlerror());
        return 1;
    }

    // 2. Effacer les anciennes erreurs
    dlerror();

    // 3. Obtenir l'adresse de la fonction
    *(void **)(&addition) = dlsym(handle, "addition");

    // 4. VÃ©rifier les erreurs
    error = dlerror();
    if (error != NULL) {
        fprintf(stderr, "Erreur dlsym: %s\n", error);
        dlclose(handle);
        return 1;
    }

    // 5. Utiliser la fonction
    printf("5 + 3 = %d\n", addition(5, 3));

    // 6. DÃ©charger la bibliothÃ¨que
    dlclose(handle);

    return 0;
}
```

**Compilation :**
```bash
gcc main.c -ldl -o programme
```

**Note :** L'option `-ldl` est nÃ©cessaire pour lier avec `libdl.so`.

### Flags de dlopen()

| Flag | Description |
|------|-------------|
| `RTLD_LAZY` | Lazy binding (rÃ©solution Ã  l'utilisation) |
| `RTLD_NOW` | Eager binding (rÃ©solution immÃ©diate) |
| `RTLD_GLOBAL` | Symboles disponibles pour d'autres bibliothÃ¨ques |
| `RTLD_LOCAL` | Symboles privÃ©s (dÃ©faut) |

**Combinaison de flags :**
```c
handle = dlopen("libmath.so", RTLD_NOW | RTLD_GLOBAL);
```

### Cas d'usage de dlopen()

1. **SystÃ¨me de plugins**
   ```c
   // Charger des plugins Ã  la demande
   void *plugin = dlopen("plugin_compression.so", RTLD_LAZY);
   ```

2. **Chargement conditionnel**
   ```c
   // Charger une bibliothÃ¨que seulement si elle existe
   void *handle = dlopen("liboptional.so", RTLD_LAZY);
   if (handle) {
       // Utiliser les fonctionnalitÃ©s optionnelles
   }
   ```

3. **Support de plusieurs backends**
   ```c
   // Choisir dynamiquement entre plusieurs implÃ©mentations
   if (use_gpu) {
       handle = dlopen("libcompute_gpu.so", RTLD_LAZY);
   } else {
       handle = dlopen("libcompute_cpu.so", RTLD_LAZY);
   }
   ```

4. **Hot-reloading** (rechargement Ã  chaud)
   ```c
   // Recharger une bibliothÃ¨que modifiÃ©e sans redÃ©marrer le programme
   dlclose(old_handle);
   new_handle = dlopen("libmodule.so", RTLD_NOW);
   ```

---

## RÃ©solution de symboles : Cas spÃ©ciaux

### Symboles faibles (weak symbols)

Un symbole faible peut Ãªtre Ã©crasÃ© par une dÃ©finition forte.

```c
// DÃ©finition faible (bibliothÃ¨que)
__attribute__((weak))
void custom_handler(void) {
    printf("Handler par dÃ©faut\n");
}

// DÃ©finition forte (programme utilisateur)
void custom_handler(void) {
    printf("Handler personnalisÃ©\n");  // Cette version sera utilisÃ©e
}
```

**UtilitÃ© :** Fournir des implÃ©mentations par dÃ©faut remplaÃ§ables.

### Symboles masquÃ©s (hidden symbols)

Rendre des symboles invisibles de l'extÃ©rieur :

```c
__attribute__((visibility("hidden")))
void internal_function(void) {
    // Fonction interne Ã  la bibliothÃ¨que
}
```

**Compilation :**
```bash
gcc -fPIC -fvisibility=hidden -shared lib.c -o lib.so
```

**Avantages :**
- âœ… RÃ©duit les conflits de noms
- âœ… Optimisation (le linker peut faire des suppositions)
- âœ… RÃ©duit la taille de la table des symboles

### Alias de symboles

CrÃ©er plusieurs noms pour une mÃªme fonction :

```c
int addition(int a, int b) {
    return a + b;
}

// CrÃ©er un alias
int add(int a, int b) __attribute__((alias("addition")));
```

Maintenant, `add()` et `addition()` pointent vers le mÃªme code.

---

## ProblÃ¨mes courants et solutions

### ProblÃ¨me 1 : "cannot open shared object file"

**Erreur :**
```
./programme: error while loading shared libraries: libmath.so.1: cannot open shared object file: No such file or directory
```

**Causes :**
- La bibliothÃ¨que n'est pas dans un rÃ©pertoire de recherche
- Le SONAME ne correspond pas

**Solutions :**

1. **Copier la bibliothÃ¨que dans un rÃ©pertoire systÃ¨me :**
   ```bash
   sudo cp libmath.so.1 /usr/local/lib/
   sudo ldconfig
   ```

2. **Utiliser LD_LIBRARY_PATH :**
   ```bash
   LD_LIBRARY_PATH=/path/to/lib ./programme
   ```

3. **Utiliser RPATH Ã  la compilation :**
   ```bash
   gcc main.c -lmath -Wl,-rpath,/path/to/lib -o programme
   ```

4. **Ajouter au cache systÃ¨me :**
   ```bash
   # CrÃ©er un fichier de configuration
   echo "/path/to/lib" | sudo tee /etc/ld.so.conf.d/mylib.conf
   sudo ldconfig
   ```

### ProblÃ¨me 2 : "undefined symbol"

**Erreur :**
```
./programme: symbol lookup error: ./programme: undefined symbol: addition
```

**Causes :**
- Le symbole n'est pas dans la bibliothÃ¨que
- La bibliothÃ¨que n'a pas Ã©tÃ© liÃ©e correctement
- Version de bibliothÃ¨que incorrecte

**Solutions :**

1. **VÃ©rifier que le symbole existe :**
   ```bash
   nm -D libmath.so | grep addition
   ```

2. **VÃ©rifier les dÃ©pendances :**
   ```bash
   ldd programme
   ```

3. **Forcer la rÃ©solution immÃ©diate pour dÃ©tecter le problÃ¨me :**
   ```bash
   LD_BIND_NOW=1 ./programme
   ```

### ProblÃ¨me 3 : Symbole rÃ©solu vers la mauvaise bibliothÃ¨que

**Diagnostic :**
```bash
LD_DEBUG=symbols ./programme 2>&1 | grep my_function
```

**Solution :** Utiliser `LD_PRELOAD` pour forcer la bonne bibliothÃ¨que :
```bash
LD_PRELOAD=/path/to/correct/lib.so ./programme
```

### ProblÃ¨me 4 : Conflit de symboles

Deux bibliothÃ¨ques dÃ©finissent le mÃªme symbole.

**Solution 1 : Lazy binding**
Le premier chargÃ© gagne.

**Solution 2 : Symbol versioning**
Utiliser des versions de symboles diffÃ©rentes.

**Solution 3 : Namespace**
PrÃ©fixer les symboles (ex: `mylib_function`).

---

## Outils de diagnostic

### `ldd` : Lister les dÃ©pendances

```bash
ldd programme
```

Sortie :
```
linux-vdso.so.1 (0x00007ffd123ab000)
libmath.so.1 => /usr/local/lib/libmath.so.1.2.3 (0x00007f1234000000)
libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f1233000000)
/lib64/ld-linux-x86-64.so.2 (0x00007f1235000000)
```

**Options utiles :**
- `ldd -v` : Mode verbeux
- `ldd -u` : Symboles non utilisÃ©s
- `ldd -r` : Relocations

### `nm` : Lister les symboles

```bash
# Symboles dynamiques
nm -D libmath.so

# Tous les symboles
nm libmath.so

# Symboles non dÃ©finis seulement
nm -u programme
```

### `objdump` : DÃ©sassembler et analyser

```bash
# Voir les sections
objdump -h libmath.so

# Voir les symboles dynamiques
objdump -T libmath.so

# DÃ©sassembler la PLT
objdump -d programme | grep @plt
```

### `readelf` : Analyser le format ELF

```bash
# Voir les dÃ©pendances
readelf -d programme | grep NEEDED

# Voir le SONAME
readelf -d libmath.so | grep SONAME

# Voir les relocations
readelf -r programme

# Voir les sections
readelf -S libmath.so
```

### `pmap` : Carte mÃ©moire d'un processus

```bash
# Lancer le programme en arriÃ¨re-plan
./programme &
PID=$!

# Voir la carte mÃ©moire
pmap $PID

# Ou avec plus de dÃ©tails
cat /proc/$PID/maps
```

Sortie exemple :
```
00400000-00401000 r-xp programme
00600000-00601000 rw-p programme
7f1234000000-7f1234001000 r-xp libmath.so.1.2.3
7f1235000000-7f1235200000 r-xp libc-2.31.so
```

### `strace` : Tracer les appels systÃ¨me

```bash
strace -e openat ./programme
```

Montre tous les fichiers ouverts, y compris les bibliothÃ¨ques :
```
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
```

---

## SÃ©curitÃ© et bonnes pratiques

### Dangers de `LD_PRELOAD`

`LD_PRELOAD` peut Ãªtre utilisÃ© malicieusement :

```bash
# Un attaquant pourrait intercepter toutes les fonctions !
LD_PRELOAD=/tmp/malicious.so /usr/bin/sudo ...
```

**Protection :** Pour les binaires setuid/setgid, le systÃ¨me ignore `LD_PRELOAD` et `LD_LIBRARY_PATH`.

### RPATH vs RUNPATH

**RPATH :**
- âŒ Prioritaire sur `LD_LIBRARY_PATH`
- âŒ Peut causer des problÃ¨mes de sÃ©curitÃ©

**RUNPATH (recommandÃ©) :**
- âœ… ConsultÃ© aprÃ¨s `LD_LIBRARY_PATH`
- âœ… Plus flexible

**CrÃ©er un RUNPATH :**
```bash
gcc -Wl,-rpath,/path/to/lib -Wl,--enable-new-dtags main.c -o programme
```

### RÃ©duire la surface d'attaque

1. **Limiter les symboles exportÃ©s :**
   ```bash
   gcc -fvisibility=hidden -fPIC -shared lib.c -o lib.so
   ```

2. **Utiliser BIND_NOW pour Ã©viter PLT/GOT attacks :**
   ```bash
   gcc -Wl,-z,now main.c -o programme
   ```

3. **Activer RELRO (Relocation Read-Only) :**
   ```bash
   gcc -Wl,-z,relro,-z,now main.c -o programme
   ```

**VÃ©rifier les protections :**
```bash
checksec --file=programme
```

---

## Exemple pratique : SystÃ¨me de plugins

### Architecture

```
Programme principal
    â”œâ”€ plugin_interface.h
    â”œâ”€ plugin_compression.so
    â”œâ”€ plugin_encryption.so
    â””â”€ plugin_validation.so
```

### Interface de plugin

**Fichier `plugin_interface.h` :**
```c
#ifndef PLUGIN_INTERFACE_H
#define PLUGIN_INTERFACE_H

typedef struct {
    const char *name;
    const char *version;
    int (*init)(void);
    void (*process)(const char *data);
    void (*cleanup)(void);
} Plugin;

// Fonction que chaque plugin doit exporter
Plugin *get_plugin(void);

#endif
```

### ImplÃ©mentation d'un plugin

**Fichier `plugin_compression.c` :**
```c
#include <stdio.h>
#include "plugin_interface.h"

static int compression_init(void) {
    printf("Plugin Compression initialisÃ©\n");
    return 0;
}

static void compression_process(const char *data) {
    printf("Compression de : %s\n", data);
    // Code de compression ici
}

static void compression_cleanup(void) {
    printf("Plugin Compression nettoyÃ©\n");
}

static Plugin compression_plugin = {
    .name = "Compression",
    .version = "1.0",
    .init = compression_init,
    .process = compression_process,
    .cleanup = compression_cleanup
};

Plugin *get_plugin(void) {
    return &compression_plugin;
}
```

**Compilation du plugin :**
```bash
gcc -fPIC -shared plugin_compression.c -o plugin_compression.so
```

### Chargeur de plugins

**Fichier `main.c` :**
```c
#include <stdio.h>
#include <dlfcn.h>
#include "plugin_interface.h"

int load_plugin(const char *path) {
    void *handle;
    Plugin *(*get_plugin_func)(void);
    Plugin *plugin;

    // Charger la bibliothÃ¨que
    handle = dlopen(path, RTLD_LAZY);
    if (!handle) {
        fprintf(stderr, "Erreur: %s\n", dlerror());
        return -1;
    }

    // Obtenir la fonction get_plugin
    *(void **)(&get_plugin_func) = dlsym(handle, "get_plugin");
    if (!get_plugin_func) {
        fprintf(stderr, "Symbole get_plugin non trouvÃ©\n");
        dlclose(handle);
        return -1;
    }

    // Obtenir l'interface du plugin
    plugin = get_plugin_func();

    printf("Plugin chargÃ© : %s v%s\n", plugin->name, plugin->version);

    // Utiliser le plugin
    plugin->init();
    plugin->process("DonnÃ©es de test");
    plugin->cleanup();

    dlclose(handle);
    return 0;
}

int main(int argc, char *argv[]) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <plugin.so>\n", argv[0]);
        return 1;
    }

    return load_plugin(argv[1]);
}
```

**Compilation :**
```bash
gcc main.c -ldl -o loader
```

**Utilisation :**
```bash
./loader ./plugin_compression.so
```

Sortie :
```
Plugin chargÃ© : Compression v1.0
Plugin Compression initialisÃ©
Compression de : DonnÃ©es de test
Plugin Compression nettoyÃ©
```

---

## RÃ©sumÃ© des commandes essentielles

| Commande | Description |
|----------|-------------|
| `ldd programme` | Afficher les dÃ©pendances |
| `nm -D lib.so` | Lister les symboles dynamiques |
| `readelf -d programme \| grep NEEDED` | Voir les bibliothÃ¨ques requises |
| `LD_DEBUG=all ./programme 2>&1 \| less` | Debug du loader |
| `LD_LIBRARY_PATH=/path ./programme` | SpÃ©cifier un chemin de bibliothÃ¨que |
| `LD_PRELOAD=lib.so ./programme` | PrÃ©charger une bibliothÃ¨que |
| `LD_BIND_NOW=1 ./programme` | Forcer la rÃ©solution immÃ©diate |
| `objdump -d programme \| grep @plt` | Voir la PLT |
| `pmap PID` | Carte mÃ©moire d'un processus |
| `strace -e openat ./programme` | Tracer l'ouverture de fichiers |

---

## Points clÃ©s Ã  retenir

- âœ… **Le loader dynamique** (`ld.so`) rÃ©sout les symboles au runtime
- âœ… **PLT** (Procedure Linkage Table) = table de redirection des fonctions
- âœ… **GOT** (Global Offset Table) = table contenant les adresses rÃ©elles
- âœ… **Lazy binding** (dÃ©faut) = rÃ©solution Ã  la premiÃ¨re utilisation
- âœ… **Eager binding** (`LD_BIND_NOW`) = rÃ©solution au dÃ©marrage
- âœ… **Ordre de recherche** : RPATH â†’ LD_LIBRARY_PATH â†’ RUNPATH â†’ cache â†’ /lib
- âœ… **`LD_PRELOAD`** permet d'intercepter des fonctions
- âœ… **`dlopen()`** permet le chargement explicite de bibliothÃ¨ques
- âœ… **`LD_DEBUG`** affiche les dÃ©tails de la rÃ©solution
- âœ… **Symboles faibles** peuvent Ãªtre Ã©crasÃ©s
- âœ… **VisibilitÃ© des symboles** contrÃ´le l'exposition de l'API

La rÃ©solution de symboles au runtime est un mÃ©canisme complexe mais puissant qui permet la flexibilitÃ©, le partage de code et les systÃ¨mes de plugins modernes. Comprendre ce mÃ©canisme est essentiel pour dÃ©boguer efficacement et crÃ©er des applications modulaires.

Dans la section suivante, nous comparerons en dÃ©tail les bibliothÃ¨ques statiques et dynamiques pour vous aider Ã  choisir la meilleure approche pour vos projets.

â­ï¸ [DiffÃ©rences statiques vs dynamiques](/14-bibliotheques/03-differences-statiques-dynamiques.md)
