ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 21.5.2 Utilisation de maps

## Introduction

Dans la section prÃ©cÃ©dente (21.5.1), nous avons crÃ©Ã© notre premier programme eBPF qui utilisait `bpf_printk()` pour afficher des informations. Cette approche fonctionne bien pour le dÃ©bogage, mais elle a des limitations importantes pour des cas d'usage rÃ©els.

Dans cette section, nous allons dÃ©couvrir les **BPF maps**, qui sont le mÃ©canisme principal de communication entre le code eBPF (qui s'exÃ©cute dans le kernel) et le code userspace (votre programme C). Les maps sont au cÅ“ur de la puissance d'eBPF et permettent de construire des outils d'observabilitÃ© et de monitoring performants.

## Pourquoi les maps sont nÃ©cessaires

### Les limitations de bpf_printk()

Rappelons les problÃ¨mes de `bpf_printk()` :

- âŒ **LimitÃ© Ã  3 arguments** : Impossible de passer des structures complexes
- âŒ **Performance mÃ©diocre** : Chaque appel gÃ©nÃ¨re du overhead
- âŒ **Pas structurÃ©** : Les donnÃ©es sont sous forme de texte brut
- âŒ **Difficile Ã  parser** : Il faut lire `/sys/kernel/debug/tracing/trace_pipe` et analyser le texte
- âŒ **Pas adaptÃ© aux volumes Ã©levÃ©s** : Peut saturer le buffer de trace

### Ce que les maps apportent

- âœ… **Communication bidirectionnelle** : Kernel â†” Userspace
- âœ… **Structures de donnÃ©es typÃ©es** : Tableaux, hash maps, stacks, etc.
- âœ… **Haute performance** : AccÃ¨s optimisÃ© en O(1) pour les hash maps
- âœ… **Persistance** : Les donnÃ©es survivent entre les appels
- âœ… **AgrÃ©gation** : PossibilitÃ© de compter, accumuler, filtrer
- âœ… **Configuration dynamique** : Userspace peut modifier les maps Ã  la volÃ©e

## Qu'est-ce qu'une BPF map ?

Une BPF map est essentiellement une **structure de donnÃ©es partagÃ©e** entre le kernel et l'espace utilisateur. Pensez-y comme Ã  une base de donnÃ©es trÃ¨s rapide et optimisÃ©e qui vit dans le kernel.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Espace Userspace                        â”‚
â”‚                                                      â”‚
â”‚  Programme C                                         â”‚
â”‚  â”œâ”€ Lit les donnÃ©es de la map                        â”‚
â”‚  â”œâ”€ Ã‰crit dans la map (configuration)                â”‚
â”‚  â””â”€ Affiche ou traite les donnÃ©es                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â”‚ AccÃ¨s via file descriptors
                 â”‚ (lecture/Ã©criture)
                 â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              BPF MAP (dans le kernel)                â”‚
â”‚                                                      â”‚
â”‚  ClÃ©   â”‚  Valeur                                     â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€                                     â”‚
â”‚  1000  â”‚  42                                         â”‚
â”‚  1001  â”‚  15                                         â”‚
â”‚  0     â”‚  123                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â”‚ AccÃ¨s via helpers BPF
                 â”‚ (bpf_map_lookup_elem, etc.)
                 â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Programme eBPF (kernel)                 â”‚
â”‚                                                      â”‚
â”‚  Code qui intercepte des Ã©vÃ©nements                  â”‚
â”‚  â”œâ”€ Lit des valeurs dans la map                      â”‚
â”‚  â”œâ”€ Met Ã  jour des compteurs                         â”‚
â”‚  â””â”€ InsÃ¨re de nouvelles entrÃ©es                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Types de maps disponibles

eBPF offre plusieurs types de maps, chacun optimisÃ© pour un cas d'usage spÃ©cifique :

### 1. BPF_MAP_TYPE_HASH (Hash map)

**Description :** Table de hachage classique (clÃ© â†’ valeur)
**ComplexitÃ© :** O(1) en moyenne
**Usage :** Compteurs, statistiques, cache

```c
// Exemple : Compter les exÃ©cutions par utilisateur (UID â†’ count)
struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 10240);
    __type(key, __u32);      // UID
    __type(value, __u64);    // Compteur
} exec_count SEC(".maps");
```

### 2. BPF_MAP_TYPE_ARRAY (Tableau)

**Description :** Tableau avec indices numÃ©riques (0, 1, 2, ...)
**ComplexitÃ© :** O(1)
**Usage :** Statistiques fixes, configuration

```c
// Exemple : Tableau de 256 compteurs
struct {
    __uint(type, BPF_MAP_TYPE_ARRAY);
    __uint(max_entries, 256);
    __type(key, __u32);      // Index 0..255
    __type(value, __u64);    // Valeur
} stats_array SEC(".maps");
```

### 3. BPF_MAP_TYPE_PERCPU_HASH

**Description :** Hash map avec une copie par CPU
**Usage :** Haute performance, Ã©vite les locks

### 4. BPF_MAP_TYPE_LRU_HASH

**Description :** Hash map avec Ã©viction LRU (Least Recently Used)
**Usage :** Cache avec taille limitÃ©e

### 5. BPF_MAP_TYPE_RINGBUF (Ring Buffer)

**Description :** Buffer circulaire pour Ã©vÃ©nements
**Usage :** Streaming d'Ã©vÃ©nements vers userspace

### 6. BPF_MAP_TYPE_PERF_EVENT_ARRAY

**Description :** Transmission d'Ã©vÃ©nements via perf
**Usage :** TraÃ§age Ã  haute performance

**Note :** Pour dÃ©buter, concentrez-vous sur `BPF_MAP_TYPE_HASH` et `BPF_MAP_TYPE_ARRAY`, qui couvrent 80% des cas d'usage.

## Exemple pratique : Compteur d'exÃ©cutions par utilisateur

AmÃ©liorons notre programme "Hello World" pour qu'il **compte** le nombre de fois que chaque utilisateur lance des programmes, au lieu de juste afficher un message.

### Architecture du programme

```
Ã‰vÃ©nement : execve()
      â†“
Programme eBPF :
  1. RÃ©cupÃ¨re l'UID de l'utilisateur
  2. Cherche l'UID dans la map exec_count
  3. Si trouvÃ© : incrÃ©mente le compteur
  4. Si non trouvÃ© : initialise Ã  1
      â†“
Map exec_count (UID â†’ count)
      â†“
Programme userspace :
  Lit pÃ©riodiquement la map
  Affiche : UID 1000 â†’ 42 exÃ©cutions
```

### Partie 1 : Code eBPF (kernel)

CrÃ©ez le fichier `execcount.bpf.c` :

```c
// execcount.bpf.c
#include <linux/bpf.h>
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>

char LICENSE[] SEC("license") = "GPL";

// DÃ©finition de la map : Hash table pour compter les exÃ©cutions par UID
struct {
    __uint(type, BPF_MAP_TYPE_HASH);     // Type : Hash map
    __uint(max_entries, 10240);           // Maximum 10240 utilisateurs
    __type(key, __u32);                   // ClÃ© = UID (User ID)
    __type(value, __u64);                 // Valeur = Compteur d'exÃ©cutions
} exec_count SEC(".maps");

// Programme eBPF attachÃ© Ã  l'appel systÃ¨me execve
SEC("tp/syscalls/sys_enter_execve")
int count_execve(struct trace_event_raw_sys_enter *ctx)
{
    __u64 uid_gid = bpf_get_current_uid_gid();
    __u32 uid = uid_gid;  // Extraire l'UID (32 bits bas)

    // Chercher si cet UID existe dÃ©jÃ  dans la map
    __u64 *count = bpf_map_lookup_elem(&exec_count, &uid);

    if (count) {
        // L'UID existe dÃ©jÃ  : incrÃ©menter le compteur
        __sync_fetch_and_add(count, 1);
    } else {
        // Nouvel UID : initialiser le compteur Ã  1
        __u64 initial_count = 1;
        bpf_map_update_elem(&exec_count, &uid, &initial_count, BPF_ANY);
    }

    return 0;
}
```

### Explication dÃ©taillÃ©e du code eBPF

#### DÃ©finition de la map

```c
struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 10240);
    __type(key, __u32);
    __type(value, __u64);
} exec_count SEC(".maps");
```

- **`__uint(type, ...)`** : SpÃ©cifie le type de map (ici, hash table)
- **`__uint(max_entries, ...)`** : Nombre maximum d'entrÃ©es (mÃ©moire kernel limitÃ©e !)
- **`__type(key, ...)`** : Type de la clÃ© (ici, `__u32` pour l'UID)
- **`__type(value, ...)`** : Type de la valeur (ici, `__u64` pour un compteur)
- **`SEC(".maps")`** : Indique que c'est une dÃ©finition de map

#### Recherche dans la map

```c
__u64 *count = bpf_map_lookup_elem(&exec_count, &uid);
```

**`bpf_map_lookup_elem()`** est un helper qui cherche une clÃ© dans une map :
- **Premier argument** : Pointeur vers la map
- **DeuxiÃ¨me argument** : Pointeur vers la clÃ© Ã  chercher
- **Retour** : Pointeur vers la valeur (ou `NULL` si non trouvÃ©)

**Important :** Le retour est un **pointeur**. Vous ne rÃ©cupÃ©rez pas une copie de la valeur, mais son adresse en mÃ©moire. C'est pour des raisons de performance.

#### IncrÃ©menter de maniÃ¨re atomique

```c
__sync_fetch_and_add(count, 1);
```

Cette instruction est **atomique** (thread-safe). C'est crucial car plusieurs CPUs peuvent exÃ©cuter ce code simultanÃ©ment. Sans opÃ©ration atomique, vous auriez des **race conditions** (deux CPUs lisant la mÃªme valeur, incrÃ©mentant, et Ã©crivant, ce qui perdrait une incrÃ©mentation).

#### InsÃ©rer une nouvelle entrÃ©e

```c
__u64 initial_count = 1;
bpf_map_update_elem(&exec_count, &uid, &initial_count, BPF_ANY);
```

**`bpf_map_update_elem()`** insÃ¨re ou met Ã  jour une entrÃ©e :
- **Arguments** : map, clÃ©, valeur, flags
- **Flags possibles** :
  - `BPF_ANY` : CrÃ©e ou met Ã  jour
  - `BPF_NOEXIST` : CrÃ©e uniquement (Ã©choue si existe)
  - `BPF_EXIST` : Met Ã  jour uniquement (Ã©choue si n'existe pas)

### Partie 2 : Code userspace (C)

CrÃ©ez le fichier `execcount.c` :

```c
// execcount.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <bpf/libbpf.h>
#include <bpf/bpf.h>
#include "execcount.skel.h"

static volatile sig_atomic_t keep_running = 1;

static void sig_handler(int sig)
{
    keep_running = 0;
}

// Fonction callback appelÃ©e pour chaque entrÃ©e de la map
static int print_exec_count(int map_fd, __u32 *key, __u64 *value, void *ctx)
{
    printf("  UID %5u : %llu exÃ©cutions\n", *key, *value);
    return 0;
}

int main(int argc, char **argv)
{
    struct execcount_bpf *skel;
    int err;

    // Installer le gestionnaire de signal
    signal(SIGINT, sig_handler);
    signal(SIGTERM, sig_handler);

    printf("=== Compteur d'exÃ©cutions par utilisateur ===\n");
    printf("Appuyez sur CTRL+C pour arrÃªter.\n\n");

    // 1. Ouvrir le squelette BPF
    skel = execcount_bpf__open();
    if (!skel) {
        fprintf(stderr, "Erreur lors de l'ouverture du squelette BPF\n");
        return 1;
    }

    // 2. Charger le programme dans le kernel
    err = execcount_bpf__load(skel);
    if (err) {
        fprintf(stderr, "Erreur lors du chargement : %d\n", err);
        goto cleanup;
    }

    // 3. Attacher le programme au tracepoint
    err = execcount_bpf__attach(skel);
    if (err) {
        fprintf(stderr, "Erreur lors de l'attachement : %d\n", err);
        goto cleanup;
    }

    printf("âœ“ Programme eBPF attachÃ© avec succÃ¨s !\n");
    printf("âœ“ Comptage des exÃ©cutions en cours...\n\n");

    // Boucle principale : afficher les statistiques toutes les 2 secondes
    while (keep_running) {
        sleep(2);

        printf("\n=== Statistiques (mises Ã  jour toutes les 2s) ===\n");

        // RÃ©cupÃ©rer le file descriptor de la map
        int map_fd = bpf_map__fd(skel->maps.exec_count);

        // Parcourir toutes les entrÃ©es de la map
        __u32 key = 0;
        __u32 next_key;
        __u64 value;

        while (bpf_map_get_next_key(map_fd, &key, &next_key) == 0) {
            // Lire la valeur associÃ©e Ã  next_key
            if (bpf_map_lookup_elem(map_fd, &next_key, &value) == 0) {
                printf("  UID %5u : %llu exÃ©cutions\n", next_key, value);
            }
            key = next_key;
        }

        printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
    }

    printf("\n\nArrÃªt du compteur...\n");

cleanup:
    execcount_bpf__destroy(skel);
    printf("Programme dÃ©tachÃ©. Au revoir !\n");

    return err != 0;
}
```

### Explication dÃ©taillÃ©e du code userspace

#### RÃ©cupÃ©rer le file descriptor de la map

```c
int map_fd = bpf_map__fd(skel->maps.exec_count);
```

Chaque map BPF est reprÃ©sentÃ©e par un **file descriptor** (un entier). C'est via ce FD que vous allez lire/Ã©crire dans la map depuis userspace.

#### Parcourir une hash map

```c
__u32 key = 0;
__u32 next_key;

while (bpf_map_get_next_key(map_fd, &key, &next_key) == 0) {
    // Utiliser next_key...
    key = next_key;
}
```

**`bpf_map_get_next_key()`** permet d'itÃ©rer sur les clÃ©s d'une hash map :
- **Arguments** : map FD, clÃ© actuelle, pointeur vers prochaine clÃ©
- **Retour** : 0 si succÃ¨s, -1 si fin de map
- **Astuce** : Commencez avec `key = 0` (ou n'importe quelle valeur) pour obtenir la premiÃ¨re clÃ©

**Pourquoi ce mÃ©canisme ?** Les hash maps ne sont pas ordonnÃ©es, donc il n'y a pas de "clÃ© 0, clÃ© 1, clÃ© 2...". Cette fonction vous donne la prochaine clÃ© disponible.

#### Lire une valeur

```c
if (bpf_map_lookup_elem(map_fd, &next_key, &value) == 0) {
    printf("  UID %5u : %llu exÃ©cutions\n", next_key, value);
}
```

**`bpf_map_lookup_elem()`** en userspace fonctionne comme dans le kernel :
- Lit la valeur associÃ©e Ã  une clÃ©
- Retourne 0 si succÃ¨s, -1 si clÃ© introuvable

## Compilation et exÃ©cution

### Makefile

CrÃ©ez un `Makefile` similaire Ã  la section prÃ©cÃ©dente :

```makefile
# Makefile
CLANG = clang
BPFTOOL = bpftool
CC = gcc

CFLAGS = -g -Wall
BPF_CFLAGS = -g -O2 -target bpf -D__TARGET_ARCH_x86

TARGET = execcount
BPF_OBJ = $(TARGET).bpf.o
SKEL = $(TARGET).skel.h

all: $(TARGET)

$(BPF_OBJ): $(TARGET).bpf.c
	$(CLANG) $(BPF_CFLAGS) -c $< -o $@

$(SKEL): $(BPF_OBJ)
	$(BPFTOOL) gen skeleton $< > $@

$(TARGET): $(SKEL) $(TARGET).c
	$(CC) $(CFLAGS) $(TARGET).c -o $@ -lbpf -lelf -lz

clean:
	rm -f $(TARGET) $(BPF_OBJ) $(SKEL)

.PHONY: all clean
```

### Compiler et lancer

```bash
make
sudo ./execcount
```

### RÃ©sultat attendu

```
=== Compteur d'exÃ©cutions par utilisateur ===
Appuyez sur CTRL+C pour arrÃªter.

âœ“ Programme eBPF attachÃ© avec succÃ¨s !
âœ“ Comptage des exÃ©cutions en cours...


=== Statistiques (mises Ã  jour toutes les 2s) ===
  UID  1000 : 15 exÃ©cutions
  UID     0 : 3 exÃ©cutions
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

=== Statistiques (mises Ã  jour toutes les 2s) ===
  UID  1000 : 27 exÃ©cutions
  UID     0 : 5 exÃ©cutions
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```

Dans un autre terminal, lancez des commandes pour voir les compteurs augmenter :

```bash
ls
pwd
whoami
date
```

Chaque commande incrÃ©mente le compteur de votre UID !

## OpÃ©rations avancÃ©es sur les maps

### Supprimer une entrÃ©e

```c
// Depuis le code eBPF
bpf_map_delete_elem(&exec_count, &uid);

// Depuis userspace
bpf_map_delete_elem(map_fd, &key);
```

### VÃ©rifier si une clÃ© existe

```c
__u64 *value = bpf_map_lookup_elem(&exec_count, &uid);
if (value) {
    // La clÃ© existe
} else {
    // La clÃ© n'existe pas
}
```

### Initialiser une map depuis userspace

Vous pouvez prÃ©-remplir une map avant d'attacher le programme :

```c
// AprÃ¨s __load() mais avant __attach()
int map_fd = bpf_map__fd(skel->maps.exec_count);

__u32 uid = 1000;
__u64 initial_value = 0;
bpf_map_update_elem(map_fd, &uid, &initial_value, BPF_ANY);
```

Ceci est utile pour des **maps de configuration** que le code eBPF lit.

## Maps pour la configuration

Les maps ne servent pas seulement Ã  stocker des donnÃ©es, mais aussi Ã  **configurer** le comportement du programme eBPF dynamiquement.

### Exemple : Filtrage par UID

```c
// Dans le code eBPF
struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 100);
    __type(key, __u32);    // UID
    __type(value, __u8);   // 1 = activÃ©, 0 = dÃ©sactivÃ©
} uid_filter SEC(".maps");

SEC("tp/syscalls/sys_enter_execve")
int count_execve(struct trace_event_raw_sys_enter *ctx)
{
    __u32 uid = bpf_get_current_uid_gid();

    // VÃ©rifier si on doit tracer cet UID
    __u8 *enabled = bpf_map_lookup_elem(&uid_filter, &uid);
    if (!enabled || *enabled == 0) {
        return 0;  // UID non tracÃ©, on ignore
    }

    // Continuer le traitement...
    return 0;
}
```

Depuis userspace, vous pouvez activer/dÃ©sactiver des UIDs Ã  la volÃ©e :

```c
// Activer le traÃ§age pour UID 1000
__u32 uid = 1000;
__u8 enabled = 1;
bpf_map_update_elem(filter_fd, &uid, &enabled, BPF_ANY);

// DÃ©sactiver le traÃ§age pour UID 0
uid = 0;
enabled = 0;
bpf_map_update_elem(filter_fd, &uid, &enabled, BPF_ANY);
```

## Types de maps avancÃ©s

### Array map : Statistiques fixes

Exemple : Compter les appels par type de signal :

```c
struct {
    __uint(type, BPF_MAP_TYPE_ARRAY);
    __uint(max_entries, 64);  // 64 signaux possibles
    __type(key, __u32);       // Index = numÃ©ro du signal
    __type(value, __u64);     // Compteur
} signal_stats SEC(".maps");

// IncrÃ©menter le compteur pour le signal 9 (SIGKILL)
__u32 sig = 9;
__u64 *count = bpf_map_lookup_elem(&signal_stats, &sig);
if (count) {
    __sync_fetch_and_add(count, 1);
}
```

**Avantage des arrays** : Toutes les entrÃ©es sont prÃ©-allouÃ©es (de 0 Ã  max_entries-1), donc pas besoin de `bpf_map_update_elem()` pour initialiser.

### Per-CPU maps : Haute performance

```c
struct {
    __uint(type, BPF_MAP_TYPE_PERCPU_HASH);
    __uint(max_entries, 10240);
    __type(key, __u32);
    __type(value, __u64);
} percpu_stats SEC(".maps");
```

**Principe :** Chaque CPU a sa propre copie de la map, ce qui Ã©vite la contention (pas de locks nÃ©cessaires).

**Lecture depuis userspace :**
```c
__u64 values[num_cpus];
bpf_map_lookup_elem(map_fd, &key, values);

// values[0] = valeur du CPU 0
// values[1] = valeur du CPU 1
// etc.

__u64 total = 0;
for (int i = 0; i < num_cpus; i++) {
    total += values[i];
}
```

## Debugging des maps

### Inspecter une map avec bpftool

```bash
# Lister toutes les maps
sudo bpftool map list

# Afficher le contenu d'une map (par son ID)
sudo bpftool map dump id 42

# Exemple de sortie :
# key: 00 04 00 00  value: 0f 00 00 00 00 00 00 00
# key: e8 03 00 00  value: 1a 00 00 00 00 00 00 00
```

**Lecture** :
- `key: 00 04 00 00` â†’ UID 1024 (0x0400 en little-endian)
- `value: 0f 00...` â†’ 15 exÃ©cutions (0x0F)

### Vider une map

```bash
# Supprimer toutes les entrÃ©es d'une map
sudo bpftool map delete id 42 key 0x0
```

### Voir les maps d'un programme

```bash
sudo bpftool prog show id <prog_id>
# Affiche les maps utilisÃ©es par ce programme
```

## Gestion de la mÃ©moire des maps

### Limites du kernel

Les maps consomment de la **mÃ©moire kernel** (non swappable). Il y a des limites :

- **`max_entries`** : Nombre maximum d'entrÃ©es dans la map
- **`RLIMIT_MEMLOCK`** : Limite systÃ¨me de mÃ©moire verrouillÃ©e

Si vous dÃ©passez ces limites, le chargement Ã©chouera :

```
libbpf: Error in bpf_create_map_xattr(exec_count):ERROR: permission denied
```

**Solution :**
```bash
# Augmenter la limite (temporaire)
ulimit -l unlimited
```

Ou dans le code :
```c
#include <sys/resource.h>

struct rlimit rlim = {
    .rlim_cur = RLIM_INFINITY,
    .rlim_max = RLIM_INFINITY
};
setrlimit(RLIMIT_MEMLOCK, &rlim);
```

### Calcul de la taille mÃ©moire

Une hash map avec :
- 10 000 entrÃ©es
- ClÃ© : `__u32` (4 bytes)
- Valeur : `__u64` (8 bytes)

Consomme approximativement :
```
10000 Ã— (4 + 8 + overhead) â‰ˆ 150-200 KB
```

Pour les arrays, c'est plus prÃ©visible :
```
max_entries Ã— sizeof(value)
```

## Patterns courants avec les maps

### 1. Compteurs globaux

```c
struct {
    __uint(type, BPF_MAP_TYPE_ARRAY);
    __uint(max_entries, 1);
    __type(key, __u32);
    __type(value, __u64);
} global_counter SEC(".maps");

// IncrÃ©menter
__u32 key = 0;
__u64 *count = bpf_map_lookup_elem(&global_counter, &key);
if (count) {
    __sync_fetch_and_add(count, 1);
}
```

### 2. Cache LRU

```c
struct {
    __uint(type, BPF_MAP_TYPE_LRU_HASH);
    __uint(max_entries, 1000);  // Garde les 1000 entrÃ©es les plus rÃ©centes
    __type(key, __u32);
    __type(value, struct data);
} cache SEC(".maps");
```

Quand la map est pleine, les entrÃ©es les moins rÃ©cemment utilisÃ©es sont automatiquement Ã©vincÃ©es.

### 3. Timestamps

```c
struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 10000);
    __type(key, __u32);
    __type(value, __u64);  // Timestamp en nanosecondes
} last_seen SEC(".maps");

// Enregistrer le timestamp actuel
__u64 ts = bpf_ktime_get_ns();
bpf_map_update_elem(&last_seen, &uid, &ts, BPF_ANY);
```

### 4. Structures complexes

```c
struct exec_info {
    __u64 count;
    __u64 last_timestamp;
    char last_comm[16];
};

struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 10240);
    __type(key, __u32);
    __type(value, struct exec_info);
} exec_details SEC(".maps");
```

## Performance et bonnes pratiques

### âœ… Ã€ faire

1. **Utilisez des maps per-CPU** pour les statistiques Ã  haute frÃ©quence
2. **Limitez `max_entries`** Ã  ce qui est nÃ©cessaire
3. **Utilisez des LRU maps** si vous ne contrÃ´lez pas le nombre d'entrÃ©es
4. **PrÃ©fÃ©rez les arrays** quand les clÃ©s sont des indices contigus
5. **Utilisez des opÃ©rations atomiques** pour les mises Ã  jour

### âŒ Ã€ Ã©viter

1. **CrÃ©er des maps trop grandes** (gaspillage mÃ©moire kernel)
2. **Boucler sur toutes les entrÃ©es** dans le code eBPF (peut dÃ©passer la limite d'instructions)
3. **Oublier les vÃ©rifications NULL** aprÃ¨s `bpf_map_lookup_elem()`
4. **Utiliser des structures trop grandes** comme valeurs (dÃ©gradation des performances)

## RÃ©sumÃ©

Dans cette section, vous avez appris :

- âœ… **Ce que sont les BPF maps** : Structures de donnÃ©es partagÃ©es kernel â†” userspace
- âœ… **Les diffÃ©rents types de maps** : Hash, Array, Per-CPU, LRU, etc.
- âœ… **Comment crÃ©er et manipuler des maps** : lookup, update, delete
- âœ… **Les opÃ©rations atomiques** : NÃ©cessaires pour Ã©viter les race conditions
- âœ… **Comment itÃ©rer sur une map** depuis userspace
- âœ… **Patterns courants** : Compteurs, cache, configuration dynamique
- âœ… **Performance et bonnes pratiques**

**DiffÃ©rences clÃ©s avec bpf_printk()** :

| Aspect | bpf_printk() | BPF Maps |
|--------|-------------|----------|
| Performance | âŒ Lente | âœ… TrÃ¨s rapide |
| Structure donnÃ©es | âŒ Texte brut | âœ… TypÃ©es |
| AgrÃ©gation | âŒ Impossible | âœ… Native |
| Bidirectionnel | âŒ Non | âœ… Oui |
| Production | âŒ Non recommandÃ© | âœ… Standard |

**Prochaine Ã©tape :** Dans la section 21.5.3, nous verrons comment attacher des programmes eBPF Ã  diffÃ©rents **hooks kernel** (kprobes, uprobes, etc.) pour instrumenter encore plus finement le systÃ¨me.

## Ressources complÃ©mentaires

- **Documentation maps :** https://ebpf.io/what-is-ebpf/#maps
- **Types de maps :** `man 2 bpf` (section BPF_MAP_TYPE_*)
- **Exemples libbpf :** https://github.com/libbpf/libbpf-bootstrap/tree/master/examples/c
- **Performance des maps :** https://www.brendangregg.com/blog/2015-05-15/ebpf-one-small-step.html

---

*Note : Les maps BPF sont Ã©galement accessibles via le filesystem `/sys/fs/bpf/` en les "pinant", ce qui permet de les partager entre plusieurs programmes. Nous aborderons ce concept dans les sections avancÃ©es.*

â­ï¸ [Attacher Ã  des hooks kernel](/21-introduction-ebpf/05.3-hooks-kernel.md)
