üîù Retour au [Sommaire](/SOMMAIRE.md)

# 15.3.1 Core Dumps

## Introduction

Un **core dump** (ou fichier core) est une capture instantan√©e de la m√©moire d'un programme au moment o√π il s'est crash√©. C'est comme une "photographie post-mortem" qui permet d'analyser ce qui s'est pass√© juste avant le crash, m√™me si le programme ne s'ex√©cute plus.

### Pourquoi les core dumps sont essentiels ?

Imaginez que votre application en production crash √† 3h du matin. Sans core dump, vous ne saurez jamais :
- Quelle √©tait la valeur des variables au moment du crash
- Quelle fonction a provoqu√© l'erreur
- L'√©tat complet de la pile d'appels

Avec un core dump, vous pouvez "remonter le temps" et enqu√™ter comme un d√©tective sur une sc√®ne de crime.

---

## Qu'est-ce qui g√©n√®re un core dump ?

Un core dump est cr√©√© automatiquement par le syst√®me d'exploitation lorsque :
- **Segmentation fault** (acc√®s m√©moire invalide)
- **Abort signal** (appel √† `abort()`)
- **Bus error** (alignement m√©moire incorrect)
- **Floating point exception** (division par z√©ro)
- **Illegal instruction** (code machine invalide)

### Exemple de crash typique

```c
#include <stdio.h>

int main() {
    int *ptr = NULL;
    *ptr = 42;  // ‚ö†Ô∏è Segmentation fault : d√©r√©f√©rencement d'un pointeur NULL
    return 0;
}
```

Lorsque ce programme s'ex√©cute, il va crasher et (si configur√©) g√©n√©rer un fichier core.

---

## Configuration des core dumps sur Ubuntu

Par d√©faut, les core dumps sont souvent d√©sactiv√©s ou limit√©s. Voici comment les activer.

### 1. V√©rifier la limite actuelle

```bash
ulimit -c
```

- Si la sortie est `0`, les core dumps sont d√©sactiv√©s
- Si c'est `unlimited`, ils sont activ√©s sans limite de taille

### 2. Activer les core dumps (session courante)

```bash
ulimit -c unlimited
```

Cette commande permet de g√©n√©rer des core dumps de taille illimit√©e pour la session shell actuelle.

### 3. Activer les core dumps de mani√®re permanente

Pour que la configuration persiste apr√®s un red√©marrage, ajoutez cette ligne dans `~/.bashrc` :

```bash
echo "ulimit -c unlimited" >> ~/.bashrc
```

Puis rechargez la configuration :

```bash
source ~/.bashrc
```

### 4. Configuration syst√®me (systemd)

Sur les syst√®mes modernes avec systemd, les core dumps sont g√©r√©s par `systemd-coredump`. V√©rifiez la configuration :

```bash
# Voir o√π sont stock√©s les core dumps
coredumpctl list

# Configuration du service
sudo systemctl status systemd-coredump
```

---

## Emplacement des core dumps

### Configuration classique

Par d√©faut, le fichier core est cr√©√© dans le r√©pertoire de travail du programme avec le nom `core` ou `core.<PID>`.

Vous pouvez v√©rifier le pattern de nommage avec :

```bash
cat /proc/sys/kernel/core_pattern
```

Sorties possibles :
- `core` : Fichier nomm√© "core" dans le r√©pertoire courant
- `core.%p` : "core" suivi du PID (ex: `core.12345`)
- `|/usr/lib/systemd/systemd-coredump ...` : G√©r√© par systemd

### Avec systemd-coredump

Si la sortie commence par `|`, les core dumps sont g√©r√©s par systemd. Pour y acc√©der :

```bash
# Lister tous les core dumps
coredumpctl list

# Voir les d√©tails d'un crash r√©cent
coredumpctl info

# Exporter un core dump vers le r√©pertoire courant
coredumpctl dump -o mon_programme.core
```

---

## G√©n√©rer un core dump pour le debugging

### Compilation avec symboles de d√©bogage

**Crucial** : Pour que le core dump soit exploitable, votre programme doit √™tre compil√© avec l'option `-g` :

```bash
gcc -g -o mon_programme mon_programme.c
```

Sans `-g`, vous n'aurez pas les noms de variables et de fonctions dans le core dump.

### Programme de test

Cr√©ons un programme qui va crasher intentionnellement :

```c
// crash_test.c
#include <stdio.h>
#include <stdlib.h>

void fonction_niveau_3() {
    int *ptr = NULL;
    printf("Je vais crasher...\n");
    *ptr = 42;  // Segfault !
}

void fonction_niveau_2() {
    fonction_niveau_3();
}

void fonction_niveau_1() {
    fonction_niveau_2();
}

int main() {
    printf("D√©but du programme\n");
    fonction_niveau_1();
    printf("Cette ligne ne sera jamais ex√©cut√©e\n");
    return 0;
}
```

Compilation et ex√©cution :

```bash
gcc -g -o crash_test crash_test.c  
ulimit -c unlimited  
./crash_test
```

R√©sultat :
```
D√©but du programme  
Je vais crasher...  
Segmentation fault (core dumped)  
```

Un fichier `core` ou `core.<PID>` a √©t√© cr√©√©.

---

## Analyser un core dump avec GDB

### Lancement de GDB avec le core dump

La syntaxe g√©n√©rale est :

```bash
gdb <programme> <fichier_core>
```

Exemple :

```bash
gdb ./crash_test core
```

ou avec systemd :

```bash
coredumpctl debug
```

### Commandes essentielles dans GDB

#### 1. **Afficher la backtrace (pile d'appels)**

```gdb
(gdb) bt
```

ou en version d√©taill√©e :

```gdb
(gdb) bt full
```

**Sortie typique :**
```
#0  0x00005555555551a9 in fonction_niveau_3 () at crash_test.c:7
#1  0x00005555555551c8 in fonction_niveau_2 () at crash_test.c:11
#2  0x00005555555551d8 in fonction_niveau_1 () at crash_test.c:15
#3  0x00005555555551f8 in main () at crash_test.c:20
```

Ici, on voit clairement que le crash s'est produit dans `fonction_niveau_3` √† la ligne 7.

#### 2. **Naviguer dans les frames**

```gdb
(gdb) frame 0        # Aller √† la frame 0 (fonction qui a crash√©)
(gdb) frame 3        # Aller √† la frame 3 (main)
(gdb) up             # Remonter d'une frame
(gdb) down           # Descendre d'une frame
```

#### 3. **Inspecter les variables**

Une fois dans la bonne frame :

```gdb
(gdb) info locals    # Afficher toutes les variables locales
(gdb) print ptr      # Afficher la valeur de 'ptr'
(gdb) print *ptr     # Tenter de d√©r√©f√©rencer (va montrer l'erreur)
```

#### 4. **Examiner le code source**

```gdb
(gdb) list           # Afficher le code autour du crash
(gdb) list 7         # Afficher le code autour de la ligne 7
```

#### 5. **Informations sur les registres et threads**

```gdb
(gdb) info registers # Voir l'√©tat des registres CPU
(gdb) info threads   # Lister tous les threads (programmes multi-thread√©s)
(gdb) thread 2       # Basculer sur le thread 2
```

---

## Sc√©narios pratiques d'utilisation

### Cas 1 : Crash en production

**Situation :** Votre serveur web crash al√©atoirement la nuit.

**Solution :**
1. Activez les core dumps sur le serveur de production (avec limite de taille)
2. Configurez une rotation automatique (pour ne pas remplir le disque)
3. Quand un crash survient, r√©cup√©rez le core dump
4. Analysez-le sur votre machine de d√©veloppement avec GDB

```bash
# Sur le serveur (ajout au script de d√©marrage)
ulimit -c 500000  # Limite √† ~500 MB

# R√©cup√©ration
scp serveur:/chemin/core ./core_production

# Analyse locale
gdb ./serveur_web core_production
```

### Cas 2 : Core dump d'un processus actif

Parfois, vous voulez cr√©er un core dump d'un processus qui **ne crash pas**, pour analyser son √©tat actuel :

```bash
# M√©thode 1 : Avec gcore (n√©cessite gdb)
gcore <PID>

# M√©thode 2 : Avec kill (envoie SIGABRT)
kill -ABRT <PID>

# M√©thode 3 : Depuis GDB
gdb -p <PID>
(gdb) generate-core-file
```

### Cas 3 : Analyser un double-free

```c
// double_free.c
#include <stdlib.h>

int main() {
    char *buffer = malloc(100);
    free(buffer);
    free(buffer);  // ‚ö†Ô∏è Double free !
    return 0;
}
```

Compilation et g√©n√©ration du core :

```bash
gcc -g -o double_free double_free.c
./double_free
# Erreur : double free or corruption (fasttop)
```

Analyse avec GDB :

```gdb
gdb ./double_free core
(gdb) bt
# On voit les deux appels √† free() dans la backtrace
```

---

## Bonnes pratiques et conseils

### 1. **Toujours compiler avec `-g` en d√©veloppement**

M√™me si vous ne debuggez pas imm√©diatement, gardez les symboles. Vous pouvez les retirer plus tard avec `strip` pour la production.

```bash
# D√©veloppement
gcc -g -Wall -Wextra -o app app.c

# Production (optionnel, pour r√©duire la taille)
strip app -o app_stripped
```

### 2. **Limiter la taille des core dumps**

En production, √©vitez `unlimited` :

```bash
ulimit -c 100000  # Limite √† ~100 MB
```

### 3. **Rotation automatique**

Configurez une politique de nettoyage pour ne pas saturer le disque :

```bash
# Garder seulement les 5 core dumps les plus r√©cents
find /var/cores -name "core.*" -mtime +7 -delete
```

### 4. **S√©curit√©**

Les core dumps peuvent contenir des **donn√©es sensibles** (mots de passe, cl√©s API en m√©moire). En production :
- Limitez l'acc√®s aux fichiers core (permissions)
- Chiffrez-les si n√©cessaire
- Automatisez leur suppression apr√®s analyse

```bash
# S√©curiser l'acc√®s
chmod 600 core
```

### 5. **Core dumps et Docker**

Dans un conteneur Docker, activez les core dumps :

```dockerfile
# Dockerfile
RUN echo "ulimit -c unlimited" >> /etc/profile

# Ou au lancement
docker run --ulimit core=-1 mon_image
```

---

## Limitations et alternatives

### Limitations des core dumps

1. **Taille** : Un programme avec beaucoup de m√©moire g√©n√®re un core dump gigantesque
2. **Donn√©es sensibles** : Risque de fuite d'informations
3. **Pas de contexte temporel** : On ne voit que l'instant T du crash

### Alternatives compl√©mentaires

- **rr (Record and Replay)** : Enregistre l'ex√©cution enti√®re pour un debugging "time-travel"
- **Sanitizers** : D√©tectent les erreurs avant le crash (AddressSanitizer, etc.)
- **Logs structur√©s** : Combinez core dumps avec des logs d√©taill√©s
- **Core dump automatique + notification** : Scripts pour alerter imm√©diatement en cas de crash

---

## R√©sum√© des commandes essentielles

```bash
# Configuration
ulimit -c unlimited              # Activer les core dumps  
ulimit -c                         # V√©rifier l'√©tat  

# Localisation
cat /proc/sys/kernel/core_pattern   # Voir o√π sont cr√©√©s les cores  
coredumpctl list                    # Lister les cores (systemd)  

# G√©n√©ration
gcc -g -o prog prog.c            # Compiler avec symboles de d√©bogage
./prog                            # Ex√©cuter (et crasher)

# Analyse
gdb ./prog core                  # Charger le core dump  
coredumpctl debug                # Ou via systemd  

# Commandes GDB
(gdb) bt                         # Backtrace
(gdb) bt full                    # Backtrace avec variables
(gdb) frame N                    # Aller √† la frame N
(gdb) info locals                # Variables locales
(gdb) print variable             # Afficher une variable
(gdb) list                       # Voir le code source
```

---

## Conclusion

Les core dumps sont un outil **indispensable** pour diagnostiquer les crashs, surtout en production o√π vous ne pouvez pas ex√©cuter le programme sous un d√©bogueur en temps r√©el.

**Points cl√©s √† retenir :**
- ‚úÖ Toujours activer les core dumps en d√©veloppement
- ‚úÖ Compiler avec `-g` pour avoir les symboles de d√©bogage
- ‚úÖ Utiliser `gdb` avec `bt`, `frame`, et `print` pour l'analyse
- ‚úÖ En production, limiter la taille et s√©curiser l'acc√®s
- ‚úÖ Combiner avec d'autres outils (sanitizers, logs) pour un diagnostic complet

Avec cette ma√Ætrise des core dumps, vous pouvez d√©sormais transformer chaque crash en opportunit√© d'apprentissage et de correction ! üêõüîç

‚è≠Ô∏è [Debugging distant](/15-debogage-et-qualite/03.2-debugging-distant.md)
