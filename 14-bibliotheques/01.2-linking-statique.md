ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 14.1.2 Linking statique

## Introduction

Le **linking statique** (ou Ã©dition de liens statique) est le processus par lequel le code d'une bibliothÃ¨que statique (`.a`) est **copiÃ© et intÃ©grÃ© directement** dans l'exÃ©cutable final lors de la compilation. Contrairement au linking dynamique, le programme rÃ©sultant contient tout le code nÃ©cessaire Ã  son exÃ©cution.

Dans cette section, nous allons comprendre comment le linker (Ã©diteur de liens) fonctionne et comment utiliser les bibliothÃ¨ques statiques dans vos projets.

---

## Qu'est-ce que le linking ?

### Les Ã©tapes de la compilation

Rappelons les 4 Ã©tapes principales de la compilation en C :

1. **PrÃ©processing** : Expansion des macros et inclusions (`gcc -E`)
2. **Compilation** : Transformation en code assembleur (`gcc -S`)
3. **Assemblage** : CrÃ©ation de fichiers objets `.o` (`gcc -c`)
4. **Linking** : Assemblage des fichiers objets en exÃ©cutable final â† **Nous sommes ici**

### Le rÃ´le du linker

Le **linker** (aussi appelÃ© **Ã©diteur de liens** ou **ld**) a plusieurs responsabilitÃ©s :

1. **RÃ©soudre les symboles** : Trouver oÃ¹ sont dÃ©finies les fonctions appelÃ©es
2. **Combiner les fichiers objets** : Regrouper tous les `.o` nÃ©cessaires
3. **IntÃ©grer le code des bibliothÃ¨ques** : Copier les fonctions utilisÃ©es depuis les `.a`
4. **GÃ©nÃ©rer l'exÃ©cutable final** : Produire un fichier binaire exÃ©cutable

---

## Linking statique vs Linking dynamique

### DiffÃ©rences fondamentales

| Aspect | Linking statique | Linking dynamique |
|--------|------------------|-------------------|
| Extension | `.a` (archive) | `.so` (shared object) |
| IntÃ©gration | Code copiÃ© dans l'exÃ©cutable | Code chargÃ© au runtime |
| Taille exÃ©cutable | Plus grande | Plus petite |
| DÃ©pendances | Aucune dÃ©pendance externe | NÃ©cessite la `.so` Ã  l'exÃ©cution |
| Vitesse de dÃ©marrage | Plus rapide | Plus lente (chargement dynamique) |
| Mises Ã  jour | Recompilation nÃ©cessaire | Automatique (nouvelle `.so`) |
| PortabilitÃ© | ExÃ©cutable autonome | DÃ©pend des bibliothÃ¨ques systÃ¨me |

### Illustration du linking statique

```
Avant linking :                    AprÃ¨s linking :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  main.o      â”‚                   â”‚                    â”‚
â”‚  - main()    â”‚                   â”‚   ExÃ©cutable       â”‚
â”‚  - appelle:  â”‚                   â”‚   autonome         â”‚
â”‚    addition()â”‚â”€â”€â”                â”‚                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚                â”‚  - main()          â”‚
                  â”‚                â”‚  - addition()      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   Linker       â”‚  - multiplication()â”‚
â”‚ libmath.a    â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º     â”‚  - printf()        â”‚
â”‚- addition()  â”‚  â”‚                â”‚  - ... (libc)      â”‚
â”‚- mult()      â”‚â”€â”€â”˜                â”‚                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   Tout est dans un seul
                                   fichier binaire !
```

---

## Compiler avec une bibliothÃ¨que statique

### Exemple de base

Reprenons l'exemple de la bibliothÃ¨que `libmath_utils.a` crÃ©Ã©e dans la section prÃ©cÃ©dente.

**Structure du projet :**
```
mon_projet/
â”œâ”€â”€ math_utils.h          # En-tÃªte de la bibliothÃ¨que
â”œâ”€â”€ libmath_utils.a       # BibliothÃ¨que statique (dÃ©jÃ  compilÃ©e)
â””â”€â”€ main.c                # Notre programme
```

**Fichier `main.c`** :
```c
#include <stdio.h>
#include "math_utils.h"

int main() {
    int a = 15, b = 3;

    printf("Addition : %d + %d = %d\n", a, b, addition(a, b));
    printf("Multiplication : %d * %d = %d\n", a, b, multiplication(a, b));

    return 0;
}
```

### MÃ©thode 1 : Lier directement avec le fichier `.a`

```bash
gcc main.c libmath_utils.a -o programme
```

**Explication :**
- `gcc` : Le compilateur
- `main.c` : Notre code source
- `libmath_utils.a` : La bibliothÃ¨que statique Ã  lier
- `-o programme` : Nom de l'exÃ©cutable

Le linker copiera automatiquement les fonctions `addition()` et `multiplication()` depuis `libmath_utils.a` dans l'exÃ©cutable `programme`.

### MÃ©thode 2 : Utiliser les options `-L` et `-l` (RecommandÃ©e)

```bash
gcc main.c -L. -lmath_utils -o programme
```

**DÃ©composition de la commande :**

| Option | Signification | Explication |
|--------|---------------|-------------|
| `gcc` | Compilateur | Lance le compilateur GCC |
| `main.c` | Fichier source | Notre code Ã  compiler |
| `-L.` | **Library directory** | Ajoute le rÃ©pertoire `.` (courant) au chemin de recherche |
| `-lmath_utils` | **Link library** | Lie avec `libmath_utils.a` (note : sans `lib` ni `.a`) |
| `-o programme` | Output | Nom de l'exÃ©cutable |

> **Convention importante** : L'option `-lNOM` cherche automatiquement un fichier nommÃ© `libNOM.a` (ou `libNOM.so`). C'est pourquoi on Ã©crit `-lmath_utils` et non `-llibmath_utils.a`.

### MÃ©thode 3 : SpÃ©cifier un rÃ©pertoire de bibliothÃ¨ques

Si votre bibliothÃ¨que est dans un sous-rÃ©pertoire :

```
mon_projet/
â”œâ”€â”€ main.c
â”œâ”€â”€ include/
â”‚   â””â”€â”€ math_utils.h
â””â”€â”€ lib/
    â””â”€â”€ libmath_utils.a
```

Commande de compilation :
```bash
gcc main.c -Iinclude -Llib -lmath_utils -o programme
```

**Options supplÃ©mentaires :**
- `-Iinclude` : Ajoute le rÃ©pertoire `include/` au chemin de recherche des headers
- `-Llib` : Ajoute le rÃ©pertoire `lib/` au chemin de recherche des bibliothÃ¨ques

---

## Ordre de liaison : Un piÃ¨ge courant

### Pourquoi l'ordre est important ?

Le linker GNU (`ld`) traite les fichiers **dans l'ordre** oÃ¹ ils apparaissent sur la ligne de commande. Il rÃ©sout les symboles de **gauche Ã  droite**.

### RÃ¨gle d'or

**Les fichiers qui utilisent des symboles doivent venir AVANT les fichiers qui les dÃ©finissent.**

### Exemple problÃ©matique âŒ

```bash
gcc -lmath_utils main.c -o programme
```

**Erreur potentielle :**
```
undefined reference to `addition'  
undefined reference to `multiplication'  
```

**Pourquoi ?** Le linker voit `-lmath_utils` en premier, mais ne sait pas encore quelles fonctions sont nÃ©cessaires car il n'a pas encore lu `main.c`.

### Ordre correct âœ…

```bash
gcc main.c -lmath_utils -o programme
```

ou

```bash
gcc main.c -L. -lmath_utils -o programme
```

Le linker lit `main.c` d'abord, note les symboles non rÃ©solus (`addition`, `multiplication`), puis les trouve dans `libmath_utils.a`.

### DÃ©pendances entre bibliothÃ¨ques

Si vous avez plusieurs bibliothÃ¨ques qui dÃ©pendent les unes des autres :

```bash
gcc main.c -lbiblio1 -lbiblio2 -lbiblio3 -o programme
```

**RÃ¨gle :** Les bibliothÃ¨ques "utilisatrices" avant les bibliothÃ¨ques "fournisseuses".

Si `biblio1` utilise des fonctions de `biblio2`, et `biblio2` utilise des fonctions de `biblio3` :

```bash
gcc main.c -lbiblio1 -lbiblio2 -lbiblio3 -o programme
```

---

## VÃ©rifier le linking

### VÃ©rifier les symboles dÃ©finis dans l'exÃ©cutable

AprÃ¨s compilation, vÃ©rifiez que les symboles sont bien intÃ©grÃ©s :

```bash
nm programme | grep addition
```

Sortie attendue :
```
00000000000011a9 T addition
```

**LÃ©gende :**
- `T` : Symbole dÃ©fini dans la section `.text` (code exÃ©cutable)
- L'adresse hexadÃ©cimale montre oÃ¹ se trouve la fonction

### VÃ©rifier les dÃ©pendances dynamiques

Pour confirmer que l'exÃ©cutable n'a PAS de dÃ©pendances dynamiques sur notre bibliothÃ¨que :

```bash
ldd programme
```

Sortie typique :
```
linux-vdso.so.1 (0x00007ffd8e7fe000)  
libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f8e5a400000)  
/lib64/ld-linux-x86-64.so.2 (0x00007f8e5a800000)
```

Vous voyez `libc.so.6` (bibliothÃ¨que C standard, liÃ©e dynamiquement par dÃ©faut), mais **pas** de `libmath_utils.so`, car notre code a Ã©tÃ© liÃ© **statiquement**.

### VÃ©rifier la taille de l'exÃ©cutable

```bash
ls -lh programme
```

Vous constaterez que l'exÃ©cutable est plus volumineux car il contient le code de `libmath_utils.a`.

---

## Linking statique de la libc

### Comportement par dÃ©faut

Par dÃ©faut, GCC lie la bibliothÃ¨que C standard (`libc`) **dynamiquement**. C'est pourquoi `ldd` montre `libc.so.6`.

### Forcer le linking statique complet

Pour crÃ©er un exÃ©cutable **totalement statique** (y compris la libc) :

```bash
gcc main.c -L. -lmath_utils -static -o programme_static
```

L'option `-static` force le linking statique de **toutes** les bibliothÃ¨ques, y compris la libc.

**VÃ©rification :**
```bash
ldd programme_static
```

Sortie :
```
not a dynamic executable
```

L'exÃ©cutable est maintenant **complÃ¨tement autonome** mais beaucoup plus volumineux.

### Comparaison de taille

```bash
ls -lh programme programme_static
```

Exemple de sortie :
```
-rwxr-xr-x 1 user user  16K Nov 26 10:00 programme
-rwxr-xr-x 1 user user 850K Nov 26 10:05 programme_static
```

Le programme statique complet est **50 fois plus gros** car il contient toute la libc !

---

## Options de linking avancÃ©es

### `-static` : Linking complÃ¨tement statique

```bash
gcc main.c -lmath_utils -static -o programme
```

Force le linking statique de **toutes** les bibliothÃ¨ques.

### `-Wl,option` : Passer des options au linker

GCC est un "driver" qui appelle le linker `ld`. Pour passer des options directement au linker :

```bash
gcc main.c -lmath_utils -Wl,--verbose -o programme
```

`-Wl,--verbose` passe l'option `--verbose` au linker pour afficher des dÃ©tails.

### `-Wl,-Bstatic` et `-Wl,-Bdynamic` : ContrÃ´le sÃ©lectif

Pour lier certaines bibliothÃ¨ques en statique et d'autres en dynamique :

```bash
gcc main.c -Wl,-Bstatic -lmath_utils -Wl,-Bdynamic -lm -o programme
```

**Explication :**
- `-Wl,-Bstatic` : Les bibliothÃ¨ques suivantes seront liÃ©es statiquement
- `-lmath_utils` : LiÃ©e statiquement
- `-Wl,-Bdynamic` : Retour au mode dynamique
- `-lm` : BibliothÃ¨que mathÃ©matique liÃ©e dynamiquement

### `--start-group` et `--end-group` : DÃ©pendances circulaires

Si vous avez des dÃ©pendances circulaires entre bibliothÃ¨ques :

```bash
gcc main.c -Wl,--start-group -lbibA -lbibB -lbibC -Wl,--end-group -o programme
```

Le linker fait plusieurs passes sur les bibliothÃ¨ques pour rÃ©soudre tous les symboles.

---

## Avantages du linking statique

### âœ… 1. ExÃ©cutable autonome

**Avantage principal :** L'exÃ©cutable contient tout le code nÃ©cessaire.

```bash
./programme  # Fonctionne partout, mÃªme sans libmath_utils.a
```

Pas besoin de :
- Installer la bibliothÃ¨que sur la machine cible
- Configurer `LD_LIBRARY_PATH`
- S'inquiÃ©ter de versions incompatibles

### âœ… 2. Pas de "Dependency Hell"

Le problÃ¨me classique du linking dynamique :
```
error while loading shared libraries: libmath_utils.so.1: cannot open shared object file
```

**Avec le linking statique :** Ce problÃ¨me n'existe pas.

### âœ… 3. Performance au dÃ©marrage

L'exÃ©cutable se lance plus rapidement car :
- Pas de rÃ©solution de symboles au runtime
- Pas de chargement de bibliothÃ¨ques dynamiques
- Pas d'appels `dlopen()` / `dlsym()`

### âœ… 4. SÃ©curitÃ© et isolation

- L'exÃ©cutable ne peut pas Ãªtre affectÃ© par une mise Ã  jour malveillante d'une `.so`
- Comportement dÃ©terministe garanti

---

## InconvÃ©nients du linking statique

### âŒ 1. Taille de l'exÃ©cutable

Le code est dupliquÃ© dans chaque exÃ©cutable :

```
Programme A (20 MB) â† libmath.a (5 MB)  
Programme B (25 MB) â† libmath.a (5 MB)  
Programme C (18 MB) â† libmath.a (5 MB)  
```

**Total disque :** 63 MB au lieu de 48 MB (avec une seule `.so` partagÃ©e)

### âŒ 2. Mises Ã  jour de sÃ©curitÃ©

Si une faille est dÃ©couverte dans `libmath_utils.a` :
- **Linking dynamique :** On met Ã  jour la `.so`, tous les programmes en bÃ©nÃ©ficient
- **Linking statique :** Il faut **recompiler** tous les programmes !

### âŒ 3. Utilisation de la RAM

Plusieurs instances du programme consomment plus de RAM car le code n'est pas partagÃ© :

```
RAM avec .so partagÃ©e :    RAM avec linking statique :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Programme Aâ”‚             â”‚ Programme Aâ”‚
â”‚ (code app) â”‚             â”‚ (code app +â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚  libmath)  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚ Programme Bâ”‚             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (code app) â”‚             â”‚ Programme Bâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚ (code app +â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚  libmath)  â”‚
â”‚libmath.so  â”‚â—„â”€â”€â”€â”€tous    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚ (partagÃ©e) â”‚    partagent
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### âŒ 4. Temps de compilation

Linking statique peut Ãªtre plus lent, surtout avec de grosses bibliothÃ¨ques.

---

## Quand utiliser le linking statique ?

### âœ… Cas d'usage recommandÃ©s

1. **Distribution d'outils CLI**
   ```bash
   # Votre outil fonctionne partout sans installation
   curl -L https://example.com/mytool -o mytool
   chmod +x mytool
   ./mytool
   ```

2. **Environnements embarquÃ©s**
   - Espace limitÃ©, pas de systÃ¨me de packages
   - ContrÃ´le total sur l'exÃ©cutable

3. **Conteneurs Docker (binaires statiques)**
   ```dockerfile
   FROM scratch
   COPY programme /
   ENTRYPOINT ["/programme"]
   ```
   Un conteneur de quelques KB seulement !

4. **Applications critiques**
   - Isolation maximale
   - Pas de dÃ©pendances externes Ã  gÃ©rer

5. **DÃ©ploiement sur machines hÃ©tÃ©rogÃ¨nes**
   - DiffÃ©rentes distributions Linux
   - Versions de libc diffÃ©rentes

### âŒ Cas oÃ¹ Ã©viter le linking statique

1. **Applications systÃ¨me standard** (navigateurs, bureautique)
2. **Serveurs long-running** (Apache, Nginx) â†’ mises Ã  jour frÃ©quentes
3. **Environnements avec beaucoup d'exÃ©cutables** â†’ gaspillage de RAM/disque
4. **Besoin de plugins dynamiques** â†’ `dlopen()` nÃ©cessaire

---

## Workflow pratique complet

### Projet complet avec bibliothÃ¨que statique

**Structure :**
```
mon_projet/
â”œâ”€â”€ include/
â”‚   â””â”€â”€ math_utils.h
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ addition.c
â”‚   â”œâ”€â”€ multiplication.c
â”‚   â””â”€â”€ main.c
â”œâ”€â”€ lib/
â”‚   â””â”€â”€ (bibliothÃ¨ques compilÃ©es)
â”œâ”€â”€ build/
â”‚   â””â”€â”€ (fichiers objets)
â””â”€â”€ Makefile
```

**Makefile complet :**
```makefile
# Compilateur et flags
CC = gcc  
CFLAGS = -Wall -Wextra -Iinclude  
LDFLAGS = -Llib  
LDLIBS = -lmath_utils  

# RÃ©pertoires
SRC_DIR = src  
BUILD_DIR = build  
LIB_DIR = lib  
INC_DIR = include  

# Cibles
TARGET = programme  
LIB_TARGET = $(LIB_DIR)/libmath_utils.a  

# Fichiers sources de la bibliothÃ¨que
LIB_SRCS = $(SRC_DIR)/addition.c $(SRC_DIR)/multiplication.c  
LIB_OBJS = $(patsubst $(SRC_DIR)/%.c,$(BUILD_DIR)/%.o,$(LIB_SRCS))  

# RÃ¨gle par dÃ©faut
all: $(TARGET)

# CrÃ©er les rÃ©pertoires nÃ©cessaires
$(BUILD_DIR) $(LIB_DIR):
	mkdir -p $@

# Compiler la bibliothÃ¨que statique
$(LIB_TARGET): $(LIB_OBJS) | $(LIB_DIR)
	ar rcs $@ $^
	ranlib $@

# Compiler les objets de la bibliothÃ¨que
$(BUILD_DIR)/%.o: $(SRC_DIR)/%.c | $(BUILD_DIR)
	$(CC) $(CFLAGS) -c $< -o $@

# Compiler le programme principal avec linking statique
$(TARGET): $(SRC_DIR)/main.c $(LIB_TARGET)
	$(CC) $(CFLAGS) $< $(LDFLAGS) $(LDLIBS) -o $@

# Nettoyage
clean:
	rm -rf $(BUILD_DIR) $(LIB_DIR) $(TARGET)

# RÃ¨gle pour tout recompiler
rebuild: clean all

.PHONY: all clean rebuild
```

**Utilisation :**
```bash
make           # Compile tout
./programme    # ExÃ©cute
make clean     # Nettoie
```

---

## Debugging du linking

### ProblÃ¨me : "undefined reference to ..."

**Erreur typique :**
```
/usr/bin/ld: /tmp/main-abc123.o: in function `main':
main.c:(.text+0x1a): undefined reference to `addition'  
collect2: error: ld returned 1 exit status  
```

**Causes possibles :**

1. **BibliothÃ¨que non spÃ©cifiÃ©e**
   ```bash
   # âŒ Mauvais
   gcc main.c -o programme

   # âœ… Correct
   gcc main.c -lmath_utils -o programme
   ```

2. **Ordre incorrect**
   ```bash
   # âŒ Mauvais
   gcc -lmath_utils main.c -o programme

   # âœ… Correct
   gcc main.c -lmath_utils -o programme
   ```

3. **Chemin de bibliothÃ¨que incorrect**
   ```bash
   # âŒ Mauvais (bibliothÃ¨que dans lib/)
   gcc main.c -lmath_utils -o programme

   # âœ… Correct
   gcc main.c -Llib -lmath_utils -o programme
   ```

4. **Nom de bibliothÃ¨que incorrect**
   ```bash
   # âŒ Mauvais
   gcc main.c -llibmath_utils.a -o programme

   # âœ… Correct (sans lib ni .a)
   gcc main.c -lmath_utils -o programme
   ```

### ProblÃ¨me : "cannot find -lmath_utils"

**Erreur :**
```
/usr/bin/ld: cannot find -lmath_utils
collect2: error: ld returned 1 exit status
```

**Solutions :**

1. **VÃ©rifier que la bibliothÃ¨que existe :**
   ```bash
   ls -la libmath_utils.a
   ```

2. **SpÃ©cifier le chemin avec -L :**
   ```bash
   gcc main.c -L. -lmath_utils -o programme
   ```

3. **VÃ©rifier les chemins de recherche du linker :**
   ```bash
   gcc main.c -lmath_utils -o programme -Wl,--verbose 2>&1 | grep SEARCH_DIR
   ```

### Afficher les dÃ©tails du linking

Pour voir exactement ce que fait le linker :

```bash
gcc main.c -lmath_utils -o programme -Wl,--verbose > link_log.txt 2>&1
```

Ou en version courte :
```bash
gcc main.c -lmath_utils -o programme -v
```

---

## RÃ©sumÃ© des commandes essentielles

| Commande | Description |
|----------|-------------|
| `gcc main.c libmath.a -o prog` | Linking direct avec le fichier `.a` |
| `gcc main.c -L. -lmath -o prog` | Linking avec `-L` et `-l` (recommandÃ©) |
| `gcc main.c -lmath -static -o prog` | Linking 100% statique (avec libc) |
| `nm programme` | Lister les symboles dans l'exÃ©cutable |
| `ldd programme` | Afficher les dÃ©pendances dynamiques |
| `file programme` | VÃ©rifier le type de l'exÃ©cutable |
| `gcc ... -Wl,--verbose` | Afficher les dÃ©tails du linking |

---

## Points clÃ©s Ã  retenir

- âœ… **Le linking statique intÃ¨gre le code de la bibliothÃ¨que dans l'exÃ©cutable**
- âœ… **Syntaxe recommandÃ©e :** `gcc main.c -L<dir> -l<nom> -o prog`
- âœ… **L'ordre compte :** Fichiers utilisateurs AVANT bibliothÃ¨ques
- âœ… **Avantage principal :** ExÃ©cutable autonome, portable
- âœ… **InconvÃ©nient principal :** Taille accrue, pas de mises Ã  jour automatiques
- âœ… **Option `-static`** : Force le linking statique complet (y compris libc)
- âœ… **Debugging :** Utilisez `nm`, `ldd` et `-Wl,--verbose`

Dans la section suivante, nous explorerons les **bibliothÃ¨ques dynamiques** (`.so`) et comparerons en profondeur les deux approches.

â­ï¸ [BibliothÃ¨ques dynamiques (.so)](/14-bibliotheques/02-bibliotheques-dynamiques.md)
