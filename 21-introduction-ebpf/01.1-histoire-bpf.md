ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 21.1.1 Histoire : de BPF classique Ã  eBPF

## Introduction

Pour comprendre eBPF (extended Berkeley Packet Filter), il faut d'abord connaÃ®tre son ancÃªtre : BPF. Cette histoire commence dans les annÃ©es 1990 et illustre comment une technologie initialement conÃ§ue pour un usage trÃ¨s spÃ©cifique est devenue l'une des innovations les plus importantes du noyau Linux moderne.

---

## ğŸ“œ 1992 : La naissance de BPF

### Le problÃ¨me Ã  rÃ©soudre

Au dÃ©but des annÃ©es 1990, les administrateurs rÃ©seau et les dÃ©veloppeurs d'outils de diagnostic (comme `tcpdump`) faisaient face Ã  un problÃ¨me majeur : **comment filtrer efficacement les paquets rÃ©seau au niveau du noyau ?**

**Avant BPF**, le processus Ã©tait inefficace :
1. Le noyau capturait **tous** les paquets rÃ©seau
2. Les paquets Ã©taient copiÃ©s vers l'espace utilisateur
3. L'application filtrait les paquets pertinents dans l'espace utilisateur
4. Les paquets non pertinents Ã©taient jetÃ©s

**RÃ©sultat** : Gaspillage massif de ressources CPU et de bande passante mÃ©moire.

### La solution : Berkeley Packet Filter (BPF)

En **1992**, Steven McCanne et Van Jacobson de l'UniversitÃ© de Berkeley publient un article rÃ©volutionnaire : *"The BSD Packet Filter: A New Architecture for User-level Packet Capture"*.

**L'idÃ©e rÃ©volutionnaire** : Permettre Ã  l'utilisateur de dÃ©finir un petit programme (en bytecode) qui s'exÃ©cute **directement dans le noyau** pour filtrer les paquets **avant** qu'ils ne soient copiÃ©s vers l'espace utilisateur.

### Architecture de BPF classique

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         ESPACE UTILISATEUR             â”‚
â”‚                                        â”‚
â”‚  Application (tcpdump, wireshark)      â”‚
â”‚      â†‘                                 â”‚
â”‚      â”‚ Seuls les paquets               â”‚
â”‚      â”‚ correspondants                  â”‚
â””â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      â”‚     NOYAU LINUX                 â”‚
â”‚      â”‚                                 â”‚
â”‚  â”Œâ”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚  â”‚  BPF Interpreter â”‚                  â”‚
â”‚  â”‚  (Machine Virtuelle)                â”‚
â”‚  â”‚   â€¢ Filtre en bytecode              â”‚
â”‚  â”‚   â€¢ SÃ©curisÃ© (vÃ©rificateur)         â”‚
â”‚  â””â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”‚      â”‚                                 â”‚
â”‚  â”Œâ”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚  â”‚  Packets rÃ©seau  â”‚                  â”‚
â”‚  â”‚  (Interface NIC) â”‚                  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### CaractÃ©ristiques de BPF classique

**Machine virtuelle simple** :
- **11 instructions** seulement (comparaison, saut, arithmÃ©tique)
- **2 registres** (Accumulateur et Index)
- **MÃ©moire scratch** de 16 slots

**SÃ©curitÃ©** :
- Programme Ã  **taille fixe** (limitÃ©)
- **VÃ©rificateur** : Le noyau vÃ©rifie que le programme est sÃ»r avant de l'exÃ©cuter
- Garantie de **terminaison** : Pas de boucles infinies possibles

**Performance** :
- ExÃ©cution dans le noyau = pas de copie inutile
- **10 Ã  100 fois plus rapide** que le filtrage en espace utilisateur

### Exemple : Filtre BPF classique

Voici Ã  quoi ressemble un filtre BPF classique pour capturer uniquement les paquets TCP vers le port 80 (HTTP) :

```
ldh [12]              ; Charge le type Ethernet (offset 12)
jeq #0x800, L1, L2    ; Si IPv4 (0x800), aller Ã  L1, sinon L2
L1: ldb [23]          ; Charge le protocole IP (offset 23)
    jeq #6, L3, L2    ; Si TCP (6), aller Ã  L3, sinon L2
L3: ldh [20]          ; Charge le port destination
    jeq #80, L4, L2   ; Si port 80, accepter (L4), sinon rejeter (L2)
L4: ret #-1           ; Accepter le paquet (retourner -1 = true)
L2: ret #0            ; Rejeter le paquet (retourner 0 = false)
```

**Traduction en franÃ§ais** :
1. Regarde si c'est un paquet IPv4
2. Si oui, regarde si c'est du TCP
3. Si oui, regarde si le port destination est 80
4. Si toutes les conditions sont vraies â†’ accepter, sinon rejeter

---

## ğŸ”„ 2000-2010 : Adoption et limitations

### Adoption massive

BPF devient **le standard de facto** pour la capture de paquets :
- **tcpdump** : Outil en ligne de commande
- **Wireshark** : Interface graphique
- **libpcap** : BibliothÃ¨que standard pour la capture rÃ©seau

Tous les systÃ¨mes UNIX modernes (Linux, BSD, macOS, Solaris) intÃ¨grent BPF.

### Limitations croissantes

Avec le temps, les limitations de BPF classique deviennent Ã©videntes :

**1. LimitÃ© au rÃ©seau**
- BPF ne peut filtrer **que** les paquets rÃ©seau
- Impossible de l'utiliser pour d'autres cas d'usage (tracing, sÃ©curitÃ©, etc.)

**2. Instructions limitÃ©es**
- Seulement 11 instructions â†’ logique complexe difficile
- Pas de support pour les structures de donnÃ©es avancÃ©es
- Pas d'accÃ¨s Ã  la mÃ©moire noyau

**3. Architecture 32 bits**
- Registres de 32 bits seulement
- Pas adaptÃ© aux architectures 64 bits modernes

**4. Pas d'Ã©tat persistant**
- Impossible de garder des informations entre paquets
- Pas de compteurs, pas de statistiques

---

## ğŸš€ 2014 : La rÃ©volution eBPF

### Le contexte

En 2014, Alexei Starovoitov (ingÃ©nieur chez PLUMgrid, puis Facebook/Meta) propose une refonte complÃ¨te de BPF. Son objectif : **transformer BPF d'un simple filtre de paquets en une plateforme gÃ©nÃ©rique et sÃ»re pour exÃ©cuter du code dans le noyau Linux**.

Le nouveau nom : **eBPF** (extended BPF)

### Changements majeurs

**1. Machine virtuelle moderne**

| Aspect | BPF classique | eBPF |
|--------|---------------|------|
| **Registres** | 2 (32 bits) | 11 (64 bits) |
| **Instructions** | ~11 | ~100+ |
| **MÃ©moire** | 16 slots scratch | Maps illimitÃ©es + stack 512 bytes |
| **Architecture** | 32 bits | 64 bits natif |

**2. PortÃ©e Ã©tendue**

eBPF n'est plus limitÃ© au rÃ©seau. Il peut Ãªtre attachÃ© Ã  :
- **Tracepoints** du noyau (Ã©vÃ©nements systÃ¨me)
- **Kprobes/Uprobes** (instrumentation dynamique)
- **Perf events** (performance monitoring)
- **Cgroups** (contrÃ´le de ressources)
- **XDP** (eXpress Data Path - traitement rÃ©seau ultra-rapide)
- **Sockets, TC (Traffic Control)**, etc.

**3. Structures de donnÃ©es : BPF Maps**

Introduction des **BPF Maps** : structures de donnÃ©es partagÃ©es entre le noyau et l'espace utilisateur.

Types de maps :
- **Hash tables** : Stockage clÃ©-valeur
- **Arrays** : Tableaux indexÃ©s
- **Ring buffers** : Communication efficace
- **LRU caches** : Caches avec Ã©viction automatique
- Et bien d'autres...

**4. JIT Compilation**

eBPF intÃ¨gre un compilateur **Just-In-Time (JIT)** :
- Le bytecode eBPF est compilÃ© en **code machine natif**
- Performance Ã©quivalente au code C natif du noyau
- Support pour x86-64, ARM64, RISC-V, etc.

**5. VÃ©rificateur renforcÃ©**

Le vÃ©rificateur eBPF est bien plus sophistiquÃ© :
- VÃ©rifie l'absence de boucles infinies
- Garantit que tous les chemins se terminent
- VÃ©rifie les accÃ¨s mÃ©moire (pas de dÃ©passement de buffer)
- EmpÃªche les fuites de donnÃ©es sensibles du noyau
- Limite la complexitÃ© (< 1 million d'instructions)

---

## ğŸ¯ Pourquoi "extended" ?

Le terme "extended" ne rend pas justice Ã  l'ampleur des changements. Voici une comparaison :

### BPF classique (1992-2014)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Use case : Filtrage rÃ©seau â”‚
â”‚                              â”‚
â”‚   â€¢ Simple VM (11 inst.)     â”‚
â”‚   â€¢ Seulement pour packets   â”‚
â”‚   â€¢ Pas d'Ã©tat persistant    â”‚
â”‚   â€¢ 32 bits                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### eBPF (2014+)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Plateforme programmable du noyau        â”‚
â”‚                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Networking  â”‚  â”‚  ObservabilitÃ©       â”‚  â”‚
â”‚  â”‚  â€¢ XDP       â”‚  â”‚  â€¢ Tracing           â”‚  â”‚
â”‚  â”‚  â€¢ TC        â”‚  â”‚  â€¢ Profiling         â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  SÃ©curitÃ©    â”‚  â”‚  Monitoring          â”‚  â”‚
â”‚  â”‚  â€¢ Seccomp   â”‚  â”‚  â€¢ MÃ©triques         â”‚  â”‚
â”‚  â”‚  â€¢ LSM       â”‚  â”‚  â€¢ Logging           â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                              â”‚
â”‚  â€¢ VM 64 bits moderne (11 registres)         â”‚
â”‚  â€¢ 100+ instructions                         â”‚
â”‚  â€¢ BPF Maps (structures de donnÃ©es)          â”‚
â”‚  â€¢ JIT compilation                           â”‚
â”‚  â€¢ VÃ©rificateur de sÃ©curitÃ© avancÃ©           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“ˆ 2015-2025 : L'adoption explosive

### Adoption dans le noyau Linux

- **Linux 3.18 (2014)** : Introduction d'eBPF
- **Linux 4.1 (2015)** : Support XDP (Express Data Path)
- **Linux 4.4 (2016)** : BPF pour la sÃ©curitÃ© (seccomp-bpf)
- **Linux 4.7 (2016)** : Support des tracepoints
- **Linux 4.15 (2018)** : BTF (BPF Type Format) pour la portabilitÃ©
- **Linux 5.x+** : AmÃ©lioration continue (helpers, maps, etc.)

### Projets majeurs basÃ©s sur eBPF

**Networking** :
- **Cilium** : CNI (Container Network Interface) pour Kubernetes
- **Katran** : Load balancer L4 de Facebook/Meta
- **Cloudflare** : Protection DDoS et load balancing

**ObservabilitÃ©** :
- **bpftrace** : Outil de tracing dynamique
- **BCC (BPF Compiler Collection)** : Outils de performance
- **Pixie** : ObservabilitÃ© automatique pour Kubernetes

**SÃ©curitÃ©** :
- **Falco** : DÃ©tection d'intrusions et anomalies
- **Tetragon** : Security observability basÃ© sur eBPF

### Pourquoi cet engouement ?

**1. Performance sans compromis**
- Code exÃ©cutÃ© dans le noyau (pas de context switch)
- JIT compilation = vitesse native
- Zero-copy pour le traitement de donnÃ©es

**2. SÃ©curitÃ© par design**
- VÃ©rificateur garantit qu'aucun crash n'est possible
- Pas besoin de modules noyau custom (dangereux)
- Isolation complÃ¨te

**3. Dynamisme**
- Chargement/dÃ©chargement Ã  chaud (sans reboot)
- Mise Ã  jour de la logique sans interruption
- Pas de recompilation du noyau

**4. PortabilitÃ©**
- Un programme eBPF fonctionne sur diffÃ©rentes versions du noyau
- BTF (BPF Type Format) rÃ©sout les problÃ¨mes de compatibilitÃ©
- Ã‰cosystÃ¨me d'outils mature (libbpf, bpftool)

---

## ğŸ¤” Analogie pour les dÃ©butants

Imaginez le noyau Linux comme **l'aÃ©roport d'une grande ville**.

### Avant BPF : ContrÃ´le inefficace

Tous les passagers (paquets rÃ©seau) doivent :
1. Passer la douane (noyau â†’ espace utilisateur)
2. ÃŠtre vÃ©rifiÃ©s manuellement un par un (filtrage application)
3. Les non-concernÃ©s font demi-tour (gaspillage)

**RÃ©sultat** : Files d'attente interminables, douaniers dÃ©bordÃ©s.

### BPF classique (1992) : ContrÃ´le intelligent

On place des **agents de prÃ©-tri** (programmes BPF) **avant la douane** :
- "Vous allez Ã  Paris ? Passez par la porte A."
- "Les autres, sortie B."

**RÃ©sultat** : Beaucoup plus efficace, mais limitÃ© aux voyageurs (paquets).

### eBPF (2014+) : SystÃ¨me de gestion intelligent

Les agents deviennent des **robots intelligents programmables** qui peuvent :
- Trier les passagers (rÃ©seau)
- Compter les bagages (mÃ©triques)
- DÃ©tecter les comportements suspects (sÃ©curitÃ©)
- Prioriser les VIPs (QoS)
- Collecter des statistiques (observabilitÃ©)
- S'adapter en temps rÃ©el (programmabilitÃ©)

Et tout Ã§a **sans ralentir le trafic** et **sans danger** (vÃ©rificateur).

---

## ğŸ“ RÃ©sumÃ© : Les jalons historiques

| AnnÃ©e | Ã‰vÃ©nement | Impact |
|-------|-----------|--------|
| **1992** | Publication de BPF par Berkeley | Filtrage rÃ©seau efficace dans le noyau |
| **1997** | BPF intÃ©grÃ© dans Linux 2.1 | Adoption dans l'Ã©cosystÃ¨me Linux |
| **2000s** | Adoption massive (tcpdump, Wireshark) | Standard de facto pour capture rÃ©seau |
| **2014** | Alexei Starovoitov propose eBPF | Transformation en plateforme gÃ©nÃ©rique |
| **2014** | Linux 3.18 : Introduction eBPF | DÃ©but de la rÃ©volution |
| **2016** | XDP (Express Data Path) | Performance rÃ©seau extrÃªme |
| **2018** | BTF (BPF Type Format) | PortabilitÃ© entre versions noyau |
| **2020+** | Adoption enterprise massive | Cilium, Falco, Pixie, Datadog, etc. |
| **2025** | eBPF standard de l'industrie | Incontournable pour DevOps/SRE moderne |

---

## ğŸ’¡ Pourquoi apprendre eBPF en 2025 ?

**Pour les DevOps/SRE** :
- ObservabilitÃ© sans agent avec overhead minimal
- Debugging de production sans redÃ©ploiement
- SÃ©curitÃ© rÃ©seau et runtime moderne (Cilium, Falco)

**Pour les dÃ©veloppeurs systÃ¨me** :
- Comprendre les mÃ©canismes internes de Linux
- CrÃ©er des outils de performance custom
- Instrumentation dynamique des applications

**Pour les ingÃ©nieurs rÃ©seau** :
- Load balancing et DDoS protection (XDP)
- Optimisation du chemin rÃ©seau (zero-copy)
- Remplacement progressif d'iptables

---

## ğŸ”® Conclusion

De **simple filtre de paquets en 1992** Ã  **plateforme de programmation du noyau en 2025**, BPF a parcouru un chemin extraordinaire. eBPF est aujourd'hui considÃ©rÃ© comme **l'une des innovations les plus importantes de Linux depuis des dÃ©cennies**.

La citation de Brendan Gregg (expert performance chez Netflix) rÃ©sume bien l'impact :

> *"eBPF fait pour Linux ce que JavaScript a fait pour HTML. Il transforme un systÃ¨me statique en une plateforme programmable dynamique."*

Dans les sections suivantes, nous allons explorer :
- L'architecture technique d'eBPF
- Comment Ã©crire des programmes eBPF
- Les cas d'usage concrets pour DevOps

**Passons Ã  la pratique !** ğŸš€

---

## ğŸ“š RÃ©fÃ©rences historiques

- [The BSD Packet Filter (1992) - Paper original](https://www.tcpdump.org/papers/bpf-usenix93.pdf)
- [eBPF Summit Archives](https://ebpf.io/summit-2024/)
- [Linux Kernel Archives - BPF](https://www.kernel.org/doc/html/latest/bpf/)
- [Cilium Blog - eBPF History](https://cilium.io/blog/)

â­ï¸ [Pourquoi eBPF rÃ©volutionne Linux](/21-introduction-ebpf/01.2-pourquoi-ebpf-revolutionne.md)
