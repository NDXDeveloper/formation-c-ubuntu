üîù Retour au [Sommaire](/SOMMAIRE.md)

# 18.10.2 Types atomiques

## Vue d'ensemble

La biblioth√®que `stdatomic.h` de C11 introduit une famille compl√®te de **types atomiques** qui permettent d'effectuer des op√©rations thread-safe sur diff√©rents types de donn√©es. Dans cette section, nous allons explorer tous les types disponibles, leur syntaxe, et comment les utiliser.

---

## Les types atomiques de base

### Nomenclature

Tous les types atomiques suivent le m√™me sch√©ma de nommage :

```
atomic_<type>
```

Par exemple :
- `int` ‚Üí `atomic_int`
- `bool` ‚Üí `atomic_bool`
- `char` ‚Üí `atomic_char`

### Liste compl√®te des types atomiques standards

Voici tous les types atomiques d√©finis par C11 :

| Type standard | Type atomique | Description |
|--------------|---------------|-------------|
| `_Bool` | `atomic_bool` | Bool√©en (vrai/faux) |
| `char` | `atomic_char` | Caract√®re sign√© |
| `signed char` | `atomic_schar` | Caract√®re sign√© explicite |
| `unsigned char` | `atomic_uchar` | Caract√®re non sign√© |
| `short` | `atomic_short` | Entier court sign√© |
| `unsigned short` | `atomic_ushort` | Entier court non sign√© |
| `int` | `atomic_int` | Entier sign√© |
| `unsigned int` | `atomic_uint` | Entier non sign√© |
| `long` | `atomic_long` | Entier long sign√© |
| `unsigned long` | `atomic_ulong` | Entier long non sign√© |
| `long long` | `atomic_llong` | Entier tr√®s long sign√© |
| `unsigned long long` | `atomic_ullong` | Entier tr√®s long non sign√© |
| `char16_t` | `atomic_char16_t` | Caract√®re UTF-16 |
| `char32_t` | `atomic_char32_t` | Caract√®re UTF-32 |
| `wchar_t` | `atomic_wchar_t` | Caract√®re large |

### Types atomiques de taille fixe

En incluant `<stdint.h>`, vous avez acc√®s √† des types de taille garantie :

| Type standard | Type atomique | Taille |
|--------------|---------------|--------|
| `int8_t` | `atomic_int8_t` | 8 bits sign√©s |
| `uint8_t` | `atomic_uint8_t` | 8 bits non sign√©s |
| `int16_t` | `atomic_int16_t` | 16 bits sign√©s |
| `uint16_t` | `atomic_uint16_t` | 16 bits non sign√©s |
| `int32_t` | `atomic_int32_t` | 32 bits sign√©s |
| `uint32_t` | `atomic_uint32_t` | 32 bits non sign√©s |
| `int64_t` | `atomic_int64_t` | 64 bits sign√©s |
| `uint64_t` | `atomic_uint64_t` | 64 bits non sign√©s |

### Types atomiques pour pointeurs et tailles

| Type standard | Type atomique | Usage |
|--------------|---------------|-------|
| `size_t` | `atomic_size_t` | Tailles m√©moire |
| `ptrdiff_t` | `atomic_ptrdiff_t` | Diff√©rence de pointeurs |
| `intptr_t` | `atomic_intptr_t` | Pointeur vers entier |
| `uintptr_t` | `atomic_uintptr_t` | Pointeur vers entier non sign√© |
| `intmax_t` | `atomic_intmax_t` | Plus grand entier sign√© |
| `uintmax_t` | `atomic_uintmax_t` | Plus grand entier non sign√© |

---

## D√©claration et initialisation

### Syntaxe de base

```c
#include <stdatomic.h>

// D√©claration simple
atomic_int compteur;

// D√©claration avec initialisation
atomic_int compteur = 0;

// Ou avec ATOMIC_VAR_INIT (obsol√®te en C17, mais valide)
atomic_int compteur = ATOMIC_VAR_INIT(0);
```

**Note importante** : En C11, `ATOMIC_VAR_INIT` √©tait recommand√©, mais depuis C17, l'initialisation directe est la m√©thode standard.

### Initialisation recommand√©e (C17+)

```c
// ‚úÖ M√©thode moderne et recommand√©e
atomic_int compteur = 0;
atomic_bool flag = false;
atomic_long total = 100L;
```

### Initialisation dynamique

Si vous devez initialiser une variable atomique apr√®s sa d√©claration :

```c
#include <stdatomic.h>

atomic_int compteur;

void initialiser(void) {
    atomic_store(&compteur, 0);  // Initialisation atomique
}
```

---

## Types atomiques courants en d√©tail

### 1. atomic_int : Le type le plus utilis√©

```c
#include <stdio.h>
#include <stdatomic.h>
#include <pthread.h>

atomic_int compteur_global = 0;

void* incrementer(void* arg) {
    for (int i = 0; i < 100000; i++) {
        atomic_fetch_add(&compteur_global, 1);
    }
    return NULL;
}

int main(void) {
    pthread_t threads[4];

    // Cr√©er 4 threads
    for (int i = 0; i < 4; i++) {
        pthread_create(&threads[i], NULL, incrementer, NULL);
    }

    // Attendre tous les threads
    for (int i = 0; i < 4; i++) {
        pthread_join(threads[i], NULL);
    }

    printf("Compteur final : %d\n", atomic_load(&compteur_global));
    // R√©sultat garanti : 400000

    return 0;
}
```

**Cas d'usage** :
- Compteurs de r√©f√©rences
- Statistiques (nombre de requ√™tes, erreurs, etc.)
- Identifiants uniques g√©n√©r√©s de mani√®re concurrente

---

### 2. atomic_bool : Signalisation entre threads

```c
#include <stdio.h>
#include <stdatomic.h>
#include <pthread.h>
#include <unistd.h>

atomic_bool continuer = true;
atomic_int compteur_travail = 0;

void* travailleur(void* arg) {
    int id = *(int*)arg;

    // Continuer tant que le flag est vrai
    while (atomic_load(&continuer)) {
        atomic_fetch_add(&compteur_travail, 1);
        usleep(1000);  // Simuler du travail
    }

    printf("Thread %d s'arr√™te.\n", id);
    return NULL;
}

int main(void) {
    pthread_t threads[3];
    int ids[3] = {1, 2, 3};

    // D√©marrer 3 threads travailleurs
    for (int i = 0; i < 3; i++) {
        pthread_create(&threads[i], NULL, travailleur, &ids[i]);
    }

    // Laisser les threads travailler 2 secondes
    sleep(2);

    // Signal d'arr√™t
    printf("Envoi du signal d'arr√™t...\n");
    atomic_store(&continuer, false);

    // Attendre que tous les threads se terminent
    for (int i = 0; i < 3; i++) {
        pthread_join(threads[i], NULL);
    }

    printf("Travail total effectu√© : %d\n", atomic_load(&compteur_travail));

    return 0;
}
```

**Cas d'usage** :
- Flags de shutdown/arr√™t gracieux
- √âtats "ready" / "done"
- Conditions de synchronisation simples

---

### 3. atomic_size_t : Gestion de tailles

```c
#include <stdio.h>
#include <stdatomic.h>
#include <pthread.h>
#include <stdlib.h>

atomic_size_t memoire_utilisee = 0;

void* allouer_memoire(void* arg) {
    for (int i = 0; i < 1000; i++) {
        size_t taille = 1024;  // 1 KB
        void* ptr = malloc(taille);

        if (ptr) {
            atomic_fetch_add(&memoire_utilisee, taille);
            // ... utiliser la m√©moire ...
            free(ptr);
            atomic_fetch_sub(&memoire_utilisee, taille);
        }
    }
    return NULL;
}

int main(void) {
    pthread_t threads[5];

    for (int i = 0; i < 5; i++) {
        pthread_create(&threads[i], NULL, allouer_memoire, NULL);
    }

    for (int i = 0; i < 5; i++) {
        pthread_join(threads[i], NULL);
    }

    printf("M√©moire utilis√©e √† la fin : %zu octets\n",
           atomic_load(&memoire_utilisee));

    return 0;
}
```

**Cas d'usage** :
- Tracking de l'utilisation m√©moire
- Compteurs de taille de buffer
- Gestion de pools de ressources

---

### 4. atomic_uintptr_t : Pointeurs atomiques

Les pointeurs eux-m√™mes peuvent √™tre atomiques. C'est utile quand plusieurs threads doivent acc√©der ou modifier un pointeur partag√©.

```c
#include <stdio.h>
#include <stdatomic.h>
#include <pthread.h>
#include <stdlib.h>

typedef struct {
    int valeur;
    char nom[32];
} Configuration;

// Pointeur atomique vers une configuration
_Atomic(Configuration*) config_actuelle = NULL;

void* lecteur(void* arg) {
    for (int i = 0; i < 5; i++) {
        // Lire le pointeur de mani√®re atomique
        Configuration* cfg = atomic_load(&config_actuelle);

        if (cfg) {
            printf("Thread %ld lit config : %s = %d\n",
                   pthread_self(), cfg->nom, cfg->valeur);
        } else {
            printf("Thread %ld : pas de config\n", pthread_self());
        }

        sleep(1);
    }
    return NULL;
}

int main(void) {
    pthread_t thread1, thread2;

    pthread_create(&thread1, NULL, lecteur, NULL);
    pthread_create(&thread2, NULL, lecteur, NULL);

    sleep(1);

    // Changer la configuration
    Configuration* nouvelle_config = malloc(sizeof(Configuration));
    nouvelle_config->valeur = 42;
    snprintf(nouvelle_config->nom, 32, "config_v1");

    // Stocker le nouveau pointeur de mani√®re atomique
    atomic_store(&config_actuelle, nouvelle_config);
    printf("Configuration mise √† jour !\n");

    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);

    free(nouvelle_config);
    return 0;
}
```

**Cas d'usage** :
- Configuration hot-reload
- Structures de donn√©es lock-free
- Caches partag√©s

---

### 5. Types de taille fixe : Contr√¥le pr√©cis

Quand la taille exacte importe (protocoles r√©seau, s√©rialisation, etc.) :

```c
#include <stdio.h>
#include <stdatomic.h>
#include <stdint.h>
#include <pthread.h>

// Compteur 32 bits garanti
atomic_uint32_t compteur_paquets = 0;

// Timestamp 64 bits garanti
atomic_uint64_t dernier_timestamp = 0;

void* traiter_paquet(void* arg) {
    for (int i = 0; i < 10000; i++) {
        atomic_fetch_add(&compteur_paquets, 1);

        // Simuler un timestamp (en microsecondes)
        uint64_t now = (uint64_t)time(NULL) * 1000000;
        atomic_store(&dernier_timestamp, now);
    }
    return NULL;
}

int main(void) {
    pthread_t threads[4];

    for (int i = 0; i < 4; i++) {
        pthread_create(&threads[i], NULL, traiter_paquet, NULL);
    }

    for (int i = 0; i < 4; i++) {
        pthread_join(threads[i], NULL);
    }

    printf("Total de paquets : %u\n", atomic_load(&compteur_paquets));
    printf("Dernier timestamp : %lu\n", atomic_load(&dernier_timestamp));

    return 0;
}
```

**Cas d'usage** :
- Protocoles r√©seau
- Formats de fichiers binaires
- Interop√©rabilit√© avec du code embarqu√©

---

## Types atomiques g√©n√©riques avec _Atomic

### Syntaxe alternative

En plus des types nomm√©s (`atomic_int`, etc.), C11 fournit le qualificateur `_Atomic` :

```c
// Ces deux d√©clarations sont √©quivalentes :
atomic_int compteur1;
_Atomic int compteur2;

// Aussi pour les pointeurs :
_Atomic(int*) ptr_atomique;
```

### Utilisation avec des types custom

Le qualificateur `_Atomic` peut √™tre appliqu√© √† **n'importe quel type** (avec limitations) :

```c
typedef struct {
    int x;
    int y;
} Point;

// ‚ö†Ô∏è Attention : fonctionne SEULEMENT si la taille est support√©e
_Atomic Point position;
```

**Limitation importante** : Les structures ne sont atomiques que si :
1. Leur taille totale est support√©e par le hardware (g√©n√©ralement ‚â§ 8 ou 16 octets)
2. Leur alignement est appropri√©

Pour v√©rifier si un type est atomique lock-free :

```c
#include <stdatomic.h>
#include <stdio.h>

typedef struct {
    int x;
    int y;
} Point;

int main(void) {
    _Atomic Point pos;

    if (atomic_is_lock_free(&pos)) {
        printf("Point est atomique lock-free ‚úì\n");
    } else {
        printf("Point n√©cessite des locks ‚úó\n");
    }

    return 0;
}
```

---

## Tableaux de types atomiques

### D√©claration

Vous pouvez cr√©er des tableaux de types atomiques :

```c
#include <stdatomic.h>

#define TAILLE 10

atomic_int tableau[TAILLE];

// Initialisation
for (int i = 0; i < TAILLE; i++) {
    atomic_store(&tableau[i], 0);
}
```

### Exemple : Histogramme concurrent

```c
#include <stdio.h>
#include <stdatomic.h>
#include <pthread.h>
#include <stdlib.h>
#include <time.h>

#define NB_BUCKETS 10
#define NB_VALEURS 100000

atomic_int histogramme[NB_BUCKETS];

void* generer_valeurs(void* arg) {
    unsigned int seed = (unsigned int)pthread_self();

    for (int i = 0; i < NB_VALEURS; i++) {
        // G√©n√©rer un nombre al√©atoire entre 0 et 9
        int bucket = rand_r(&seed) % NB_BUCKETS;
        atomic_fetch_add(&histogramme[bucket], 1);
    }

    return NULL;
}

int main(void) {
    pthread_t threads[4];

    // Initialiser l'histogramme
    for (int i = 0; i < NB_BUCKETS; i++) {
        atomic_store(&histogramme[i], 0);
    }

    // Lancer 4 threads g√©n√©rateurs
    for (int i = 0; i < 4; i++) {
        pthread_create(&threads[i], NULL, generer_valeurs, NULL);
    }

    for (int i = 0; i < 4; i++) {
        pthread_join(threads[i], NULL);
    }

    // Afficher l'histogramme
    printf("Histogramme des valeurs g√©n√©r√©es :\n");
    for (int i = 0; i < NB_BUCKETS; i++) {
        int count = atomic_load(&histogramme[i]);
        printf("Bucket %d : %d\n", i, count);
    }

    return 0;
}
```

---

## V√©rification du support lock-free

### Macros de v√©rification √† la compilation

C11 fournit des macros pour v√©rifier le support lock-free :

```c
#include <stdatomic.h>
#include <stdio.h>

int main(void) {
    printf("Support lock-free :\n");

    #if ATOMIC_BOOL_LOCK_FREE == 2
        printf("  atomic_bool : toujours lock-free ‚úì\n");
    #elif ATOMIC_BOOL_LOCK_FREE == 1
        printf("  atomic_bool : parfois lock-free ?\n");
    #else
        printf("  atomic_bool : jamais lock-free ‚úó\n");
    #endif

    #if ATOMIC_INT_LOCK_FREE == 2
        printf("  atomic_int : toujours lock-free ‚úì\n");
    #elif ATOMIC_INT_LOCK_FREE == 1
        printf("  atomic_int : parfois lock-free ?\n");
    #else
        printf("  atomic_int : jamais lock-free ‚úó\n");
    #endif

    #if ATOMIC_LONG_LOCK_FREE == 2
        printf("  atomic_long : toujours lock-free ‚úì\n");
    #elif ATOMIC_LONG_LOCK_FREE == 1
        printf("  atomic_long : parfois lock-free ?\n");
    #else
        printf("  atomic_long : jamais lock-free ‚úó\n");
    #endif

    #if ATOMIC_LLONG_LOCK_FREE == 2
        printf("  atomic_llong : toujours lock-free ‚úì\n");
    #elif ATOMIC_LLONG_LOCK_FREE == 1
        printf("  atomic_llong : parfois lock-free ?\n");
    #else
        printf("  atomic_llong : jamais lock-free ‚úó\n");
    #endif

    #if ATOMIC_POINTER_LOCK_FREE == 2
        printf("  pointeurs atomiques : toujours lock-free ‚úì\n");
    #elif ATOMIC_POINTER_LOCK_FREE == 1
        printf("  pointeurs atomiques : parfois lock-free ?\n");
    #else
        printf("  pointeurs atomiques : jamais lock-free ‚úó\n");
    #endif

    return 0;
}
```

**Valeurs possibles** :
- `0` : Jamais lock-free (toujours avec locks)
- `1` : Parfois lock-free (d√©pend du contexte runtime)
- `2` : Toujours lock-free (garanti)

### V√©rification √† l'ex√©cution

Pour des types sp√©cifiques ou des structures custom :

```c
atomic_int x;
if (atomic_is_lock_free(&x)) {
    printf("Cette variable est lock-free\n");
}
```

---

## Consid√©rations de portabilit√©

### Support selon les architectures

| Architecture | Types typiquement lock-free |
|-------------|----------------------------|
| x86/x64 | int, long, pointeurs (jusqu'√† 64 bits) |
| ARM 32-bit | int, pointeurs 32 bits |
| ARM 64-bit | int, long, pointeurs 64 bits |
| RISC-V | int, long, pointeurs (selon config) |

### Types probl√©matiques

‚ö†Ô∏è **Attention** : Ces types peuvent ne PAS √™tre lock-free :

```c
// Sur x86 32 bits, long long (64 bits) peut n√©cessiter des locks
atomic_llong grand_nombre;  // Potentiellement pas lock-free

// Structures toujours risqu√©es
typedef struct {
    int a, b, c;  // 12 octets
} Triple;
_Atomic Triple triple;  // Probablement PAS lock-free
```

### Recommandations pour la portabilit√©

1. **Privil√©giez les types de base** : `atomic_int`, `atomic_bool`, `atomic_size_t`
2. **V√©rifiez le support** : Utilisez les macros `ATOMIC_*_LOCK_FREE`
3. **Documentez les pr√©requis** : Si votre code n√©cessite un support lock-free
4. **Testez sur les plateformes cibles** : Les √©mulateurs ne refl√®tent pas toujours le comportement r√©el

---

## Comparaison des types atomiques

### Quand utiliser quel type ?

| Besoin | Type recommand√© | Alternative |
|--------|----------------|-------------|
| Compteur simple | `atomic_int` | `atomic_long` |
| Flag bool√©en | `atomic_bool` | `atomic_int` (0/1) |
| Taille m√©moire | `atomic_size_t` | `atomic_ulong` |
| Pointeur partag√© | `_Atomic(T*)` | `atomic_uintptr_t` |
| ID unique 64 bits | `atomic_uint64_t` | `atomic_ullong` |
| Indice de tableau | `atomic_size_t` | `atomic_uint` |

### Performance relative

```
atomic_bool, atomic_int, atomic_long (taille native)
  ‚Üí Excellente performance, toujours lock-free

atomic_llong (64 bits sur 32-bit)
  ‚Üí Bonne performance, parfois lock-free

_Atomic struct
  ‚Üí Variable, souvent pas lock-free, utiliser avec pr√©caution
```

---

## Bonnes pratiques

### ‚úÖ √Ä faire

1. **Utilisez le type le plus petit possible**
   ```c
   // Si vous n'avez besoin que de 0-255
   atomic_uchar compteur_petit;  // Meilleur que atomic_int
   ```

2. **Pr√©f√©rez les types standards nomm√©s**
   ```c
   atomic_int x;  // ‚úì Clair et portable
   _Atomic int y; // ‚úì Aussi valide, mais moins idiomatique
   ```

3. **V√©rifiez le support lock-free pour la performance critique**
   ```c
   #if ATOMIC_INT_LOCK_FREE != 2
       #error "Ce code n√©cessite atomic_int lock-free"
   #endif
   ```

### ‚ùå √Ä √©viter

1. **N'utilisez pas d'atomiques pour des structures complexes**
   ```c
   // ‚úó Mauvais : probablement pas lock-free
   typedef struct { int a, b, c, d; } Quad;
   _Atomic Quad donnees;

   // ‚úì Bon : prot√©gez avec un mutex √† la place
   pthread_mutex_t lock;
   Quad donnees;
   ```

2. **N'assumez jamais qu'un type est lock-free sans v√©rifier**
   ```c
   // ‚úó Mauvais : assumption dangereuse
   atomic_llong compteur;  // Peut ne pas √™tre lock-free !

   // ‚úì Bon : v√©rification explicite
   atomic_llong compteur;
   assert(atomic_is_lock_free(&compteur));
   ```

---

## R√©sum√©

### Points cl√©s

1. **C11 fournit une famille compl√®te de types atomiques** pour tous les types primitifs
2. **Nomenclature coh√©rente** : `atomic_<type>` ou `_Atomic type`
3. **Support lock-free variable** selon le type et l'architecture
4. **V√©rification obligatoire** pour garantir les performances attendues
5. **Types de taille fixe** (`atomic_uint32_t`, etc.) pour le contr√¥le pr√©cis

### Types les plus utilis√©s en pratique

| Type | Usage principal | Fr√©quence |
|------|----------------|-----------|
| `atomic_int` | Compteurs, stats | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |
| `atomic_bool` | Flags, signaux | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |
| `atomic_size_t` | Tailles, indices | ‚≠ê‚≠ê‚≠ê‚≠ê |
| `_Atomic(T*)` | Pointeurs partag√©s | ‚≠ê‚≠ê‚≠ê |
| `atomic_uint64_t` | IDs, timestamps | ‚≠ê‚≠ê‚≠ê |

### Dans la section suivante

**18.10.3 Memory ordering** : Nous explorerons comment contr√¥ler l'ordre d'ex√©cution et la visibilit√© des op√©rations atomiques avec les diff√©rents niveaux de synchronisation (relaxed, acquire, release, seq_cst).

---

## Ressources compl√©mentaires

### Documentation
- **cppreference.com** : Documentation compl√®te sur stdatomic.h
- **C11 Standard** : Section 7.17 - Atomics
- **GCC Manual** : __atomic builtins

### Pour aller plus loin
- Testez diff√©rents types atomiques sur votre architecture
- Mesurez les performances avec et sans lock-free
- Explorez le code source de Redis ou Nginx pour voir l'utilisation r√©elle

---

**üí° Conseil pratique** : Commencez toujours par `atomic_int` et `atomic_bool`. Ces deux types couvrent 90% des cas d'usage r√©els et sont garantis lock-free sur toutes les plateformes modernes.

‚è≠Ô∏è [Memory ordering](/18-threads-et-concurrence/10.3-memory-ordering.md)
