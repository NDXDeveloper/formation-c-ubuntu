üîù Retour au [Sommaire](/SOMMAIRE.md)

# 30.1.4 Ex√©cution des tests unitaires

## Introduction

Les **tests unitaires** sont des petits programmes qui v√©rifient automatiquement que votre code C fonctionne correctement. Dans un pipeline CI/CD, l'ex√©cution automatique de ces tests √† chaque modification du code permet de **d√©tecter les bugs imm√©diatement** avant qu'ils n'atteignent la production.

Cette section vous montre comment int√©grer et ex√©cuter vos tests unitaires dans GitHub Actions, en partant du principe que vous avez d√©j√† des tests ou que vous allez en cr√©er.

---

## Pourquoi les tests unitaires en CI ?

### Avantages de l'automatisation des tests

1. **D√©tection pr√©coce des r√©gressions** : Un bug est d√©tect√© d√®s qu'il est introduit
2. **Confiance dans le code** : Vous savez que votre code fonctionne avant de le merger
3. **Documentation vivante** : Les tests montrent comment utiliser votre code
4. **Refactoring sans peur** : Modifiez le code en sachant que les tests vous prot√®gent
5. **Qualit√© visible** : Badge de statut des tests sur votre README

### Le cycle Test-Driven Development (TDD)

```
√âcrire un test ‚Üí Le test √©choue ‚Üí √âcrire le code ‚Üí Le test passe ‚Üí Refactorer
```

En CI, ce cycle est automatis√© et v√©rifi√© √† chaque commit.

---

## Frameworks de tests unitaires pour C

Contrairement √† d'autres langages, C n'a pas de framework de test int√©gr√©. Voici les plus populaires :

### 1. Unity (Recommand√© pour d√©buter)

- **Simple** et **l√©ger**
- Pas de d√©pendances
- Parfait pour l'embarqu√©
- [GitHub : ThrowTheSwitch/Unity](https://github.com/ThrowTheSwitch/Unity)

### 2. Check

- Plus complet
- Support de fixtures
- Isolation des tests (fork)
- Installation via apt : `sudo apt-get install check`

### 3. CUnit

- Framework complet
- Interface graphique disponible
- Plus ancien mais stable

### 4. Criterion

- Moderne et √©l√©gant
- Tests parall√®les
- Rapports d√©taill√©s
- [GitHub : Snaipe/Criterion](https://github.com/Snaipe/Criterion)

**Dans ce tutoriel, nous utiliserons Unity pour sa simplicit√©.**

---

## Structure d'un projet avec tests

Voici l'organisation typique d'un projet C avec tests :

```
mon-projet/
‚îú‚îÄ‚îÄ CMakeLists.txt
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ calculator.c
‚îÇ   ‚îî‚îÄ‚îÄ calculator.h
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ test_calculator.c
‚îÇ   ‚îî‚îÄ‚îÄ unity/              ‚Üê Framework Unity
‚îÇ       ‚îú‚îÄ‚îÄ unity.c
‚îÇ       ‚îî‚îÄ‚îÄ unity.h
‚îî‚îÄ‚îÄ .github/
    ‚îî‚îÄ‚îÄ workflows/
        ‚îî‚îÄ‚îÄ ci.yml
```

---

## Exemple simple : Tester une fonction

### Code source √† tester

**src/calculator.h**
```c
#ifndef CALCULATOR_H
#define CALCULATOR_H

int add(int a, int b);  
int subtract(int a, int b);  
int multiply(int a, int b);  

#endif
```

**src/calculator.c**
```c
#include "calculator.h"

int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

int multiply(int a, int b) {
    return a * b;
}
```

### Test unitaire avec Unity

**tests/test_calculator.c**
```c
#include "unity/unity.h"
#include "../src/calculator.h"

// Fonction appel√©e avant chaque test
void setUp(void) {
    // Initialisation si n√©cessaire
}

// Fonction appel√©e apr√®s chaque test
void tearDown(void) {
    // Nettoyage si n√©cessaire
}

// Test 1 : Addition de nombres positifs
void test_add_positive_numbers(void) {
    TEST_ASSERT_EQUAL_INT(5, add(2, 3));
    TEST_ASSERT_EQUAL_INT(100, add(50, 50));
}

// Test 2 : Addition avec z√©ro
void test_add_with_zero(void) {
    TEST_ASSERT_EQUAL_INT(42, add(42, 0));
    TEST_ASSERT_EQUAL_INT(42, add(0, 42));
}

// Test 3 : Addition de nombres n√©gatifs
void test_add_negative_numbers(void) {
    TEST_ASSERT_EQUAL_INT(-5, add(-2, -3));
    TEST_ASSERT_EQUAL_INT(0, add(-10, 10));
}

// Test 4 : Soustraction
void test_subtract(void) {
    TEST_ASSERT_EQUAL_INT(2, subtract(5, 3));
    TEST_ASSERT_EQUAL_INT(-5, subtract(5, 10));
}

// Test 5 : Multiplication
void test_multiply(void) {
    TEST_ASSERT_EQUAL_INT(6, multiply(2, 3));
    TEST_ASSERT_EQUAL_INT(0, multiply(5, 0));
}

// Fonction principale : Lance tous les tests
int main(void) {
    UNITY_BEGIN();

    RUN_TEST(test_add_positive_numbers);
    RUN_TEST(test_add_with_zero);
    RUN_TEST(test_add_negative_numbers);
    RUN_TEST(test_subtract);
    RUN_TEST(test_multiply);

    return UNITY_END();
}
```

**Macros Unity les plus courantes :**

- `TEST_ASSERT_EQUAL_INT(expected, actual)` : V√©rifie l'√©galit√© d'entiers
- `TEST_ASSERT_EQUAL_STRING(expected, actual)` : V√©rifie l'√©galit√© de cha√Ænes
- `TEST_ASSERT_TRUE(condition)` : V√©rifie qu'une condition est vraie
- `TEST_ASSERT_NULL(pointer)` : V√©rifie qu'un pointeur est NULL
- `TEST_ASSERT_NOT_NULL(pointer)` : V√©rifie qu'un pointeur n'est pas NULL

---

## Configuration CMake pour les tests

**CMakeLists.txt**

```cmake
cmake_minimum_required(VERSION 3.10)  
project(Calculator C)  

set(CMAKE_C_STANDARD 17)

# Biblioth√®que principale
add_library(calculator_lib
    src/calculator.c
)

target_include_directories(calculator_lib PUBLIC src)

# Ex√©cutable principal
add_executable(calculator
    src/main.c
)

target_link_libraries(calculator calculator_lib)

# ===== TESTS =====

# Activer les tests
enable_testing()

# Unity framework
add_library(unity
    tests/unity/unity.c
)

target_include_directories(unity PUBLIC tests/unity)

# Ex√©cutable de test
add_executable(test_calculator
    tests/test_calculator.c
)

target_link_libraries(test_calculator
    calculator_lib
    unity
)

# D√©clarer les tests pour CTest
add_test(NAME calculator_tests COMMAND test_calculator)
```

**Points importants :**

- `enable_testing()` : Active le support des tests dans CMake
- `add_test()` : Enregistre un test pour CTest
- Les tests sont compil√©s comme des ex√©cutables s√©par√©s

---

## Workflow de base : Ex√©cuter les tests

Voici un workflow GitHub Actions minimal pour lancer vos tests :

```yaml
name: Tests Unitaires

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout du code
      uses: actions/checkout@v4
      with:
        submodules: recursive  # Si Unity est un submodule Git

    - name: Configurer CMake
      run: cmake -B build -DCMAKE_BUILD_TYPE=Debug

    - name: Compiler le projet et les tests
      run: cmake --build build

    - name: Ex√©cuter les tests
      run: |
        cd build
        ctest --output-on-failure
```

**Options CTest utiles :**

- `--output-on-failure` : Affiche la sortie seulement si un test √©choue
- `--verbose` ou `-V` : Mode verbeux (affiche tout)
- `-j4` : Parall√©lise l'ex√©cution des tests (4 threads)
- `--rerun-failed` : Relance seulement les tests qui ont √©chou√©

---

## Comprendre la sortie de CTest

### Sortie en cas de succ√®s

```
Test project /home/runner/work/project/build
    Start 1: calculator_tests
1/1 Test #1: calculator_tests .................   Passed    0.01 sec

100% tests passed, 0 tests failed out of 1

Total Test time (real) =   0.02 sec
```

### Sortie en cas d'√©chec

```
Test project /home/runner/work/project/build
    Start 1: calculator_tests
1/1 Test #1: calculator_tests .................***Failed    0.01 sec

0% tests passed, 1 tests failed out of 1

Total Test time (real) =   0.02 sec

The following tests FAILED:
	  1 - calculator_tests (Failed)
Errors while running CTest
```

Avec `--output-on-failure`, vous verrez aussi les d√©tails :

```
tests/test_calculator.c:18:test_add_positive_numbers:FAIL: Expected 5 Was 6
```

---

## Workflow avanc√© avec matrice de tests

Tester avec diff√©rentes configurations :

```yaml
name: Tests Multi-Config

on: [push, pull_request]

jobs:
  test:
    name: Tests - ${{ matrix.build-type }} - ${{ matrix.compiler }}
    runs-on: ubuntu-latest

    strategy:
      fail-fast: false
      matrix:
        build-type: [Debug, Release]
        compiler: [gcc, clang]
        compiler-version: [11, 12, 13]

    steps:
    - uses: actions/checkout@v4
      with:
        submodules: recursive

    - name: Installer le compilateur
      run: |
        sudo apt-get update
        if [ "${{ matrix.compiler }}" = "gcc" ]; then
          sudo apt-get install -y gcc-${{ matrix.compiler-version }}
          echo "CC=gcc-${{ matrix.compiler-version }}" >> $GITHUB_ENV
        else
          sudo apt-get install -y clang-${{ matrix.compiler-version }}
          echo "CC=clang-${{ matrix.compiler-version }}" >> $GITHUB_ENV
        fi

    - name: Configurer
      run: |
        cmake -B build \
          -DCMAKE_BUILD_TYPE=${{ matrix.build-type }} \
          -DCMAKE_C_COMPILER=$CC

    - name: Compiler
      run: cmake --build build

    - name: Lancer les tests
      run: |
        cd build
        ctest --output-on-failure --verbose
```

---

## Tests avec plusieurs ex√©cutables de test

Si vous avez plusieurs fichiers de tests :

**CMakeLists.txt**

```cmake
enable_testing()

# Test 1 : Calculator
add_executable(test_calculator tests/test_calculator.c)  
target_link_libraries(test_calculator calculator_lib unity)  
add_test(NAME test_calculator COMMAND test_calculator)  

# Test 2 : String utilities
add_executable(test_string tests/test_string.c)  
target_link_libraries(test_string string_lib unity)  
add_test(NAME test_string COMMAND test_string)  

# Test 3 : File operations
add_executable(test_file tests/test_file.c)  
target_link_libraries(test_file file_lib unity)  
add_test(NAME test_file COMMAND test_file)  
```

CTest lancera automatiquement tous les tests :

```bash
ctest --output-on-failure
```

**Sortie :**

```
Test project /home/runner/work/project/build
    Start 1: test_calculator
1/3 Test #1: test_calculator ..................   Passed    0.01 sec
    Start 2: test_string
2/3 Test #2: test_string ......................   Passed    0.01 sec
    Start 3: test_file
3/3 Test #3: test_file ........................   Passed    0.02 sec

100% tests passed, 0 tests failed out of 3
```

---

## Lancer des tests sp√©cifiques

### Avec CTest

```bash
# Lancer un test par son nom
ctest -R test_calculator

# Exclure certains tests
ctest -E test_slow

# Lancer les tests correspondant √† un pattern
ctest -R "test_.*_basic"
```

### Dans le workflow

```yaml
- name: Lancer seulement les tests rapides
  run: ctest --test-dir build -R "test_.*_fast"
```

---

## Gestion des tests qui √©chouent

### Marquer un test comme attendu √† √©chouer

Dans CMakeLists.txt :

```cmake
add_test(NAME test_known_bug COMMAND test_known_bug)  
set_tests_properties(test_known_bug PROPERTIES WILL_FAIL TRUE)  
```

Ce test est attendu √† √©chouer, donc CTest consid√©rera un √©chec comme un succ√®s.

### Timeout pour les tests longs

```cmake
add_test(NAME test_slow COMMAND test_slow)  
set_tests_properties(test_slow PROPERTIES TIMEOUT 30)  # 30 secondes max  
```

---

## Workflow complet avec rapport de tests

```yaml
name: CI avec Tests D√©taill√©s

on:
  push:
    branches: [ main ]
  pull_request:

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        submodules: recursive

    - name: Installer les d√©pendances
      run: |
        sudo apt-get update
        sudo apt-get install -y cmake gcc

    - name: Configurer
      run: cmake -B build -DCMAKE_BUILD_TYPE=Debug

    - name: Compiler
      run: cmake --build build -j$(nproc)

    - name: Lancer les tests (mode normal)
      id: tests
      continue-on-error: true
      run: |
        cd build
        ctest --output-on-failure

    - name: Lancer les tests (mode verbose si √©chec)
      if: steps.tests.outcome == 'failure'
      run: |
        cd build
        ctest --rerun-failed --verbose

    - name: Afficher un r√©sum√©
      if: always()
      run: |
        cd build
        echo "=== R√©sum√© des tests ==="
        ctest -N
        echo ""
        echo "=== R√©sultats ==="
        if [ -f Testing/Temporary/LastTest.log ]; then
          tail -20 Testing/Temporary/LastTest.log
        fi

    - name: Uploader les logs de tests
      if: failure()
      uses: actions/upload-artifact@v4
      with:
        name: test-logs
        path: build/Testing/Temporary/
```

**Points cl√©s :**

- `continue-on-error: true` : Continue m√™me si les tests √©chouent
- `if: steps.tests.outcome == 'failure'` : Relance en mode verbose si √©chec
- `if: always()` : S'ex√©cute toujours (succ√®s ou √©chec)
- Upload des logs en cas d'√©chec pour analyse

---

## Tests avec arguments et variables d'environnement

### Passer des arguments aux tests

```cmake
add_test(NAME test_with_args
         COMMAND test_calculator --verbose --input data.txt)
```

### D√©finir des variables d'environnement

```cmake
add_test(NAME test_with_env COMMAND test_file)  
set_tests_properties(test_with_env PROPERTIES  
    ENVIRONMENT "TEST_DATA_DIR=/tmp/test_data"
)
```

Dans le workflow :

```yaml
- name: Lancer les tests avec variables d'environnement
  env:
    TEST_MODE: CI
    DATA_PATH: ${{ github.workspace }}/test_data
  run: ctest --test-dir build
```

---

## Framework Check : Alternative plus compl√®te

Si vous utilisez Check au lieu de Unity :

**Installation dans le workflow :**

```yaml
- name: Installer Check
  run: |
    sudo apt-get update
    sudo apt-get install -y check pkg-config
```

**Exemple de test avec Check :**

```c
#include <check.h>
#include "../src/calculator.h"

START_TEST(test_add) {
    ck_assert_int_eq(add(2, 3), 5);
    ck_assert_int_eq(add(-1, 1), 0);
}
END_TEST

START_TEST(test_multiply) {
    ck_assert_int_eq(multiply(2, 3), 6);
    ck_assert_int_eq(multiply(0, 100), 0);
}
END_TEST

Suite *calculator_suite(void) {
    Suite *s = suite_create("Calculator");
    TCase *tc_core = tcase_create("Core");

    tcase_add_test(tc_core, test_add);
    tcase_add_test(tc_core, test_multiply);
    suite_add_tcase(s, tc_core);

    return s;
}

int main(void) {
    Suite *s = calculator_suite();
    SRunner *sr = srunner_create(s);

    srunner_run_all(sr, CK_NORMAL);
    int number_failed = srunner_ntests_failed(sr);
    srunner_free(sr);

    return (number_failed == 0) ? 0 : 1;
}
```

**CMakeLists.txt avec Check :**

```cmake
find_package(PkgConfig REQUIRED)  
pkg_check_modules(CHECK REQUIRED check)  

add_executable(test_calculator tests/test_calculator.c)  
target_link_libraries(test_calculator  
    calculator_lib
    ${CHECK_LIBRARIES}
)
target_include_directories(test_calculator PRIVATE ${CHECK_INCLUDE_DIRS})

add_test(NAME calculator_tests COMMAND test_calculator)
```

---

## Criterion : Framework moderne

**Installation de Criterion :**

```yaml
- name: Installer Criterion
  run: |
    sudo apt-get update
    sudo apt-get install -y libcriterion-dev
```

**Exemple de test avec Criterion :**

```c
#include <criterion/criterion.h>
#include "../src/calculator.h"

Test(calculator, test_add) {
    cr_assert_eq(add(2, 3), 5);
    cr_assert_eq(add(-1, 1), 0);
}

Test(calculator, test_multiply) {
    cr_assert_eq(multiply(2, 3), 6);
    cr_assert_eq(multiply(0, 100), 0);
}

Test(calculator, test_divide_by_zero) {
    cr_expect_neq(divide(10, 0), 0, "Division par z√©ro devrait √™tre g√©r√©e");
}
```

Criterion lance automatiquement tous les tests sans n√©cessiter de fonction `main()` !

---

## Tests param√©tr√©s avec Criterion

```c
#include <criterion/criterion.h>
#include <criterion/parameterized.h>

struct test_data {
    int a;
    int b;
    int expected;
};

ParameterizedTestParameters(calculator, test_add_params) {
    static struct test_data params[] = {
        {2, 3, 5},
        {-1, 1, 0},
        {0, 0, 0},
        {100, -50, 50},
    };
    size_t nb_params = sizeof(params) / sizeof(struct test_data);
    return cr_make_param_array(struct test_data, params, nb_params);
}

ParameterizedTest(struct test_data *data, calculator, test_add_params) {
    cr_assert_eq(add(data->a, data->b), data->expected);
}
```

Un seul test g√©n√®re 4 cas de test automatiquement !

---

## G√©n√©rer un rapport XML pour CI

CTest peut g√©n√©rer des rapports au format JUnit XML :

```yaml
- name: Lancer les tests avec rapport XML
  run: |
    cd build
    ctest --output-junit tests-report.xml

- name: Publier les r√©sultats de tests
  uses: EnricoMi/publish-unit-test-result-action@v2
  if: always()
  with:
    files: build/tests-report.xml
```

Cette action affiche un r√©sum√© des tests directement dans la PR GitHub !

---

## Tests de m√©moire avec Valgrind

Int√©grer Valgrind dans les tests :

```yaml
- name: Installer Valgrind
  run: sudo apt-get install -y valgrind

- name: Lancer les tests avec Valgrind
  run: |
    cd build
    ctest -T memcheck
```

Ou ex√©cuter Valgrind manuellement sur chaque test :

```yaml
- name: Tests avec d√©tection de fuites
  run: |
    cd build
    valgrind --leak-check=full --error-exitcode=1 ./test_calculator
```

---

## Badge de statut des tests

Ajoutez un badge dans votre README.md :

```markdown
![Tests](https://github.com/username/repo/actions/workflows/ci.yml/badge.svg)
```

Le badge sera :
- ‚úÖ Vert si tous les tests passent
- ‚ùå Rouge si des tests √©chouent
- üü° Jaune si le workflow est en cours

---

## Bonnes pratiques pour les tests en CI

### 1. Tests rapides

‚úÖ **Les tests unitaires doivent √™tre rapides** (< 1 seconde par test)
- √âvitez les I/O disque
- √âvitez les appels r√©seau
- Utilisez des mocks pour les d√©pendances lentes

### 2. Tests d√©terministes

‚úÖ **Les tests doivent toujours donner le m√™me r√©sultat**
- Pas de d√©pendance √† l'heure syst√®me (sauf si mock√©e)
- Pas de g√©n√©ration al√©atoire non seed√©e
- Pas de d√©pendance √† l'ordre d'ex√©cution

### 3. Tests isol√©s

‚úÖ **Chaque test doit √™tre ind√©pendant**
- Utilisez `setUp()` et `tearDown()`
- Nettoyez les ressources (fichiers, m√©moire)
- Pas d'√©tat partag√© entre tests

### 4. Messages d'erreur clairs

```c
// ‚ùå Mauvais
TEST_ASSERT_TRUE(result);

// ‚úÖ Bon
TEST_ASSERT_TRUE_MESSAGE(result, "La fonction devrait retourner true pour un tableau vide");
```

### 5. Ne testez qu'une chose √† la fois

```c
// ‚ùå Mauvais : test trop complexe
void test_calculator(void) {
    TEST_ASSERT_EQUAL(5, add(2, 3));
    TEST_ASSERT_EQUAL(2, subtract(5, 3));
    TEST_ASSERT_EQUAL(6, multiply(2, 3));
}

// ‚úÖ Bon : un test par fonctionnalit√©
void test_add(void) {
    TEST_ASSERT_EQUAL(5, add(2, 3));
}

void test_subtract(void) {
    TEST_ASSERT_EQUAL(2, subtract(5, 3));
}

void test_multiply(void) {
    TEST_ASSERT_EQUAL(6, multiply(2, 3));
}
```

### 6. Nommage descriptif

```c
// ‚ùå Mauvais
void test1(void) { ... }  
void test2(void) { ... }  

// ‚úÖ Bon
void test_add_two_positive_numbers(void) { ... }  
void test_add_with_overflow_should_handle_gracefully(void) { ... }  
```

---

## Debugging des tests qui √©chouent en CI

### Strat√©gie de debugging

1. **Reproduire localement**
   ```bash
   cmake -B build -DCMAKE_BUILD_TYPE=Debug
   cmake --build build
   cd build && ctest --verbose
   ```

2. **Activer les logs d√©taill√©s**
   ```yaml
   - name: Tests en mode debug
     run: |
       cd build
       ctest --verbose --debug
   ```

3. **Ajouter des prints dans vos tests**
   ```c
   void test_something(void) {
       printf("DEBUG: Testing with value = %d\n", value);
       TEST_ASSERT_EQUAL(expected, actual);
   }
   ```

4. **V√©rifier les variables d'environnement**
   ```yaml
   - name: Afficher l'environnement
     run: env | sort
   ```

5. **Compiler avec symboles de debug**
   ```yaml
   - name: Configurer en Debug
     run: cmake -B build -DCMAKE_BUILD_TYPE=Debug
   ```

---

## Template de workflow complet

Voici un workflow pr√™t √† l'emploi :

```yaml
name: Tests Unitaires

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    name: Tests sur ${{ matrix.os }}
    runs-on: ${{ matrix.os }}

    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest]
        build-type: [Debug, Release]

    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        submodules: recursive

    - name: Installer les d√©pendances
      run: |
        sudo apt-get update
        sudo apt-get install -y cmake gcc

    - name: Configurer
      run: |
        cmake -B build \
          -DCMAKE_BUILD_TYPE=${{ matrix.build-type }}

    - name: Compiler
      run: cmake --build build -j$(nproc)

    - name: Lancer les tests
      run: |
        cd build
        ctest --output-on-failure -j$(nproc)

    - name: Uploader les logs (si √©chec)
      if: failure()
      uses: actions/upload-artifact@v4
      with:
        name: test-logs-${{ matrix.os }}-${{ matrix.build-type }}
        path: build/Testing/Temporary/
```

---

## R√©sum√©

**√âtapes pour ex√©cuter des tests en CI :**

1. **√âcrire des tests** avec un framework (Unity, Check, Criterion)
2. **Configurer CMake** avec `enable_testing()` et `add_test()`
3. **Compiler** avec `cmake --build build`
4. **Lancer** avec `ctest --output-on-failure`

**Commandes CTest essentielles :**

- `ctest` : Lance tous les tests
- `ctest --output-on-failure` : Affiche les d√©tails seulement si √©chec
- `ctest --verbose` : Mode verbeux
- `ctest -R pattern` : Lance seulement les tests matchant le pattern
- `ctest -j4` : Parall√©lise sur 4 threads

---

## Prochaines √©tapes

Maintenant que vos tests s'ex√©cutent automatiquement, vous pouvez :

- Ajouter des **sanitizers** pour d√©tecter les bugs m√©moire
- Utiliser **Valgrind** pour les fuites m√©moire
- Mesurer la **couverture de code** (gcov/lcov)
- Configurer des **tests d'int√©gration**
- Ajouter des **tests de performance**

Ces sujets sont couverts dans les sections suivantes.

---

## Ressources compl√©mentaires

- [Unity Framework](https://github.com/ThrowTheSwitch/Unity)
- [Check Framework](https://libcheck.github.io/check/)
- [Criterion Framework](https://github.com/Snaipe/Criterion)
- [CTest Documentation](https://cmake.org/cmake/help/latest/manual/ctest.1.html)
- [Testing Best Practices](https://github.com/google/googletest/blob/main/docs/primer.md)

---

**üéØ Points cl√©s √† retenir :**

- ‚úÖ Les tests unitaires d√©tectent les bugs avant la production
- ‚úÖ Utilisez un framework adapt√© (Unity pour d√©buter)
- ‚úÖ CMake int√®gre les tests avec `enable_testing()` et `add_test()`
- ‚úÖ CTest ex√©cute tous les tests automatiquement
- ‚úÖ `--output-on-failure` affiche les d√©tails seulement si n√©cessaire
- ‚úÖ Les tests doivent √™tre rapides, d√©terministes et isol√©s
- ‚úÖ Ajoutez un badge de statut dans votre README pour la visibilit√©

‚è≠Ô∏è [V√©rification avec sanitizers](/30-integration-continue/01.5-verification-sanitizers.md)
