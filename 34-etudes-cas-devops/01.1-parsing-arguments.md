üîù Retour au [Sommaire](/SOMMAIRE.md)

# 34.1.1 Parsing d'arguments

## Introduction

Lorsque vous cr√©ez un outil en ligne de commande (CLI), la premi√®re √©tape consiste √† analyser les arguments pass√©s par l'utilisateur. C'est ce qu'on appelle le **parsing d'arguments**. Un bon parsing d'arguments rend votre outil professionnel et facile √† utiliser.

### Exemple d'utilisation typique

```bash
# Exemples d'outils CLI courants
ls -la /home
grep -r "pattern" --ignore-case fichier.txt
gcc -Wall -O2 -o programme programme.c
```

Dans ces exemples, `-la`, `-r`, `--ignore-case`, `-Wall` sont des **options** ou **arguments** que le programme doit comprendre et traiter.

---

## 1. Les bases : argc et argv

### 1.1 Comprendre la signature de main()

Tout programme C commence par la fonction `main()`. Pour recevoir des arguments, on utilise cette signature compl√®te :

```c
int main(int argc, char *argv[])
```

**Explication des param√®tres :**

- **`argc`** (argument count) : Le nombre total d'arguments pass√©s au programme, incluant le nom du programme lui-m√™me.
- **`argv`** (argument vector) : Un tableau de cha√Ænes de caract√®res contenant les arguments.

### 1.2 Exemple simple

```c
#include <stdio.h>

int main(int argc, char *argv[]) {
    printf("Nombre d'arguments : %d\n", argc);

    for (int i = 0; i < argc; i++) {
        printf("argv[%d] = %s\n", i, argv[i]);
    }

    return 0;
}
```

**Compilation et ex√©cution :**

```bash
gcc -o demo demo.c
./demo hello world
```

**Sortie :**

```
Nombre d'arguments : 3
argv[0] = ./demo
argv[1] = hello
argv[2] = world
```

**Points importants :**
- `argv[0]` contient toujours le nom du programme
- `argv[argc]` vaut toujours `NULL` (sentinelle de fin)
- Les arguments sont toujours des cha√Ænes (`char*`), m√™me pour les nombres

### 1.3 Parsing manuel basique

```c
#include <stdio.h>
#include <string.h>

int main(int argc, char *argv[]) {
    int verbose = 0;

    // Parcourir les arguments
    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "-v") == 0 || strcmp(argv[i], "--verbose") == 0) {
            verbose = 1;
        } else if (strcmp(argv[i], "-h") == 0 || strcmp(argv[i], "--help") == 0) {
            printf("Usage: %s [-v|--verbose] [-h|--help]\n", argv[0]);
            return 0;
        } else {
            fprintf(stderr, "Option inconnue : %s\n", argv[i]);
            return 1;
        }
    }

    if (verbose) {
        printf("Mode verbose activ√©\n");
    }

    return 0;
}
```

**Limites du parsing manuel :**
- Code r√©p√©titif et verbeux
- Difficile √† maintenir avec beaucoup d'options
- Gestion des erreurs fastidieuse
- Pas de support natif pour les options avec valeurs (`-o fichier.txt`)

---

## 2. getopt() : La solution standard POSIX

`getopt()` est une fonction de la biblioth√®que standard POSIX qui simplifie grandement le parsing d'arguments. Elle est disponible sur tous les syst√®mes UNIX/Linux.

### 2.1 Syntaxe de base

```c
#include <unistd.h>

int getopt(int argc, char *argv[], const char *optstring);
```

**Param√®tres :**
- `argc`, `argv` : Les arguments de `main()`
- `optstring` : Une cha√Æne d√©finissant les options accept√©es

**Variables globales utilis√©es par getopt :**
- `optarg` : Pointe vers l'argument d'une option (si elle en attend un)
- `optind` : Index du prochain √©l√©ment √† traiter dans `argv`
- `opterr` : Si non-z√©ro, getopt affiche des messages d'erreur (d√©faut: 1)
- `optopt` : Contient le caract√®re d'option inconnu en cas d'erreur

### 2.2 Format de optstring

La cha√Æne `optstring` d√©finit les options accept√©es :

- **`"abc"`** : Les options `-a`, `-b`, `-c` sont accept√©es (sans argument)
- **`"a:b:c"`** : `-a` et `-b` attendent un argument, `-c` non
- **`"a::b:c"`** : `-a` a un argument optionnel, `-b` obligatoire, `-c` aucun
- **`":abc"`** : Le `:` initial d√©sactive les messages d'erreur automatiques

### 2.3 Exemple complet avec getopt()

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

void afficher_aide(const char *nom_prog) {
    printf("Usage: %s [OPTIONS]\n", nom_prog);
    printf("Options:\n");
    printf("  -h          Afficher cette aide\n");
    printf("  -v          Mode verbose\n");
    printf("  -o FILE     Fichier de sortie\n");
    printf("  -n NUMBER   Nombre d'it√©rations\n");
}

int main(int argc, char *argv[]) {
    int verbose = 0;
    char *output_file = NULL;
    int iterations = 1;
    int opt;

    // Parsing des options
    while ((opt = getopt(argc, argv, "hvo:n:")) != -1) {
        switch (opt) {
            case 'h':
                afficher_aide(argv[0]);
                return 0;

            case 'v':
                verbose = 1;
                break;

            case 'o':
                output_file = optarg;
                break;

            case 'n':
                iterations = atoi(optarg);
                if (iterations <= 0) {
                    fprintf(stderr, "Erreur: -n doit √™tre > 0\n");
                    return 1;
                }
                break;

            case '?':
                // Option inconnue ou argument manquant
                fprintf(stderr, "Essayez '%s -h' pour plus d'informations.\n", argv[0]);
                return 1;

            default:
                afficher_aide(argv[0]);
                return 1;
        }
    }

    // Traitement des arguments non-option (arguments positionnels)
    if (optind < argc) {
        printf("Arguments restants: ");
        for (int i = optind; i < argc; i++) {
            printf("%s ", argv[i]);
        }
        printf("\n");
    }

    // Utilisation des options pars√©es
    if (verbose) {
        printf("Mode verbose activ√©\n");
        printf("Fichier de sortie: %s\n", output_file ? output_file : "stdout");
        printf("It√©rations: %d\n", iterations);
    }

    return 0;
}
```

**Exemple d'utilisation :**

```bash
./programme -v -o resultat.txt -n 10 fichier1 fichier2
```

**Sortie :**

```
Mode verbose activ√©
Fichier de sortie: resultat.txt
It√©rations: 10
Arguments restants: fichier1 fichier2
```

### 2.4 Gestion des erreurs avec getopt()

```c
// D√©sactiver les messages d'erreur automatiques
opterr = 0;

while ((opt = getopt(argc, argv, ":hvo:n:")) != -1) {
    switch (opt) {
        // ... autres cas ...

        case ':':
            // Option sans son argument requis
            fprintf(stderr, "L'option -%c n√©cessite un argument\n", optopt);
            return 1;

        case '?':
            // Option inconnue
            fprintf(stderr, "Option inconnue: -%c\n", optopt);
            return 1;
    }
}
```

---

## 3. getopt_long() : Support des options longues

Pour des outils plus professionnels, on utilise souvent des options longues comme `--verbose` en plus des courtes `-v`. C'est le r√¥le de `getopt_long()`.

### 3.1 Inclusion et syntaxe

```c
#include <getopt.h>

int getopt_long(int argc, char *argv[],
                const char *optstring,
                const struct option *longopts,
                int *longindex);
```

### 3.2 Structure option

```c
struct option {
    const char *name;    // Nom de l'option longue
    int has_arg;         // no_argument, required_argument, optional_argument
    int *flag;           // NULL ou pointeur vers variable √† modifier
    int val;             // Valeur √† retourner (ou √† placer dans *flag)
};
```

**Valeurs pour has_arg :**
- `no_argument` (0) : L'option ne prend pas d'argument
- `required_argument` (1) : L'option n√©cessite un argument
- `optional_argument` (2) : L'option peut avoir un argument

### 3.3 Exemple complet avec getopt_long()

```c
#include <stdio.h>
#include <stdlib.h>
#include <getopt.h>
#include <string.h>

void afficher_aide(const char *nom_prog) {
    printf("Usage: %s [OPTIONS]\n", nom_prog);
    printf("Options:\n");
    printf("  -h, --help              Afficher cette aide\n");
    printf("  -v, --verbose           Mode verbose\n");
    printf("  -o, --output FILE       Fichier de sortie\n");
    printf("  -n, --iterations NUM    Nombre d'it√©rations\n");
    printf("      --version           Afficher la version\n");
}

int main(int argc, char *argv[]) {
    int verbose = 0;
    char *output_file = NULL;
    int iterations = 1;

    // D√©finition des options longues
    static struct option long_options[] = {
        {"help",       no_argument,       0, 'h'},
        {"verbose",    no_argument,       0, 'v'},
        {"output",     required_argument, 0, 'o'},
        {"iterations", required_argument, 0, 'n'},
        {"version",    no_argument,       0, 0},
        {0, 0, 0, 0}  // Terminateur obligatoire
    };

    int opt;
    int option_index = 0;

    // Parsing avec getopt_long
    while ((opt = getopt_long(argc, argv, "hvo:n:",
                              long_options, &option_index)) != -1) {
        switch (opt) {
            case 0:
                // Option longue sans √©quivalent court
                if (strcmp(long_options[option_index].name, "version") == 0) {
                    printf("Version 1.0.0\n");
                    return 0;
                }
                break;

            case 'h':
                afficher_aide(argv[0]);
                return 0;

            case 'v':
                verbose = 1;
                break;

            case 'o':
                output_file = optarg;
                break;

            case 'n':
                iterations = atoi(optarg);
                if (iterations <= 0) {
                    fprintf(stderr, "Erreur: --iterations doit √™tre > 0\n");
                    return 1;
                }
                break;

            case '?':
                fprintf(stderr, "Essayez '%s --help' pour plus d'informations.\n",
                        argv[0]);
                return 1;

            default:
                return 1;
        }
    }

    // V√©rifications post-parsing
    if (output_file == NULL) {
        fprintf(stderr, "Erreur: l'option -o/--output est obligatoire\n");
        return 1;
    }

    // Utilisation
    if (verbose) {
        printf("Configuration:\n");
        printf("  Fichier de sortie: %s\n", output_file);
        printf("  It√©rations: %d\n", iterations);
    }

    return 0;
}
```

**Exemples d'utilisation :**

```bash
# Options courtes
./programme -v -o output.txt -n 5

# Options longues
./programme --verbose --output output.txt --iterations 5

# M√©lange
./programme -v --output output.txt -n 5

# Option sans √©quivalent court
./programme --version
```

---

## 4. Bonnes pratiques

### 4.1 Validation des arguments

```c
// V√©rifier qu'un argument num√©rique est valide
char *endptr;
long value = strtol(optarg, &endptr, 10);

if (*endptr != '\0' || value < 1 || value > 100) {
    fprintf(stderr, "Erreur: valeur invalide pour -n: %s\n", optarg);
    return 1;
}
```

### 4.2 Gestion des arguments obligatoires

```c
// V√©rifier apr√®s le parsing
if (output_file == NULL) {
    fprintf(stderr, "Erreur: l'option -o est obligatoire\n");
    afficher_aide(argv[0]);
    return 1;
}
```

### 4.3 Message d'aide clair

Un bon message d'aide doit inclure :
- **Usage** : Syntaxe de base
- **Description** : Ce que fait le programme
- **Options** : Liste d√©taill√©e avec descriptions
- **Exemples** : Cas d'utilisation concrets

```c
void afficher_aide(const char *nom_prog) {
    printf("Usage: %s [OPTIONS] FILE...\n\n", nom_prog);
    printf("Description:\n");
    printf("  Traite les fichiers sp√©cifi√©s et g√©n√®re un rapport.\n\n");
    printf("Options:\n");
    printf("  -h, --help              Afficher cette aide et quitter\n");
    printf("  -v, --verbose           Afficher des informations d√©taill√©es\n");
    printf("  -o, --output FILE       Fichier de sortie (d√©faut: stdout)\n");
    printf("  -f, --format FMT        Format de sortie: json, xml, text\n");
    printf("      --version           Afficher la version et quitter\n\n");
    printf("Exemples:\n");
    printf("  %s -v input.txt\n", nom_prog);
    printf("  %s -o report.json --format json data/*.txt\n", nom_prog);
}
```

### 4.4 Convention de retour

```c
// Codes de retour standards
#define EXIT_SUCCESS 0
#define EXIT_FAILURE 1

// Utilisation
if (erreur) {
    return EXIT_FAILURE;
}
return EXIT_SUCCESS;
```

### 4.5 Gestion des options combin√©es

`getopt()` supporte automatiquement les options combin√©es :

```bash
# Ces deux commandes sont √©quivalentes
./programme -a -b -c
./programme -abc
```

---

## 5. Patterns courants

### 5.1 Argument optionnel avec valeur par d√©faut

```c
char *config_file = "/etc/myapp.conf";  // D√©faut

while ((opt = getopt(argc, argv, "c:")) != -1) {
    switch (opt) {
        case 'c':
            config_file = optarg;
            break;
    }
}
```

### 5.2 Option compteur (niveau de verbosit√©)

```c
int verbosity = 0;

while ((opt = getopt(argc, argv, "v")) != -1) {
    switch (opt) {
        case 'v':
            verbosity++;  // -vvv donnera verbosity = 3
            break;
    }
}
```

### 5.3 Options mutuellement exclusives

```c
int mode_json = 0;
int mode_xml = 0;

while ((opt = getopt(argc, argv, "jx")) != -1) {
    switch (opt) {
        case 'j':
            if (mode_xml) {
                fprintf(stderr, "Erreur: -j et -x sont mutuellement exclusifs\n");
                return 1;
            }
            mode_json = 1;
            break;
        case 'x':
            if (mode_json) {
                fprintf(stderr, "Erreur: -j et -x sont mutuellement exclusifs\n");
                return 1;
            }
            mode_xml = 1;
            break;
    }
}
```

---

## 6. Alternatives modernes

### 6.1 Biblioth√®ques tierces

Pour des projets plus complexes, consid√©rez :

- **argp** (GNU) : Plus puissant que getopt
- **popt** : Utilis√© par RPM et d'autres outils
- **argtable** : Approche d√©clarative
- **docopt.c** : G√©n√©ration automatique depuis la documentation

### 6.2 Exemple avec argp (aper√ßu)

```c
#include <argp.h>

const char *argp_program_version = "programme 1.0";
static char doc[] = "Programme de d√©monstration";
static char args_doc[] = "FILE...";

static struct argp_option options[] = {
    {"verbose", 'v', 0, 0, "Mode verbose"},
    {"output",  'o', "FILE", 0, "Fichier de sortie"},
    {0}
};

// argp offre beaucoup plus de fonctionnalit√©s mais est plus complexe
```

---

## 7. R√©capitulatif

### Quand utiliser quoi ?

| M√©thode | Cas d'usage |
|---------|-------------|
| **Parsing manuel** | Script tr√®s simple avec 1-2 options |
| **getopt()** | Programme standard avec options courtes |
| **getopt_long()** | Outil professionnel avec options longues |
| **Biblioth√®ques tierces** | Projets complexes avec sous-commandes |

### Checklist d'un bon parsing d'arguments

- ‚úÖ **Validation** : V√©rifier tous les arguments
- ‚úÖ **Aide** : Option `-h/--help` claire et compl√®te
- ‚úÖ **Erreurs** : Messages d'erreur explicites
- ‚úÖ **Standards** : Respecter les conventions POSIX
- ‚úÖ **Retour** : Codes de retour appropri√©s
- ‚úÖ **Documentation** : Exemples d'utilisation

---

## Conclusion

Le parsing d'arguments est la porte d'entr√©e de votre outil CLI. Un bon parsing rend votre programme :
- **Professionnel** : Interface coh√©rente avec les standards UNIX
- **Facile √† utiliser** : Options intuitives et bien document√©es
- **Robuste** : Gestion d'erreurs appropri√©e

`getopt_long()` est aujourd'hui le standard de facto pour les outils CLI en C sous Linux. Il offre le meilleur compromis entre simplicit√© d'utilisation et fonctionnalit√©s.

---

**Points cl√©s √† retenir :**
- `argc` et `argv` sont les bases du parsing d'arguments
- `getopt()` simplifie le parsing pour les options courtes
- `getopt_long()` ajoute le support des options longues (recommand√©)
- Toujours valider les arguments et g√©rer les erreurs
- Fournir une aide claire avec `-h/--help`

‚è≠Ô∏è [Interaction avec le syst√®me](/34-etudes-cas-devops/01.2-interaction-systeme.md)
