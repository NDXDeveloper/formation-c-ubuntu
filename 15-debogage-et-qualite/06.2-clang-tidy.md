üîù Retour au [Sommaire](/SOMMAIRE.md)

# 15.6.2 clang-tidy - Linter et Modernisation de Code C

## Introduction

**clang-tidy** est un outil d'analyse statique et de linting d√©velopp√© par le projet LLVM/Clang. Plus puissant et moderne que cppcheck, il va au-del√† de la simple d√©tection de bugs : il propose des suggestions de modernisation du code, v√©rifie le respect des conventions, et peut m√™me **corriger automatiquement** certains probl√®mes.

### Qu'est-ce qu'un linter ?

Un **linter** est un outil qui analyse votre code pour :
- D√©tecter des erreurs potentielles
- V√©rifier le respect des conventions de codage
- Sugg√©rer des am√©liorations de style
- Identifier du code obsol√®te ou dangereux

**clang-tidy** fait tout cela et plus encore !

### Pourquoi clang-tidy ?

- ‚úÖ **Plus de 400 checks** couvrant tous les aspects du code C/C++
- ‚úÖ **Corrections automatiques** avec l'option `--fix`
- ‚úÖ **Int√©gration native** avec les compilateurs Clang
- ‚úÖ **Modernisation du code** vers les standards r√©cents (C11, C17, C23)
- ‚úÖ **Extensible** via des plugins personnalis√©s
- ‚úÖ **Support des bases de donn√©es de compilation** (compile_commands.json)

---

## Installation sur Ubuntu

### M√©thode 1 : Via APT (recommand√©)

```bash
sudo apt update
sudo apt install clang-tidy
```

V√©rifiez l'installation :

```bash
clang-tidy --version
```

**Sortie typique :**
```
LLVM (http://llvm.org/):
  LLVM version 14.0.0
  Optimized build.
  Default target: x86_64-pc-linux-gnu
```

### M√©thode 2 : Installer une version sp√©cifique

Pour obtenir la derni√®re version de clang-tidy :

```bash
# Ajouter le d√©p√¥t LLVM
wget https://apt.llvm.org/llvm.sh
chmod +x llvm.sh
sudo ./llvm.sh 18  # Installe LLVM 18

# Installer clang-tidy
sudo apt install clang-tidy-18

# Cr√©er un lien symbolique
sudo update-alternatives --install /usr/bin/clang-tidy clang-tidy /usr/bin/clang-tidy-18 100
```

---

## Utilisation de base

### Premier scan simple

Cr√©ons un fichier `example.c` avec quelques probl√®mes :

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    // Variable non utilis√©e
    int unused_var = 42;

    // Allocation sans v√©rification
    int *ptr = malloc(10 * sizeof(int));
    ptr[0] = 100;

    // Utilisation de strcpy (dangereux)
    char buffer[20];
    char *source = "Hello World";
    strcpy(buffer, source);

    // Comparaison de pointeur avec 0 au lieu de NULL
    if (ptr == 0) {
        printf("Pointer is null\n");
    }

    free(ptr);
    return 0;
}
```

Pour l'analyser avec clang-tidy :

```bash
clang-tidy example.c -- -std=c11
```

**Note importante :** Le `--` s√©pare les options de clang-tidy des options du compilateur.

### Sortie typique

```
example.c:7:9: warning: unused variable 'unused_var' [clang-diagnostic-unused-variable]
    int unused_var = 42;
        ^

example.c:10:18: warning: consider using calloc instead of malloc [clang-analyzer-unix.Malloc]
    int *ptr = malloc(10 * sizeof(int));
                 ^

example.c:15:5: warning: 'strcpy' is deprecated: This function is provided for compatibility reasons only [clang-analyzer-security.insecureAPI.strcpy]
    strcpy(buffer, source);
    ^

example.c:18:13: warning: comparing a pointer to 0 is not recommended, use nullptr or NULL instead [modernize-use-nullptr]
    if (ptr == 0) {
            ^
```

clang-tidy a d√©tect√© plusieurs probl√®mes de style et de s√©curit√© !

---

## Cat√©gories de checks

clang-tidy organise ses v√©rifications en **cat√©gories**. Voici les principales :

### 1. **bugprone-*** : D√©tection de bugs potentiels

D√©tecte des patterns de code susceptibles de causer des bugs.

**Exemples :**
- `bugprone-infinite-loop` : Boucles infinies accidentelles
- `bugprone-use-after-move` : Utilisation apr√®s d√©placement
- `bugprone-signed-char-misuse` : Mauvaise utilisation de char sign√©

```c
// Exemple d√©tect√© par bugprone-infinite-loop
int i = 0;
while (i < 10) {
    printf("%d\n", i);
    // Oubli de i++
}
```

### 2. **clang-analyzer-*** : Analyseur statique du compilateur

Int√®gre l'analyseur statique de Clang pour d√©tecter des bugs complexes.

**Exemples :**
- `clang-analyzer-core.NullDereference` : D√©r√©f√©rencement de NULL
- `clang-analyzer-deadcode.DeadStores` : Affectations inutiles
- `clang-analyzer-security.insecureAPI.*` : APIs dangereuses

```c
// D√©tect√© par clang-analyzer-core.NullDereference
int *ptr = NULL;
*ptr = 5;  // Erreur !
```

### 3. **readability-*** : Lisibilit√© du code

V√©rifie que le code respecte les bonnes pratiques de lisibilit√©.

**Exemples :**
- `readability-braces-around-statements` : Accolades dans les if/for
- `readability-identifier-naming` : Conventions de nommage
- `readability-magic-numbers` : Nombres magiques

```c
// D√©tect√© par readability-magic-numbers
int array[100];  // 100 est un nombre magique

// Mieux :
#define MAX_SIZE 100
int array[MAX_SIZE];
```

### 4. **modernize-*** : Modernisation du code

Sugg√®re des am√©liorations pour utiliser les fonctionnalit√©s modernes du langage.

**Exemples :**
- `modernize-use-nullptr` : Utiliser NULL au lieu de 0
- `modernize-avoid-c-arrays` : Pr√©f√©rer des structures
- `modernize-deprecated-headers` : Headers obsol√®tes

```c
// D√©tect√© par modernize-use-nullptr
if (ptr == 0) {  // Ancien style
    // ...
}

// Mieux :
if (ptr == NULL) {  // Style moderne
    // ...
}
```

### 5. **performance-*** : Optimisations de performance

Identifie des opportunit√©s d'optimisation.

**Exemples :**
- `performance-unnecessary-copy-initialization` : Copies inutiles
- `performance-for-range-copy` : Copies dans les boucles
- `performance-move-const-arg` : D√©placements constants

```c
// D√©tect√© par performance-unnecessary-copy-initialization
void process(const char *str) {
    char copy[100];
    strcpy(copy, str);  // Copie peut-√™tre inutile
    // Si on ne modifie jamais copy, utiliser directement str
}
```

### 6. **cert-*** : R√®gles de s√©curit√© CERT

V√©rifie la conformit√© avec les standards de s√©curit√© CERT (Carnegie Mellon).

**Exemples :**
- `cert-err33-c` : V√©rification des valeurs de retour
- `cert-str34-c` : Cha√Ænes nulltermin√©es
- `cert-mem30-c` : Gestion m√©moire s√©curis√©e

```c
// D√©tect√© par cert-err33-c
malloc(100);  // Pas de v√©rification du retour !

// Mieux :
void *ptr = malloc(100);
if (ptr == NULL) {
    // G√©rer l'erreur
}
```

### 7. **misc-*** : V√©rifications diverses

Checks qui ne rentrent pas dans les autres cat√©gories.

**Exemples :**
- `misc-unused-parameters` : Param√®tres non utilis√©s
- `misc-redundant-expression` : Expressions redondantes
- `misc-static-assert` : Utiliser static_assert quand possible

---

## Options principales de clang-tidy

### Activer/D√©sactiver des checks

#### Activer tous les checks

```bash
clang-tidy -checks='*' example.c -- -std=c11
```

‚ö†Ô∏è **Attention :** Cela peut g√©n√©rer beaucoup de warnings !

#### Activer des cat√©gories sp√©cifiques

```bash
# Uniquement les checks de s√©curit√© et de bugs
clang-tidy -checks='bugprone-*,cert-*' example.c -- -std=c11
```

#### D√©sactiver certains checks

```bash
# Tous les checks sauf readability
clang-tidy -checks='*,-readability-*' example.c -- -std=c11
```

#### Combinaisons complexes

```bash
# Activer bugprone et modernize, mais d√©sactiver modernize-use-trailing-return-type
clang-tidy -checks='bugprone-*,modernize-*,-modernize-use-trailing-return-type' example.c -- -std=c11
```

### Lister tous les checks disponibles

```bash
clang-tidy -list-checks
```

Vous verrez une liste comme :
```
Enabled checks:
    bugprone-argument-comment
    bugprone-assert-side-effect
    bugprone-bad-signal-to-kill-thread
    cert-dcl50-cpp
    cert-env33-c
    ...
```

### Corriger automatiquement les probl√®mes

L'option `--fix` applique les corrections sugg√©r√©es :

```bash
clang-tidy -checks='modernize-use-nullptr' --fix example.c -- -std=c11
```

‚ö†Ô∏è **Attention :** Faites toujours un backup avant d'utiliser `--fix` !

Pour voir les modifications sans les appliquer :

```bash
clang-tidy -checks='modernize-use-nullptr' --fix-errors --dry-run example.c -- -std=c11
```

---

## Fichier de configuration .clang-tidy

Pour les projets complexes, cr√©ez un fichier `.clang-tidy` √† la racine du projet :

### Exemple de configuration de base

```yaml
# .clang-tidy
---
Checks: '-*,bugprone-*,cert-*,clang-analyzer-*,modernize-*,performance-*,readability-*'
WarningsAsErrors: ''
HeaderFilterRegex: ''
FormatStyle: none

CheckOptions:
  - key: readability-identifier-naming.VariableCase
    value: lower_case
  - key: readability-identifier-naming.FunctionCase
    value: lower_case
  - key: readability-identifier-naming.MacroCase
    value: UPPER_CASE
  - key: readability-braces-around-statements.ShortStatementLines
    value: '1'
```

### Configuration pour un projet C strict

```yaml
# .clang-tidy pour C pur
---
Checks: >
  -*,
  bugprone-*,
  cert-*,
  clang-analyzer-*,
  performance-*,
  readability-*,
  -readability-isolate-declaration,
  -readability-magic-numbers

WarningsAsErrors: 'bugprone-*,cert-*'
HeaderFilterRegex: '.*'
FormatStyle: file

CheckOptions:
  - key: cert-err33-c.CheckedFunctions
    value: 'malloc;calloc;realloc;fopen;fclose;fread;fwrite'
  - key: readability-function-size.LineThreshold
    value: '100'
  - key: readability-identifier-naming.FunctionCase
    value: 'lower_case'
```

Ensuite, lancez simplement :

```bash
clang-tidy example.c -- -std=c11
```

clang-tidy utilisera automatiquement la configuration du fichier `.clang-tidy`.

---

## Int√©gration avec CMake

Pour les projets utilisant CMake, clang-tidy peut utiliser la base de donn√©es de compilation.

### G√©n√©rer compile_commands.json

```bash
mkdir build
cd build
cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON ..
```

Cela cr√©e un fichier `compile_commands.json` contenant toutes les commandes de compilation.

### Analyser le projet

```bash
clang-tidy -p build src/main.c
```

L'option `-p` indique le r√©pertoire contenant `compile_commands.json`.

### Analyser tous les fichiers du projet

```bash
find src -name "*.c" -exec clang-tidy -p build {} \;
```

Ou en utilisant `run-clang-tidy` (script fourni avec clang-tidy) :

```bash
run-clang-tidy -p build
```

---

## Exemples pratiques

### Exemple 1 : D√©tecter les variables non utilis√©es

**Code probl√©matique :**

```c
#include <stdio.h>

int main() {
    int x = 10;
    int y = 20;  // Non utilis√©e
    int z = 30;

    printf("x = %d, z = %d\n", x, z);
    return 0;
}
```

**Commande :**

```bash
clang-tidy -checks='clang-diagnostic-unused-variable' example.c -- -std=c11
```

**R√©sultat :**

```
example.c:5:9: warning: unused variable 'y' [clang-diagnostic-unused-variable]
    int y = 20;
        ^
```

### Exemple 2 : Moderniser les comparaisons NULL

**Code √† moderniser :**

```c
#include <stdlib.h>

int main() {
    int *ptr = malloc(sizeof(int));

    if (ptr == 0) {  // Ancien style
        return 1;
    }

    *ptr = 42;
    free(ptr);
    return 0;
}
```

**Commande avec correction automatique :**

```bash
clang-tidy -checks='modernize-use-nullptr' --fix example.c -- -std=c11
```

**Code apr√®s correction :**

```c
#include <stdlib.h>

int main() {
    int *ptr = malloc(sizeof(int));

    if (ptr == NULL) {  // Style moderne
        return 1;
    }

    *ptr = 42;
    free(ptr);
    return 0;
}
```

### Exemple 3 : V√©rifier les conventions de nommage

**Code non conforme :**

```c
#include <stdio.h>

int MyFunction() {  // PascalCase non recommand√© en C
    int MyVariable = 10;  // idem
    return MyVariable;
}

int main() {
    printf("%d\n", MyFunction());
    return 0;
}
```

**Configuration `.clang-tidy` :**

```yaml
---
Checks: 'readability-identifier-naming'

CheckOptions:
  - key: readability-identifier-naming.FunctionCase
    value: lower_case
  - key: readability-identifier-naming.VariableCase
    value: lower_case
```

**Commande :**

```bash
clang-tidy example.c -- -std=c11
```

**R√©sultat :**

```
example.c:3:5: warning: function 'MyFunction' should use lower_case [readability-identifier-naming]
int MyFunction() {
    ^~~~~~~~~~
    my_function

example.c:4:9: warning: variable 'MyVariable' should use lower_case [readability-identifier-naming]
    int MyVariable = 10;
        ^~~~~~~~~~
        my_variable
```

### Exemple 4 : D√©tecter les APIs dangereuses

**Code avec fonctions dangereuses :**

```c
#include <stdio.h>
#include <string.h>

int main() {
    char buffer[50];
    char input[100] = "Hello World";

    // strcpy est dangereux (pas de v√©rification de taille)
    strcpy(buffer, input);

    // gets est extr√™mement dangereux (buffer overflow garanti)
    // gets(buffer);  // Comment√© car obsol√®te

    printf("%s\n", buffer);
    return 0;
}
```

**Commande :**

```bash
clang-tidy -checks='clang-analyzer-security.insecureAPI.*' example.c -- -std=c11
```

**R√©sultat :**

```
example.c:9:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer [clang-analyzer-security.insecureAPI.strcpy]
    strcpy(buffer, input);
    ^
```

**Suggestion :** Utiliser `strncpy` ou `strlcpy` (si disponible).

---

## clang-tidy vs cppcheck

| Aspect | cppcheck | clang-tidy |
|--------|----------|------------|
| **Nombre de checks** | ~200 | 400+ |
| **Performance** | Plus rapide | Plus lent (analyse approfondie) |
| **Corrections auto** | ‚ùå Non | ‚úÖ Oui (--fix) |
| **Modernisation** | Limit√©e | Excellente |
| **Int√©gration compilateur** | Ind√©pendant | Bas√© sur Clang |
| **Faux positifs** | Peu | Tr√®s peu |
| **Configuration** | Simple | Plus complexe |
| **Courbe d'apprentissage** | Facile | Moyenne |

### Recommandation

Utilisez **les deux** :
1. **cppcheck** pour un premier scan rapide
2. **clang-tidy** pour une analyse approfondie et la modernisation

---

## Int√©gration dans le workflow de d√©veloppement

### 1. Pre-commit hook Git

Cr√©ez `.git/hooks/pre-commit` :

```bash
#!/bin/bash

# Obtenir les fichiers C modifi√©s
FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.c$')

if [ -n "$FILES" ]; then
    echo "Running clang-tidy on modified files..."
    clang-tidy -checks='bugprone-*,cert-*' $FILES -- -std=c11

    if [ $? -ne 0 ]; then
        echo "‚ùå clang-tidy found issues. Commit aborted."
        exit 1
    fi
fi

echo "‚úÖ clang-tidy passed!"
exit 0
```

Rendez-le ex√©cutable :

```bash
chmod +x .git/hooks/pre-commit
```

### 2. Script de v√©rification quotidienne

Cr√©ez `check_code.sh` :

```bash
#!/bin/bash

echo "üîç Running clang-tidy on entire codebase..."

find src -name "*.c" | while read file; do
    echo "Checking $file..."
    clang-tidy -checks='*' "$file" -- -std=c11
done

echo "‚úÖ Analysis complete!"
```

### 3. Int√©gration VS Code

Dans `.vscode/settings.json` :

```json
{
    "C_Cpp.codeAnalysis.clangTidy.enabled": true,
    "C_Cpp.codeAnalysis.clangTidy.checks.enabled": [
        "bugprone-*",
        "cert-*",
        "modernize-*",
        "performance-*",
        "readability-*"
    ],
    "C_Cpp.codeAnalysis.clangTidy.path": "/usr/bin/clang-tidy"
}
```

Les probl√®mes appara√Ætront directement dans l'√©diteur !

---

## Bonnes pratiques avec clang-tidy

### 1. Commencer progressivement

Ne pas activer tous les checks d'un coup sur un projet existant. Commencez par :

```bash
clang-tidy -checks='bugprone-*,cert-*' src/ -- -std=c11
```

Puis ajoutez progressivement d'autres cat√©gories.

### 2. Fixer en priorit√© les bugs critiques

Ordre de priorit√© :
1. **cert-*** (s√©curit√©)
2. **bugprone-*** (bugs potentiels)
3. **clang-analyzer-*** (analyse statique)
4. **modernize-*** (modernisation)
5. **readability-*** (lisibilit√©)
6. **performance-*** (optimisation)

### 3. Utiliser --fix avec pr√©caution

Testez toujours apr√®s avoir utilis√© `--fix` :

```bash
# 1. Faire un backup
cp -r src src_backup

# 2. Appliquer les fixes
clang-tidy -checks='modernize-*' --fix src/*.c -- -std=c11

# 3. Compiler et tester
make
./run_tests

# 4. Si OK, supprimer le backup
rm -rf src_backup
```

### 4. Documenter les suppressions

Si vous d√©sactivez un check, expliquez pourquoi dans le code :

```c
// NOLINTNEXTLINE(cert-err34-c) : Cette conversion est volontaire et s√©curis√©e ici
int value = atoi(user_input);
```

Ou dans le fichier de configuration :

```yaml
# D√©sactivation de readability-magic-numbers car nous utilisons beaucoup de constantes
# dans les calculs math√©matiques et les rendre toutes nomm√©es r√©duirait la lisibilit√©
Checks: '*,-readability-magic-numbers'
```

### 5. Cr√©er des configurations par type de code

**Pour du code embarqu√© (`.clang-tidy-embedded`) :**

```yaml
---
Checks: >
  bugprone-*,
  cert-*,
  performance-*,
  -bugprone-easily-swappable-parameters

CheckOptions:
  - key: performance-unnecessary-copy-initialization.AllowedTypes
    value: 'std::function'
```

**Pour des utilitaires syst√®me (`.clang-tidy-system`) :**

```yaml
---
Checks: >
  *,
  -readability-magic-numbers,
  -readability-function-cognitive-complexity

CheckOptions:
  - key: readability-function-size.LineThreshold
    value: '200'
```

Lancez avec :

```bash
clang-tidy --config-file=.clang-tidy-embedded embedded_code.c -- -std=c11
```

---

## R√©solution de probl√®mes courants

### Probl√®me 1 : "error: unable to handle compilation"

**Cause :** clang-tidy ne trouve pas les headers ou les options de compilation.

**Solution :**

```bash
# Sp√©cifier les chemins d'inclusion
clang-tidy example.c -- -std=c11 -I/usr/include -I./include
```

Ou utiliser `compile_commands.json` :

```bash
clang-tidy -p build example.c
```

### Probl√®me 2 : Trop de warnings

**Solution :** Filtrer les checks :

```bash
# Commencer l√©ger
clang-tidy -checks='bugprone-*' example.c -- -std=c11

# Puis augmenter progressivement
clang-tidy -checks='bugprone-*,cert-*' example.c -- -std=c11
```

### Probl√®me 3 : Faux positifs

**Solution :** Supprimer localement avec NOLINTNEXTLINE :

```c
// NOLINTNEXTLINE(bugprone-narrowing-conversions)
int x = (int)large_value;
```

Ou dans la configuration :

```yaml
Checks: '*,-bugprone-narrowing-conversions'
```

---

## Commandes utiles - Cheat Sheet

```bash
# Analyse basique
clang-tidy example.c -- -std=c11

# Tous les checks
clang-tidy -checks='*' example.c -- -std=c11

# Checks sp√©cifiques
clang-tidy -checks='bugprone-*,cert-*' example.c -- -std=c11

# Lister les checks disponibles
clang-tidy -list-checks

# Corrections automatiques
clang-tidy -checks='modernize-*' --fix example.c -- -std=c11

# Avec compile_commands.json
clang-tidy -p build src/main.c

# Analyser tout le projet
run-clang-tidy -p build

# V√©rifier la configuration
clang-tidy -dump-config

# Export des r√©sultats en YAML
clang-tidy -checks='*' --export-fixes=fixes.yaml example.c -- -std=c11
```

---

## Ressources suppl√©mentaires

### Documentation officielle
- Site web : [https://clang.llvm.org/extra/clang-tidy/](https://clang.llvm.org/extra/clang-tidy/)
- Liste compl√®te des checks : [https://clang.llvm.org/extra/clang-tidy/checks/list.html](https://clang.llvm.org/extra/clang-tidy/checks/list.html)
- GitHub : [https://github.com/llvm/llvm-project/tree/main/clang-tools-extra/clang-tidy](https://github.com/llvm/llvm-project/tree/main/clang-tools-extra/clang-tidy)

### Commandes de diagnostic

```bash
# V√©rifier quelle configuration est appliqu√©e
clang-tidy -dump-config example.c -- -std=c11

# Voir les explications d√©taill√©es d'un check
clang-tidy -checks='bugprone-infinite-loop' --explain-config example.c -- -std=c11

# Mode verbeux pour debug
clang-tidy -checks='*' -v example.c -- -std=c11
```

---

## R√©sum√©

**clang-tidy** est l'outil d'analyse statique **le plus puissant** pour le C moderne :

- ‚úÖ **Plus de 400 checks** couvrant tous les aspects du code
- ‚úÖ **Corrections automatiques** pour gagner du temps
- ‚úÖ **Modernisation du code** vers les derniers standards
- ‚úÖ **Int√©gration facile** dans tous les workflows
- ‚úÖ **Configuration flexible** via fichiers YAML
- ‚úÖ **D√©tection pr√©cise** avec tr√®s peu de faux positifs

**Configuration recommand√©e pour d√©buter :**

```bash
clang-tidy -checks='bugprone-*,cert-*,modernize-*' example.c -- -std=c11
```

**Commande compl√®te pour un projet en production :**

```bash
clang-tidy -checks='*,-readability-magic-numbers' --warnings-as-errors='bugprone-*,cert-*' -p build src/
```

---

**üí° Conseil final :** Combinez clang-tidy avec cppcheck, les sanitizers et Valgrind pour obtenir une **couverture maximale** de la qualit√© du code. clang-tidy excelle dans la d√©tection de probl√®mes de style et de modernisation, tandis que Valgrind et les sanitizers d√©tectent les probl√®mes √† l'ex√©cution.

**üéØ Workflow recommand√© :**
1. **cppcheck** : Premi√®re passe rapide
2. **clang-tidy** : Analyse approfondie + modernisation
3. **Compilation avec warnings** : `gcc -Wall -Wextra -Werror`
4. **Sanitizers** : Tests avec ASan/UBSan
5. **Valgrind** : V√©rification finale des fuites m√©moire

Avec cette combinaison, votre code C sera de qualit√© professionnelle ! üöÄ

‚è≠Ô∏è [Configuration et int√©gration continue](/15-debogage-et-qualite/06.3-configuration-ci.md)
