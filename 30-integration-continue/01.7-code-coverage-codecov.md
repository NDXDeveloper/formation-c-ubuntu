üîù Retour au [Sommaire](/SOMMAIRE.md)

# 30.1.7 Code coverage et Codecov

## Introduction

La **couverture de code** (code coverage) est une m√©trique qui mesure quel pourcentage de votre code source est **r√©ellement ex√©cut√©** par vos tests. C'est un indicateur de qualit√© essentiel qui vous aide √† identifier les parties de votre code qui ne sont pas test√©es et qui pourraient contenir des bugs non d√©tect√©s.

**Codecov** est un service web qui visualise vos rapports de couverture, suit leur √©volution dans le temps, et s'int√®gre parfaitement avec GitHub pour afficher les r√©sultats directement dans vos Pull Requests.

---

## Pourquoi mesurer la couverture de code ?

### Les avantages

1. **Identifier le code non test√©** : Savoir exactement quelles lignes ne sont pas couvertes par les tests
2. **Am√©liorer la qualit√©** : Plus de couverture = moins de bugs potentiels
3. **Confiance dans les refactorings** : Modifier du code bien test√© est moins risqu√©
4. **M√©triques objectives** : Suivre l'√©volution de la qualit√© dans le temps
5. **Reviews facilit√©es** : Voir dans les PR quelles nouvelles lignes ne sont pas test√©es

### Ce que la couverture mesure

La couverture de code mesure plusieurs aspects :

#### 1. Line Coverage (Couverture de ligne) üìä

**Le pourcentage de lignes ex√©cut√©es au moins une fois.**

```c
int max(int a, int b) {
    if (a > b) {          // ‚úÖ Ex√©cut√©e
        return a;         // ‚úÖ Ex√©cut√©e
    }
    return b;             // ‚ùå Jamais ex√©cut√©e si test avec a > b seulement
}
```

Si vos tests appellent seulement `max(10, 5)`, la couverture sera **75%** (3 lignes sur 4).

#### 2. Branch Coverage (Couverture de branchement) üåø

**Le pourcentage de branches conditionnelles test√©es.**

```c
if (x > 0) {      // Branche 1: x > 0 ‚úÖ
    // ...        // Branche 2: x <= 0 ‚ùå
}
```

Pour 100% de branch coverage, il faut tester **les deux cas** : `x > 0` et `x <= 0`.

#### 3. Function Coverage (Couverture de fonction) üîß

**Le pourcentage de fonctions appel√©es au moins une fois.**

```c
void fonction_utilisee(void) { ... }    // ‚úÖ Appel√©e  
void fonction_oubliee(void) { ... }     // ‚ùå Jamais appel√©e  
```

---

## Les outils de couverture en C

### gcov : L'outil de base

**gcov** est l'outil de couverture fourni avec GCC. Il analyse quelles lignes de code ont √©t√© ex√©cut√©es.

**Caract√©ristiques :**
- Int√©gr√© √† GCC (pas d'installation suppl√©mentaire)
- G√©n√®re des rapports texte
- Fonctionne au niveau des fichiers sources
- N√©cessite une compilation avec flags sp√©ciaux

### lcov : Visualisation HTML

**lcov** est une interface graphique pour gcov qui g√©n√®re des rapports HTML navigables.

**Caract√©ristiques :**
- Rapports HTML √©l√©gants
- Vue d'ensemble du projet
- Navigation par fichier/dossier
- Graphiques de couverture

**Installation :**
```bash
sudo apt-get install lcov
```

---

## Workflow de la couverture de code

Le processus se d√©roule en 4 √©tapes :

```
1. Compiler avec flags de couverture
         ‚Üì
2. Ex√©cuter les tests
         ‚Üì
3. G√©n√©rer les rapports (gcov/lcov)
         ‚Üì
4. Uploader vers Codecov (optionnel)
```

---

## √âtape 1 : Compiler avec la couverture

Pour activer la couverture, compilez avec les flags suivants :

```bash
gcc --coverage -o app main.c
```

Ou de mani√®re plus explicite :

```bash
gcc -fprofile-arcs -ftest-coverage -o app main.c
```

**Explications des flags :**

- `--coverage` : Raccourci pour `-fprofile-arcs -ftest-coverage`
- `-fprofile-arcs` : G√©n√®re des fichiers `.gcda` pendant l'ex√©cution
- `-ftest-coverage` : G√©n√®re des fichiers `.gcno` √† la compilation

**Fichiers g√©n√©r√©s :**

- `.gcno` : Fichier de notes (compile time) - structure du programme
- `.gcda` : Fichier de donn√©es (runtime) - compteurs d'ex√©cution

---

## √âtape 2 : Ex√©cuter les tests

Lancez simplement votre programme ou vos tests :

```bash
./app
```

Les fichiers `.gcda` sont mis √† jour automatiquement avec les informations d'ex√©cution.

---

## √âtape 3 : G√©n√©rer les rapports avec gcov

### Rapport simple avec gcov

```bash
gcov main.c
```

**Sortie :**
```
File 'main.c'  
Lines executed:75.00% of 20  
Creating 'main.c.gcov'  
```

Le fichier `main.c.gcov` contient le code source annot√© :

**main.c.gcov**
```
        -:    0:Source:main.c
        -:    1:#include <stdio.h>
        -:    2:
        5:    3:int add(int a, int b) {
        5:    4:    return a + b;
        -:    5:}
        -:    6:
    #####:    7:int multiply(int a, int b) {
    #####:    8:    return a * b;
    #####:    9:}
        -:   10:
        1:   11:int main(void) {
        1:   12:    printf("Result: %d\n", add(2, 3));
        1:   13:    return 0;
        -:   14:}
```

**L√©gende :**
- `-:` : Ligne non ex√©cutable (commentaires, d√©clarations)
- `5:` : Ligne ex√©cut√©e 5 fois
- `#####:` : Ligne jamais ex√©cut√©e (probl√®me !)
- `1:` : Ligne ex√©cut√©e 1 fois

---

## Configuration CMake pour la couverture

**CMakeLists.txt**

```cmake
cmake_minimum_required(VERSION 3.10)  
project(MonProjet C)  

# Option pour activer la couverture
option(ENABLE_COVERAGE "Enable code coverage" OFF)

if(ENABLE_COVERAGE)
    message(STATUS "Code coverage activ√©e")

    # Flags de couverture
    add_compile_options(--coverage)
    add_link_options(--coverage)

    # GCC ou Clang seulement
    if(NOT CMAKE_C_COMPILER_ID MATCHES "GNU|Clang")
        message(FATAL_ERROR "Coverage n√©cessite GCC ou Clang")
    endif()
endif()

# Votre projet
add_library(calculator_lib src/calculator.c)  
add_executable(calculator src/main.c)  
target_link_libraries(calculator calculator_lib)  

# Tests
enable_testing()  
add_executable(test_calculator tests/test_calculator.c)  
target_link_libraries(test_calculator calculator_lib)  
add_test(NAME calculator_tests COMMAND test_calculator)  
```

**Utilisation :**

```bash
# Configuration avec couverture
cmake -B build -DENABLE_COVERAGE=ON

# Compilation
cmake --build build

# Ex√©cution des tests
cd build && ctest

# G√©n√©ration du rapport
gcov CMakeFiles/calculator_lib.dir/src/calculator.c.gcno
```

---

## G√©n√©ration de rapports HTML avec lcov

lcov permet de cr√©er de beaux rapports HTML :

### √âtapes compl√®tes

```bash
# 1. R√©initialiser les compteurs
lcov --zerocounters --directory .

# 2. Capturer l'√©tat initial
lcov --capture --initial --directory . --output-file coverage_base.info

# 3. Ex√©cuter les tests
ctest

# 4. Capturer les donn√©es de couverture
lcov --capture --directory . --output-file coverage_test.info

# 5. Combiner les donn√©es
lcov --add-tracefile coverage_base.info \
     --add-tracefile coverage_test.info \
     --output-file coverage_total.info

# 6. Retirer les fichiers syst√®me et tests
lcov --remove coverage_total.info \
     '/usr/*' \
     '*/tests/*' \
     '*/unity/*' \
     --output-file coverage_filtered.info

# 7. G√©n√©rer le HTML
genhtml coverage_filtered.info --output-directory coverage_html

# 8. Ouvrir dans le navigateur
xdg-open coverage_html/index.html
```

**R√©sultat :** Un site web navigable avec :
- Vue d'ensemble du projet
- D√©tails par fichier
- Code source color√© (vert = couvert, rouge = non couvert)
- Graphiques et statistiques

---

## Workflow GitHub Actions : Couverture de base

Voici un workflow minimal pour g√©n√©rer la couverture :

```yaml
name: Code Coverage

on: [push, pull_request]

jobs:
  coverage:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout du code
      uses: actions/checkout@v4

    - name: Installer les outils
      run: |
        sudo apt-get update
        sudo apt-get install -y gcc cmake lcov

    - name: Configurer avec couverture
      run: |
        cmake -B build \
          -DCMAKE_BUILD_TYPE=Debug \
          -DCMAKE_C_FLAGS="--coverage"

    - name: Compiler
      run: cmake --build build

    - name: Lancer les tests
      run: |
        cd build
        ctest --output-on-failure

    - name: G√©n√©rer le rapport de couverture
      run: |
        cd build
        lcov --capture --directory . --output-file coverage.info
        lcov --remove coverage.info '/usr/*' '*/tests/*' --output-file coverage_filtered.info
        lcov --list coverage_filtered.info

    - name: Uploader le rapport HTML
      uses: actions/upload-artifact@v4
      with:
        name: coverage-report
        path: build/coverage_html/
```

---

## Int√©gration avec Codecov

**Codecov** est un service qui h√©berge et visualise vos rapports de couverture. Il s'int√®gre avec GitHub pour :

- Afficher la couverture dans les PRs
- Suivre l'√©volution dans le temps
- Comparer les branches
- Badge de couverture pour le README

### √âtape 1 : S'inscrire sur Codecov

1. Allez sur [codecov.io](https://codecov.io)
2. Connectez-vous avec votre compte GitHub
3. Autorisez l'acc√®s √† vos d√©p√¥ts
4. Activez votre d√©p√¥t dans Codecov

### √âtape 2 : Obtenir le token (optionnel pour d√©p√¥ts publics)

Pour les **d√©p√¥ts priv√©s**, vous avez besoin d'un token :

1. Sur Codecov, allez dans les settings de votre d√©p√¥t
2. Copiez le `CODECOV_TOKEN`
3. Dans GitHub, allez dans `Settings ‚Üí Secrets ‚Üí Actions`
4. Cr√©ez un secret `CODECOV_TOKEN` avec la valeur

**Pour les d√©p√¥ts publics**, aucun token n'est n√©cessaire.

### √âtape 3 : Workflow avec Codecov

```yaml
name: Code Coverage avec Codecov

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  coverage:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Installer les outils
      run: |
        sudo apt-get update
        sudo apt-get install -y gcc cmake lcov

    - name: Configurer avec couverture
      run: |
        cmake -B build \
          -DCMAKE_BUILD_TYPE=Debug \
          -DCMAKE_C_FLAGS="--coverage -O0"

    - name: Compiler
      run: cmake --build build

    - name: Lancer les tests
      run: |
        cd build
        ctest --output-on-failure

    - name: G√©n√©rer le rapport lcov
      run: |
        cd build
        lcov --capture --directory . --output-file coverage.info
        lcov --remove coverage.info \
             '/usr/*' \
             '*/tests/*' \
             '*/unity/*' \
             --output-file coverage.info
        lcov --list coverage.info

    - name: Uploader vers Codecov
      uses: codecov/codecov-action@v4
      with:
        token: ${{ secrets.CODECOV_TOKEN }}  # Optionnel pour d√©p√¥ts publics
        files: ./build/coverage.info
        flags: unittests
        name: codecov-umbrella
        fail_ci_if_error: true
```

**Param√®tres de l'action Codecov :**

- `token:` Token d'authentification (seulement pour priv√©s)
- `files:` Chemin vers le fichier de couverture
- `flags:` Tags pour organiser les rapports (ex: unittests, integration)
- `fail_ci_if_error:` Faire √©chouer la CI si l'upload √©choue

---

## Comprendre les m√©triques Codecov

### Dashboard Codecov

Apr√®s l'upload, Codecov affiche :

#### 1. Couverture globale

```
Project Coverage: 85.42%
```

Pourcentage de lignes couvertes dans tout le projet.

#### 2. Diff Coverage (dans les PRs)

```
Patch Coverage: 92.30%
```

Pourcentage des **nouvelles lignes ajout√©es** qui sont couvertes par des tests.

#### 3. Changement de couverture

```
Coverage: 85.42% (+2.15%) ‚Üó
```

√âvolution de la couverture par rapport √† la branche de base.

### Dans les Pull Requests

Codecov ajoute un commentaire automatique :

```
Coverage: 85.42% (+2.15%)

Files changed: 3

| File | Coverage | Œî |
|------|----------|---|
| src/calculator.c | 95.00% | +5.00% ‚Üó |
| src/utils.c | 75.00% | -2.00% ‚Üò |
| src/main.c | 100.00% | 0.00% ‚Üí |
```

**Interpr√©tation :**
- ‚Üó : La couverture a augment√© (bon signe)
- ‚Üò : La couverture a diminu√© (attention !)
- ‚Üí : Pas de changement

---

## Badge de couverture dans le README

Ajoutez un badge de couverture dans votre `README.md` :

```markdown
[![codecov](https://codecov.io/gh/username/repo/branch/main/graph/badge.svg)](https://codecov.io/gh/username/repo)
```

Le badge affiche la couverture actuelle :

![Coverage](https://img.shields.io/badge/coverage-85%25-brightgreen)

**Couleurs automatiques :**
- üü¢ Vert : ‚â• 80%
- üü° Jaune : 60-79%
- üî¥ Rouge : < 60%

---

## Configuration avanc√©e de Codecov

### Fichier codecov.yml

Cr√©ez un fichier `.codecov.yml` √† la racine de votre projet pour configurer Codecov :

**.codecov.yml**

```yaml
# Configuration Codecov

coverage:
  status:
    project:
      default:
        target: 80%           # Couverture minimale requise
        threshold: 2%         # Tol√©rance de baisse

    patch:
      default:
        target: 90%           # Nouveau code doit √™tre bien test√©
        threshold: 5%

comment:
  layout: "header, diff, flags, files"
  behavior: default

ignore:
  - "tests/**"              # Ignorer les fichiers de tests
  - "**/*.h"                # Ignorer les headers (optionnel)
  - "examples/**"           # Ignorer les exemples
```

**Explications :**

- `project.target: 80%` : La couverture globale doit √™tre ‚â• 80%
- `patch.target: 90%` : Le nouveau code doit √™tre couvert √† 90%
- `threshold:` Tol√©rance de baisse acceptable
- `ignore:` Fichiers √† exclure du calcul

---

## Workflow complet avec matrice

Pour tester la couverture sur plusieurs configurations :

```yaml
name: CI avec Code Coverage

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test-and-coverage:
    name: Tests et Couverture - ${{ matrix.compiler }}
    runs-on: ubuntu-latest

    strategy:
      fail-fast: false
      matrix:
        compiler: [gcc-12, gcc-13]

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Installer les outils
      run: |
        sudo apt-get update
        sudo apt-get install -y ${{ matrix.compiler }} cmake lcov

    - name: Configurer
      run: |
        cmake -B build \
          -DCMAKE_C_COMPILER=${{ matrix.compiler }} \
          -DCMAKE_BUILD_TYPE=Debug \
          -DCMAKE_C_FLAGS="--coverage -O0 -g"

    - name: Compiler
      run: cmake --build build -j$(nproc)

    - name: Lancer les tests
      run: |
        cd build
        ctest --output-on-failure --verbose

    - name: G√©n√©rer le rapport de couverture
      run: |
        cd build
        lcov --capture --directory . --output-file coverage.info
        lcov --remove coverage.info \
             '/usr/*' '*/tests/*' '*/unity/*' \
             --output-file coverage.info
        lcov --list coverage.info

    - name: G√©n√©rer le HTML
      run: |
        cd build
        genhtml coverage.info --output-directory coverage_html

    - name: Uploader vers Codecov
      uses: codecov/codecov-action@v4
      with:
        token: ${{ secrets.CODECOV_TOKEN }}
        files: ./build/coverage.info
        flags: ${{ matrix.compiler }}
        name: codecov-${{ matrix.compiler }}

    - name: Uploader le rapport HTML
      if: matrix.compiler == 'gcc-13'  # Seulement pour une config
      uses: actions/upload-artifact@v4
      with:
        name: coverage-html
        path: build/coverage_html/
```

---

## Analyser un rapport de couverture

### Vue d'ensemble du projet

```
Overall coverage rate:
  lines......: 85.4% (234 of 274 lines)
  functions..: 90.0% (18 of 20 functions)
  branches...: 78.2% (43 of 55 branches)
```

**Objectifs typiques :**
- **Excellent** : ‚â• 90%
- **Bon** : 80-89%
- **Acceptable** : 70-79%
- **Insuffisant** : < 70%

### Fichier par fichier

```
File                      Lines    Funcs   Branches
------------------------------------------------
src/calculator.c          95.0%    100%    92.3%  
src/utils.c               75.0%    80.0%   66.7%  
src/parser.c              60.0%    70.0%   50.0%  ‚Üê √Ä am√©liorer !  
```

**Priorit√© :** Am√©liorer les fichiers avec la plus faible couverture.

### Code source annot√©

Dans le HTML g√©n√©r√© :

```c
10:    if (x > 0) {          // ‚úÖ Ligne couverte (ex√©cut√©e 10 fois)
10:        return x;
  :    } else {
#####:    return -x;          // ‚ùå Jamais ex√©cut√© !
  :    }
```

**Code color√© :**
- üü¢ **Vert** : Ligne ex√©cut√©e
- üî¥ **Rouge** : Ligne jamais ex√©cut√©e
- ‚ö™ **Gris** : Ligne non ex√©cutable

---

## Am√©liorer la couverture de code

### Strat√©gies

#### 1. Identifier les gaps

Utilisez le rapport HTML pour trouver les lignes rouges :

```bash
# Ouvrir le rapport
xdg-open build/coverage_html/index.html
```

Cliquez sur les fichiers avec faible couverture.

#### 2. √âcrire des tests cibl√©s

Pour chaque branche non couverte, ajoutez un test :

```c
// Fonction avec branche non couverte
int divide(int a, int b) {
    if (b == 0) {
        return -1;        // ‚ùå Non test√© !
    }
    return a / b;
}

// Ajouter un test
void test_divide_by_zero(void) {
    TEST_ASSERT_EQUAL(-1, divide(10, 0));  // ‚úÖ Maintenant couvert
}
```

#### 3. Tester les cas limites

```c
// Tester :
- Valeurs nulles
- Valeurs n√©gatives
- D√©bordements
- Cas d'erreur
- Conditions aux limites
```

#### 4. Ne pas viser 100% √† tout prix

**100% de couverture ‚â† 0 bugs**

Certaines parties du code sont difficiles √† tester :
- Code de gestion d'erreurs rares
- Code d√©pendant du mat√©riel
- Code legacy sans tests

**Objectif r√©aliste** : 80-90% de couverture.

---

## Exclure du code de la couverture

### Avec des commentaires sp√©ciaux

Pour exclure des lignes sp√©cifiques :

```c
// LCOV_EXCL_START
void fonction_impossible_a_tester(void) {
    // Ce code ne sera pas compt√© dans la couverture
}
// LCOV_EXCL_STOP

void autre_fonction(void) {
    impossible_a_atteindre();  // LCOV_EXCL_LINE
}
```

### Avec lcov --remove

```bash
lcov --remove coverage.info \
     '*/tests/*' \
     '*/examples/*' \
     '*/vendor/*' \
     --output-file coverage_filtered.info
```

---

## Couverture par type de test

Utilisez des flags pour s√©parer les types de tests :

```yaml
- name: Tests unitaires
  run: |
    cd build
    ctest -L unit
    lcov --capture --directory . --output-file unit_coverage.info

- name: Tests d'int√©gration
  run: |
    cd build
    ctest -L integration
    lcov --capture --directory . --output-file integration_coverage.info

- name: Upload s√©par√©
  uses: codecov/codecov-action@v4
  with:
    files: ./build/unit_coverage.info
    flags: unittests

- name: Upload int√©gration
  uses: codecov/codecov-action@v4
  with:
    files: ./build/integration_coverage.info
    flags: integration
```

Sur Codecov, vous pourrez voir la couverture par flag s√©par√©ment.

---

## Protection de branche avec couverture

Dans GitHub, vous pouvez bloquer les PRs qui diminuent la couverture :

### Configuration dans .codecov.yml

```yaml
coverage:
  status:
    project:
      default:
        target: auto      # Maintenir la couverture actuelle
        threshold: 0%     # Aucune baisse tol√©r√©e

    patch:
      default:
        target: 80%       # Nouveau code doit √™tre test√© √† 80%

github_checks:
  annotations: true       # Annoter les lignes non couvertes
```

### Dans GitHub Settings

`Settings ‚Üí Branches ‚Üí Branch protection rules`

Cochez :
- ‚òë Require status checks to pass
  - ‚òë codecov/project
  - ‚òë codecov/patch

Les PRs ne pourront √™tre merg√©es que si la couverture est suffisante.

---

## Erreurs courantes et solutions

### Erreur : "No coverage data found"

**Cause :** Fichiers `.gcda` non g√©n√©r√©s.

**Solutions :**
1. V√©rifier que `--coverage` est bien dans les flags de compilation ET de linking
2. S'assurer que les tests ont bien √©t√© ex√©cut√©s
3. V√©rifier que le working directory est correct

```yaml
- name: Debug
  run: |
    find build -name "*.gcda" -ls  # Chercher les fichiers .gcda
```

### Erreur : Couverture √† 0% sur Codecov

**Cause :** Chemins de fichiers incorrects dans coverage.info

**Solution :** Utiliser des chemins relatifs

```bash
lcov --capture --directory . --base-directory .. --output-file coverage.info
```

### Erreur : "gcov not found"

**Solution :** Installer le paquet gcov

```yaml
- name: Installer gcov
  run: sudo apt-get install -y gcc
```

### Couverture incoh√©rente entre local et CI

**Cause :** Diff√©rences de compilation ou d'ex√©cution

**Solutions :**
1. M√™me version de GCC/Clang
2. M√™mes flags de compilation
3. M√™me suite de tests ex√©cut√©e

---

## Bonnes pratiques

### 1. Compiler sans optimisations

```bash
-O0  # D√©sactive les optimisations
```

Les optimisations peuvent rendre le rapport de couverture difficile √† interpr√©ter.

### 2. Ajouter les symboles de debug

```bash
--coverage -g -O0
```

Am√©liore la pr√©cision des rapports.

### 3. Nettoyer entre les runs

```bash
find . -name "*.gcda" -delete  # Supprimer les anciennes donn√©es
```

√âvite de mixer les donn√©es de plusieurs ex√©cutions.

### 4. Exclure les fichiers non pertinents

```bash
lcov --remove coverage.info '/usr/*' '*/tests/*' '*/vendor/*'
```

Ne comptez que votre code applicatif.

### 5. Viser 80-90% de couverture

C'est un bon √©quilibre entre qualit√© et effort.

### 6. Prioriser la patch coverage

Le nouveau code doit √™tre bien test√© (‚â• 90%).

### 7. Automatiser compl√®tement

La couverture doit √™tre mesur√©e **√† chaque commit**, pas manuellement.

---

## Alternatives √† Codecov

### Coveralls

Similaire √† Codecov, mais interface diff√©rente.

```yaml
- name: Uploader vers Coveralls
  uses: coverallsapp/github-action@v2
  with:
    github-token: ${{ secrets.GITHUB_TOKEN }}
    file: build/coverage.info
```

### SonarCloud

Analyse plus compl√®te (qualit√© de code + couverture).

```yaml
- name: SonarCloud Scan
  uses: SonarSource/sonarcloud-github-action@master
  env:
    SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
```

### Rapports HTML en artifact

Simple et gratuit, mais moins de fonctionnalit√©s.

```yaml
- name: Upload HTML
  uses: actions/upload-artifact@v4
  with:
    name: coverage-report
    path: build/coverage_html/
```

---

## Template de workflow complet

Voici un workflow production-ready :

```yaml
name: Tests et Couverture de Code

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  coverage:
    name: Code Coverage
    runs-on: ubuntu-latest

    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # N√©cessaire pour Codecov

    - name: Installer les d√©pendances
      run: |
        sudo apt-get update
        sudo apt-get install -y gcc-13 cmake lcov

    - name: Configurer avec couverture
      run: |
        cmake -B build \
          -DCMAKE_C_COMPILER=gcc-13 \
          -DCMAKE_BUILD_TYPE=Debug \
          -DCMAKE_C_FLAGS="--coverage -O0 -g"

    - name: Compiler
      run: cmake --build build -j$(nproc)

    - name: Nettoyer les donn√©es pr√©c√©dentes
      run: |
        cd build
        lcov --zerocounters --directory .

    - name: Ex√©cuter les tests
      run: |
        cd build
        ctest --output-on-failure --verbose

    - name: G√©n√©rer le rapport de couverture
      run: |
        cd build

        # Capturer les donn√©es
        lcov --capture --directory . --output-file coverage.info

        # Nettoyer (retirer fichiers syst√®me et tests)
        lcov --remove coverage.info \
             '/usr/*' \
             '*/tests/*' \
             '*/unity/*' \
             '*/examples/*' \
             --output-file coverage.info

        # Afficher le r√©sum√©
        echo "=== R√©sum√© de la couverture ==="
        lcov --list coverage.info

    - name: V√©rifier la couverture minimale
      run: |
        cd build
        COVERAGE=$(lcov --summary coverage.info | grep "lines" | awk '{print $2}' | sed 's/%//')
        echo "Couverture actuelle: ${COVERAGE}%"

        if (( $(echo "$COVERAGE < 80" | bc -l) )); then
          echo "‚ùå Couverture insuffisante (< 80%)"
          exit 1
        else
          echo "‚úÖ Couverture satisfaisante (‚â• 80%)"
        fi

    - name: G√©n√©rer le rapport HTML
      run: |
        cd build
        genhtml coverage.info --output-directory coverage_html

    - name: Uploader vers Codecov
      uses: codecov/codecov-action@v4
      with:
        token: ${{ secrets.CODECOV_TOKEN }}
        files: ./build/coverage.info
        flags: unittests
        name: codecov-umbrella
        fail_ci_if_error: true

    - name: Uploader le rapport HTML
      uses: actions/upload-artifact@v4
      with:
        name: coverage-html-report
        path: build/coverage_html/
        retention-days: 30

    - name: Commenter la PR
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const coverage = '85.4%';  // √Ä calculer depuis lcov
          github.rest.issues.createComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
            body: `## üìä Code Coverage\n\nCouverture actuelle: **${coverage}**\n\n[Voir le rapport d√©taill√©](https://codecov.io/gh/${context.repo.owner}/${context.repo.repo}/pull/${context.issue.number})`
          })
```

---

## R√©sum√©

**La couverture de code mesure quelles parties de votre code sont test√©es.**

**Outils essentiels :**
- **gcov** : Collecte les donn√©es de couverture
- **lcov** : G√©n√®re des rapports HTML
- **Codecov** : H√©berge et visualise les rapports

**Configuration minimale :**

1. Compiler avec `--coverage`
2. Ex√©cuter les tests
3. G√©n√©rer le rapport avec `lcov`
4. Uploader vers Codecov

**M√©triques importantes :**
- **Line coverage** : % de lignes ex√©cut√©es
- **Branch coverage** : % de branches test√©es
- **Patch coverage** : % du nouveau code test√©

**Objectifs :**
- **Projet** : ‚â• 80% de couverture globale
- **Patch** : ‚â• 90% pour le nouveau code

---

## Prochaines √©tapes

Maintenant que vous mesurez la couverture, vous pouvez :

- Configurer l'**analyse statique** (clang-tidy, cppcheck)
- Publier des **artifacts de build**
- Cr√©er des **releases automatiques**
- Mettre en place des **notifications** de CI

Ces sujets sont couverts dans les sections suivantes.

---

## Ressources compl√©mentaires

- [Documentation gcov](https://gcc.gnu.org/onlinedocs/gcc/Gcov.html)
- [Documentation lcov](http://ltp.sourceforge.net/coverage/lcov.php)
- [Codecov Documentation](https://docs.codecov.com/)
- [Code Coverage Best Practices](https://martinfowler.com/bliki/TestCoverage.html)

---

**üéØ Points cl√©s √† retenir :**

- ‚úÖ La couverture mesure quel code est ex√©cut√© par les tests
- ‚úÖ Compiler avec `--coverage` pour activer gcov
- ‚úÖ lcov g√©n√®re de beaux rapports HTML
- ‚úÖ Codecov h√©berge les rapports et s'int√®gre aux PRs
- ‚úÖ Viser 80-90% de couverture pour un bon √©quilibre
- ‚úÖ La patch coverage (nouveau code) doit √™tre ‚â• 90%
- ‚úÖ Automatiser compl√®tement dans le CI/CD
- ‚úÖ 100% de couverture ‚â† 0 bugs, c'est juste un indicateur

‚è≠Ô∏è [Static analysis](/30-integration-continue/01.8-static-analysis.md)
