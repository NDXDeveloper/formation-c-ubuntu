üîù Retour au [Sommaire](/SOMMAIRE.md)

# 34.3.1 Collecte de M√©triques

## Introduction

La collecte de m√©triques est le c≈ìur d'un agent de monitoring syst√®me. Elle consiste √† r√©cup√©rer p√©riodiquement des informations sur l'√©tat du syst√®me (CPU, m√©moire, disque, r√©seau) pour les exposer ou les transmettre √† un syst√®me de supervision.

Dans cette section, nous allons explorer comment collecter ces m√©triques en C sur un syst√®me Linux en utilisant les interfaces natives du syst√®me d'exploitation.

---

## Pourquoi collecter des m√©triques en C ?

- **Performance** : Un agent √©crit en C consomme tr√®s peu de ressources
- **Pas de d√©pendances** : Pas besoin de runtime (Python, JVM)
- **Acc√®s direct au syst√®me** : Lecture optimis√©e des fichiers `/proc` et `/sys`
- **Portabilit√©** : Code facilement d√©ployable sur diff√©rentes distributions Linux

---

## Les sources de m√©triques sur Linux

Linux expose les informations syst√®me via des **pseudo-syst√®mes de fichiers** :

### 1. `/proc` - Informations processus et syst√®me
Le syst√®me de fichiers `/proc` est une interface virtuelle vers le noyau Linux.

**Fichiers cl√©s :**
- `/proc/stat` : Statistiques CPU globales
- `/proc/meminfo` : Informations m√©moire d√©taill√©es
- `/proc/loadavg` : Charge syst√®me (load average)
- `/proc/uptime` : Temps depuis le d√©marrage
- `/proc/net/dev` : Statistiques r√©seau par interface
- `/proc/diskstats` : Statistiques disque

### 2. `/sys` - Informations mat√©riel et kernel
Le syst√®me de fichiers sysfs expose les informations du mat√©riel.

**Exemples :**
- `/sys/class/thermal/thermal_zone0/temp` : Temp√©rature CPU
- `/sys/block/sda/stat` : Statistiques disque

### 3. Appels syst√®me
Certaines m√©triques n√©cessitent des appels syst√®me directs :
- `sysinfo()` : Informations syst√®me globales
- `getrusage()` : Utilisation des ressources

---

## Collecte des m√©triques CPU

### Comprendre `/proc/stat`

Le fichier `/proc/stat` contient les compteurs de temps CPU en **jiffies** (unit√© de temps kernel, g√©n√©ralement 1/100e de seconde).

**Format :**
```
cpu  user nice system idle iowait irq softirq steal guest guest_nice
cpu0 ... (m√™me format pour chaque c≈ìur)
```

**Signification des champs :**
- `user` : Temps en mode utilisateur
- `nice` : Temps en processus √† priorit√© modifi√©e
- `system` : Temps en mode kernel
- `idle` : Temps inactif
- `iowait` : Temps d'attente I/O
- `irq` : Temps de traitement d'interruptions mat√©rielles
- `softirq` : Temps de traitement d'interruptions logicielles
- `steal` : Temps vol√© par l'hyperviseur (virtualisation)

### Exemple de code : Lecture des stats CPU

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    unsigned long long user;
    unsigned long long nice;
    unsigned long long system;
    unsigned long long idle;
    unsigned long long iowait;
    unsigned long long irq;
    unsigned long long softirq;
    unsigned long long steal;
} cpu_stats_t;

int read_cpu_stats(cpu_stats_t *stats) {
    FILE *fp = fopen("/proc/stat", "r");
    if (fp == NULL) {
        perror("Erreur ouverture /proc/stat");
        return -1;
    }

    char buffer[256];

    // Lire la premi√®re ligne (cpu global)
    if (fgets(buffer, sizeof(buffer), fp) == NULL) {
        fclose(fp);
        return -1;
    }

    // Parser la ligne
    int parsed = sscanf(buffer, "cpu %llu %llu %llu %llu %llu %llu %llu %llu",
                        &stats->user,
                        &stats->nice,
                        &stats->system,
                        &stats->idle,
                        &stats->iowait,
                        &stats->irq,
                        &stats->softirq,
                        &stats->steal);

    fclose(fp);

    if (parsed < 8) {
        fprintf(stderr, "Erreur parsing CPU stats\n");
        return -1;
    }

    return 0;
}
```

### Calcul du pourcentage d'utilisation CPU

Pour obtenir le pourcentage d'utilisation, il faut **deux mesures espac√©es dans le temps** :

```c
#include <unistd.h>

double calculate_cpu_usage(cpu_stats_t *prev, cpu_stats_t *curr) {
    // Calcul du temps total et du temps idle
    unsigned long long prev_idle = prev->idle + prev->iowait;
    unsigned long long curr_idle = curr->idle + curr->iowait;

    unsigned long long prev_total = prev->user + prev->nice + prev->system +
                                    prev->idle + prev->iowait + prev->irq +
                                    prev->softirq + prev->steal;
    unsigned long long curr_total = curr->user + curr->nice + curr->system +
                                    curr->idle + curr->iowait + curr->irq +
                                    curr->softirq + curr->steal;

    // Diff√©rences
    unsigned long long total_diff = curr_total - prev_total;
    unsigned long long idle_diff = curr_idle - prev_idle;

    // Calcul du pourcentage (temps actif / temps total)
    if (total_diff == 0) {
        return 0.0;
    }

    double usage = 100.0 * (total_diff - idle_diff) / total_diff;
    return usage;
}

// Exemple d'utilisation
void monitor_cpu(void) {
    cpu_stats_t prev_stats, curr_stats;

    // Premi√®re mesure
    if (read_cpu_stats(&prev_stats) != 0) {
        return;
    }

    // Attendre 1 seconde
    sleep(1);

    // Deuxi√®me mesure
    if (read_cpu_stats(&curr_stats) != 0) {
        return;
    }

    // Calculer l'utilisation
    double cpu_usage = calculate_cpu_usage(&prev_stats, &curr_stats);
    printf("Utilisation CPU: %.2f%%\n", cpu_usage);
}
```

**Points cl√©s :**
- Les valeurs dans `/proc/stat` sont des **compteurs cumulatifs** depuis le d√©marrage
- Il faut calculer la **diff√©rence** entre deux mesures
- Le pourcentage = (temps_actif / temps_total) √ó 100

---

## Collecte des m√©triques M√©moire

### Comprendre `/proc/meminfo`

Le fichier `/proc/meminfo` contient toutes les informations sur la m√©moire syst√®me.

**Extrait :**
```
MemTotal:       16384000 kB
MemFree:         2048000 kB
MemAvailable:    8192000 kB
Buffers:          512000 kB
Cached:          4096000 kB
SwapTotal:       8192000 kB
SwapFree:        6144000 kB
```

### Exemple de code : Lecture de la m√©moire

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    unsigned long total_kb;
    unsigned long free_kb;
    unsigned long available_kb;
    unsigned long buffers_kb;
    unsigned long cached_kb;
    unsigned long swap_total_kb;
    unsigned long swap_free_kb;
} memory_stats_t;

int read_memory_stats(memory_stats_t *stats) {
    FILE *fp = fopen("/proc/meminfo", "r");
    if (fp == NULL) {
        perror("Erreur ouverture /proc/meminfo");
        return -1;
    }

    char line[256];

    // Initialiser √† 0
    memset(stats, 0, sizeof(memory_stats_t));

    while (fgets(line, sizeof(line), fp) != NULL) {
        char key[64];
        unsigned long value;

        // Parser chaque ligne (format: "Key: Value kB")
        if (sscanf(line, "%63s %lu kB", key, &value) == 2) {
            if (strcmp(key, "MemTotal:") == 0) {
                stats->total_kb = value;
            } else if (strcmp(key, "MemFree:") == 0) {
                stats->free_kb = value;
            } else if (strcmp(key, "MemAvailable:") == 0) {
                stats->available_kb = value;
            } else if (strcmp(key, "Buffers:") == 0) {
                stats->buffers_kb = value;
            } else if (strcmp(key, "Cached:") == 0) {
                stats->cached_kb = value;
            } else if (strcmp(key, "SwapTotal:") == 0) {
                stats->swap_total_kb = value;
            } else if (strcmp(key, "SwapFree:") == 0) {
                stats->swap_free_kb = value;
            }
        }
    }

    fclose(fp);
    return 0;
}

void print_memory_usage(void) {
    memory_stats_t stats;

    if (read_memory_stats(&stats) != 0) {
        return;
    }

    // Calculs
    unsigned long used_kb = stats.total_kb - stats.free_kb -
                            stats.buffers_kb - stats.cached_kb;
    double mem_usage_percent = 100.0 * used_kb / stats.total_kb;

    unsigned long swap_used_kb = stats.swap_total_kb - stats.swap_free_kb;
    double swap_usage_percent = (stats.swap_total_kb > 0) ?
                                100.0 * swap_used_kb / stats.swap_total_kb : 0.0;

    // Affichage
    printf("M√©moire Totale:     %lu MB\n", stats.total_kb / 1024);
    printf("M√©moire Utilis√©e:   %lu MB (%.2f%%)\n",
           used_kb / 1024, mem_usage_percent);
    printf("M√©moire Disponible: %lu MB\n", stats.available_kb / 1024);
    printf("Swap Total:         %lu MB\n", stats.swap_total_kb / 1024);
    printf("Swap Utilis√©:       %lu MB (%.2f%%)\n",
           swap_used_kb / 1024, swap_usage_percent);
}
```

**Points importants :**
- `MemAvailable` est plus pertinent que `MemFree` (inclut la m√©moire r√©cup√©rable)
- La m√©moire utilis√©e r√©elle = Total - Free - Buffers - Cached
- Les valeurs sont en **kilooctets** (kB)

---

## Collecte des m√©triques Disque

### Comprendre `/proc/diskstats`

Le fichier `/proc/diskstats` contient les statistiques I/O pour chaque p√©riph√©rique.

**Format :**
```
  8       0 sda 123456 789 987654 1234 567890 4321 6543210 9876 0 5432 11110
```

**Colonnes principales (index√©es √† partir de 1) :**
- Col 3 : Nom du p√©riph√©rique
- Col 4 : Lectures compl√©t√©es
- Col 6 : Secteurs lus
- Col 8 : √âcritures compl√©t√©es
- Col 10 : Secteurs √©crits

### Exemple de code : Lecture des stats disque

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    char device[32];
    unsigned long reads_completed;
    unsigned long sectors_read;
    unsigned long writes_completed;
    unsigned long sectors_written;
} disk_stats_t;

int read_disk_stats(const char *device_name, disk_stats_t *stats) {
    FILE *fp = fopen("/proc/diskstats", "r");
    if (fp == NULL) {
        perror("Erreur ouverture /proc/diskstats");
        return -1;
    }

    char line[256];
    int found = 0;

    while (fgets(line, sizeof(line), fp) != NULL) {
        int major, minor;
        char device[32];
        unsigned long reads, reads_merged, sectors_read, ms_reading;
        unsigned long writes, writes_merged, sectors_written, ms_writing;
        unsigned long io_in_progress, ms_io, weighted_ms_io;

        // Parser la ligne compl√®te
        int parsed = sscanf(line, "%d %d %31s %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu",
                           &major, &minor, device,
                           &reads, &reads_merged, &sectors_read, &ms_reading,
                           &writes, &writes_merged, &sectors_written, &ms_writing,
                           &io_in_progress, &ms_io, &weighted_ms_io);

        if (parsed >= 14 && strcmp(device, device_name) == 0) {
            strncpy(stats->device, device, sizeof(stats->device) - 1);
            stats->reads_completed = reads;
            stats->sectors_read = sectors_read;
            stats->writes_completed = writes;
            stats->sectors_written = sectors_written;
            found = 1;
            break;
        }
    }

    fclose(fp);

    if (!found) {
        fprintf(stderr, "P√©riph√©rique %s non trouv√©\n", device_name);
        return -1;
    }

    return 0;
}

void monitor_disk(const char *device) {
    disk_stats_t prev_stats, curr_stats;

    // Premi√®re mesure
    if (read_disk_stats(device, &prev_stats) != 0) {
        return;
    }

    // Attendre 1 seconde
    sleep(1);

    // Deuxi√®me mesure
    if (read_disk_stats(device, &curr_stats) != 0) {
        return;
    }

    // Calculer les taux (par seconde)
    unsigned long reads_per_sec = curr_stats.reads_completed - prev_stats.reads_completed;
    unsigned long writes_per_sec = curr_stats.writes_completed - prev_stats.writes_completed;

    // 1 secteur = 512 octets g√©n√©ralement
    unsigned long bytes_read = (curr_stats.sectors_read - prev_stats.sectors_read) * 512;
    unsigned long bytes_written = (curr_stats.sectors_written - prev_stats.sectors_written) * 512;

    printf("Disque %s:\n", device);
    printf("  Lectures/s:  %lu (%.2f MB/s)\n",
           reads_per_sec, bytes_read / (1024.0 * 1024.0));
    printf("  √âcritures/s: %lu (%.2f MB/s)\n",
           writes_per_sec, bytes_written / (1024.0 * 1024.0));
}
```

---

## Collecte des m√©triques R√©seau

### Comprendre `/proc/net/dev`

Le fichier `/proc/net/dev` contient les statistiques r√©seau par interface.

**Format :**
```
Inter-|   Receive                                                |  Transmit
 face |bytes    packets errs drop fifo frame compressed multicast|bytes    packets errs drop fifo colls carrier compressed
    lo: 1234567    5678    0    0    0     0          0         0  1234567    5678    0    0    0     0       0          0
  eth0: 9876543  123456    0    0    0     0          0         0  5432109   98765    0    0    0     0       0          0
```

### Exemple de code : Lecture des stats r√©seau

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    char interface[32];
    unsigned long long rx_bytes;
    unsigned long long rx_packets;
    unsigned long long tx_bytes;
    unsigned long long tx_packets;
} network_stats_t;

int read_network_stats(const char *interface_name, network_stats_t *stats) {
    FILE *fp = fopen("/proc/net/dev", "r");
    if (fp == NULL) {
        perror("Erreur ouverture /proc/net/dev");
        return -1;
    }

    char line[512];
    int found = 0;

    // Ignorer les 2 premi√®res lignes (en-t√™tes)
    fgets(line, sizeof(line), fp);
    fgets(line, sizeof(line), fp);

    while (fgets(line, sizeof(line), fp) != NULL) {
        char interface[32];
        unsigned long long rx_bytes, rx_packets, rx_errs, rx_drop;
        unsigned long long tx_bytes, tx_packets, tx_errs, tx_drop;

        // Parser la ligne
        int parsed = sscanf(line, " %31[^:]: %llu %llu %llu %llu %*llu %*llu %*llu %*llu "
                                  "%llu %llu %llu %llu",
                           interface,
                           &rx_bytes, &rx_packets, &rx_errs, &rx_drop,
                           &tx_bytes, &tx_packets, &tx_errs, &tx_drop);

        if (parsed >= 9 && strcmp(interface, interface_name) == 0) {
            strncpy(stats->interface, interface, sizeof(stats->interface) - 1);
            stats->rx_bytes = rx_bytes;
            stats->rx_packets = rx_packets;
            stats->tx_bytes = tx_bytes;
            stats->tx_packets = tx_packets;
            found = 1;
            break;
        }
    }

    fclose(fp);

    if (!found) {
        fprintf(stderr, "Interface %s non trouv√©e\n", interface_name);
        return -1;
    }

    return 0;
}

void monitor_network(const char *interface) {
    network_stats_t prev_stats, curr_stats;

    // Premi√®re mesure
    if (read_network_stats(interface, &prev_stats) != 0) {
        return;
    }

    // Attendre 1 seconde
    sleep(1);

    // Deuxi√®me mesure
    if (read_network_stats(interface, &curr_stats) != 0) {
        return;
    }

    // Calculer les d√©bits
    unsigned long long rx_bytes_per_sec = curr_stats.rx_bytes - prev_stats.rx_bytes;
    unsigned long long tx_bytes_per_sec = curr_stats.tx_bytes - prev_stats.tx_bytes;

    printf("Interface %s:\n", interface);
    printf("  R√©ception:    %.2f MB/s (%llu paquets/s)\n",
           rx_bytes_per_sec / (1024.0 * 1024.0),
           curr_stats.rx_packets - prev_stats.rx_packets);
    printf("  Transmission: %.2f MB/s (%llu paquets/s)\n",
           tx_bytes_per_sec / (1024.0 * 1024.0),
           curr_stats.tx_packets - prev_stats.tx_packets);
}
```

---

## Utilisation de l'appel syst√®me `sysinfo()`

Pour certaines m√©triques globales, l'appel syst√®me `sysinfo()` est plus simple.

### Exemple avec sysinfo

```c
#include <sys/sysinfo.h>
#include <stdio.h>

void get_system_info(void) {
    struct sysinfo info;

    if (sysinfo(&info) != 0) {
        perror("sysinfo");
        return;
    }

    printf("Uptime:          %ld secondes (%ld jours)\n",
           info.uptime, info.uptime / 86400);
    printf("Load Average:    %.2f %.2f %.2f\n",
           info.loads[0] / 65536.0,
           info.loads[1] / 65536.0,
           info.loads[2] / 65536.0);
    printf("RAM Totale:      %lu MB\n",
           info.totalram / (1024 * 1024));
    printf("RAM Libre:       %lu MB\n",
           info.freeram / (1024 * 1024));
    printf("Processus:       %u\n", info.procs);
}
```

**Avantages de `sysinfo()` :**
- Un seul appel syst√®me
- Pas de parsing de fichiers
- Informations coh√©rentes au m√™me instant

**Limitations :**
- Moins de d√©tails que `/proc/meminfo`
- Pas d'acc√®s aux m√©triques par p√©riph√©rique

---

## Structure d'un collecteur de m√©triques

### Organisation modulaire

Un bon agent de monitoring s√©pare les responsabilit√©s :

```c
// metrics.h - Interface de collecte
typedef struct {
    double cpu_usage_percent;
    unsigned long memory_used_kb;
    unsigned long memory_total_kb;
    double memory_usage_percent;
    // ... autres m√©triques
} system_metrics_t;

int collect_all_metrics(system_metrics_t *metrics);

// metrics.c - Impl√©mentation
int collect_all_metrics(system_metrics_t *metrics) {
    cpu_stats_t prev_cpu, curr_cpu;
    memory_stats_t mem_stats;

    // Collecter CPU
    if (read_cpu_stats(&prev_cpu) != 0) return -1;
    sleep(1);
    if (read_cpu_stats(&curr_cpu) != 0) return -1;
    metrics->cpu_usage_percent = calculate_cpu_usage(&prev_cpu, &curr_cpu);

    // Collecter M√©moire
    if (read_memory_stats(&mem_stats) != 0) return -1;
    metrics->memory_total_kb = mem_stats.total_kb;
    metrics->memory_used_kb = mem_stats.total_kb - mem_stats.available_kb;
    metrics->memory_usage_percent = 100.0 * metrics->memory_used_kb /
                                    metrics->memory_total_kb;

    // ... autres m√©triques

    return 0;
}
```

---

## Bonnes pratiques de collecte

### 1. Gestion des erreurs
Toujours v√©rifier les retours des fonctions :

```c
if (read_cpu_stats(&stats) != 0) {
    // Log l'erreur, retourner une valeur par d√©faut, ou arr√™ter
    fprintf(stderr, "Impossible de lire les stats CPU\n");
    return -1;
}
```

### 2. √âviter les fuites de descripteurs
Toujours fermer les fichiers, m√™me en cas d'erreur :

```c
FILE *fp = fopen("/proc/stat", "r");
if (fp == NULL) {
    return -1;
}

// ... traitement ...

fclose(fp);  // Ne pas oublier !
```

Ou mieux, utiliser un pattern de nettoyage syst√©matique :

```c
int read_cpu_stats(cpu_stats_t *stats) {
    FILE *fp = NULL;
    int result = -1;
    char buffer[256];

    fp = fopen("/proc/stat", "r");
    if (fp == NULL) {
        goto cleanup;
    }

    if (fgets(buffer, sizeof(buffer), fp) == NULL) {
        goto cleanup;
    }

    // ... parsing ...

    result = 0;  // Succ√®s

cleanup:
    if (fp != NULL) {
        fclose(fp);
    }
    return result;
}
```

### 3. Buffer sizing
Utiliser des buffers suffisamment grands pour √©viter les d√©passements :

```c
char line[512];  // Suffisant pour /proc/net/dev
char buffer[4096];  // Pour fichiers plus grands
```

### 4. Validation des donn√©es
V√©rifier que les valeurs lues sont coh√©rentes :

```c
if (stats->total_kb == 0) {
    fprintf(stderr, "Valeur invalide pour MemTotal\n");
    return -1;
}
```

### 5. √âchantillonnage temporel
Pour les m√©triques bas√©es sur des diff√©rences (CPU, r√©seau, disque) :
- Utiliser un intervalle constant (ex: 1 seconde)
- Stocker la mesure pr√©c√©dente
- Calculer le delta

```c
typedef struct {
    cpu_stats_t prev_cpu;
    network_stats_t prev_net;
    time_t last_sample_time;
} metrics_state_t;

void update_metrics(metrics_state_t *state, system_metrics_t *metrics) {
    cpu_stats_t curr_cpu;

    read_cpu_stats(&curr_cpu);
    metrics->cpu_usage = calculate_cpu_usage(&state->prev_cpu, &curr_cpu);

    // Sauvegarder pour la prochaine fois
    state->prev_cpu = curr_cpu;
    state->last_sample_time = time(NULL);
}
```

---

## Optimisations

### 1. Mise en cache des fichiers ouverts
Pour des lectures fr√©quentes, garder les descripteurs ouverts :

```c
static FILE *stat_fp = NULL;

int read_cpu_stats_cached(cpu_stats_t *stats) {
    if (stat_fp == NULL) {
        stat_fp = fopen("/proc/stat", "r");
        if (stat_fp == NULL) return -1;
    }

    // Revenir au d√©but du fichier
    rewind(stat_fp);

    // ... lecture ...
}

void cleanup_cached_files(void) {
    if (stat_fp != NULL) {
        fclose(stat_fp);
        stat_fp = NULL;
    }
}
```

**Attention :** Cela fonctionne pour `/proc` car les fichiers sont dynamiques.

### 2. √âviter les allocations inutiles
R√©utiliser les structures :

```c
// ‚ùå Mauvais : allocation r√©p√©t√©e
cpu_stats_t *stats = malloc(sizeof(cpu_stats_t));
// ... utilisation ...
free(stats);

// ‚úÖ Bon : allocation unique
static cpu_stats_t stats;
read_cpu_stats(&stats);
```

### 3. Lecture en bloc
Pour de gros fichiers, lire en une seule fois :

```c
char buffer[4096];
size_t bytes_read = fread(buffer, 1, sizeof(buffer) - 1, fp);
buffer[bytes_read] = '\0';
// Parser le buffer en m√©moire
```

---

## Cas d'usage avanc√©s

### Collecte par c≈ìur CPU

Pour monitorer chaque c≈ìur individuellement :

```c
typedef struct {
    int core_id;
    cpu_stats_t stats;
} per_core_stats_t;

int read_per_core_stats(per_core_stats_t *cores, int max_cores, int *num_cores) {
    FILE *fp = fopen("/proc/stat", "r");
    if (fp == NULL) return -1;

    char line[256];
    *num_cores = 0;

    // Ignorer la ligne "cpu" globale
    fgets(line, sizeof(line), fp);

    // Lire chaque ligne "cpuN"
    while (fgets(line, sizeof(line), fp) != NULL && *num_cores < max_cores) {
        if (strncmp(line, "cpu", 3) != 0) break;
        if (line[3] < '0' || line[3] > '9') continue;  // Pas cpuX

        int core_id;
        cpu_stats_t *stats = &cores[*num_cores].stats;

        int parsed = sscanf(line, "cpu%d %llu %llu %llu %llu %llu %llu %llu %llu",
                           &core_id,
                           &stats->user, &stats->nice, &stats->system, &stats->idle,
                           &stats->iowait, &stats->irq, &stats->softirq, &stats->steal);

        if (parsed >= 9) {
            cores[*num_cores].core_id = core_id;
            (*num_cores)++;
        }
    }

    fclose(fp);
    return 0;
}
```

### Collecte des m√©triques r√©seau pour toutes les interfaces

```c
typedef struct {
    char interface[32];
    network_stats_t stats;
} interface_stats_t;

int read_all_interfaces(interface_stats_t *interfaces, int max_interfaces,
                       int *num_interfaces) {
    FILE *fp = fopen("/proc/net/dev", "r");
    if (fp == NULL) return -1;

    char line[512];
    *num_interfaces = 0;

    // Ignorer les 2 lignes d'en-t√™te
    fgets(line, sizeof(line), fp);
    fgets(line, sizeof(line), fp);

    while (fgets(line, sizeof(line), fp) != NULL &&
           *num_interfaces < max_interfaces) {
        network_stats_t *stats = &interfaces[*num_interfaces].stats;
        char *interface = interfaces[*num_interfaces].interface;

        int parsed = sscanf(line, " %31[^:]: %llu %llu %*u %*u %*u %*u %*u %*u "
                                  "%llu %llu",
                           interface,
                           &stats->rx_bytes, &stats->rx_packets,
                           &stats->tx_bytes, &stats->tx_packets);

        if (parsed >= 5) {
            (*num_interfaces)++;
        }
    }

    fclose(fp);
    return 0;
}
```

---

## R√©sum√©

La collecte de m√©triques syst√®me en C sur Linux repose sur :

1. **Lecture des pseudo-fichiers** (`/proc`, `/sys`)
   - Parsing de formats textuels simples
   - Gestion des erreurs d'ouverture/lecture

2. **Calculs de diff√©rences** pour les m√©triques dynamiques
   - Deux √©chantillons espac√©s dans le temps
   - Calcul de taux (par seconde)

3. **Appels syst√®me** pour certaines m√©triques
   - `sysinfo()` pour vue globale rapide
   - Compl√©mentaire aux fichiers `/proc`

4. **Bonnes pratiques**
   - Toujours fermer les descripteurs
   - Valider les donn√©es lues
   - Structurer le code de mani√®re modulaire
   - Optimiser pour les lectures fr√©quentes

Dans la prochaine section, nous verrons comment **exposer ces m√©triques au format Prometheus** pour int√©gration dans un √©cosyst√®me de monitoring moderne.

---

## R√©f√©rences

- **Documentation kernel Linux** : `/usr/src/linux/Documentation/filesystems/proc.txt`
- **Man pages** : `man 5 proc`
- **sysinfo** : `man 2 sysinfo`
- **Prometheus exposition format** : https://prometheus.io/docs/instrumenting/exposition_formats/

‚è≠Ô∏è [Export Prometheus](/34-etudes-cas-devops/03.2-export-prometheus.md)
