ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 21.5.1 Hello World : tracer les appels systÃ¨me

## Introduction

Bienvenue dans votre premier programme eBPF ! Dans cette section, nous allons crÃ©er un programme simple mais puissant qui trace les appels systÃ¨me `execve` sur votre systÃ¨me Linux. Cet appel systÃ¨me est utilisÃ© chaque fois qu'un nouveau programme est lancÃ©, ce qui en fait une cible idÃ©ale pour observer l'activitÃ© du systÃ¨me.

Ne vous inquiÃ©tez pas si eBPF vous semble intimidant au premier abord. Nous allons procÃ©der Ã©tape par Ã©tape, en expliquant chaque concept au fur et Ã  mesure.

## Qu'allons-nous construire ?

Notre programme eBPF va :
1. **S'attacher** Ã  l'appel systÃ¨me `execve` dans le noyau Linux
2. **Capturer** des informations chaque fois qu'un programme est lancÃ©
3. **Afficher** le nom du programme et l'utilisateur qui l'a lancÃ©

C'est l'Ã©quivalent d'un "Hello World" dans le monde eBPF : simple, mais qui dÃ©montre les concepts fondamentaux.

## PrÃ©requis

Avant de commencer, assurez-vous d'avoir installÃ© les outils nÃ©cessaires :

```bash
sudo apt update  
sudo apt install -y clang llvm libelf-dev libbpf-dev linux-headers-$(uname -r) bpftool  
```

## Architecture de notre programme

Un programme eBPF typique se compose de **deux parties** :

1. **Le programme kernel (eBPF)** : Code qui s'exÃ©cute dans le noyau Linux
2. **Le programme userspace (C)** : Code qui charge le programme eBPF et rÃ©cupÃ¨re les donnÃ©es

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     Programme Userspace (C)         â”‚
â”‚  - Charge le programme eBPF         â”‚
â”‚  - Lit les donnÃ©es des maps         â”‚
â”‚  - Affiche les rÃ©sultats            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚ libbpf
               â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Noyau Linux (Kernel)           â”‚
â”‚                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚  Programme eBPF           â”‚      â”‚
â”‚  â”‚  - AttachÃ© Ã  execve       â”‚      â”‚
â”‚  â”‚  - Capture les donnÃ©es    â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Partie 1 : Le programme eBPF (kernel)

CrÃ©ons d'abord le fichier `hello_bpf.bpf.c` :

```c
// hello_bpf.bpf.c
#include <linux/bpf.h>
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>

// DÃ©finition de la licence (obligatoire pour eBPF)
char LICENSE[] SEC("license") = "GPL";

// Section qui indique oÃ¹ attacher ce programme
// SEC("tp/syscalls/sys_enter_execve") signifie :
// - tp = tracepoint
// - syscalls = catÃ©gorie des appels systÃ¨me
// - sys_enter_execve = point d'entrÃ©e de l'appel execve
SEC("tp/syscalls/sys_enter_execve")  
int trace_execve(struct trace_event_raw_sys_enter *ctx)  
{
    // RÃ©cupÃ©rer l'ID du processus actuel
    __u64 pid_tgid = bpf_get_current_pid_tgid();
    __u32 pid = pid_tgid >> 32;  // Process ID
    __u32 tid = (__u32)pid_tgid;  // Thread ID

    // RÃ©cupÃ©rer l'UID (User ID) de l'utilisateur
    __u64 uid_gid = bpf_get_current_uid_gid();
    __u32 uid = uid_gid;

    // Buffer pour stocker le nom de la commande
    char comm[16];
    bpf_get_current_comm(&comm, sizeof(comm));

    // Afficher les informations via bpf_printk
    // (visible dans /sys/kernel/debug/tracing/trace_pipe)
    bpf_printk("Programme lancÃ© : %s (PID=%d, UID=%d)\n", comm, pid, uid);

    return 0;
}
```

### Explication ligne par ligne

**Les includes :**
```c
#include <linux/bpf.h>
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
```
Ces fichiers d'en-tÃªte fournissent les dÃ©finitions et fonctions nÃ©cessaires pour Ã©crire du code eBPF.

**La licence :**
```c
char LICENSE[] SEC("license") = "GPL";
```
eBPF nÃ©cessite que vous dÃ©clariez une licence GPL. C'est une exigence du noyau Linux pour des raisons de sÃ©curitÃ© et de compatibilitÃ©.

**La macro SEC() :**
```c
SEC("tp/syscalls/sys_enter_execve")
```
Cette macro indique **oÃ¹** attacher notre programme dans le noyau :
- `tp` = tracepoint (un point d'accroche prÃ©dÃ©fini dans le kernel)
- `syscalls` = catÃ©gorie des tracepoints liÃ©s aux appels systÃ¨me
- `sys_enter_execve` = le moment exact oÃ¹ l'appel systÃ¨me `execve` commence

**Les fonctions helper :**

eBPF fournit des fonctions "helper" qui sont les seules fonctions que vous pouvez appeler depuis le code kernel :

- `bpf_get_current_pid_tgid()` : RÃ©cupÃ¨re l'ID du processus et du thread
- `bpf_get_current_uid_gid()` : RÃ©cupÃ¨re l'ID de l'utilisateur et du groupe
- `bpf_get_current_comm()` : RÃ©cupÃ¨re le nom de la commande (limitÃ© Ã  16 caractÃ¨res)
- `bpf_printk()` : Affiche un message de debug (comme `printf` mais pour le kernel)

**Important :** Le code eBPF est trÃ¨s restreint. Vous ne pouvez pas :
- Utiliser de boucles non bornÃ©es
- Appeler des fonctions arbitraires
- AccÃ©der Ã  la mÃ©moire de maniÃ¨re non contrÃ´lÃ©e

Le verifier eBPF vÃ©rifie toutes ces contraintes avant de charger votre programme.

## Partie 2 : Le programme userspace (C)

CrÃ©ons maintenant le fichier `hello_bpf.c` qui va charger notre programme eBPF :

```c
// hello_bpf.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <bpf/libbpf.h>
#include "hello_bpf.skel.h"

// Variable globale pour gÃ©rer l'arrÃªt propre du programme
static volatile sig_atomic_t keep_running = 1;

// Gestionnaire de signal pour CTRL+C
static void sig_handler(int sig)
{
    keep_running = 0;
}

int main(int argc, char **argv)
{
    struct hello_bpf_bpf *skel;
    int err;

    // Activer le mode verbose de libbpf pour le dÃ©bogage
    libbpf_set_print(NULL);

    // Installer le gestionnaire de signal
    signal(SIGINT, sig_handler);
    signal(SIGTERM, sig_handler);

    printf("DÃ©marrage du traceur eBPF...\n");
    printf("Appuyez sur CTRL+C pour arrÃªter.\n\n");

    // 1. Ouvrir le fichier BPF (gÃ©nÃ©rÃ© par bpftool)
    skel = hello_bpf_bpf__open();
    if (!skel) {
        fprintf(stderr, "Erreur lors de l'ouverture du squelette BPF\n");
        return 1;
    }

    // 2. Charger et vÃ©rifier le programme BPF dans le kernel
    err = hello_bpf_bpf__load(skel);
    if (err) {
        fprintf(stderr, "Erreur lors du chargement du programme BPF : %d\n", err);
        goto cleanup;
    }

    // 3. Attacher le programme au tracepoint
    err = hello_bpf_bpf__attach(skel);
    if (err) {
        fprintf(stderr, "Erreur lors de l'attachement du programme : %d\n", err);
        goto cleanup;
    }

    printf("âœ“ Programme eBPF attachÃ© avec succÃ¨s !\n");
    printf("âœ“ TraÃ§age des appels systÃ¨me execve en cours...\n");
    printf("âœ“ Consultez /sys/kernel/debug/tracing/trace_pipe pour voir les traces\n\n");

    // Boucle principale : attendre que l'utilisateur arrÃªte le programme
    while (keep_running) {
        sleep(1);
    }

    printf("\n\nArrÃªt du traceur...\n");

cleanup:
    // 4. Nettoyer et dÃ©tacher le programme
    hello_bpf_bpf__destroy(skel);
    printf("Programme eBPF dÃ©tachÃ©. Au revoir !\n");

    return err != 0;
}
```

### Explication du code userspace

**Le fichier skeleton :**
```c
#include "hello_bpf.skel.h"
```
Ce fichier sera gÃ©nÃ©rÃ© automatiquement par `bpftool`. Il contient des structures et fonctions qui facilitent le chargement de votre programme eBPF.

**Les Ã©tapes de chargement :**

1. **Open** : `hello_bpf_bpf__open()`
   - Ouvre et parse le fichier objet eBPF

2. **Load** : `hello_bpf_bpf__load()`
   - Charge le programme dans le kernel
   - Le verifier vÃ©rifie que le code est sÃ»r

3. **Attach** : `hello_bpf_bpf__attach()`
   - Attache le programme au tracepoint spÃ©cifiÃ©

4. **Destroy** : `hello_bpf_bpf__destroy()`
   - DÃ©tache et nettoie tout

## Compilation et exÃ©cution

### Ã‰tape 1 : CrÃ©er le Makefile

CrÃ©ez un fichier `Makefile` pour automatiser la compilation :

```makefile
# Makefile
CLANG = clang  
BPFTOOL = bpftool  
CC = gcc  

# Flags de compilation
CFLAGS = -g -Wall  
BPF_CFLAGS = -g -O2 -target bpf -D__TARGET_ARCH_x86  

# Nom du programme
TARGET = hello_bpf  
BPF_OBJ = $(TARGET).bpf.o  
SKEL = $(TARGET).skel.h  

all: $(TARGET)

# Ã‰tape 1 : Compiler le code eBPF en objet BPF
$(BPF_OBJ): $(TARGET).bpf.c
	$(CLANG) $(BPF_CFLAGS) -c $< -o $@

# Ã‰tape 2 : GÃ©nÃ©rer le skeleton avec bpftool
$(SKEL): $(BPF_OBJ)
	$(BPFTOOL) gen skeleton $< > $@

# Ã‰tape 3 : Compiler le programme userspace
$(TARGET): $(SKEL) $(TARGET).c
	$(CC) $(CFLAGS) $(TARGET).c -o $@ -lbpf -lelf -lz

clean:
	rm -f $(TARGET) $(BPF_OBJ) $(SKEL)

.PHONY: all clean
```

### Ã‰tape 2 : Compiler

```bash
make
```

Vous devriez voir :
```
clang -g -O2 -target bpf -D__TARGET_ARCH_x86 -c hello_bpf.bpf.c -o hello_bpf.bpf.o  
bpftool gen skeleton hello_bpf.bpf.o > hello_bpf.skel.h  
gcc -g -Wall hello_bpf.c -o hello_bpf -lbpf -lelf -lz  
```

### Ã‰tape 3 : ExÃ©cuter (nÃ©cessite root)

Dans un premier terminal :
```bash
sudo ./hello_bpf
```

Vous verrez :
```
DÃ©marrage du traceur eBPF...  
Appuyez sur CTRL+C pour arrÃªter.  

âœ“ Programme eBPF attachÃ© avec succÃ¨s !
âœ“ TraÃ§age des appels systÃ¨me execve en cours...
âœ“ Consultez /sys/kernel/debug/tracing/trace_pipe pour voir les traces
```

### Ã‰tape 4 : Voir les traces

Dans un **second terminal**, consultez les traces en temps rÃ©el :

```bash
sudo cat /sys/kernel/debug/tracing/trace_pipe
```

Vous verrez des lignes comme :
```
          ls-32451 [003] .... 123456.789012: bpf_trace_printk: Programme lancÃ© : ls (PID=32451, UID=1000)
        bash-32452 [002] .... 123456.790123: bpf_trace_printk: Programme lancÃ© : bash (PID=32452, UID=1000)
       chrome-32453 [001] .... 123456.791234: bpf_trace_printk: Programme lancÃ© : chrome (PID=32453, UID=1000)
```

### Ã‰tape 5 : GÃ©nÃ©rer de l'activitÃ©

Dans un troisiÃ¨me terminal, lancez des commandes pour voir votre traceur en action :

```bash
ls -la  
pwd  
whoami  
date  
```

Chaque commande devrait apparaÃ®tre dans le `trace_pipe` !

## Comprendre ce qui se passe

Voici le flux complet :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Vous lancez une commande : ls -la                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Le shell appelle execve("/bin/ls", ["ls", "-la"], ...)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Le kernel Linux commence Ã  traiter l'appel systÃ¨me       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Le tracepoint sys_enter_execve est dÃ©clenchÃ©             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Votre programme eBPF s'exÃ©cute dans le kernel !          â”‚
â”‚ - RÃ©cupÃ¨re PID, UID, nom de la commande                  â”‚
â”‚ - Appelle bpf_printk()                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Le message apparaÃ®t dans trace_pipe                      â”‚
â”‚ Programme lancÃ© : ls (PID=..., UID=...)                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Le point crucial :** Tout cela se passe **sans modifier une seule ligne du kernel Linux** et **sans redÃ©marrer le systÃ¨me**. C'est la magie d'eBPF !

## Pourquoi est-ce rÃ©volutionnaire ?

Avant eBPF, pour tracer des appels systÃ¨me, vous deviez :
- Modifier le code source du kernel
- Recompiler le kernel
- RedÃ©marrer la machine
- EspÃ©rer ne pas avoir introduit de bug qui crashe tout

Avec eBPF :
- Vous Ã©crivez un petit programme
- Vous le chargez dynamiquement
- Le verifier garantit qu'il est sÃ»r
- Si vous l'arrÃªtez, tout redevient normal

## Limitations et points d'attention

### bpf_printk() n'est pas pour la production

`bpf_printk()` est pratique pour dÃ©boguer, mais :
- âŒ LimitÃ© Ã  3 arguments
- âŒ Performance mÃ©diocre
- âŒ Pas adaptÃ© pour de gros volumes de donnÃ©es

Pour la production, on utilise des **BPF maps** (nous verrons cela dans la section suivante 21.5.2).

### PrivilÃ¨ges root nÃ©cessaires

eBPF nÃ©cessite des privilÃ¨ges Ã©levÃ©s car il interagit avec le kernel. Vous devez exÃ©cuter votre programme avec `sudo`.

### Le code eBPF est restreint

Le verifier eBPF est trÃ¨s strict :
- Pas de boucles infinies
- Pas d'accÃ¨s mÃ©moire non vÃ©rifiÃ©
- Taille de programme limitÃ©e (historiquement 4096 instructions, augmentÃ© depuis)
- Pas d'appels de fonctions arbitraires

## Aller plus loin

### Voir tous les tracepoints disponibles

```bash
# Lister les catÃ©gories de tracepoints
ls /sys/kernel/debug/tracing/events/

# Lister les tracepoints d'une catÃ©gorie (ex: syscalls)
ls /sys/kernel/debug/tracing/events/syscalls/
```

### Tracer d'autres appels systÃ¨me

Pour tracer `openat` (ouverture de fichiers) :
```c
SEC("tp/syscalls/sys_enter_openat")
```

Pour tracer `write` (Ã©criture) :
```c
SEC("tp/syscalls/sys_enter_write")
```

### DÃ©boguer votre programme eBPF

Si le chargement Ã©choue, utilisez :
```bash
sudo bpftool prog load hello_bpf.bpf.o /sys/fs/bpf/hello
```

Le verifier vous donnera des dÃ©tails sur l'erreur.

### Inspecter les programmes chargÃ©s

```bash
# Lister tous les programmes eBPF actifs
sudo bpftool prog list

# Voir les dÃ©tails d'un programme
sudo bpftool prog show id <ID>

# Voir le code assemblÃ© (bytecode)
sudo bpftool prog dump xlated id <ID>
```

## RÃ©sumÃ©

FÃ©licitations ! Vous venez de crÃ©er votre premier programme eBPF qui :

- âœ… S'attache dynamiquement au kernel Linux
- âœ… Trace les appels systÃ¨me `execve` en temps rÃ©el
- âœ… Affiche le PID, l'UID et le nom des programmes lancÃ©s
- âœ… Fonctionne sans redÃ©marrage ni modification du kernel

**Ce que vous avez appris :**
- La structure d'un programme eBPF (kernel + userspace)
- Les helpers eBPF de base
- Comment compiler et charger un programme eBPF
- L'utilisation de `bpf_printk()` pour le dÃ©bogage
- Le concept de tracepoints

**Prochaine Ã©tape :** Dans la section 21.5.2, nous verrons comment utiliser les **BPF maps** pour communiquer efficacement entre le kernel et userspace, ce qui est la vraie maniÃ¨re de faire en production.

## Ressources complÃ©mentaires

- **Documentation officielle :** https://ebpf.io
- **Exemples libbpf :** https://github.com/libbpf/libbpf-bootstrap
- **RÃ©fÃ©rence des helpers :** https://man7.org/linux/man-pages/man7/bpf-helpers.7.html
- **Livre "Learning eBPF"** par Liz Rice (O'Reilly)

---

*Note : Ce tutoriel suppose un kernel Linux >= 5.8 et des outils rÃ©cents (libbpf >= 0.8). Sur des systÃ¨mes plus anciens, certains dÃ©tails peuvent diffÃ©rer.*

â­ï¸ [Utilisation de maps](/21-introduction-ebpf/05.2-utilisation-maps.md)
