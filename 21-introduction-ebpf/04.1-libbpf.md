üîù Retour au [Sommaire](/SOMMAIRE.md)

# 21.4.1 libbpf

## Introduction

**libbpf** est la biblioth√®que C officielle pour d√©velopper des applications eBPF modernes. Elle constitue la **fondation** sur laquelle sont construits la plupart des outils eBPF que vous utilisez aujourd'hui : Cilium, Falco, bpftrace, et bien d'autres.

Si vous voulez comprendre comment eBPF fonctionne r√©ellement "sous le capot", ou si vous souhaitez d√©velopper vos propres outils eBPF personnalis√©s, **libbpf est incontournable**.

---

## Qu'est-ce que libbpf ?

### D√©finition simple

**libbpf** est une biblioth√®que C qui simplifie le d√©veloppement d'applications eBPF en fournissant des fonctions de haut niveau pour :

1. **Charger** des programmes eBPF dans le kernel
2. **Attacher** ces programmes √† des points d'ancrage (hooks)
3. **Interagir** avec les BPF maps depuis l'userspace
4. **G√©rer** le cycle de vie des programmes eBPF

### Pourquoi libbpf existe

Sans libbpf, d√©velopper une application eBPF n√©cessiterait d'utiliser directement les **syscalls bas niveau** :

```c
// Sans libbpf : Code complexe et verbeux
int prog_fd = bpf(BPF_PROG_LOAD, &attr, sizeof(attr));  
int map_fd = bpf(BPF_MAP_CREATE, &map_attr, sizeof(map_attr));  
int link_fd = bpf(BPF_LINK_CREATE, &link_attr, sizeof(link_attr));  
// ... des dizaines de lignes de code r√©p√©titif
```

**Avec libbpf :**

```c
// Avec libbpf : Simple et lisible
struct bpf_object *obj = bpf_object__open_file("program.bpf.o", NULL);  
bpf_object__load(obj);  
struct bpf_link *link = bpf_program__attach(prog);  
```

**libbpf abstrait la complexit√©** tout en restant performant et flexible.

---

## L'√©volution de l'√©cosyst√®me eBPF

### Les trois g√©n√©rations d'outils eBPF

Pour comprendre la place de libbpf, il faut comprendre l'√©volution de l'√©cosyst√®me :

#### **G√©n√©ration 1 : Syscalls bruts (2014-2016)**

```c
// √âcrire directement dans le kernel via syscalls
struct bpf_insn prog[] = {
    BPF_MOV64_IMM(BPF_REG_0, 0),
    BPF_EXIT_INSN(),
};

union bpf_attr attr = {
    .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,
    .insns = ptr_to_u64(prog),
    .insn_cnt = sizeof(prog) / sizeof(prog[0]),
    // ... des dizaines de champs √† remplir
};

int fd = syscall(__NR_bpf, BPF_PROG_LOAD, &attr, sizeof(attr));
```

**Probl√®mes :**
- ‚ùå Extr√™mement verbeux
- ‚ùå Sujet aux erreurs
- ‚ùå Difficile √† maintenir
- ‚ùå Pas portable entre versions kernel

#### **G√©n√©ration 2 : BCC (2016-2020)**

BCC (BPF Compiler Collection) a r√©volutionn√© l'accessibilit√© d'eBPF en introduisant un **workflow Python + C** :

```python
# Programme BCC : Python + C inline
from bcc import BPF

# Code eBPF en C (compil√© √† la vol√©e)
prog = """  
int hello(void *ctx) {  
    bpf_trace_printk("Hello, eBPF!\\n");
    return 0;
}
"""

b = BPF(text=prog)  
b.attach_kprobe(event="sys_clone", fn_name="hello")  
b.trace_print()  
```

**Avantages :**
- ‚úÖ Tr√®s facile √† utiliser
- ‚úÖ Parfait pour le prototypage rapide
- ‚úÖ Compilation √† la vol√©e

**Probl√®mes :**
- ‚ùå **D√©pendance runtime lourde** : N√©cessite LLVM/Clang sur chaque machine
- ‚ùå **D√©marrage lent** : Compilation √† chaque ex√©cution (1-5 secondes)
- ‚ùå **Consommation m√©moire** : LLVM = 100+ MB de RAM
- ‚ùå **Pas portable** : Le binaire contient du code source C
- ‚ùå **Difficile √† distribuer** : Impossible de faire un binaire standalone

#### **G√©n√©ration 3 : libbpf + CO-RE (2020-aujourd'hui)**

libbpf avec **CO-RE** (Compile Once - Run Everywhere) repr√©sente l'approche moderne :

```c
// Programme eBPF moderne avec libbpf
#include <linux/bpf.h>
#include <bpf/bpf_helpers.h>

SEC("kprobe/sys_clone")  
int hello(struct pt_regs *ctx) {  
    bpf_printk("Hello, eBPF!\n");
    return 0;
}

char LICENSE[] SEC("license") = "GPL";
```

**Compilation (une fois) :**
```bash
clang -O2 -target bpf -c program.bpf.c -o program.bpf.o
```

**Chargement (userspace) :**
```c
struct bpf_object *obj = bpf_object__open_file("program.bpf.o", NULL);  
bpf_object__load(obj);  
// Attacher, utiliser...
```

**Avantages :**
- ‚úÖ **Binaire standalone** : Un seul fichier ex√©cutable
- ‚úÖ **Portable** : Fonctionne sur diff√©rentes versions kernel (CO-RE)
- ‚úÖ **D√©marrage instantan√©** : Pas de compilation runtime
- ‚úÖ **L√©ger** : Pas de d√©pendance LLVM/Clang en production
- ‚úÖ **Distribution facile** : apt install, docker, etc.

---

## Architecture d'une application libbpf

Une application eBPF moderne avec libbpf se compose de **deux parties** :

### 1. Le programme kernel (eBPF code)

**Fichier : `program.bpf.c`**

```c
#include <linux/bpf.h>
#include <bpf/bpf_helpers.h>

// D√©finir une BPF map
struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __type(key, __u32);
    __type(value, __u64);
    __uint(max_entries, 1024);
} counts SEC(".maps");

// Programme eBPF
SEC("kprobe/sys_execve")  
int trace_execve(struct pt_regs *ctx) {  
    __u32 pid = bpf_get_current_pid_tgid() >> 32;
    __u64 *count = bpf_map_lookup_elem(&counts, &pid);

    if (count) {
        (*count)++;
    } else {
        __u64 one = 1;
        bpf_map_update_elem(&counts, &pid, &one, BPF_ANY);
    }

    return 0;
}

char LICENSE[] SEC("license") = "GPL";
```

**Compilation :**
```bash
clang -O2 -target bpf -g -c program.bpf.c -o program.bpf.o
```

Cette compilation produit un **fichier objet ELF** contenant le bytecode eBPF.

### 2. Le loader userspace (C code)

**Fichier : `loader.c`**

```c
#include <stdio.h>
#include <unistd.h>
#include <bpf/libbpf.h>
#include <bpf/bpf.h>

int main(int argc, char **argv) {
    struct bpf_object *obj;
    struct bpf_program *prog;
    struct bpf_link *link;
    int map_fd;

    // 1. Ouvrir le fichier objet eBPF
    obj = bpf_object__open_file("program.bpf.o", NULL);
    if (!obj) {
        fprintf(stderr, "Failed to open BPF object\n");
        return 1;
    }

    // 2. Charger dans le kernel
    if (bpf_object__load(obj)) {
        fprintf(stderr, "Failed to load BPF object\n");
        return 1;
    }

    // 3. Trouver le programme
    prog = bpf_object__find_program_by_name(obj, "trace_execve");
    if (!prog) {
        fprintf(stderr, "Failed to find program\n");
        return 1;
    }

    // 4. Attacher au hook
    link = bpf_program__attach(prog);
    if (!link) {
        fprintf(stderr, "Failed to attach program\n");
        return 1;
    }

    printf("Successfully started! Press Ctrl-C to stop.\n");

    // 5. Obtenir le file descriptor de la map
    map_fd = bpf_object__find_map_fd_by_name(obj, "counts");

    // 6. Boucle principale : lire la map toutes les secondes
    while (1) {
        sleep(1);

        __u32 key, next_key;
        __u64 value;

        key = 0;
        while (bpf_map_get_next_key(map_fd, &key, &next_key) == 0) {
            bpf_map_lookup_elem(map_fd, &next_key, &value);
            printf("PID %u: %llu execve calls\n", next_key, value);
            key = next_key;
        }
    }

    // 7. Cleanup (jamais atteint ici, mais bonne pratique)
    bpf_link__destroy(link);
    bpf_object__close(obj);

    return 0;
}
```

**Compilation du loader :**
```bash
gcc -o loader loader.c -lbpf -lelf -lz
```

**Ex√©cution :**
```bash
sudo ./loader
```

---

## Les concepts cl√©s de libbpf

### 1. **bpf_object** : Conteneur du programme

Un **bpf_object** repr√©sente un fichier objet eBPF charg√© en m√©moire :

```c
struct bpf_object *obj;

// Ouvrir depuis un fichier
obj = bpf_object__open_file("program.bpf.o", NULL);

// Ou ouvrir depuis la m√©moire
obj = bpf_object__open_mem(buffer, size, NULL);

// Charger dans le kernel
bpf_object__load(obj);

// Cleanup
bpf_object__close(obj);
```

### 2. **bpf_program** : Un programme eBPF individuel

Un objet peut contenir **plusieurs programmes** :

```c
struct bpf_program *prog;

// Trouver par nom
prog = bpf_object__find_program_by_name(obj, "trace_execve");

// Ou it√©rer sur tous les programmes
bpf_object__for_each_program(prog, obj) {
    printf("Found program: %s\n", bpf_program__name(prog));
}

// Attacher
struct bpf_link *link = bpf_program__attach(prog);
```

### 3. **bpf_link** : Connexion au hook kernel

Un **bpf_link** repr√©sente l'attachement d'un programme √† un hook :

```c
struct bpf_link *link;

// Attacher (automatique selon la section SEC())
link = bpf_program__attach(prog);

// Ou attacher manuellement √† un kprobe
link = bpf_program__attach_kprobe(prog, false, "sys_execve");

// D√©tacher et lib√©rer
bpf_link__destroy(link);
```

**Important :** Tant que le `bpf_link` existe, le programme reste attach√©. Sa destruction d√©tache le programme.

### 4. **bpf_map** : Structures de donn√©es partag√©es

Les BPF maps permettent le partage de donn√©es entre kernel et userspace :

```c
int map_fd;

// Obtenir le file descriptor
map_fd = bpf_object__find_map_fd_by_name(obj, "counts");

// Op√©rations sur la map
__u32 key = 123;
__u64 value = 456;

// Insertion/mise √† jour
bpf_map_update_elem(map_fd, &key, &value, BPF_ANY);

// Lecture
bpf_map_lookup_elem(map_fd, &key, &value);

// Suppression
bpf_map_delete_elem(map_fd, &key);

// It√©ration
__u32 next_key;
while (bpf_map_get_next_key(map_fd, &key, &next_key) == 0) {
    // Traiter next_key
    key = next_key;
}
```

---

## CO-RE : Compile Once - Run Everywhere

### Le probl√®me de la portabilit√© kernel

Historiquement, un programme eBPF compil√© pour une version du kernel **ne fonctionnait pas** sur une autre version :

```
Programme compil√© pour kernel 5.10
                ‚Üì
        Fonctionne ? ‚ùå sur kernel 5.15
                      ‚ùå sur kernel 6.1
```

**Raison :** Les structures du kernel changent entre versions.

**Exemple :**

```c
// Kernel 5.10
struct task_struct {
    int pid;
    char comm[16];
    // ... 200 autres champs
};

// Kernel 5.15 : Champs r√©organis√©s !
struct task_struct {
    char comm[16];
    int pid;  // ‚Üê Position chang√©e !
    // ... champs diff√©rents
};
```

### La solution CO-RE

**CO-RE** (Compile Once - Run Everywhere) r√©sout ce probl√®me via trois composants :

#### 1. **BTF (BPF Type Format)**

BTF est un format qui d√©crit la structure des types du kernel :

```bash
# Voir les informations BTF du kernel
bpftool btf dump file /sys/kernel/btf/vmlinux | head -20

[1] INT 'int' size=4 bits_offset=0 nr_bits=32 encoding=SIGNED
[2] PTR '(anon)' type_id=1
[3] STRUCT 'task_struct' size=9472 vlen=232
    'pid' type_id=1 bits_offset=2560
    'comm' type_id=4 bits_offset=6912
    ...
```

Le kernel moderne (5.x+) embarque BTF, permettant √† libbpf de conna√Ætre la structure exacte des types.

#### 2. **Macros BPF_CORE_READ**

Ces macros g√©n√®rent du code qui s'adapte automatiquement :

```c
#include <bpf/bpf_core_read.h>

SEC("kprobe/sys_execve")  
int trace_execve(struct pt_regs *ctx) {  
    struct task_struct *task = (struct task_struct *)bpf_get_current_task();

    // Lecture portable avec CO-RE
    int pid = BPF_CORE_READ(task, pid);
    char comm[16];
    BPF_CORE_READ_STR_INTO(&comm, task, comm);

    bpf_printk("PID: %d, COMM: %s\n", pid, comm);
    return 0;
}
```

**BPF_CORE_READ** g√©n√®re du code qui :
1. Lit les informations BTF au chargement
2. Calcule les offsets corrects pour le kernel actuel
3. Ajuste les acc√®s m√©moire en cons√©quence

#### 3. **libbpf relocation**

√Ä l'ex√©cution, libbpf **relocate** les acc√®s :

```
Compilation (une fois) :
  program.bpf.c ‚Üí program.bpf.o (avec relocation info)

Chargement (runtime) :
  libbpf lit BTF du kernel actuel
         ‚Üì
  Calcule les offsets corrects
         ‚Üì
  Applique les relocations
         ‚Üì
  Charge le programme modifi√© dans le kernel
```

### Exemple concret CO-RE

**Code source (portable) :**

```c
#include <vmlinux.h>  // Types kernel g√©n√©r√©s depuis BTF
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_core_read.h>

SEC("tp/sched/sched_process_exec")  
int handle_exec(struct trace_event_raw_sched_process_exec *ctx) {  
    struct task_struct *task = (struct task_struct *)bpf_get_current_task();

    // Lecture CO-RE : portable entre versions kernel
    pid_t pid = BPF_CORE_READ(task, pid);
    pid_t tgid = BPF_CORE_READ(task, tgid);

    char comm[16];
    bpf_probe_read_kernel_str(&comm, sizeof(comm), &task->comm);

    bpf_printk("Exec: PID=%d, TGID=%d, COMM=%s\n", pid, tgid, comm);
    return 0;
}

char LICENSE[] SEC("license") = "GPL";
```

**Compilation (une fois) :**
```bash
clang -O2 -target bpf -g -c program.bpf.c -o program.bpf.o
```

**Utilisation (partout) :**
- ‚úÖ Kernel 5.10
- ‚úÖ Kernel 5.15
- ‚úÖ Kernel 6.1
- ‚úÖ Kernel avec config custom

---

## libbpf vs BCC : Comparaison d√©taill√©e

| Aspect | BCC | libbpf + CO-RE |
|--------|-----|----------------|
| **Langage** | Python + C inline | C pur |
| **Compilation** | Runtime (√† chaque lancement) | Compile-time (une fois) |
| **D√©marrage** | 1-5 secondes | < 50 ms |
| **D√©pendances runtime** | LLVM/Clang (100+ MB) | libbpf (< 1 MB) |
| **Consommation RAM** | 100-200 MB | < 5 MB |
| **Distribution** | Source code n√©cessaire | Binaire standalone |
| **Portabilit√© kernel** | Limit√©e | Excellente (CO-RE) |
| **Performance** | Bonne | Excellente |
| **Facilit√© d'utilisation** | ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ (tr√®s facile) | ‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ (courbe d'apprentissage) |
| **Cas d'usage id√©al** | Prototypage, scripts | Production, outils durables |

### Quand utiliser BCC

- ‚úÖ **Prototypage rapide** : Tester une id√©e en 5 minutes
- ‚úÖ **Scripts one-shot** : Debugging ponctuel
- ‚úÖ **Environnement dev** : O√π LLVM est d√©j√† install√©
- ‚úÖ **Apprentissage** : Commencer avec eBPF facilement

### Quand utiliser libbpf

- ‚úÖ **Applications production** : Outils d√©ploy√©s en prod
- ‚úÖ **Distribution publique** : apt/yum packages, containers
- ‚úÖ **Performance critique** : D√©marrage rapide requis
- ‚úÖ **Syst√®mes embarqu√©s** : Ressources limit√©es
- ‚úÖ **Outils syst√®me** : Int√©gration dans l'OS

---

## Installation et setup

### 1. Installation des d√©pendances

**Ubuntu/Debian :**
```bash
# Biblioth√®ques de d√©veloppement
sudo apt update  
sudo apt install -y \  
    clang \
    llvm \
    libelf-dev \
    libbpf-dev \
    linux-headers-$(uname -r) \
    build-essential

# Version kernel minimale recommand√©e : 5.4+
uname -r
```

**Fedora/RHEL :**
```bash
sudo dnf install -y \
    clang \
    llvm \
    elfutils-libelf-devel \
    libbpf-devel \
    kernel-devel
```

### 2. V√©rifier l'installation

```bash
# V√©rifier libbpf
pkg-config --modversion libbpf
# Sortie attendue : 1.0.0 ou sup√©rieur

# V√©rifier clang avec support BPF
clang -target bpf -v 2>&1 | grep bpf
# Doit afficher : Target: bpf
```

### 3. G√©n√©rer vmlinux.h

**vmlinux.h** contient toutes les d√©finitions de types du kernel :

```bash
# G√©n√©rer depuis le kernel actuel
bpftool btf dump file /sys/kernel/btf/vmlinux format c > vmlinux.h

# Ou t√©l√©charger depuis un repository
wget https://raw.githubusercontent.com/libbpf/libbpf-bootstrap/master/examples/c/vmlinux.h
```

Ce fichier remplace tous les headers kernel (`<linux/*.h>`).

---

## Structure d'un projet libbpf moderne

### Arborescence recommand√©e

```
my-ebpf-tool/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ program.bpf.c        # Code kernel eBPF
‚îÇ   ‚îî‚îÄ‚îÄ loader.c             # Code userspace
‚îú‚îÄ‚îÄ include/
‚îÇ   ‚îî‚îÄ‚îÄ vmlinux.h            # Types kernel
‚îú‚îÄ‚îÄ Makefile                 # Build system
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ .gitignore
```

### Makefile complet

```makefile
# Makefile pour projet libbpf

CLANG := clang  
LLC := llc  
BPFTOOL := bpftool  

# Flags de compilation eBPF
BPF_CFLAGS := -O2 -target bpf -g -I./include  
BPF_SOURCE := src/program.bpf.c  
BPF_OBJECT := program.bpf.o  

# Flags de compilation userspace
USER_CFLAGS := -Wall -O2  
USER_SOURCE := src/loader.c  
USER_BINARY := my-tool  
USER_LIBS := -lbpf -lelf -lz  

all: $(BPF_OBJECT) $(USER_BINARY)

# Compiler le programme eBPF
$(BPF_OBJECT): $(BPF_SOURCE)
	$(CLANG) $(BPF_CFLAGS) -c $< -o $@

# Compiler le loader userspace
$(USER_BINARY): $(USER_SOURCE) $(BPF_OBJECT)
	gcc $(USER_CFLAGS) $< -o $@ $(USER_LIBS)

clean:
	rm -f $(BPF_OBJECT) $(USER_BINARY)

install:
	sudo cp $(USER_BINARY) /usr/local/bin/

.PHONY: all clean install
```

### Build et ex√©cution

```bash
# Compiler
make

# Ex√©cuter (n√©cessite root)
sudo ./my-tool

# Installer syst√®me
sudo make install
```

---

## Exemple complet : Tracer les ouvertures de fichiers

### Code kernel : `opensnoop.bpf.c`

```c
#include "vmlinux.h"
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include <bpf/bpf_core_read.h>

// Structure pour les √©v√©nements
struct event {
    u32 pid;
    u32 uid;
    int ret;
    char comm[16];
    char filename[256];
};

// Ringbuffer pour communiquer avec l'userspace
struct {
    __uint(type, BPF_MAP_TYPE_RINGBUF);
    __uint(max_entries, 256 * 1024);
} events SEC(".maps");

// Map temporaire pour stocker les arguments
struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __type(key, u32);
    __type(value, const char *);
    __uint(max_entries, 10240);
} tmp_filename SEC(".maps");

// Hook √† l'entr√©e de sys_openat
SEC("tracepoint/syscalls/sys_enter_openat")  
int trace_enter_openat(struct trace_event_raw_sys_enter *ctx) {  
    u64 id = bpf_get_current_pid_tgid();
    u32 pid = id >> 32;

    // Sauvegarder le pointeur vers le filename
    const char *filename = (const char *)ctx->args[1];
    bpf_map_update_elem(&tmp_filename, &pid, &filename, BPF_ANY);

    return 0;
}

// Hook √† la sortie de sys_openat
SEC("tracepoint/syscalls/sys_exit_openat")  
int trace_exit_openat(struct trace_event_raw_sys_exit *ctx) {  
    u64 id = bpf_get_current_pid_tgid();
    u32 pid = id >> 32;
    u32 uid = bpf_get_current_uid_gid();

    // R√©cup√©rer le filename sauvegard√©
    const char **filename_ptr = bpf_map_lookup_elem(&tmp_filename, &pid);
    if (!filename_ptr)
        return 0;

    // R√©server de l'espace dans le ringbuffer
    struct event *e = bpf_ringbuf_reserve(&events, sizeof(*e), 0);
    if (!e)
        goto cleanup;

    // Remplir l'√©v√©nement
    e->pid = pid;
    e->uid = uid;
    e->ret = ctx->ret;

    bpf_get_current_comm(&e->comm, sizeof(e->comm));
    bpf_probe_read_user_str(&e->filename, sizeof(e->filename), *filename_ptr);

    // Soumettre l'√©v√©nement
    bpf_ringbuf_submit(e, 0);

cleanup:
    bpf_map_delete_elem(&tmp_filename, &pid);
    return 0;
}

char LICENSE[] SEC("license") = "GPL";
```

### Code userspace : `opensnoop.c`

```c
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <string.h>
#include <errno.h>
#include <sys/resource.h>
#include <bpf/libbpf.h>
#include <bpf/bpf.h>

// Structure identique au code kernel
struct event {
    unsigned int pid;
    unsigned int uid;
    int ret;
    char comm[16];
    char filename[256];
};

static volatile bool exiting = false;

static void sig_handler(int sig) {
    exiting = true;
}

// Callback pour traiter les √©v√©nements du ringbuffer
static int handle_event(void *ctx, void *data, size_t data_sz) {
    const struct event *e = data;

    printf("%-6d %-6d %-16s %-4d %s\n",
           e->pid, e->uid, e->comm, e->ret, e->filename);

    return 0;
}

int main(int argc, char **argv) {
    struct bpf_object *obj;
    struct ring_buffer *rb = NULL;
    int err;

    // Augmenter la limite de m√©moire verrouill√©e
    struct rlimit rlim = {
        .rlim_cur = RLIM_INFINITY,
        .rlim_max = RLIM_INFINITY,
    };
    setrlimit(RLIMIT_MEMLOCK, &rlim);

    // G√©rer Ctrl-C proprement
    signal(SIGINT, sig_handler);
    signal(SIGTERM, sig_handler);

    // Ouvrir et charger le programme eBPF
    obj = bpf_object__open_file("opensnoop.bpf.o", NULL);
    if (!obj) {
        fprintf(stderr, "Failed to open BPF object\n");
        return 1;
    }

    err = bpf_object__load(obj);
    if (err) {
        fprintf(stderr, "Failed to load BPF object: %d\n", err);
        goto cleanup;
    }

    // Attacher tous les programmes
    struct bpf_program *prog;
    bpf_object__for_each_program(prog, obj) {
        struct bpf_link *link = bpf_program__attach(prog);
        if (!link) {
            fprintf(stderr, "Failed to attach: %s\n", bpf_program__name(prog));
            err = -1;
            goto cleanup;
        }
    }

    // Cr√©er le ringbuffer reader
    int map_fd = bpf_object__find_map_fd_by_name(obj, "events");
    rb = ring_buffer__new(map_fd, handle_event, NULL, NULL);
    if (!rb) {
        fprintf(stderr, "Failed to create ring buffer\n");
        goto cleanup;
    }

    printf("%-6s %-6s %-16s %-4s %s\n",
           "PID", "UID", "COMM", "RET", "FILENAME");

    // Boucle principale
    while (!exiting) {
        err = ring_buffer__poll(rb, 100 /* timeout ms */);
        if (err == -EINTR) {
            err = 0;
            break;
        }
        if (err < 0) {
            fprintf(stderr, "Error polling ring buffer: %d\n", err);
            break;
        }
    }

cleanup:
    ring_buffer__free(rb);
    bpf_object__close(obj);
    return err != 0;
}
```

### Compilation et ex√©cution

```bash
# Compiler le programme eBPF
clang -O2 -target bpf -g -I. -c opensnoop.bpf.c -o opensnoop.bpf.o

# Compiler le loader userspace
gcc -Wall -O2 opensnoop.c -o opensnoop -lbpf -lelf -lz

# Ex√©cuter
sudo ./opensnoop
```

**Sortie exemple :**

```
PID    UID    COMM             RET  FILENAME
1234   1000   bash             3    /etc/bash_completion
5678   0      systemd          4    /proc/1/cgroup
9012   1000   code             5    /home/user/.vscode/settings.json
3456   33     www-data         -2   /var/www/.htaccess
```

---

## Fonctionnalit√©s avanc√©es de libbpf

### 1. **Skeleton : G√©n√©ration automatique de code**

libbpf peut g√©n√©rer du code C qui simplifie encore plus l'utilisation :

```bash
# G√©n√©rer le skeleton
bpftool gen skeleton opensnoop.bpf.o > opensnoop.skel.h
```

**Utilisation du skeleton :**

```c
#include "opensnoop.skel.h"

int main() {
    struct opensnoop_bpf *skel;

    // Ouvrir, charger, attacher en UNE ligne
    skel = opensnoop_bpf__open_and_load();
    if (!skel) {
        fprintf(stderr, "Failed to load skeleton\n");
        return 1;
    }

    // Attacher automatiquement
    opensnoop_bpf__attach(skel);

    // Acc√®s direct aux maps
    int map_fd = bpf_map__fd(skel->maps.events);

    // ...

    // Cleanup automatique
    opensnoop_bpf__destroy(skel);
    return 0;
}
```

**Avantages :**
- Code plus compact
- Type-safe (v√©rifications √† la compilation)
- Pas de recherche manuelle de maps/programmes

### 2. **Global variables**

libbpf supporte les variables globales pour la configuration :

```c
// Dans le code eBPF
const volatile bool filter_failed = false;  
const volatile int min_duration_ns = 0;  

SEC("tracepoint/...")  
int trace_something(struct trace_event_raw_sys_enter *ctx) {  
    if (filter_failed && ret >= 0)
        return 0;  // Skip successful operations

    // ...
}
```

**Configuration depuis l'userspace :**

```c
// Avant le load
skel->rodata->filter_failed = true;  
skel->rodata->min_duration_ns = 1000000;  // 1ms  

opensnoop_bpf__load(skel);
```

### 3. **BPF Iterators**

Les iterators permettent de parcourir des structures kernel :

```c
SEC("iter/task")  
int dump_task(struct bpf_iter__task *ctx) {  
    struct task_struct *task = ctx->task;

    if (!task)
        return 0;

    BPF_SEQ_PRINTF(ctx->meta->seq, "PID: %d, COMM: %s\n",
               task->pid, task->comm);

    return 0;
}
```

---

## Debugging et bonnes pratiques

### 1. **Debugging avec bpf_printk**

```c
// Dans le code eBPF
bpf_printk("Debug: pid=%d, value=%llu\n", pid, value);
```

**Lecture des logs :**
```bash
sudo cat /sys/kernel/debug/tracing/trace_pipe
```

### 2. **V√©rifier les erreurs de chargement**

```c
struct bpf_object *obj = bpf_object__open_file("prog.bpf.o", NULL);  
if (libbpf_get_error(obj)) {  
    fprintf(stderr, "Failed to open: %s\n", strerror(errno));
    return 1;
}
```

### 3. **Activer les logs libbpf**

```c
// Au d√©but du main()
libbpf_set_print(libbpf_print_fn);

static int libbpf_print_fn(enum libbpf_print_level level,
                           const char *format, va_list args) {
    return vfprintf(stderr, format, args);
}
```

### 4. **V√©rifier la compatibilit√© BTF**

```bash
# V√©rifier si le kernel supporte BTF
ls /sys/kernel/btf/vmlinux

# Voir les informations BTF d'un objet
llvm-objdump -h program.bpf.o | grep BTF
```

---

## Ressources et documentation

### Documentation officielle

- **libbpf GitHub** : https://github.com/libbpf/libbpf
- **libbpf API docs** : https://libbpf.readthedocs.io/
- **libbpf-bootstrap** : https://github.com/libbpf/libbpf-bootstrap (templates de projets)

### Exemples de code

- **BCC libbpf tools** : https://github.com/iovisor/bcc/tree/master/libbpf-tools
  - Versions libbpf des outils BCC populaires
  - Excellents exemples pour apprendre

### Tutoriels

- **"BPF CO-RE (Compile Once ‚Äì Run Everywhere)"** par Andrii Nakryiko : https://nakryiko.com/posts/bpf-portability-and-co-re/
- **Kernel documentation** : https://www.kernel.org/doc/html/latest/bpf/

---

## Conclusion

**libbpf** est la fondation moderne du d√©veloppement eBPF. En tant qu'ing√©nieur syst√®me ou DevOps, ma√Ætriser libbpf vous permet de :

- ‚úÖ **D√©velopper des outils eBPF production-ready** avec binaires standalone
- ‚úÖ **Cr√©er des applications portables** gr√¢ce √† CO-RE
- ‚úÖ **Obtenir des performances optimales** (d√©marrage instantan√©, overhead minimal)
- ‚úÖ **Distribuer facilement** via packages syst√®me ou containers
- ‚úÖ **Comprendre** comment fonctionnent les outils eBPF sous le capot

Bien que la courbe d'apprentissage soit plus raide que BCC, libbpf est l'approche recommand√©e pour tout projet s√©rieux. C'est la technologie utilis√©e par **Cilium, Falco, et tous les outils eBPF modernes**.

Dans la section suivante (21.4.2), nous explorerons **bpftool**, l'outil en ligne de commande essentiel pour inspecter, debugger, et g√©rer les programmes eBPF.

---

**üí° √Ä retenir :**
- libbpf est la biblioth√®que C officielle pour eBPF moderne
- CO-RE permet la portabilit√© entre versions kernel (Compile Once, Run Everywhere)
- Les applications libbpf sont des binaires standalone (pas de d√©pendance LLVM/Clang)
- Structure en 2 parties : code kernel (.bpf.c) + loader userspace (.c)
- Plus complexe que BCC mais meilleur pour la production
- Utilis√© par tous les outils eBPF professionnels modernes

---

‚è≠Ô∏è [bpftool](/21-introduction-ebpf/04.2-bpftool.md)
