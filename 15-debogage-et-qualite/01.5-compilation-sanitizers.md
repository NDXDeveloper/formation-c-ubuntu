üîù Retour au [Sommaire](/SOMMAIRE.md)

# 15.1.5 Compilation avec sanitizers

## Introduction

Apr√®s avoir d√©couvert les diff√©rents sanitizers (ASan, UBSan, TSan, LSan), il est temps de ma√Ætriser leur **compilation** et leur **int√©gration** dans votre workflow de d√©veloppement. Cette section vous guide √† travers toutes les options de compilation, les combinaisons possibles, et les bonnes pratiques.

### Pourquoi une section d√©di√©e √† la compilation ?

Compiler correctement avec les sanitizers est crucial car :
- üéØ **Mauvaises options** = D√©tection incompl√®te ou faux positifs
- ‚ö° **Bonnes options** = D√©tection optimale avec overhead acceptable
- üîß **Combinaisons** = Certains sanitizers sont compatibles, d'autres non
- üìä **Optimisation** = Balance entre vitesse et pr√©cision

**Objectif :** Vous donner les commandes exactes et les configurations pour chaque situation.

---

## R√©capitulatif des sanitizers

### Vue d'ensemble

| Sanitizer | Flag | D√©tecte | Compatible avec |
|-----------|------|---------|----------------|
| **ASan** | `-fsanitize=address` | Erreurs m√©moire | UBSan, LSan |
| **UBSan** | `-fsanitize=undefined` | Comportements ind√©finis | ASan, LSan |
| **TSan** | `-fsanitize=thread` | Race conditions | Aucun sanitizer |
| **LSan** | `-fsanitize=leak` | Fuites m√©moire | ASan, UBSan |

### R√®gles de compatibilit√©

**‚úÖ Compatibles ensemble :**
- ASan + UBSan
- ASan + LSan (LSan est inclus par d√©faut dans ASan)
- UBSan + LSan

**‚ùå Incompatibles :**
- TSan + ASan
- TSan + UBSan
- TSan + LSan

**R√®gle simple :** TSan doit toujours √™tre utilis√© **seul**.

---

## Compilation de base avec chaque sanitizer

### AddressSanitizer (ASan)

**Commande minimale :**
```bash
gcc -fsanitize=address -g -o prog prog.c
```

**Commande recommand√©e :**
```bash
gcc -fsanitize=address -g -O1 -fno-omit-frame-pointer -o prog prog.c
```

**Options expliqu√©es :**
- `-fsanitize=address` : Active AddressSanitizer
- `-g` : Symboles de d√©bogage (pour voir les num√©ros de lignes)
- `-O1` : Optimisation l√©g√®re (recommand√©, `-O0` peut masquer certains bugs)
- `-fno-omit-frame-pointer` : Meilleurs stack traces (souvent implicite avec `-fsanitize=address`)

**‚ö†Ô∏è Note :** ASan inclut automatiquement LSan sur Linux et macOS.

### UndefinedBehaviorSanitizer (UBSan)

**Commande minimale :**
```bash
gcc -fsanitize=undefined -g -o prog prog.c
```

**Commande recommand√©e :**
```bash
gcc -fsanitize=undefined -g -O1 -fno-sanitize-recover=all -o prog prog.c
```

**Options expliqu√©es :**
- `-fsanitize=undefined` : Active UndefinedBehaviorSanitizer
- `-fno-sanitize-recover=all` : Arr√™te √† la premi√®re erreur (utile pour les tests)

**V√©rifications sp√©cifiques :**
```bash
# Uniquement les d√©bordements d'entiers sign√©s
gcc -fsanitize=signed-integer-overflow -g -o prog prog.c

# Uniquement les divisions par z√©ro
gcc -fsanitize=divide-by-zero -g -o prog prog.c

# Uniquement les shifts invalides
gcc -fsanitize=shift -g -o prog prog.c
```

### ThreadSanitizer (TSan)

**Commande minimale :**
```bash
gcc -fsanitize=thread -g -pthread -o prog prog.c
```

**Commande recommand√©e :**
```bash
gcc -fsanitize=thread -g -O1 -pthread -o prog prog.c
```

**Options expliqu√©es :**
- `-fsanitize=thread` : Active ThreadSanitizer
- `-pthread` : Lie la biblioth√®que pthread (obligatoire)
- `-O1` : Optimisation recommand√©e (pas `-O0` ni `-O2`)

**‚ö†Ô∏è Important :** TSan **ne peut pas** √™tre combin√© avec ASan, UBSan ou LSan.

### LeakSanitizer (LSan)

**Commande minimale (LSan seul) :**
```bash
gcc -fsanitize=leak -g -o prog prog.c
```

**Commande recommand√©e (avec ASan) :**
```bash
gcc -fsanitize=address -g -O1 -o prog prog.c
```

**Options expliqu√©es :**
- `-fsanitize=leak` : Active LSan uniquement (overhead minimal)
- `-fsanitize=address` : Active ASan qui inclut LSan (recommand√©)

**Note :** LSan est automatiquement inclus dans ASan, donc `-fsanitize=address` suffit g√©n√©ralement.

---

## Combinaisons de sanitizers

### Combinaison recommand√©e : ASan + UBSan + LSan

**La combinaison la plus puissante pour le d√©veloppement quotidien :**

```bash
gcc -fsanitize=address,undefined \
    -fno-sanitize-recover=all \
    -g -O1 \
    -fno-omit-frame-pointer \
    -o prog prog.c
```

**D√©tection :**
- ‚úÖ Erreurs m√©moire (buffer overflow, use-after-free, etc.)
- ‚úÖ Comportements ind√©finis (overflow, division par z√©ro, etc.)
- ‚úÖ Fuites m√©moire (incluses dans ASan)

**Overhead :** ~100-150% (2-2.5√ó plus lent)

**Usage :** D√©veloppement, tests unitaires, CI/CD

### Build s√©par√© : TSan

Comme TSan est incompatible avec les autres, cr√©ez un build d√©di√© :

```bash
gcc -fsanitize=thread \
    -g -O1 \
    -pthread \
    -o prog_tsan prog.c
```

**D√©tection :**
- ‚úÖ Race conditions
- ‚úÖ Deadlocks (partiels)
- ‚úÖ Mauvaise utilisation des mutex

**Overhead :** ~500-1500% (5-15√ó plus lent)

**Usage :** Tests de programmes multi-thread√©s uniquement

### Configuration √† deux builds

Pour une couverture compl√®te, cr√©ez **deux builds** :

**Build 1 : ASan + UBSan**
```bash
gcc -fsanitize=address,undefined -fno-sanitize-recover=all \
    -g -O1 -o prog_asan prog.c
```

**Build 2 : TSan**
```bash
gcc -fsanitize=thread -g -O1 -pthread -o prog_tsan prog.c
```

**Workflow de test :**
```bash
# Test des erreurs m√©moire et comportements ind√©finis
./prog_asan

# Test des probl√®mes de concurrence (si multi-thread√©)
./prog_tsan
```

---

## Options de compilation d√©taill√©es

### Niveaux d'optimisation

**Impact des optimisations sur les sanitizers :**

| Niveau | Impact | Recommandation |
|--------|--------|----------------|
| `-O0` | Pas d'optimisation, code lent | ‚ùå Peut masquer certains bugs |
| `-O1` | Optimisation l√©g√®re | ‚úÖ **Recommand√©** |
| `-O2` | Optimisation standard | ‚ö†Ô∏è Acceptable mais peut compliquer debug |
| `-O3` | Optimisation agressive | ‚ùå Peut interf√©rer avec sanitizers |
| `-Os` | Optimisation taille | ‚ö†Ô∏è Acceptable |

**Recommandation g√©n√©rale :** Utilisez **`-O1`** avec les sanitizers.

```bash
# ‚úÖ Bon
gcc -fsanitize=address -g -O1 -o prog prog.c

# ‚ùå √Ä √©viter
gcc -fsanitize=address -g -O0 -o prog prog.c  # Peut masquer bugs
gcc -fsanitize=address -g -O3 -o prog prog.c  # Peut perturber d√©tection
```

### Options de frame pointer

**`-fno-omit-frame-pointer` :**

Garantit des stack traces complets et pr√©cis.

```bash
gcc -fsanitize=address -g -O1 -fno-omit-frame-pointer -o prog prog.c
```

**Quand l'utiliser :**
- ‚úÖ Toujours avec ASan (souvent activ√© automatiquement)
- ‚úÖ Avec TSan pour de meilleurs rapports
- ‚ö†Ô∏è L√©ger overhead de performance (~2-5%)

**Note :** Les sanitizers activent souvent cette option automatiquement, mais il est bon de l'expliciter.

### Options de r√©cup√©ration d'erreur

**`-fno-sanitize-recover=all` :**

Arr√™te l'ex√©cution √† la premi√®re erreur d√©tect√©e (au lieu de continuer).

```bash
gcc -fsanitize=address,undefined \
    -fno-sanitize-recover=all \
    -g -O1 -o prog prog.c
```

**Quand l'utiliser :**
- ‚úÖ Tests automatis√©s (CI/CD)
- ‚úÖ Validation avant commit
- ‚úÖ Recherche de la premi√®re erreur

**Alternative :** `-fsanitize-recover=all` pour voir toutes les erreurs.

```bash
# Continue apr√®s les erreurs (affiche toutes les erreurs)
gcc -fsanitize=address,undefined \
    -fsanitize-recover=all \
    -g -O1 -o prog prog.c
```

### Options de symboles de d√©bogage

**`-g` vs `-g3` :**

```bash
# Standard (suffisant pour la plupart des cas)
gcc -fsanitize=address -g -O1 -o prog prog.c

# Symboles complets (inclut macros)
gcc -fsanitize=address -g3 -O1 -o prog prog.c
```

**Recommandation :** `-g` est suffisant, utilisez `-g3` pour du debugging tr√®s d√©taill√©.

---

## Options avanc√©es par sanitizer

### Options ASan sp√©cifiques

**D√©tection stricte des conteneurs (check_initialization_order) :**
```bash
gcc -fsanitize=address \
    -fsanitize-address-use-after-scope \
    -g -O1 -o prog prog.c
```

**Options expliqu√©es :**
- `-fsanitize-address-use-after-scope` : D√©tecte l'utilisation de variables apr√®s leur port√©e

**D√©sactiver la d√©tection de fuites (si n√©cessaire) :**
```bash
# √Ä la compilation (pas recommand√©)
gcc -fsanitize=address -fno-sanitize=leak -g -O1 -o prog prog.c

# Ou via variable d'environnement (pr√©f√©rable)
ASAN_OPTIONS=detect_leaks=0 ./prog
```

### Options UBSan sp√©cifiques

**Activer toutes les v√©rifications :**
```bash
gcc -fsanitize=undefined \
    -fsanitize=float-divide-by-zero \
    -fsanitize=float-cast-overflow \
    -g -O1 -o prog prog.c
```

**V√©rifications suppl√©mentaires disponibles :**
- `float-divide-by-zero` : Division par z√©ro en virgule flottante
- `float-cast-overflow` : Conversion float vers int qui d√©borde
- `bounds` : V√©rification des limites de tableaux (partiel)
- `alignment` : V√©rification de l'alignement des pointeurs

**Exemple complet :**
```bash
gcc -fsanitize=undefined,float-divide-by-zero,float-cast-overflow,bounds,alignment \
    -fno-sanitize-recover=all \
    -g -O1 -o prog prog.c
```

### Options TSan sp√©cifiques

**Ajuster la taille de l'historique (pour plus de pr√©cision) :**
```bash
# √Ä la compilation (non disponible)
# Utilisez les variables d'environnement √† l'ex√©cution
TSAN_OPTIONS="history_size=7" ./prog_tsan
```

**TSan avec optimisation :**
```bash
# Optimisation recommand√©e : -O1
gcc -fsanitize=thread -g -O1 -pthread -o prog prog.c
```

---

## Flags de compilation recommand√©s par contexte

### D√©veloppement quotidien

**Objectif :** √âquilibre entre d√©tection et vitesse.

```bash
gcc -fsanitize=address,undefined \
    -g -O1 \
    -Wall -Wextra \
    -o prog prog.c
```

**Caract√©ristiques :**
- D√©tection m√©moire + comportements ind√©finis
- Overhead acceptable (~2√ó plus lent)
- Tous les warnings activ√©s

### Tests automatis√©s / CI/CD

**Objectif :** D√©tection maximale, arr√™t √† la premi√®re erreur.

```bash
gcc -fsanitize=address,undefined \
    -fno-sanitize-recover=all \
    -g -O1 \
    -Wall -Wextra -Werror \
    -fno-omit-frame-pointer \
    -o prog prog.c
```

**Caract√©ristiques :**
- Arr√™t √† la premi√®re erreur
- Tous les warnings sont des erreurs (`-Werror`)
- Stack traces complets

### Tests de concurrence

**Objectif :** D√©tecter les race conditions.

```bash
gcc -fsanitize=thread \
    -g -O1 \
    -pthread \
    -Wall -Wextra \
    -o prog_tsan prog.c
```

**Ex√©cution :**
```bash
TSAN_OPTIONS="halt_on_error=1:history_size=7" ./prog_tsan
```

### Production (sans sanitizers)

**Objectif :** Performance maximale.

```bash
gcc -O2 \
    -DNDEBUG \
    -Wall -Wextra -Werror \
    -o prog prog.c
```

**Caract√©ristiques :**
- Optimisation standard (`-O2`)
- Assertions d√©sactiv√©es (`-DNDEBUG`)
- Pas de sanitizers (overhead de 0%)

---

## Int√©gration dans les syst√®mes de build

### Makefile

**Exemple de Makefile avec plusieurs configurations :**

```makefile
CC = gcc
CFLAGS = -Wall -Wextra -std=c11

# Flags communs aux sanitizers
SANITIZER_FLAGS = -g -O1 -fno-omit-frame-pointer

# Flags sp√©cifiques
ASAN_FLAGS = -fsanitize=address,undefined -fno-sanitize-recover=all
TSAN_FLAGS = -fsanitize=thread
LSAN_FLAGS = -fsanitize=leak

# Sources
SOURCES = main.c utils.c
OBJECTS = $(SOURCES:.c=.o)

# Cible par d√©faut
all: prog

# Build normal (debug)
prog: $(SOURCES)
	$(CC) $(CFLAGS) -g -O0 -o prog $(SOURCES)

# Build avec ASan + UBSan
asan: $(SOURCES)
	$(CC) $(CFLAGS) $(SANITIZER_FLAGS) $(ASAN_FLAGS) -o prog_asan $(SOURCES)

# Build avec TSan
tsan: $(SOURCES)
	$(CC) $(CFLAGS) $(SANITIZER_FLAGS) $(TSAN_FLAGS) -pthread -o prog_tsan $(SOURCES)

# Build avec LSan uniquement
lsan: $(SOURCES)
	$(CC) $(CFLAGS) $(SANITIZER_FLAGS) $(LSAN_FLAGS) -o prog_lsan $(SOURCES)

# Build production
release: $(SOURCES)
	$(CC) $(CFLAGS) -O2 -DNDEBUG -o prog_release $(SOURCES)

# Tests avec tous les sanitizers
test: asan tsan
	@echo "=== Tests avec ASan + UBSan ==="
	ASAN_OPTIONS=detect_leaks=1:halt_on_error=1 ./prog_asan
	@echo "=== Tests avec TSan ==="
	TSAN_OPTIONS=halt_on_error=1 ./prog_tsan
	@echo "‚úÖ Tous les tests sont pass√©s"

# Nettoyage
clean:
	rm -f prog prog_asan prog_tsan prog_lsan prog_release *.o

.PHONY: all asan tsan lsan release test clean
```

**Utilisation :**
```bash
# Build et test avec sanitizers
make asan
make test

# Build production
make release
```

### CMake

**Exemple de CMakeLists.txt avec sanitizers :**

```cmake
cmake_minimum_required(VERSION 3.10)
project(MonProjet C)

# Options de configuration
option(ENABLE_ASAN "Enable AddressSanitizer" OFF)
option(ENABLE_UBSAN "Enable UndefinedBehaviorSanitizer" OFF)
option(ENABLE_TSAN "Enable ThreadSanitizer" OFF)
option(ENABLE_LSAN "Enable LeakSanitizer" OFF)

# Flags communs
set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wall -Wextra -std=c11")

# Flags de sanitizers
set(SANITIZER_FLAGS "-g -O1 -fno-omit-frame-pointer")

# Configuration des sanitizers
if(ENABLE_ASAN)
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${SANITIZER_FLAGS} -fsanitize=address")
    set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -fsanitize=address")
    message(STATUS "AddressSanitizer enabled")
endif()

if(ENABLE_UBSAN)
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${SANITIZER_FLAGS} -fsanitize=undefined -fno-sanitize-recover=all")
    set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -fsanitize=undefined")
    message(STATUS "UndefinedBehaviorSanitizer enabled")
endif()

if(ENABLE_TSAN)
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${SANITIZER_FLAGS} -fsanitize=thread")
    set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -fsanitize=thread")
    message(STATUS "ThreadSanitizer enabled")
endif()

if(ENABLE_LSAN)
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${SANITIZER_FLAGS} -fsanitize=leak")
    set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -fsanitize=leak")
    message(STATUS "LeakSanitizer enabled")
endif()

# Sources
set(SOURCES
    main.c
    utils.c
)

# Ex√©cutable
add_executable(prog ${SOURCES})

# Biblioth√®que pthread si n√©cessaire
if(ENABLE_TSAN)
    target_link_libraries(prog pthread)
endif()
```

**Utilisation :**
```bash
# Build avec ASan + UBSan
mkdir build_asan && cd build_asan
cmake -DENABLE_ASAN=ON -DENABLE_UBSAN=ON ..
make

# Build avec TSan
mkdir build_tsan && cd build_tsan
cmake -DENABLE_TSAN=ON ..
make

# Build production
mkdir build_release && cd build_release
cmake -DCMAKE_BUILD_TYPE=Release ..
make
```

**CMake moderne (plus propre) :**

```cmake
cmake_minimum_required(VERSION 3.10)
project(MonProjet C)

# Fonction pour ajouter les sanitizers
function(enable_sanitizers target)
    if(CMAKE_BUILD_TYPE MATCHES "Sanitize")
        target_compile_options(${target} PRIVATE
            -fsanitize=address,undefined
            -fno-sanitize-recover=all
            -g -O1
            -fno-omit-frame-pointer
        )
        target_link_options(${target} PRIVATE
            -fsanitize=address,undefined
        )
    endif()
endfunction()

# Sources
add_executable(prog main.c utils.c)

# Appliquer les sanitizers
enable_sanitizers(prog)
```

**Utilisation :**
```bash
cmake -DCMAKE_BUILD_TYPE=Sanitize ..
make
```

---

## Compilation avec Clang

### Diff√©rences GCC vs Clang

Les deux compilateurs supportent les sanitizers, mais avec quelques diff√©rences :

| Aspect | GCC | Clang |
|--------|-----|-------|
| **ASan** | ‚úÖ Excellent | ‚úÖ Excellent |
| **UBSan** | ‚úÖ Bon | ‚úÖ Excellent |
| **TSan** | ‚úÖ Bon | ‚úÖ Excellent |
| **LSan** | ‚úÖ Inclus dans ASan | ‚úÖ Inclus dans ASan |
| **MSan** | ‚ùå Pas disponible | ‚úÖ Disponible (m√©moire non initialis√©e) |
| **Rapports** | Bons | Souvent plus d√©taill√©s |

**Recommandation :** Les deux sont excellents, utilisez ce que vous avez.

### Compilation avec Clang

**Syntaxe identique √† GCC :**

```bash
# ASan + UBSan
clang -fsanitize=address,undefined \
      -fno-sanitize-recover=all \
      -g -O1 \
      -o prog prog.c

# TSan
clang -fsanitize=thread \
      -g -O1 \
      -pthread \
      -o prog_tsan prog.c
```

### MemorySanitizer (MSan) - Exclusif √† Clang

**D√©tecte l'utilisation de m√©moire non initialis√©e :**

```bash
clang -fsanitize=memory \
      -fno-omit-frame-pointer \
      -g -O1 \
      -o prog prog.c
```

**‚ö†Ô∏è Limitation :** N√©cessite que **toutes les biblioth√®ques** soient recompil√©es avec MSan.

---

## Gestion des biblioth√®ques

### Biblioth√®ques statiques

**Pas de probl√®me particulier :**

```bash
# Compilation de la biblioth√®que
gcc -c -fsanitize=address -g -O1 utils.c -o utils.o
ar rcs libutils.a utils.o

# Compilation du programme
gcc -fsanitize=address -g -O1 main.c -L. -lutils -o prog
```

### Biblioth√®ques dynamiques

**Les sanitizers doivent √™tre dans la biblioth√®que ET dans l'ex√©cutable :**

```bash
# Compilation de la biblioth√®que partag√©e
gcc -shared -fPIC -fsanitize=address -g -O1 utils.c -o libutils.so

# Compilation du programme
gcc -fsanitize=address -g -O1 main.c -L. -lutils -o prog

# Ex√©cution
LD_LIBRARY_PATH=. ./prog
```

**Important :** Si vous liez une biblioth√®que tierce, elle doit √™tre compatible avec les sanitizers.

### Biblioth√®ques tierces non instrument√©es

**Probl√®me :** Les biblioth√®ques syst√®me ou tierces ne sont pas compil√©es avec sanitizers.

**Solutions :**

1. **Utiliser des suppressions** (pour les faux positifs)
2. **Recompiler la biblioth√®que** avec sanitizers (si possible)
3. **Accepter les limitations** (les erreurs dans la biblioth√®que ne seront pas d√©tect√©es)

**Exemple avec suppression :**
```bash
# Cr√©er un fichier de suppression
echo "leak:libtierce.so" > suppressions.txt

# Ex√©cuter avec suppressions
LSAN_OPTIONS=suppressions=suppressions.txt ./prog
```

---

## Compilation cross-platform

### Linux (Ubuntu/Debian)

```bash
# Installer les outils si n√©cessaire
sudo apt-get install gcc clang

# Compilation
gcc -fsanitize=address,undefined -g -O1 -o prog prog.c
```

### macOS

```bash
# Utiliser Clang (pr√©install√©)
clang -fsanitize=address,undefined -g -O1 -o prog prog.c
```

**Note :** Sur macOS, certains sanitizers peuvent n√©cessiter des droits suppl√©mentaires.

### Windows (MinGW)

```bash
# Avec MinGW-w64
gcc -fsanitize=address,undefined -g -O1 -o prog.exe prog.c
```

**‚ö†Ô∏è Limitation :** Support limit√© sur Windows, privil√©giez Linux/macOS pour les tests avec sanitizers.

---

## V√©rification de la configuration

### V√©rifier que les sanitizers sont actifs

**M√©thode 1 : V√©rifier les symboles**
```bash
nm prog | grep -i sanitizer
# Devrait afficher des symboles __asan_, __ubsan_, etc.
```

**M√©thode 2 : V√©rifier les biblioth√®ques li√©es**
```bash
ldd prog | grep -i san
# Devrait montrer libasan.so, libubsan.so, etc.
```

**M√©thode 3 : Provoquer une erreur volontaire**

```c
// test_asan.c
#include <stdlib.h>

int main() {
    int *ptr = malloc(10 * sizeof(int));
    ptr[20] = 42;  // Buffer overflow volontaire
    free(ptr);
    return 0;
}
```

```bash
gcc -fsanitize=address -g -o test_asan test_asan.c
./test_asan
# Doit afficher un rapport d'erreur ASan
```

### Script de v√©rification automatique

```bash
#!/bin/bash
# verify_sanitizers.sh

echo "V√©rification de la configuration des sanitizers..."

# Build avec ASan
gcc -fsanitize=address -g -O1 -o test_asan test.c 2>&1 | grep -q "error"
if [ $? -eq 0 ]; then
    echo "‚ùå Erreur de compilation avec ASan"
    exit 1
fi

# V√©rifier les symboles
nm test_asan | grep -q "__asan"
if [ $? -eq 0 ]; then
    echo "‚úÖ ASan activ√© correctement"
else
    echo "‚ùå ASan non d√©tect√©"
    exit 1
fi

echo "‚úÖ Configuration valid√©e"
```

---

## R√©solution de probl√®mes

### Erreur : "undefined reference to __asan_*"

**Cause :** Probl√®me de linkage avec la biblioth√®que sanitizer.

**Solution :**
```bash
# S'assurer d'utiliser le m√™me flag pour compilation ET linkage
gcc -fsanitize=address -g -c file1.c -o file1.o
gcc -fsanitize=address -g -c file2.c -o file2.o
gcc -fsanitize=address -g file1.o file2.o -o prog  # ‚Üê Important
```

### Erreur : "ASan runtime is not initialized"

**Cause :** Biblioth√®que sanitizer non charg√©e correctement.

**Solution :**
```bash
# S'assurer que LD_PRELOAD ou LD_LIBRARY_PATH est correct
LD_PRELOAD=/usr/lib/libasan.so ./prog
```

### Erreur : TSan + ASan en m√™me temps

**Cause :** Tentative de combiner TSan avec ASan (incompatible).

**Solution :**
```bash
# ‚ùå Ne fonctionne pas
gcc -fsanitize=address,thread -o prog prog.c

# ‚úÖ Cr√©er deux builds s√©par√©s
gcc -fsanitize=address -o prog_asan prog.c
gcc -fsanitize=thread -o prog_tsan prog.c
```

### Performance trop d√©grad√©e

**Cause :** Overhead cumul√© de plusieurs sanitizers.

**Solutions :**
1. Utiliser LSan seul au lieu d'ASan si vous ne cherchez que les fuites
2. R√©duire le niveau d'optimisation √† `-O0` temporairement
3. D√©sactiver certaines v√©rifications UBSan sp√©cifiques

```bash
# L√©ger : LSan uniquement
gcc -fsanitize=leak -g -O1 -o prog prog.c  # ~5% overhead

# Moyen : ASan + UBSan
gcc -fsanitize=address,undefined -g -O1 -o prog prog.c  # ~100% overhead

# Lourd : TSan
gcc -fsanitize=thread -g -O1 -o prog prog.c  # ~500-1500% overhead
```

---

## Bonnes pratiques de compilation

### 1. Toujours utiliser `-g`

Les symboles de d√©bogage sont **essentiels** pour des rapports lisibles.

```bash
# ‚ùå Mauvais : Pas de symboles
gcc -fsanitize=address -o prog prog.c

# ‚úÖ Bon : Avec symboles
gcc -fsanitize=address -g -o prog prog.c
```

### 2. Utiliser `-O1` avec les sanitizers

```bash
# ‚úÖ Recommand√©
gcc -fsanitize=address -g -O1 -o prog prog.c
```

### 3. Activer tous les warnings

```bash
gcc -fsanitize=address,undefined \
    -g -O1 \
    -Wall -Wextra -Wpedantic \
    -o prog prog.c
```

### 4. Traiter les warnings comme des erreurs (CI/CD)

```bash
gcc -fsanitize=address,undefined \
    -fno-sanitize-recover=all \
    -g -O1 \
    -Wall -Wextra -Werror \
    -o prog prog.c
```

### 5. Documenter vos configurations

**README.md :**
```markdown
## Compilation

### D√©veloppement
```bash
make asan
```

### Tests
```bash
make test
```

### Production
```bash
make release
```
```

---

## R√©capitulatif des commandes essentielles

### Commande universelle (d√©veloppement)

```bash
gcc -fsanitize=address,undefined \
    -fno-sanitize-recover=all \
    -g -O1 \
    -Wall -Wextra \
    -fno-omit-frame-pointer \
    -o prog prog.c
```

**Cette commande offre :**
- D√©tection des erreurs m√©moire (ASan)
- D√©tection des comportements ind√©finis (UBSan)
- D√©tection des fuites m√©moire (LSan, inclus dans ASan)
- Arr√™t √† la premi√®re erreur
- Tous les warnings
- Stack traces complets

### Commande pour code multi-thread√©

```bash
gcc -fsanitize=thread \
    -g -O1 \
    -pthread \
    -Wall -Wextra \
    -o prog_tsan prog.c
```

### Commande pour production

```bash
gcc -O2 \
    -DNDEBUG \
    -Wall -Wextra -Werror \
    -o prog prog.c
```

---

## R√©sum√©

### Points cl√©s √† retenir

1. **ASan + UBSan** = Combinaison la plus puissante
2. **TSan** doit √™tre utilis√© **seul** (incompatible avec les autres)
3. Toujours compiler avec **`-g -O1`**
4. Utiliser **`-fno-sanitize-recover=all`** pour les tests
5. Cr√©er **plusieurs builds** pour une couverture compl√®te

### Tableau r√©capitulatif des flags

| Objectif | Flags |
|----------|-------|
| **D√©veloppement** | `-fsanitize=address,undefined -g -O1` |
| **CI/CD** | `-fsanitize=address,undefined -fno-sanitize-recover=all -g -O1 -Werror` |
| **Concurrence** | `-fsanitize=thread -g -O1 -pthread` |
| **Fuites seules** | `-fsanitize=leak -g -O1` |
| **Production** | `-O2 -DNDEBUG` |

### Workflow complet

```bash
# 1. D√©veloppement avec ASan + UBSan
gcc -fsanitize=address,undefined -g -O1 -Wall -Wextra -o prog prog.c

# 2. Tests de concurrence (si multi-thread√©)
gcc -fsanitize=thread -g -O1 -pthread -o prog_tsan prog.c
./prog_tsan

# 3. CI/CD
gcc -fsanitize=address,undefined -fno-sanitize-recover=all -g -O1 -Werror -o prog prog.c
./prog --run-tests

# 4. Production
gcc -O2 -DNDEBUG -Wall -Wextra -Werror -o prog_release prog.c
```

### Prochaines √©tapes

Dans les sections suivantes, vous d√©couvrirez :
- **Performance et overhead** : Mesures d√©taill√©es de l'impact
- **Int√©gration dans le workflow** : De dev √† production
- **Cas pratiques** : Exemples r√©els d'utilisation

---

**üéØ Ma√Ætriser la compilation avec sanitizers est crucial pour √©crire du code C robuste et fiable. Ces commandes doivent devenir des r√©flexes dans votre workflow quotidien !**

‚è≠Ô∏è [Performance et overhead](/15-debogage-et-qualite/01.6-performance-overhead.md)
