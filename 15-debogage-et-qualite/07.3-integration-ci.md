ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 15.7.3 IntÃ©gration dans le CI

## Introduction

L'**intÃ©gration de la couverture de code dans le CI/CD** est l'Ã©tape finale qui transforme la mesure de couverture d'une tÃ¢che manuelle en un processus automatique et systÃ©matique. Chaque commit, chaque pull request est automatiquement analysÃ© pour s'assurer que le code reste bien testÃ©.

### Qu'est-ce que l'intÃ©gration CI de la couverture ?

L'intÃ©gration CI (Continuous Integration) de la couverture consiste Ã  :

1. **Compiler automatiquement** le code avec les flags de couverture
2. **ExÃ©cuter les tests** et collecter les donnÃ©es de couverture
3. **GÃ©nÃ©rer les rapports** (gcov/lcov)
4. **VÃ©rifier les seuils** de couverture dÃ©finis
5. **Publier les rÃ©sultats** (artifacts, badges, commentaires)
6. **Bloquer les PR** si la couverture est insuffisante

### Pourquoi automatiser la couverture dans le CI ?

**Avantages :**

- âœ… **DÃ©tection prÃ©coce** : Les rÃ©gressions de couverture sont dÃ©tectÃ©es immÃ©diatement
- âœ… **QualitÃ© garantie** : Impossible de merger du code mal testÃ©
- âœ… **VisibilitÃ©** : Tous les dÃ©veloppeurs voient l'Ã©tat de la couverture
- âœ… **Historique** : Suivi de l'Ã©volution dans le temps
- âœ… **Automatisation** : Plus besoin de lancer manuellement les rapports
- âœ… **Standardisation** : MÃªmes critÃ¨res pour tous les contributeurs

**Sans CI de couverture :**
```
DÃ©veloppeur â†’ Code â†’ Commit â†’ Merge
                                  â†“
                           (Couverture inconnue)
```

**Avec CI de couverture :**
```
DÃ©veloppeur â†’ Code â†’ Commit â†’ CI vÃ©rifie couverture â†’ OK â†’ Merge
                                         â†“
                                        NOK â†’ BloquÃ©
```

---

## Workflow gÃ©nÃ©ral

### Pipeline de couverture type

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    PIPELINE CI COVERAGE                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  1. CHECKOUT CODE                                           â”‚
â”‚     â†“                                                       â”‚
â”‚  2. INSTALL DEPENDENCIES (gcc, lcov, gcov)                  â”‚
â”‚     â†“                                                       â”‚
â”‚  3. BUILD WITH COVERAGE FLAGS                               â”‚
â”‚     gcc -fprofile-arcs -ftest-coverage                      â”‚
â”‚     â†“                                                       â”‚
â”‚  4. RUN TESTS                                               â”‚
â”‚     ./test_suite                                            â”‚
â”‚     â†“                                                       â”‚
â”‚  5. COLLECT COVERAGE DATA                                   â”‚
â”‚     lcov --capture                                          â”‚
â”‚     â†“                                                       â”‚
â”‚  6. FILTER UNWANTED FILES                                   â”‚
â”‚     lcov --remove (system files, tests)                     â”‚
â”‚     â†“                                                       â”‚
â”‚  7. GENERATE REPORTS                                        â”‚
â”‚     genhtml (HTML), gcovr (XML)                             â”‚
â”‚     â†“                                                       â”‚
â”‚  8. CHECK THRESHOLD                                         â”‚
â”‚     if coverage < 80% â†’ FAIL                                â”‚
â”‚     â†“                                                       â”‚
â”‚  9. UPLOAD ARTIFACTS                                        â”‚
â”‚     Store HTML reports                                      â”‚
â”‚     â†“                                                       â”‚
â”‚  10. PUBLISH RESULTS                                        â”‚
â”‚      Codecov, badges, PR comments                           â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## GitHub Actions : Configuration complÃ¨te

### Structure de base

CrÃ©ez `.github/workflows/coverage.yml` :

```yaml
name: Code Coverage

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  coverage:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y gcc lcov

      - name: Build with coverage
        run: |
          gcc -fprofile-arcs -ftest-coverage \
              -o myapp src/*.c -I./include

      - name: Run tests
        run: ./myapp

      - name: Generate coverage report
        run: |
          lcov --capture --directory . \
               --output-file coverage.info
          lcov --remove coverage.info '/usr/*' \
               --output-file coverage_filtered.info
          genhtml coverage_filtered.info \
                  --output-directory coverage_html

      - name: Upload coverage report
        uses: actions/upload-artifact@v3
        with:
          name: coverage-report
          path: coverage_html/
```

### Configuration avancÃ©e avec matrice de tests

```yaml
name: Coverage Matrix

on:
  push:
    branches: [ main ]
  pull_request:

env:
  COVERAGE_THRESHOLD: 80

jobs:
  coverage:
    strategy:
      matrix:
        os: [ubuntu-20.04, ubuntu-22.04]
        compiler: [gcc-9, gcc-11, gcc-13]
        include:
          - os: ubuntu-20.04
            compiler: gcc-9
          - os: ubuntu-22.04
            compiler: gcc-11
          - os: ubuntu-22.04
            compiler: gcc-13

    runs-on: ${{ matrix.os }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup compiler
        run: |
          sudo apt-get update
          sudo apt-get install -y ${{ matrix.compiler }} lcov

      - name: Set compiler
        run: echo "CC=${{ matrix.compiler }}" >> $GITHUB_ENV

      - name: Build
        run: |
          $CC -fprofile-arcs -ftest-coverage \
              -o myapp src/*.c -I./include

      - name: Run tests
        run: ./myapp

      - name: Coverage report
        run: |
          lcov --capture --directory . --output-file coverage.info
          lcov --remove coverage.info '/usr/*' \
               --output-file coverage_filtered.info
          genhtml coverage_filtered.info \
                  --output-directory coverage_html

      - name: Check threshold
        run: |
          COVERAGE=$(lcov --summary coverage_filtered.info 2>&1 | \
                     grep lines | awk '{print $2}' | tr -d '%')
          echo "Coverage: $COVERAGE%"

          if (( $(echo "$COVERAGE < $COVERAGE_THRESHOLD" | bc -l) )); then
            echo "âŒ Coverage ($COVERAGE%) below threshold ($COVERAGE_THRESHOLD%)"
            exit 1
          fi

          echo "âœ… Coverage meets threshold"

      - name: Upload artifacts
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: coverage-${{ matrix.os }}-${{ matrix.compiler }}
          path: coverage_html/
```

### Avec CMake

```yaml
name: CMake Coverage

on: [push, pull_request]

jobs:
  coverage:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y cmake gcc lcov

      - name: Configure CMake
        run: |
          cmake -B build \
                -DCMAKE_BUILD_TYPE=Debug \
                -DENABLE_COVERAGE=ON \
                -DCMAKE_C_FLAGS="-fprofile-arcs -ftest-coverage"

      - name: Build
        run: cmake --build build

      - name: Run tests
        run: |
          cd build
          ctest --output-on-failure

      - name: Generate coverage
        run: |
          cd build

          # Capture coverage
          lcov --capture --directory . \
               --output-file coverage.info

          # Filter
          lcov --remove coverage.info \
               '/usr/*' '*/test/*' '*/build/*' \
               --output-file coverage_filtered.info

          # Generate HTML
          genhtml coverage_filtered.info \
                  --output-directory coverage_html

      - name: Display summary
        run: |
          cd build
          lcov --list coverage_filtered.info

      - name: Upload coverage
        uses: actions/upload-artifact@v3
        with:
          name: coverage-report
          path: build/coverage_html/
```

### Workflow complet avec tous les checks

```yaml
name: Complete Coverage Workflow

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  COVERAGE_THRESHOLD: 80
  BUILD_TYPE: Debug

jobs:
  # Job 1: Build et tests avec couverture
  build-and-test:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Important pour comparer avec main

      - name: Cache dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache
          key: ${{ runner.os }}-deps-${{ hashFiles('**/Makefile') }}

      - name: Install tools
        run: |
          sudo apt-get update
          sudo apt-get install -y gcc lcov gcovr bc

      - name: Build with coverage
        run: |
          make clean
          make coverage

      - name: Run tests
        run: |
          make test

      - name: Generate coverage data
        run: |
          # Baseline
          lcov --capture --initial --directory . \
               --output-file coverage_base.info

          # Test data
          lcov --capture --directory . \
               --output-file coverage_test.info

          # Combine
          lcov --add-tracefile coverage_base.info \
               --add-tracefile coverage_test.info \
               --output-file coverage_total.info

          # Filter
          lcov --remove coverage_total.info \
               '/usr/*' '*/test/*' '*/vendor/*' \
               --output-file coverage_filtered.info

      - name: Generate HTML report
        run: |
          genhtml coverage_filtered.info \
                  --output-directory coverage_html \
                  --title "Project Coverage Report" \
                  --legend \
                  --show-details \
                  --branch-coverage

      - name: Generate XML report (Cobertura)
        run: |
          gcovr --xml-pretty --xml coverage.xml \
                --exclude '.*test.*' \
                --exclude '/usr/.*'

      - name: Check coverage threshold
        id: coverage-check
        run: |
          COVERAGE=$(lcov --summary coverage_filtered.info 2>&1 | \
                     grep lines | awk '{print $2}' | tr -d '%')

          echo "coverage=$COVERAGE" >> $GITHUB_OUTPUT
          echo "### Coverage Report" >> $GITHUB_STEP_SUMMARY
          echo "Coverage: **$COVERAGE%**" >> $GITHUB_STEP_SUMMARY

          if (( $(echo "$COVERAGE < $COVERAGE_THRESHOLD" | bc -l) )); then
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "âŒ Below threshold ($COVERAGE_THRESHOLD%)" >> $GITHUB_STEP_SUMMARY
            exit 1
          else
            echo "status=passed" >> $GITHUB_OUTPUT
            echo "âœ… Meets threshold ($COVERAGE_THRESHOLD%)" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Upload HTML report
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: coverage-html-report
          path: coverage_html/
          retention-days: 30

      - name: Upload coverage data
        uses: actions/upload-artifact@v3
        with:
          name: coverage-data
          path: |
            coverage_filtered.info
            coverage.xml

  # Job 2: Commentaire sur PR
  comment-pr:
    needs: build-and-test
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest

    steps:
      - name: Download coverage data
        uses: actions/download-artifact@v3
        with:
          name: coverage-data

      - name: Parse coverage
        id: parse
        run: |
          COVERAGE=$(grep -oP 'lines.*?: \K[\d.]+' coverage_filtered.info | head -1)
          echo "coverage=$COVERAGE" >> $GITHUB_OUTPUT

      - name: Comment PR
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const coverage = '${{ steps.parse.outputs.coverage }}';
            const threshold = process.env.COVERAGE_THRESHOLD;

            const status = parseFloat(coverage) >= parseFloat(threshold) ? 'âœ…' : 'âŒ';
            const color = parseFloat(coverage) >= parseFloat(threshold) ? 'green' : 'red';

            const body = `## ${status} Code Coverage Report

            **Coverage:** ${coverage}%
            **Threshold:** ${threshold}%

            ![Coverage](https://img.shields.io/badge/coverage-${coverage}%25-${color})

            [ğŸ“Š View detailed report](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
            `;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });

  # Job 3: Upload vers Codecov
  upload-codecov:
    needs: build-and-test
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download coverage
        uses: actions/download-artifact@v3
        with:
          name: coverage-data

      - name: Upload to Codecov
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage.xml
          flags: unittests
          name: codecov-umbrella
          fail_ci_if_error: true
```

---

## GitLab CI : Configuration complÃ¨te

### Configuration de base

`.gitlab-ci.yml` :

```yaml
image: ubuntu:22.04

stages:
  - build
  - test
  - coverage
  - deploy

variables:
  GIT_SUBMODULE_STRATEGY: recursive
  COVERAGE_THRESHOLD: "80"

# Template pour installer les dÃ©pendances
.install_deps: &install_deps
  before_script:
    - apt-get update -qq
    - apt-get install -y -qq gcc lcov gcovr bc

# Job: Build avec couverture
build:
  stage: build
  <<: *install_deps
  script:
    - gcc -fprofile-arcs -ftest-coverage -o myapp src/*.c -I./include
  artifacts:
    paths:
      - myapp
      - "*.gcno"
    expire_in: 1 hour

# Job: ExÃ©cuter les tests
test:
  stage: test
  <<: *install_deps
  dependencies:
    - build
  script:
    - ./myapp
  artifacts:
    paths:
      - "*.gcda"
    expire_in: 1 hour

# Job: GÃ©nÃ©rer le rapport de couverture
coverage:
  stage: coverage
  <<: *install_deps
  dependencies:
    - build
    - test
  script:
    # Capturer la couverture
    - lcov --capture --directory . --output-file coverage.info

    # Filtrer
    - lcov --remove coverage.info '/usr/*' '*/test/*'
          --output-file coverage_filtered.info

    # GÃ©nÃ©rer HTML
    - genhtml coverage_filtered.info
              --output-directory coverage_html
              --title "Coverage Report"
              --legend

    # Afficher le rÃ©sumÃ©
    - lcov --list coverage_filtered.info

    # Extraire le pourcentage pour GitLab
    - COVERAGE=$(lcov --summary coverage_filtered.info 2>&1 |
                 grep lines | awk '{print $2}' | tr -d '%')
    - echo "Coverage is $COVERAGE%"

    # VÃ©rifier le seuil
    - |
      if (( $(echo "$COVERAGE < $COVERAGE_THRESHOLD" | bc -l) )); then
        echo "Coverage ($COVERAGE%) is below threshold ($COVERAGE_THRESHOLD%)"
        exit 1
      fi

  # Regex pour extraire la couverture pour GitLab
  coverage: '/lines.*?: (\d+\.\d+)%/'

  artifacts:
    paths:
      - coverage_html/
      - coverage_filtered.info
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
    expire_in: 30 days

# Job: Publier sur GitLab Pages
pages:
  stage: deploy
  dependencies:
    - coverage
  script:
    - mkdir -p public
    - cp -r coverage_html/* public/
  artifacts:
    paths:
      - public
  only:
    - main
```

### Configuration avancÃ©e avec matrice

```yaml
.coverage_job_template: &coverage_template
  stage: coverage
  script:
    - apt-get update -qq
    - apt-get install -y -qq gcc-$GCC_VERSION lcov

    # Build
    - gcc-$GCC_VERSION -fprofile-arcs -ftest-coverage
                       -o myapp src/*.c -I./include

    # Test
    - ./myapp

    # Coverage
    - lcov --capture --directory . --output-file coverage.info
    - lcov --remove coverage.info '/usr/*'
           --output-file coverage_filtered.info
    - genhtml coverage_filtered.info --output-directory coverage_html

  artifacts:
    paths:
      - coverage_html/
    expire_in: 1 day

# Tester avec diffÃ©rentes versions de GCC
coverage:gcc-9:
  <<: *coverage_template
  variables:
    GCC_VERSION: "9"

coverage:gcc-11:
  <<: *coverage_template
  variables:
    GCC_VERSION: "11"

coverage:gcc-13:
  <<: *coverage_template
  variables:
    GCC_VERSION: "13"
```

### Avec cache pour accÃ©lÃ©rer

```yaml
variables:
  CACHE_KEY: coverage-v1

cache:
  key: ${CACHE_KEY}
  paths:
    - .cache/

coverage:
  stage: coverage
  before_script:
    - apt-get update -qq
    - apt-get install -y -qq gcc lcov
  script:
    # Build (utilise le cache si disponible)
    - make coverage

    # Tests
    - make test

    # Coverage
    - make coverage-report

  cache:
    key: ${CACHE_KEY}
    paths:
      - .cache/
      - "*.gcno"  # Cache des fichiers de notes

  artifacts:
    paths:
      - coverage_html/
```

---

## Badges de couverture

### CrÃ©ation de badges

Les badges affichent visuellement l'Ã©tat de la couverture dans le README.

#### Badge avec Codecov

```markdown
[![codecov](https://codecov.io/gh/username/repo/branch/main/graph/badge.svg)](https://codecov.io/gh/username/repo)
```

RÃ©sultat : ![codecov](https://img.shields.io/badge/coverage-85%25-brightgreen)

#### Badge avec Coveralls

```markdown
[![Coverage Status](https://coveralls.io/repos/github/username/repo/badge.svg?branch=main)](https://coveralls.io/github/username/repo?branch=main)
```

#### Badge personnalisÃ© avec shields.io

```markdown
![Coverage](https://img.shields.io/badge/coverage-85%25-brightgreen)
```

**Couleurs selon le pourcentage :**
- ğŸŸ¢ `brightgreen` : â‰¥ 80%
- ğŸŸ¡ `yellow` : 60-79%
- ğŸ”´ `red` : < 60%

#### Badge dynamique avec GitHub Actions

**Script pour gÃ©nÃ©rer le badge :**

```bash
# extract_coverage.sh
#!/bin/bash

COVERAGE=$(lcov --summary coverage.info 2>&1 | grep lines | awk '{print $2}' | tr -d '%')

if (( $(echo "$COVERAGE >= 80" | bc -l) )); then
  COLOR="brightgreen"
elif (( $(echo "$COVERAGE >= 60" | bc -l) )); then
  COLOR="yellow"
else
  COLOR="red"
fi

# CrÃ©er le JSON pour le badge
cat > coverage.json <<EOF
{
  "schemaVersion": 1,
  "label": "coverage",
  "message": "$COVERAGE%",
  "color": "$COLOR"
}
EOF
```

**Workflow GitHub Actions :**

```yaml
- name: Generate badge
  run: |
    ./extract_coverage.sh

- name: Upload badge data
  uses: actions/upload-artifact@v3
  with:
    name: coverage-badge
    path: coverage.json
```

---

## Services de couverture Cloud

### Codecov

**Avantages :**
- âœ… Gratuit pour projets open-source
- âœ… Graphiques d'Ã©volution
- âœ… Comparaison PR vs base
- âœ… Commentaires automatiques sur PR

**Configuration :**

1. **Inscription sur codecov.io**

2. **Ajouter au workflow GitHub Actions :**

```yaml
- name: Upload to Codecov
  uses: codecov/codecov-action@v3
  with:
    files: ./coverage.xml
    flags: unittests
    name: codecov-umbrella
    fail_ci_if_error: true
    verbose: true
```

3. **CrÃ©er `codecov.yml` (optionnel) :**

```yaml
coverage:
  status:
    project:
      default:
        target: 80%
        threshold: 1%
    patch:
      default:
        target: 80%

comment:
  layout: "reach, diff, flags, files"
  behavior: default
  require_changes: false
```

### Coveralls

**Configuration :**

```yaml
- name: Upload to Coveralls
  uses: coverallsapp/github-action@v2
  with:
    github-token: ${{ secrets.GITHUB_TOKEN }}
    path-to-lcov: ./coverage_filtered.info
```

### Comparaison des services

| Service | Gratuit | Graphiques | API | PR Comments |
|---------|---------|------------|-----|-------------|
| **Codecov** | âœ… OSS | â­â­â­â­â­ | âœ… | âœ… |
| **Coveralls** | âœ… OSS | â­â­â­â­ | âœ… | âœ… |
| **Codacy** | âœ… OSS | â­â­â­ | âœ… | âœ… |
| **SonarCloud** | âœ… OSS | â­â­â­â­â­ | âœ… | âœ… |

---

## Politiques de qualitÃ© et seuils

### DÃ©finir des seuils adaptÃ©s

**Recommandations par type de projet :**

| Type de projet | Seuil minimum | Seuil recommandÃ© |
|----------------|---------------|------------------|
| **BibliothÃ¨que** | 85% | 95% |
| **Application critique** | 80% | 90% |
| **Application standard** | 70% | 80% |
| **Prototype/POC** | 50% | 60% |

### Script de vÃ©rification de seuil

**check_coverage.sh :**

```bash
#!/bin/bash

set -e

COVERAGE_FILE="coverage_filtered.info"
THRESHOLD=${1:-80}

# Extraire la couverture
COVERAGE=$(lcov --summary "$COVERAGE_FILE" 2>&1 | \
           grep lines | awk '{print $2}' | tr -d '%')

echo "Coverage: $COVERAGE%"
echo "Threshold: $THRESHOLD%"

# Comparer
if (( $(echo "$COVERAGE < $THRESHOLD" | bc -l) )); then
    echo "âŒ FAILED: Coverage is below threshold"
    exit 1
fi

echo "âœ… PASSED: Coverage meets threshold"
exit 0
```

**Utilisation dans le CI :**

```yaml
- name: Check coverage threshold
  run: ./check_coverage.sh 80
```

### Seuils diffÃ©renciÃ©s

**Par type de code :**

```bash
# Seuils stricts pour le code mÃ©tier
lcov --extract coverage.info '*/src/core/*' --output-file core.info
./check_coverage.sh 90 core.info

# Seuils plus souples pour les utilitaires
lcov --extract coverage.info '*/src/utils/*' --output-file utils.info
./check_coverage.sh 70 utils.info
```

### Seuils progressifs

Pour un projet existant avec faible couverture, augmentez progressivement :

**StratÃ©gie d'amÃ©lioration :**

```yaml
# Phase 1 (Sprint 1-2): 50%
COVERAGE_THRESHOLD: 50

# Phase 2 (Sprint 3-4): 60%
COVERAGE_THRESHOLD: 60

# Phase 3 (Sprint 5-6): 70%
COVERAGE_THRESHOLD: 70

# Phase 4 (Sprint 7+): 80%
COVERAGE_THRESHOLD: 80
```

---

## Notifications et alertes

### Notification Slack

**GitHub Actions avec Slack :**

```yaml
- name: Notify Slack
  if: failure()
  uses: 8398a7/action-slack@v3
  with:
    status: ${{ job.status }}
    text: |
      âŒ Coverage check failed!
      Coverage: ${{ steps.coverage.outputs.coverage }}%
      Threshold: ${{ env.COVERAGE_THRESHOLD }}%
    webhook_url: ${{ secrets.SLACK_WEBHOOK }}
```

### Notification par email

**GitLab CI :**

```yaml
coverage:
  script:
    - make coverage-report
  after_script:
    - |
      if [ "$CI_JOB_STATUS" == "failed" ]; then
        echo "Coverage check failed" | mail -s "CI Failure" team@example.com
      fi
```

### Dashboard personnalisÃ©

**Script pour gÃ©nÃ©rer un rÃ©sumÃ© JSON :**

```bash
#!/bin/bash

COVERAGE=$(lcov --summary coverage.info 2>&1 | grep lines | awk '{print $2}' | tr -d '%')
TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
COMMIT_SHA=$(git rev-parse HEAD)
BRANCH=$(git rev-parse --abbrev-ref HEAD)

cat > coverage_report.json <<EOF
{
  "timestamp": "$TIMESTAMP",
  "commit": "$COMMIT_SHA",
  "branch": "$BRANCH",
  "coverage": {
    "lines": $COVERAGE
  },
  "threshold": {
    "lines": 80
  },
  "status": "$( (( $(echo "$COVERAGE >= 80" | bc -l) )) && echo "passed" || echo "failed" )"
}
EOF

echo "Report generated: coverage_report.json"
```

**Uploader vers une API :**

```bash
curl -X POST https://dashboard.example.com/api/coverage \
     -H "Content-Type: application/json" \
     -d @coverage_report.json
```

---

## Comparaison de couverture (PR vs Base)

### DÃ©tecter les rÃ©gressions

**Script `compare_coverage.sh` :**

```bash
#!/bin/bash

BASE_COVERAGE=$1
PR_COVERAGE=$2
TOLERANCE=1.0  # 1% de tolÃ©rance

BASE_PERCENT=$(echo "$BASE_COVERAGE" | grep -oP '\d+\.\d+')
PR_PERCENT=$(echo "$PR_COVERAGE" | grep -oP '\d+\.\d+')

DIFF=$(echo "$PR_PERCENT - $BASE_PERCENT" | bc)

echo "Base coverage: $BASE_PERCENT%"
echo "PR coverage: $PR_PERCENT%"
echo "Difference: $DIFF%"

if (( $(echo "$DIFF < -$TOLERANCE" | bc -l) )); then
    echo "âŒ Coverage regression detected!"
    exit 1
fi

if (( $(echo "$DIFF > 0" | bc -l) )); then
    echo "âœ… Coverage improved!"
else
    echo "âœ… Coverage maintained"
fi
```

**IntÃ©gration GitHub Actions :**

```yaml
- name: Get base coverage
  run: |
    git checkout ${{ github.base_ref }}
    make coverage
    BASE_COV=$(lcov --summary coverage.info 2>&1 | grep lines | awk '{print $2}')
    echo "base_coverage=$BASE_COV" >> $GITHUB_OUTPUT
  id: base

- name: Get PR coverage
  run: |
    git checkout ${{ github.head_ref }}
    make coverage
    PR_COV=$(lcov --summary coverage.info 2>&1 | grep lines | awk '{print $2}')
    echo "pr_coverage=$PR_COV" >> $GITHUB_OUTPUT
  id: pr

- name: Compare coverage
  run: |
    ./compare_coverage.sh \
      "${{ steps.base.outputs.base_coverage }}" \
      "${{ steps.pr.outputs.pr_coverage }}"
```

---

## Bonnes pratiques

### 1. SÃ©parer les jobs

Ne pas tout faire dans un seul job :

```yaml
jobs:
  build:
    # Compilation

  test:
    needs: build
    # Tests

  coverage:
    needs: test
    # GÃ©nÃ©ration du rapport

  deploy:
    needs: coverage
    # DÃ©ploiement
```

**Avantages :**
- âœ… ParallÃ©lisation possible
- âœ… Ã‰chec localisÃ©
- âœ… Artifacts partagÃ©s

### 2. Utiliser le cache intelligemment

```yaml
- name: Cache build artifacts
  uses: actions/cache@v3
  with:
    path: |
      build/
      *.gcno
    key: ${{ runner.os }}-build-${{ hashFiles('**/*.c') }}
    restore-keys: |
      ${{ runner.os }}-build-
```

### 3. Optimiser la gÃ©nÃ©ration de rapports

```bash
# GÃ©nÃ©rer seulement ce qui est nÃ©cessaire
genhtml coverage.info \
        --output-directory coverage_html \
        --no-function-coverage \  # DÃ©sactiver si non utilisÃ©
        --no-branch-coverage      # DÃ©sactiver si non utilisÃ©
```

### 4. Nettoyer les artifacts anciens

```yaml
- name: Clean old coverage data
  run: |
    find . -name "*.gcda" -delete
    find . -name "*.gcov" -delete
```

### 5. Documenter les exclusions

```c
// LCOV_EXCL_START
// Raison: Code de debug uniquement, non testÃ© en CI
void debug_function() {
    // ...
}
// LCOV_EXCL_STOP
```

### 6. Versionner la configuration

Commitez les fichiers de configuration :
- `.github/workflows/coverage.yml`
- `.gitlab-ci.yml`
- `codecov.yml`
- Scripts de couverture

### 7. Tester le workflow localement

**Avec act (GitHub Actions) :**

```bash
# Installer act
brew install act  # macOS
# ou
sudo apt install act  # Linux

# Tester le workflow
act -j coverage
```

**Avec gitlab-runner :**

```bash
# Installer gitlab-runner
curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh | sudo bash
sudo apt-get install gitlab-runner

# Tester localement
gitlab-runner exec docker coverage
```

---

## DÃ©bogage des problÃ¨mes CI

### ProblÃ¨me : Coverage Ã  0%

**Causes possibles :**
1. Tests ne s'exÃ©cutent pas
2. Fichiers `.gcda` non gÃ©nÃ©rÃ©s
3. Mauvais rÃ©pertoire de capture

**Solution :**

```yaml
- name: Debug coverage
  run: |
    echo "=== Checking .gcda files ==="
    find . -name "*.gcda"

    echo "=== Checking .gcno files ==="
    find . -name "*.gcno"

    echo "=== Working directory ==="
    pwd

    echo "=== Directory structure ==="
    ls -la
```

### ProblÃ¨me : Seuil Ã©choue mais devrait passer

**VÃ©rifications :**

```yaml
- name: Detailed coverage check
  run: |
    echo "=== Full coverage summary ==="
    lcov --list coverage.info

    echo "=== Extracted percentage ==="
    COVERAGE=$(lcov --summary coverage.info 2>&1 | grep lines | awk '{print $2}')
    echo "Raw output: $COVERAGE"
    echo "Numeric only: $(echo $COVERAGE | tr -d '%')"
```

### ProblÃ¨me : Rapports HTML manquants

**VÃ©rifier la gÃ©nÃ©ration :**

```yaml
- name: Verify HTML generation
  run: |
    if [ ! -d "coverage_html" ]; then
      echo "âŒ coverage_html directory not found"
      exit 1
    fi

    if [ ! -f "coverage_html/index.html" ]; then
      echo "âŒ index.html not found"
      exit 1
    fi

    echo "âœ… HTML report generated successfully"
    ls -la coverage_html/
```

---

## Exemple complet : Projet rÃ©el

### Structure du projet

```
project/
â”œâ”€â”€ .github/
â”‚   â””â”€â”€ workflows/
â”‚       â””â”€â”€ coverage.yml
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.c
â”‚   â””â”€â”€ utils.c
â”œâ”€â”€ include/
â”‚   â””â”€â”€ utils.h
â”œâ”€â”€ tests/
â”‚   â””â”€â”€ test_suite.c
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ check_coverage.sh
â”‚   â””â”€â”€ generate_report.sh
â”œâ”€â”€ codecov.yml
â”œâ”€â”€ CMakeLists.txt
â”œâ”€â”€ Makefile
â””â”€â”€ README.md
```

### Makefile complet

```makefile
CC = gcc
CFLAGS = -Wall -Wextra -std=c11 -I./include
COVERAGE_FLAGS = -fprofile-arcs -ftest-coverage
LDFLAGS = -lgcov

SRC = src/main.c src/utils.c
TEST_SRC = tests/test_suite.c src/utils.c
OBJ = $(SRC:.c=.o)
TEST_OBJ = $(TEST_SRC:.c=.o)

EXEC = myapp
TEST_EXEC = test_suite

# Build normal
all: $(EXEC)

$(EXEC): $(OBJ)
	$(CC) $^ -o $@ $(LDFLAGS)

%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@

# Build avec couverture
coverage: CFLAGS += $(COVERAGE_FLAGS)
coverage: LDFLAGS += $(COVERAGE_FLAGS)
coverage: clean all $(TEST_EXEC)

# Tests
$(TEST_EXEC): $(TEST_OBJ)
	$(CC) $^ -o $@ $(LDFLAGS)

test: $(TEST_EXEC)
	./$(TEST_EXEC)

# Rapport de couverture
coverage-report: coverage test
	@echo "ğŸ“Š Generating coverage report..."
	@./scripts/generate_report.sh

# VÃ©rifier le seuil
coverage-check: coverage-report
	@./scripts/check_coverage.sh 80

# Nettoyer
clean:
	rm -f $(OBJ) $(TEST_OBJ) $(EXEC) $(TEST_EXEC)
	rm -f *.gcno *.gcda *.gcov *.info
	rm -rf coverage_html/

.PHONY: all coverage test coverage-report coverage-check clean
```

### Workflow GitHub Actions final

```yaml
name: CI with Coverage

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  COVERAGE_THRESHOLD: 80

jobs:
  coverage:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup environment
        run: |
          sudo apt-get update
          sudo apt-get install -y gcc lcov gcovr

      - name: Build and test
        run: |
          make coverage-check

      - name: Generate reports
        run: |
          # HTML
          genhtml coverage_filtered.info \
                  --output-directory coverage_html

          # XML (Cobertura)
          gcovr --xml coverage.xml

      - name: Upload HTML report
        uses: actions/upload-artifact@v3
        with:
          name: coverage-report
          path: coverage_html/

      - name: Upload to Codecov
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage.xml
          fail_ci_if_error: true

      - name: Comment PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const data = fs.readFileSync('coverage_filtered.info', 'utf8');
            const match = data.match(/LF:(\d+).*LH:(\d+)/s);
            const coverage = ((match[2] / match[1]) * 100).toFixed(2);

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## ğŸ“Š Coverage Report\n\n**${coverage}%** (${match[2]}/${match[1]} lines)`
            });
```

---

## RÃ©sumÃ©

L'intÃ©gration de la couverture dans le CI est **essentielle** pour maintenir la qualitÃ© :

- âœ… **Automatisation complÃ¨te** : Plus de vÃ©rifications manuelles
- âœ… **QualitÃ© garantie** : Seuils respectÃ©s Ã  chaque commit
- âœ… **VisibilitÃ©** : Badges, rapports, graphiques
- âœ… **PrÃ©vention** : DÃ©tection prÃ©coce des rÃ©gressions
- âœ… **Collaboration** : Standards partagÃ©s par l'Ã©quipe

**Checklist d'intÃ©gration :**

- [ ] Workflow CI configurÃ© (GitHub Actions / GitLab CI)
- [ ] Build avec flags de couverture
- [ ] Tests exÃ©cutÃ©s automatiquement
- [ ] Rapports gÃ©nÃ©rÃ©s (HTML + XML)
- [ ] Seuils dÃ©finis et vÃ©rifiÃ©s
- [ ] Artifacts uploadÃ©s
- [ ] Service cloud configurÃ© (Codecov / Coveralls)
- [ ] Badges ajoutÃ©s au README
- [ ] Notifications configurÃ©es
- [ ] Documentation Ã  jour

**Workflow minimal recommandÃ© :**

```yaml
# 1. Build avec couverture
gcc -fprofile-arcs -ftest-coverage

# 2. ExÃ©cuter tests
./test_suite

# 3. GÃ©nÃ©rer rapport
lcov --capture && genhtml

# 4. VÃ©rifier seuil
./check_coverage.sh 80

# 5. Upload
codecov upload
```

**ğŸ’¡ Conseil final :** Commencez simple avec juste la vÃ©rification de seuil, puis ajoutez progressivement les fonctionnalitÃ©s avancÃ©es (badges, services cloud, notifications). L'important est d'avoir un systÃ¨me qui fonctionne et que l'Ã©quipe utilise rÃ©ellement. La couverture automatisÃ©e dans le CI transforme la qualitÃ© des tests d'une aspiration en une garantie ! ğŸš€

â­ï¸ [Gestion des Fichiers et EntrÃ©es/Sorties](/16-fichiers-et-io/README.md)
