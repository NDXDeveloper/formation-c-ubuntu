üîù Retour au [Sommaire](/SOMMAIRE.md)

# 15.2.2 Stepping (Avancer pas √† pas)

## Introduction

Une fois que vous avez plac√© des breakpoints et que votre programme est en pause dans GDB, vous avez besoin de **contr√¥ler l'ex√©cution** pour observer comment le code se comporte. C'est l√† qu'intervient le **stepping** (l'avancement pas √† pas).

Le stepping vous permet d'ex√©cuter votre programme **une ligne √† la fois**, comme si vous regardiez un film au ralenti. Vous pouvez ainsi observer l'√©volution des variables, comprendre le flux d'ex√©cution, et rep√©rer exactement o√π se produit un comportement inattendu.

---

## 1. Les Commandes de Base

GDB propose quatre commandes principales pour avancer dans le code :

| Commande | Raccourci | Action |
|----------|-----------|--------|
| `next` | `n` | Ex√©cute la ligne suivante (sans entrer dans les fonctions) |
| `step` | `s` | Ex√©cute la ligne suivante (en entrant dans les fonctions) |
| `finish` | `fin` | Continue jusqu'√† la fin de la fonction actuelle |
| `continue` | `c` | Continue l'ex√©cution jusqu'au prochain breakpoint |

Ces quatre commandes constituent **99% du stepping** que vous ferez en pratique. Comprenons-les en d√©tail.

---

## 2. La Commande `next` : Rester au M√™me Niveau

### Qu'est-ce que `next` ?

La commande `next` ex√©cute **une ligne de code** et s'arr√™te √† la ligne suivante du **m√™me niveau**. Si la ligne contient un appel de fonction, `next` **ex√©cute toute la fonction** d'un coup sans s'arr√™ter √† l'int√©rieur.

### Analogie

Imaginez que vous lisez un livre :
- Avec `next`, vous lisez **une phrase √† la fois**
- Si la phrase dit "consultez l'annexe B", vous allez √† l'annexe, la lisez enti√®rement, puis revenez √† la phrase suivante
- Vous ne vous arr√™tez **pas** dans l'annexe pour lire phrase par phrase

### Exemple Concret

Consid√©rons ce programme :

```c
#include <stdio.h>

int multiplier(int a, int b) {
    int resultat = a * b;
    return resultat;
}

int main() {
    int x = 5;
    int y = 10;
    int produit = multiplier(x, y);  // Ligne 11
    printf("Produit : %d\n", produit);
    return 0;
}
```

Dans GDB, apr√®s avoir plac√© un breakpoint au d√©but de `main()` :

```gdb
(gdb) break main
Breakpoint 1 at 0x1149: file exemple.c, line 8.

(gdb) run
Starting program: ./exemple  
Breakpoint 1, main () at exemple.c:8  
8           int x = 5;

(gdb) next
9           int y = 10;

(gdb) next
11          int produit = multiplier(x, y);

(gdb) next
12          printf("Produit : %d\n", produit);
Produit : 50
```

**Remarquez** : √Ä la ligne 11, `next` a ex√©cut√© **toute la fonction** `multiplier()` d'un seul coup. Nous n'avons **pas** vu les lignes 4 et 5 √† l'int√©rieur de cette fonction.

### Quand utiliser `next` ?

Utilisez `next` quand :
- Vous faites confiance aux fonctions appel√©es
- Vous voulez rester au niveau actuel de l'ex√©cution
- Vous d√©boguez la logique **entre** les appels de fonctions, pas √† l'int√©rieur
- Vous voulez avancer rapidement dans le code

**Astuce** : `next` est probablement la commande que vous utiliserez le plus souvent !

---

## 3. La Commande `step` : Plonger dans les Fonctions

### Qu'est-ce que `step` ?

La commande `step` ex√©cute **une ligne de code** et s'arr√™te √† la ligne suivante. Mais contrairement √† `next`, si la ligne contient un appel de fonction, `step` **entre √† l'int√©rieur** de cette fonction et s'arr√™te √† sa premi√®re ligne.

### Analogie

Reprenant l'analogie du livre :
- Avec `step`, quand vous lisez "consultez l'annexe B"
- Vous **allez dans l'annexe** et lisez **la premi√®re phrase**
- Puis vous pouvez continuer phrase par phrase dans l'annexe

### Exemple Concret

Reprenons le m√™me programme :

```c
#include <stdio.h>

int multiplier(int a, int b) {
    int resultat = a * b;
    return resultat;
}

int main() {
    int x = 5;
    int y = 10;
    int produit = multiplier(x, y);
    printf("Produit : %d\n", produit);
    return 0;
}
```

Cette fois, utilisons `step` au lieu de `next` :

```gdb
(gdb) break main
(gdb) run
Breakpoint 1, main () at exemple.c:8
8           int x = 5;

(gdb) next
9           int y = 10;

(gdb) next
11          int produit = multiplier(x, y);

(gdb) step
multiplier (a=5, b=10) at exemple.c:4
4           int resultat = a * b;
```

**Voyez-vous la diff√©rence ?** Avec `step`, nous sommes **entr√©s dans la fonction** `multiplier()` ! GDB nous montre m√™me les valeurs des param√®tres (`a=5, b=10`).

Continuons :

```gdb
(gdb) next
5           return resultat;

(gdb) next
6       }

(gdb) next
main () at exemple.c:12
12          printf("Produit : %d\n", produit);
```

Nous avons parcouru **l'int√©rieur** de `multiplier()` ligne par ligne, puis nous sommes revenus dans `main()`.

### Quand utiliser `step` ?

Utilisez `step` quand :
- Vous suspectez un bug **√† l'int√©rieur** d'une fonction
- Vous voulez comprendre comment une fonction fonctionne
- Vous d√©boguez une fonction que vous ne connaissez pas bien
- Vous voulez suivre l'ex√©cution en profondeur

### Pi√®ge : Entrer dans les Fonctions de Biblioth√®que

‚ö†Ô∏è **Attention** : `step` entre dans **toutes les fonctions**, y compris celles de la biblioth√®que standard (`printf`, `strlen`, etc.).

Par exemple :

```gdb
(gdb) step
printf("Bonjour\n");

(gdb) step
# GDB entre dans le code assembleur de printf !
__printf (format=0x555555556004 "Bonjour\n") at printf.c:28
```

Cela peut √™tre d√©routant ! Si vous entrez accidentellement dans une fonction de biblioth√®que, utilisez `finish` (voir section suivante) pour en sortir rapidement.

**Astuce** : Pour √©viter d'entrer dans certaines fonctions, vous pouvez configurer GDB avec la commande `skip` :

```gdb
skip function printf  
skip function strlen  
```

---

## 4. La Commande `finish` : Sortir d'une Fonction

### Qu'est-ce que `finish` ?

La commande `finish` dit √† GDB : *"Continue l'ex√©cution jusqu'√† ce que la fonction actuelle se termine, puis arr√™te-toi"*.

### Analogie

Si vous √™tes dans l'annexe B d'un livre et que vous r√©alisez qu'elle ne vous int√©resse pas, `finish` vous ram√®ne directement √† la page o√π vous √©tiez dans le texte principal, **sans lire le reste de l'annexe phrase par phrase**.

### Exemple Concret

Reprenons notre exemple, mais cette fois, imaginons que nous sommes entr√©s par erreur dans `multiplier()` :

```gdb
(gdb) break main
(gdb) run
Breakpoint 1, main () at exemple.c:8

(gdb) next
(gdb) next
11          int produit = multiplier(x, y);

(gdb) step
multiplier (a=5, b=10) at exemple.c:4
4           int resultat = a * b;

# Oups, je ne voulais pas entrer ici !
(gdb) finish
Run till exit from #0  multiplier (a=5, b=10) at exemple.c:4
0x0000555555555169 in main () at exemple.c:11
11          int produit = multiplier(x, y);
Value returned is $1 = 50
```

**Remarquez** : GDB nous dit m√™me la **valeur de retour** de la fonction (`50`) ! C'est tr√®s pratique pour v√©rifier qu'une fonction retourne la bonne valeur.

### Quand utiliser `finish` ?

Utilisez `finish` quand :
- Vous √™tes entr√© dans une fonction par erreur
- Vous avez vu ce que vous vouliez voir dans la fonction
- Vous voulez conna√Ætre la valeur de retour d'une fonction
- Vous voulez revenir rapidement au niveau sup√©rieur

---

## 5. La Commande `continue` : Aller au Prochain Breakpoint

### Qu'est-ce que `continue` ?

La commande `continue` reprend l'ex√©cution **normale** du programme jusqu'√† ce qu'il rencontre :
- Un autre breakpoint
- Un watchpoint (variable modifi√©e)
- Un catchpoint (√©v√©nement syst√®me)
- La fin du programme
- Un signal (comme SIGSEGV pour un crash)

### Analogie

Si `next` et `step` vous font avancer phrase par phrase, `continue` vous fait **tourner les pages** jusqu'au prochain marque-page (breakpoint).

### Exemple Concret

Imaginons un programme avec plusieurs breakpoints :

```c
#include <stdio.h>

void etape1() {
    printf("√âtape 1\n");
}

void etape2() {
    printf("√âtape 2\n");
}

void etape3() {
    printf("√âtape 3\n");
}

int main() {
    etape1();
    etape2();
    etape3();
    return 0;
}
```

Dans GDB :

```gdb
(gdb) break etape1
Breakpoint 1 at 0x1139

(gdb) break etape3
Breakpoint 2 at 0x1158

(gdb) run
Breakpoint 1, etape1 () at exemple.c:4
4           printf("√âtape 1\n");

(gdb) continue
Continuing.
√âtape 1
√âtape 2
Breakpoint 2, etape3 () at exemple.c:12
12          printf("√âtape 3\n");
```

**Remarquez** : `continue` a ex√©cut√© **tout le code** entre les deux breakpoints. Nous avons saut√© `etape2()` enti√®rement car il n'y avait pas de breakpoint dedans.

### Quand utiliser `continue` ?

Utilisez `continue` quand :
- Vous avez inspect√© l'√©tat actuel et voulez aller au prochain point d'int√©r√™t
- Vous avez plusieurs breakpoints strat√©giques
- Vous voulez laisser le programme s'ex√©cuter normalement jusqu'√† un √©v√©nement sp√©cifique
- Vous voulez avancer rapidement dans de grandes sections de code

---

## 6. Commandes Compl√©mentaires

### `stepi` et `nexti` : Stepping au Niveau Assembleur

Pour les d√©bogueurs **tr√®s avanc√©s**, GDB permet d'avancer **instruction par instruction** au niveau de l'assembleur :

- `stepi` (ou `si`) : Ex√©cute une instruction assembleur
- `nexti` (ou `ni`) : Ex√©cute une instruction assembleur (sans entrer dans les calls)

**Quand les utiliser ?**
- D√©bogage de code hautement optimis√©
- Analyse de code sans sources
- Reverse engineering
- Compr√©hension fine de l'ex√©cution au niveau CPU

Pour un d√©butant en C, vous n'aurez **presque jamais** besoin de ces commandes.

### `until` : Sortir d'une Boucle

La commande `until` (ou `u`) est tr√®s pratique pour sortir d'une boucle sans avoir √† faire `next` 1000 fois.

**Syntaxe :**

```gdb
until <ligne>
```

**Exemple :**

```c
for (int i = 0; i < 1000; i++) {
    traiter(i);  // Ligne 10
}
printf("Fin de boucle\n");  // Ligne 12
```

Dans GDB :

```gdb
(gdb) break 10
Breakpoint 1, main () at boucle.c:10
10              traiter(i);

(gdb) until 12
Fin de boucle  
main () at boucle.c:12  
12      printf("Fin de boucle\n");
```

Le programme a ex√©cut√© toute la boucle d'un coup et s'est arr√™t√© √† la ligne 12 !

### `advance` : Aller √† un Point Sp√©cifique

La commande `advance` est similaire √† `until`, mais fonctionne m√™me si le point cible est dans une autre fonction.

```gdb
advance fonction_cible  
advance fichier.c:42  
```

---

## 7. Strat√©gies de Stepping Efficaces

### Strat√©gie 1 : Le Stepping "Sandwich"

**Probl√®me** : Vous savez que le bug est entre la ligne 50 et la ligne 100.

**Solution** :
1. Placez un breakpoint √† la ligne 50
2. Utilisez `continue` pour y arriver
3. Utilisez `next` pour avancer ligne par ligne
4. D√®s que vous voyez quelque chose de suspect, utilisez `step` pour creuser

```gdb
(gdb) break 50
(gdb) run
(gdb) next
(gdb) next
(gdb) next  # La variable a une valeur bizarre ici
(gdb) step  # Entrons dans cette fonction pour voir ce qui se passe
```

### Strat√©gie 2 : Le Stepping "Zoom In/Out"

**Probl√®me** : Vous avez une longue cha√Æne d'appels de fonctions.

**Solution** :
- Utilisez `next` pour rester en vue d'ensemble (zoom out)
- Utilisez `step` quand vous voulez voir les d√©tails (zoom in)
- Utilisez `finish` pour remonter rapidement (zoom out)

```gdb
main()
  ‚îú‚îÄ fonction_a()  ‚Üê next (pas besoin de voir)
  ‚îú‚îÄ fonction_b()  ‚Üê step (suspect !)
  ‚îÇ   ‚îú‚îÄ sous_fonction_1()  ‚Üê step (creusons)
  ‚îÇ   ‚îÇ   ‚îî‚îÄ ...  ‚Üê finish (pas int√©ressant finalement)
  ‚îÇ   ‚îî‚îÄ sous_fonction_2()  ‚Üê step (le bug est ici !)
```

### Strat√©gie 3 : Stepping avec Watchpoints

Combinez le stepping avec les watchpoints pour une puissance maximale :

```gdb
(gdb) break fonction_suspecte
(gdb) run
(gdb) watch variable_importante
(gdb) continue
# Le watchpoint s'active
(gdb) step  # Maintenant, steppez pour voir exactement ce qui modifie la variable
```

### Strat√©gie 4 : R√©p√©ter la Derni√®re Commande

**Astuce √©norme** : Appuyer sur `Entr√©e` sans taper de commande r√©p√®te la **derni√®re commande**.

Cela signifie que pour avancer avec `next`, vous pouvez faire :

```gdb
(gdb) next
(gdb) [Entr√©e]
(gdb) [Entr√©e]
(gdb) [Entr√©e]
```

C'est **beaucoup** plus rapide que de taper `next` √† chaque fois !

---

## 8. Diff√©rences Cl√©s : next vs step

Clarifions une fois pour toutes la diff√©rence entre `next` et `step` avec un tableau :

| Situation | `next` | `step` |
|-----------|--------|--------|
| Ligne simple (`x = 5;`) | Ex√©cute et passe √† la ligne suivante | Ex√©cute et passe √† la ligne suivante |
| Appel de fonction | Ex√©cute **toute** la fonction | Entre **dans** la fonction |
| Fonction de biblioth√®que | Ex√©cute toute la fonction | Entre dans le code de la biblioth√®que |
| Boucle | Passe √† l'it√©ration suivante | Passe √† l'it√©ration suivante |

**Mn√©motechnique** :
- **next** = "prochain" = reste au **m√™me niveau**
- **step** = "descendre une marche" = va **plus profond**

---

## 9. Visualisation de l'Ex√©cution

Imaginons cette hi√©rarchie de fonctions :

```
main()
‚îÇ
‚îú‚îÄ> calcul_total()
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ> addition(a, b)
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ> multiplication(c, d)
‚îÇ
‚îî‚îÄ> afficher_resultat()
```

### Avec `next` :

```
main()           ‚Üê Vous √™tes ici
‚îÇ
‚îú‚îÄ> calcul_total()   ‚Üê next ex√©cute tout ceci d'un coup
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ> addition(a, b)
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ> multiplication(c, d)
‚îÇ
‚îî‚îÄ> afficher_resultat()  ‚Üê Vous arrivez ici
```

### Avec `step` :

```
main()           ‚Üê Vous √™tes ici
‚îÇ
‚îú‚îÄ> calcul_total()   ‚Üê step vous am√®ne ici
    ‚îÇ
    ‚îú‚îÄ> addition(a, b)  ‚Üê puis step vous am√®ne ici
    ‚îÇ
    ‚îî‚îÄ> multiplication(c, d)  ‚Üê et ainsi de suite
```

### Avec `finish` :

```
main()
‚îÇ
‚îú‚îÄ> calcul_total()
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ> addition(a, b)  ‚Üê Vous √™tes quelque part ici
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ> multiplication(c, d)  ‚Üê finish vous ram√®ne ici (dans calcul_total)
‚îÇ
‚îî‚îÄ> afficher_resultat()
```

> **Note** : `finish` remonte d'**un seul niveau**. Si vous √™tes dans `addition()`, `finish` vous ram√®ne dans `calcul_total()` (la fonction appelante), pas dans `main()`. Pour remonter jusqu'√† `main()`, il faudrait un deuxi√®me `finish`.

---

## 10. Erreurs Courantes et Comment les √âviter

### Erreur 1 : Utiliser `step` sur `printf()`

**Sympt√¥me** : Vous tapez `step` et vous vous retrouvez dans du code assembleur incompr√©hensible.

**Cause** : Vous √™tes entr√© dans l'impl√©mentation de `printf()`.

**Solution** :
```gdb
(gdb) finish  # Sortir rapidement
# Ou configurez GDB pour skip :
(gdb) skip function printf
```

### Erreur 2 : Oublier de Compiler avec `-g`

**Sympt√¥me** : GDB ne montre pas les num√©ros de ligne, juste des adresses m√©moire.

**Cause** : Le programme n'a pas √©t√© compil√© avec les informations de d√©bogage.

**Solution** :
```bash
gcc -g -o programme programme.c
```

### Erreur 3 : Utiliser `next` au Lieu de `step`

**Sympt√¥me** : Vous voulez voir l'int√©rieur d'une fonction mais elle s'ex√©cute d'un coup.

**Cause** : Vous avez utilis√© `next` au lieu de `step`.

**Solution** :
- Relancez le programme (`run`)
- Replacez-vous au m√™me endroit
- Cette fois, utilisez `step`

### Erreur 4 : Trop de `next` dans une Boucle

**Sympt√¥me** : Vous faites `next` 500 fois dans une boucle de 1000 it√©rations.

**Cause** : Vous n'utilisez pas les bonnes commandes.

**Solution** :
```gdb
# Option 1 : Breakpoint conditionnel
break fichier.c:25 if i == 999

# Option 2 : Until
until <ligne_apr√®s_la_boucle>

# Option 3 : Continue
# (si vous avez un autre breakpoint apr√®s la boucle)
```

---

## 11. Cas d'Usage Pratiques

### Cas 1 : D√©boguer un Segfault

```c
int main() {
    int *ptr = NULL;
    *ptr = 42;  // Crash ici
    return 0;
}
```

**D√©marche** :
```gdb
(gdb) run
Program received signal SIGSEGV, Segmentation fault.
0x0000555555555149 in main () at crash.c:3
3           *ptr = 42;

# GDB s'est arr√™t√© √† la ligne qui crash !
(gdb) print ptr
$1 = (int *) 0x0  # Ah ! Le pointeur est NULL
```

Pas besoin de stepping ici, mais ensuite vous pouvez faire `step` pour voir comment `ptr` est devenu NULL.

### Cas 2 : Variable avec Valeur Incorrecte

```c
int calculer(int n) {
    int resultat = 0;
    for (int i = 0; i < n; i++) {
        resultat += i;
    }
    return resultat;
}

int main() {
    int somme = calculer(10);
    printf("Somme : %d\n", somme);  // Donne un r√©sultat incorrect
    return 0;
}
```

**D√©marche** :
```gdb
(gdb) break calculer
(gdb) run
Breakpoint 1, calculer (n=10) at bug.c:2

(gdb) watch resultat
Hardware watchpoint 2: resultat

(gdb) continue
# Observez comment resultat change √† chaque it√©ration

(gdb) next
(gdb) print resultat
(gdb) next
(gdb) print resultat
# Vous verrez exactement o√π le calcul se trompe
```

### Cas 3 : Comprendre un Algorithme Complexe

Vous lisez du code open-source et ne comprenez pas comment fonctionne un algorithme :

```gdb
(gdb) break fonction_mysterieuse
(gdb) run
(gdb) step  # Entrez dans chaque fonction
(gdb) print variable_importante  # Inspectez les variables
(gdb) next  # Avancez ligne par ligne
# Progressivement, vous comprendrez la logique
```

---

## 12. R√©sum√© des Commandes

### Tableau R√©capitulatif

| Commande | Raccourci | Action | Utilisation |
|----------|-----------|--------|-------------|
| `next` | `n` | Ligne suivante (sans entrer) | Navigation rapide au m√™me niveau |
| `step` | `s` | Ligne suivante (avec entr√©e) | Explorer l'int√©rieur des fonctions |
| `finish` | `fin` | Fin de fonction actuelle | Sortir d'une fonction |
| `continue` | `c` | Jusqu'au prochain breakpoint | Sauter de grandes sections |
| `until` | `u` | Jusqu'√† une ligne | Sortir de boucles |
| `stepi` | `si` | Instruction assembleur (avec entr√©e) | D√©bogage bas niveau |
| `nexti` | `ni` | Instruction assembleur (sans entr√©e) | D√©bogage bas niveau |

### Flux de D√©cision

```
Dois-je voir l'int√©rieur de cette fonction ?
‚îú‚îÄ OUI ‚Üí step
‚îî‚îÄ NON ‚Üí next

Suis-je dans une fonction par erreur ?
‚îî‚îÄ OUI ‚Üí finish

Dois-je aller au prochain point d'int√©r√™t ?
‚îî‚îÄ OUI ‚Üí continue

Dois-je sortir de cette boucle ?
‚îî‚îÄ OUI ‚Üí until <ligne>
```

---

## 13. Conseils Avanc√©s

### Conseil 1 : Combinez avec TUI Mode

GDB poss√®de un **mode interface texte** (TUI) qui affiche le code source pendant que vous steppez :

```gdb
(gdb) tui enable
# Ou utilisez Ctrl+X puis A
```

Cela vous permet de **voir le code** pendant que vous steppez, sans avoir √† taper `list` constamment.

### Conseil 2 : Utilisez des Macros

Si vous faites souvent la m√™me s√©quence de commandes, cr√©ez une macro :

```gdb
(gdb) define ns
> next
> print ma_variable
> end

(gdb) ns
# Ex√©cute next puis print ma_variable
```

### Conseil 3 : Historique des Commandes

Utilisez les fl√®ches ‚Üë et ‚Üì pour naviguer dans l'historique des commandes, comme dans le terminal.

### Conseil 4 : Automatisation

Vous pouvez cr√©er un script GDB pour automatiser votre d√©bogage :

```gdb
# fichier: debug.gdb
break main  
run  
next  
next  
step  
print x  
continue  
```

Puis lancer :
```bash
gdb -x debug.gdb ./programme
```

---

## Prochaines √âtapes

Maintenant que vous ma√Ætrisez le stepping, vous √™tes pr√™t √† explorer :
- **15.2.3 Backtrace** : Analyser la pile d'appels pour comprendre le chemin d'ex√©cution
- **15.2.4 Inspection des variables** : Examiner en profondeur les structures de donn√©es
- **15.3 GDB avanc√©** : Core dumps, debugging distant, et time travel debugging

Le stepping est la **comp√©tence fondamentale** du d√©bogage. Avec de la pratique, vous d√©velopperez une intuition pour savoir quand utiliser `next`, `step`, `finish` ou `continue`. C'est cette intuition qui transforme un d√©bogage de 2 heures en un d√©bogage de 10 minutes !

---

**üí° Astuce finale :** Au d√©but, vous aurez l'impression de perdre du temps √† stepper ligne par ligne. C'est normal ! Avec l'exp√©rience, vous apprendrez √† utiliser les bonnes commandes aux bons moments, et le d√©bogage deviendra une seconde nature. La cl√© est la **pratique r√©guli√®re**.

‚è≠Ô∏è [Backtrace et analyse de la pile](/15-debogage-et-qualite/02.3-backtrace.md)
