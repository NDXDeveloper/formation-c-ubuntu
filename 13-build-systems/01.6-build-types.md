ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 13.1.6 Build types

## Introduction

Lorsque vous dÃ©veloppez un projet C, vous avez besoin de diffÃ©rentes configurations selon le contexte :
- **DÃ©veloppement** : Vous voulez des informations de debug, des vÃ©rifications supplÃ©mentaires, quitte Ã  ce que le code soit lent
- **Production** : Vous voulez un code optimisÃ©, rapide, compact, sans overhead de debug

CMake gÃ¨re ces diffÃ©rents contextes via les **build types** (types de build). Comprendre et utiliser correctement ces build types est essentiel pour tout dÃ©veloppeur C.

---

## Qu'est-ce qu'un build type ?

Un **build type** est une configuration prÃ©dÃ©finie qui dÃ©termine :
1. Les **flags de compilation** (optimisation, debug, warnings)
2. Les **dÃ©finitions de prÃ©processeur** (macros comme `NDEBUG`)
3. Le **comportement du code** (assertions activÃ©es ou non)

**Analogie** : C'est comme les diffÃ©rents modes d'une voiture :
- Mode "Eco" â†’ Build Debug (lent mais Ã©conomique en bugs)
- Mode "Sport" â†’ Build Release (rapide mais sans filet de sÃ©curitÃ©)

---

## Les quatre build types standard

CMake dÃ©finit quatre build types standard via la variable `CMAKE_BUILD_TYPE` :

### 1. Debug - Pour le dÃ©veloppement

```bash
cmake -B build -DCMAKE_BUILD_TYPE=Debug
```

**CaractÃ©ristiques** :
- âœ… Symboles de debug inclus (`-g`)
- âœ… Aucune optimisation (`-O0`)
- âœ… Assertions activÃ©es
- âŒ Code plus lent (2-10x)
- âŒ Binaires plus gros

**Flags GCC/Clang typiques** :
```
-g -O0
```

**Quand l'utiliser ?**
- DÃ©veloppement quotidien
- Debugging avec GDB/LLDB
- DÃ©tection de bugs avec Valgrind/sanitizers
- Tests unitaires

### 2. Release - Pour la production

```bash
cmake -B build -DCMAKE_BUILD_TYPE=Release
```

**CaractÃ©ristiques** :
- âœ… Optimisations maximales (`-O3`)
- âœ… Code rapide
- âœ… Binaires compacts
- âŒ Pas de symboles de debug
- âŒ Assertions dÃ©sactivÃ©es (`-DNDEBUG`)

**Flags GCC/Clang typiques** :
```
-O3 -DNDEBUG
```

**Quand l'utiliser ?**
- DÃ©ploiement en production
- Benchmarks de performance
- Distribution aux utilisateurs finaux

### 3. RelWithDebInfo - Release avec informations de debug

```bash
cmake -B build -DCMAKE_BUILD_TYPE=RelWithDebInfo
```

**CaractÃ©ristiques** :
- âœ… Optimisations activÃ©es (`-O2`)
- âœ… Symboles de debug inclus (`-g`)
- âœ… Compromis performance/debuggabilitÃ©
- âŒ Assertions dÃ©sactivÃ©es (`-DNDEBUG`)

**Flags GCC/Clang typiques** :
```
-O2 -g -DNDEBUG
```

**Quand l'utiliser ?**
- Profiling de code optimisÃ©
- Debug de problÃ¨mes en production
- Tests de performance avec traÃ§abilitÃ©
- CI/CD (tests sur code optimisÃ©)

### 4. MinSizeRel - Optimisation pour la taille

```bash
cmake -B build -DCMAKE_BUILD_TYPE=MinSizeRel
```

**CaractÃ©ristiques** :
- âœ… Optimisation pour taille minimale (`-Os`)
- âœ… Binaires trÃ¨s compacts
- âŒ Peut Ãªtre lÃ©gÃ¨rement plus lent que Release
- âŒ Pas de symboles de debug

**Flags GCC/Clang typiques** :
```
-Os -DNDEBUG
```

**Quand l'utiliser ?**
- SystÃ¨mes embarquÃ©s (mÃ©moire limitÃ©e)
- Distributions statiques
- Containers Docker (images plus petites)

---

## Comparaison des build types

### Tableau rÃ©capitulatif

| Build Type | Optimisation | Symboles Debug | Assertions | Vitesse | Taille | Usage principal |
|------------|--------------|----------------|------------|---------|--------|-----------------|
| **Debug** | Aucune (`-O0`) | âœ… Oui (`-g`) | âœ… Oui | âš ï¸ Lent | ğŸ“¦ Gros | DÃ©veloppement |
| **Release** | Max (`-O3`) | âŒ Non | âŒ Non | âš¡ Rapide | ğŸ“¦ Moyen | Production |
| **RelWithDebInfo** | Ã‰levÃ©e (`-O2`) | âœ… Oui (`-g`) | âŒ Non | âš¡ Rapide | ğŸ“¦ Gros | Profiling/CI |
| **MinSizeRel** | Taille (`-Os`) | âŒ Non | âŒ Non | âš¡ Moyen | ğŸ“¦ Petit | EmbarquÃ© |

### Exemple concret : Impact sur un programme

```c
// Programme simple : calcul intensif
#include <stdio.h>
#include <assert.h>

int fibonacci(int n) {
    assert(n >= 0);  // âœ… Actif en Debug, âŒ dÃ©sactivÃ© en Release
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

int main(void) {
    printf("Fib(40) = %d\n", fibonacci(40));
    return 0;
}
```

**RÃ©sultats de build** :

| Build Type | Temps exÃ©cution | Taille binaire | Debugging possible |
|------------|-----------------|----------------|--------------------|
| Debug | 12.5 secondes | 22 KB | âœ… Oui (avec GDB) |
| Release | 2.1 secondes | 14 KB | âŒ Non |
| RelWithDebInfo | 2.3 secondes | 18 KB | âœ… Oui (limitÃ©) |
| MinSizeRel | 2.4 secondes | 12 KB | âŒ Non |

**Observation** : Release est **6x plus rapide** que Debug !

---

## Configurer le build type

### MÃ©thode 1 : Ligne de commande (recommandÃ©e)

```bash
# Debug
cmake -B build -DCMAKE_BUILD_TYPE=Debug
cmake --build build

# Release
cmake -B build-release -DCMAKE_BUILD_TYPE=Release
cmake --build build-release

# RelWithDebInfo
cmake -B build-prof -DCMAKE_BUILD_TYPE=RelWithDebInfo
cmake --build build-prof
```

### MÃ©thode 2 : Variable d'environnement

```bash
export CMAKE_BUILD_TYPE=Release
cmake -B build
```

### MÃ©thode 3 : Dans le CMakeLists.txt (dÃ©conseillÃ©)

```cmake
# âŒ Ã€ Ã‰VITER : Force un build type, empÃªche l'utilisateur de choisir
set(CMAKE_BUILD_TYPE Release)
```

**Pourquoi Ã©viter ?** Cela empÃªche l'utilisateur de choisir son propre build type.

### MÃ©thode recommandÃ©e : Valeur par dÃ©faut avec possibilitÃ© de surcharge

```cmake
# DÃ©finir Debug par dÃ©faut SI l'utilisateur n'a rien spÃ©cifiÃ©
if(NOT CMAKE_BUILD_TYPE)
    set(CMAKE_BUILD_TYPE Debug CACHE STRING "Build type (Debug, Release, RelWithDebInfo, MinSizeRel)" FORCE)
endif()

message(STATUS "Build type: ${CMAKE_BUILD_TYPE}")
```

---

## Organiser plusieurs build types

### Pattern 1 : RÃ©pertoires sÃ©parÃ©s (recommandÃ©)

```bash
# CrÃ©er plusieurs rÃ©pertoires de build
cmake -B build-debug -DCMAKE_BUILD_TYPE=Debug
cmake -B build-release -DCMAKE_BUILD_TYPE=Release
cmake -B build-prof -DCMAKE_BUILD_TYPE=RelWithDebInfo

# Compiler selon le besoin
cmake --build build-debug      # Pour dÃ©velopper
cmake --build build-release    # Pour tester la perf
cmake --build build-prof       # Pour profiler
```

**Avantages** :
- âœ… Pas de recompilation complÃ¨te lors du changement de type
- âœ… Comparaisons faciles entre versions
- âœ… Pas de confusion

**Structure du projet** :
```
mon_projet/
â”œâ”€â”€ CMakeLists.txt
â”œâ”€â”€ src/
â”œâ”€â”€ build-debug/       # Debug
â”‚   â””â”€â”€ mon_app
â”œâ”€â”€ build-release/     # Release
â”‚   â””â”€â”€ mon_app
â””â”€â”€ build-prof/        # RelWithDebInfo
    â””â”€â”€ mon_app
```

### Pattern 2 : Script de build

```bash
#!/bin/bash
# build_all.sh - Compiler tous les build types

echo "ğŸ”¨ Building Debug..."
cmake -B build-debug -DCMAKE_BUILD_TYPE=Debug
cmake --build build-debug

echo "ğŸš€ Building Release..."
cmake -B build-release -DCMAKE_BUILD_TYPE=Release
cmake --build build-release

echo "ğŸ“Š Building RelWithDebInfo..."
cmake -B build-prof -DCMAKE_BUILD_TYPE=RelWithDebInfo
cmake --build build-prof

echo "âœ… All builds complete!"
echo "  Debug:   ./build-debug/mon_app"
echo "  Release: ./build-release/mon_app"
echo "  Profiling: ./build-prof/mon_app"
```

### Pattern 3 : Generators multi-config

Certains generators (Visual Studio, Xcode, Ninja Multi-Config) supportent plusieurs configurations dans le mÃªme rÃ©pertoire :

```bash
# Configurer une fois
cmake -B build -G "Ninja Multi-Config"

# Compiler chaque type sans reconfigurer
cmake --build build --config Debug
cmake --build build --config Release
cmake --build build --config RelWithDebInfo
```

**Note** : Moins utilisÃ© sur Linux (oÃ¹ Make et Ninja simple sont prÃ©fÃ©rÃ©s).

---

## Personnaliser les flags par build type

### Ajouter des flags Ã  un build type spÃ©cifique

```cmake
# Flags supplÃ©mentaires pour Debug
set(CMAKE_C_FLAGS_DEBUG "${CMAKE_C_FLAGS_DEBUG} -fsanitize=address -fno-omit-frame-pointer")

# Flags supplÃ©mentaires pour Release
set(CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE} -flto -march=native")
```

**RÃ©sultat** :
- Debug : `-g -O0 -fsanitize=address -fno-omit-frame-pointer`
- Release : `-O3 -DNDEBUG -flto -march=native`

### Exemple : Sanitizers en Debug uniquement

```cmake
if(CMAKE_BUILD_TYPE STREQUAL "Debug")
    message(STATUS "Activation des sanitizers pour Debug")
    add_compile_options(-fsanitize=address -fsanitize=undefined)
    add_link_options(-fsanitize=address -fsanitize=undefined)
endif()
```

### Exemple : Optimisations agressives en Release

```cmake
if(CMAKE_BUILD_TYPE STREQUAL "Release")
    message(STATUS "Optimisations agressives activÃ©es")
    add_compile_options(
        -O3
        -march=native     # Optimise pour le CPU actuel
        -flto            # Link-Time Optimization
        -ffast-math      # Optimisations mathÃ©matiques (attention : peut casser IEEE 754)
    )
endif()
```

---

## VÃ©rifier le build type dans le code C

### Utiliser les macros dÃ©finies par CMake

En mode Release, CMake dÃ©finit automatiquement `NDEBUG` :

```c
#include <stdio.h>
#include <assert.h>

int main(void) {
#ifdef NDEBUG
    printf("Build: RELEASE (optimisÃ©)\n");
#else
    printf("Build: DEBUG (non optimisÃ©)\n");
#endif

    int x = 42;
    assert(x > 0);  // âœ… VÃ©rifiÃ© en Debug, âŒ ignorÃ© en Release

    return 0;
}
```

### DÃ©finir vos propres macros selon le build type

```cmake
if(CMAKE_BUILD_TYPE STREQUAL "Debug")
    target_compile_definitions(mon_app PRIVATE DEBUG_MODE=1)
elseif(CMAKE_BUILD_TYPE STREQUAL "Release")
    target_compile_definitions(mon_app PRIVATE RELEASE_MODE=1)
endif()
```

Dans le code C :
```c
#ifdef DEBUG_MODE
    printf("[DEBUG] Valeur de x = %d\n", x);
#endif

#ifdef RELEASE_MODE
    // Code spÃ©cifique Ã  la production
#endif
```

### Pattern : Logging conditionnel

```c
#ifdef NDEBUG
#define LOG_DEBUG(...)  // Ne rien faire en Release
#else
#define LOG_DEBUG(fmt, ...) \
    fprintf(stderr, "[DEBUG] " fmt "\n", ##__VA_ARGS__)
#endif

int main(void) {
    int result = compute();
    LOG_DEBUG("RÃ©sultat du calcul : %d", result);  // Visible uniquement en Debug
    return 0;
}
```

---

## DÃ©tection automatique si aucun build type n'est spÃ©cifiÃ©

### Pattern recommandÃ©

```cmake
# Si l'utilisateur n'a pas spÃ©cifiÃ© de build type
if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
    message(STATUS "Aucun build type spÃ©cifiÃ©, utilisation de Debug par dÃ©faut")
    set(CMAKE_BUILD_TYPE Debug CACHE STRING
        "Choisir le type de build (Debug, Release, RelWithDebInfo, MinSizeRel)"
        FORCE
    )
    # DÃ©finir les options possibles pour les GUI CMake
    set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS
        "Debug" "Release" "RelWithDebInfo" "MinSizeRel"
    )
endif()

message(STATUS "Build type: ${CMAKE_BUILD_TYPE}")
```

### Forcer Debug pour Ã©viter les erreurs

```cmake
# Pour les dÃ©butants : toujours utiliser Debug sauf si explicitement demandÃ©
if(NOT CMAKE_BUILD_TYPE)
    set(CMAKE_BUILD_TYPE Debug)
    message(WARNING "Pas de build type spÃ©cifiÃ©. Utilisation de Debug.")
    message(WARNING "Pour la production, utilisez: cmake -DCMAKE_BUILD_TYPE=Release")
endif()
```

---

## Cas d'usage pratiques

### DÃ©veloppement quotidien

```bash
# Configuration initiale (une seule fois)
cmake -B build -DCMAKE_BUILD_TYPE=Debug

# Compilation rapide aprÃ¨s modification
cmake --build build

# Debugging
gdb ./build/mon_app

# Valgrind
valgrind --leak-check=full ./build/mon_app
```

### Tests de performance

```bash
# Build optimisÃ©
cmake -B build-release -DCMAKE_BUILD_TYPE=Release
cmake --build build-release

# Benchmark
time ./build-release/mon_app

# Comparaison avec Debug
time ./build-debug/mon_app
```

### Profiling avec perf

```bash
# Build avec infos de debug mais optimisÃ©
cmake -B build-prof -DCMAKE_BUILD_TYPE=RelWithDebInfo
cmake --build build-prof

# Profiling
perf record ./build-prof/mon_app
perf report
```

### Packaging pour distribution

```bash
# Build ultra-optimisÃ©
cmake -B build-dist -DCMAKE_BUILD_TYPE=Release
cmake --build build-dist

# Strip des symboles (encore plus compact)
strip build-dist/mon_app

# CrÃ©er l'archive
tar -czf mon_app-1.0.0-linux-x86_64.tar.gz -C build-dist mon_app
```

---

## IntÃ©gration CI/CD

### Pattern : Tester plusieurs build types

**GitHub Actions** :
```yaml
name: Build

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        build_type: [Debug, Release, RelWithDebInfo]

    steps:
    - uses: actions/checkout@v3

    - name: Configure CMake
      run: cmake -B build -DCMAKE_BUILD_TYPE=${{ matrix.build_type }}

    - name: Build
      run: cmake --build build

    - name: Test
      run: ctest --test-dir build --output-on-failure
```

Ce workflow teste automatiquement les 3 build types Ã  chaque push !

---

## Erreurs courantes et solutions

### Erreur 1 : Build type vide

**SymptÃ´me** :
```bash
cmake -B build
# Aucun flag d'optimisation, pas de -g
```

**Cause** : `CMAKE_BUILD_TYPE` n'est pas dÃ©fini.

**Solution** :
```bash
cmake -B build -DCMAKE_BUILD_TYPE=Debug
```

### Erreur 2 : Build type mal orthographiÃ©

**SymptÃ´me** :
```bash
cmake -B build -DCMAKE_BUILD_TYPE=release
# CMake accepte mais n'utilise pas les flags attendus
```

**Cause** : Les build types sont **sensibles Ã  la casse** (`Release` â‰  `release`).

**Solution** :
```bash
# âœ… Correct
cmake -B build -DCMAKE_BUILD_TYPE=Release

# âŒ Incorrect
cmake -B build -DCMAKE_BUILD_TYPE=release
```

### Erreur 3 : MÃ©langer Debug et Release dans le mÃªme build

**SymptÃ´me** : Comportement imprÃ©visible, segfaults Ã©tranges.

**Cause** : Recompiler avec un build type diffÃ©rent sans nettoyer.

**Solution** :
```bash
# Toujours nettoyer quand on change de build type
rm -rf build
cmake -B build -DCMAKE_BUILD_TYPE=Release
```

Ou utiliser des rÃ©pertoires sÃ©parÃ©s :
```bash
cmake -B build-debug -DCMAKE_BUILD_TYPE=Debug
cmake -B build-release -DCMAKE_BUILD_TYPE=Release
```

### Erreur 4 : Assertions Ã©chouent en Release

**SymptÃ´me** :
```c
assert(ptr != NULL);  // Fonctionne en Debug, ignorÃ© en Release
```

**Explication** : En Release, `NDEBUG` dÃ©sactive `assert()`.

**Solution** : Pour les vÃ©rifications critiques, utilisez des vÃ©rifications explicites :
```c
// âŒ DÃ©sactivÃ© en Release
assert(ptr != NULL);

// âœ… Toujours actif
if (ptr == NULL) {
    fprintf(stderr, "Erreur: pointeur NULL\n");
    return -1;
}
```

---

## Bonnes pratiques

### 1. DÃ©veloppez toujours en Debug

```bash
# Workflow quotidien
cmake -B build -DCMAKE_BUILD_TYPE=Debug
cmake --build build
./build/mon_app
```

**Pourquoi ?**
- DÃ©tection prÃ©coce des bugs (assertions)
- Meilleur debugging
- Sanitizers plus efficaces

### 2. Testez rÃ©guliÃ¨rement en Release

```bash
# Avant chaque commit important
cmake -B build-release -DCMAKE_BUILD_TYPE=Release
cmake --build build-release
./build-release/mon_app
```

**Pourquoi ?**
- Les optimisations peuvent rÃ©vÃ©ler des bugs (ex: race conditions)
- Tester les performances rÃ©elles
- VÃ©rifier que les assertions ne masquent pas des bugs

### 3. Utilisez RelWithDebInfo pour le profiling

```bash
# Pour analyser les performances
cmake -B build-prof -DCMAKE_BUILD_TYPE=RelWithDebInfo
cmake --build build-prof

# Profiling avec gprof, perf, Valgrind Callgrind...
perf record -g ./build-prof/mon_app
perf report
```

### 4. Ne commitez JAMAIS les rÃ©pertoires de build

**.gitignore** :
```gitignore
# Builds
build/
build-*/
cmake-build-*/

# Cache CMake
CMakeCache.txt
CMakeFiles/
```

### 5. Documentez le build type recommandÃ©

**README.md** :
```markdown
## Compilation

### DÃ©veloppement
```bash
cmake -B build -DCMAKE_BUILD_TYPE=Debug
cmake --build build
```

### Production
```bash
cmake -B build -DCMAKE_BUILD_TYPE=Release
cmake --build build
```

### Profiling
```bash
cmake -B build -DCMAKE_BUILD_TYPE=RelWithDebInfo
cmake --build build
```
```

---

## Exemple complet : CMakeLists.txt avec gestion des build types

```cmake
cmake_minimum_required(VERSION 3.15)
project(MonApp VERSION 1.0.0 LANGUAGES C)

# ============================================
# BUILD TYPE PAR DÃ‰FAUT
# ============================================
if(NOT CMAKE_BUILD_TYPE)
    set(CMAKE_BUILD_TYPE Debug CACHE STRING
        "Build type (Debug, Release, RelWithDebInfo, MinSizeRel)"
        FORCE
    )
endif()

message(STATUS "")
message(STATUS "===========================================")
message(STATUS "  ${PROJECT_NAME} ${PROJECT_VERSION}")
message(STATUS "  Build type: ${CMAKE_BUILD_TYPE}")
message(STATUS "===========================================")

# ============================================
# CONFIGURATION SELON LE BUILD TYPE
# ============================================

if(CMAKE_BUILD_TYPE STREQUAL "Debug")
    message(STATUS "ğŸ› Configuration Debug:")
    message(STATUS "  - Symboles de debug activÃ©s")
    message(STATUS "  - Aucune optimisation")
    message(STATUS "  - Sanitizers activÃ©s")

    # AddressSanitizer pour dÃ©tecter les bugs mÃ©moire
    add_compile_options(-fsanitize=address -fno-omit-frame-pointer)
    add_link_options(-fsanitize=address)

    # Warnings stricts
    add_compile_options(-Wall -Wextra -Wpedantic -Werror)

elseif(CMAKE_BUILD_TYPE STREQUAL "Release")
    message(STATUS "ğŸš€ Configuration Release:")
    message(STATUS "  - Optimisations maximales")
    message(STATUS "  - Pas de symboles de debug")
    message(STATUS "  - Assertions dÃ©sactivÃ©es")

    # Optimisations agressives
    add_compile_options(-O3 -march=native)

elseif(CMAKE_BUILD_TYPE STREQUAL "RelWithDebInfo")
    message(STATUS "ğŸ“Š Configuration RelWithDebInfo:")
    message(STATUS "  - Optimisations activÃ©es")
    message(STATUS "  - Symboles de debug prÃ©sents")
    message(STATUS "  - IdÃ©al pour le profiling")

endif()

message(STATUS "")

# ============================================
# STANDARD C
# ============================================
set(CMAKE_C_STANDARD 11)
set(CMAKE_C_STANDARD_REQUIRED ON)

# ============================================
# EXÃ‰CUTABLE
# ============================================
add_executable(mon_app
    src/main.c
    src/utils.c
)

# DÃ©finir la version dans le code
target_compile_definitions(mon_app PRIVATE
    APP_VERSION="${PROJECT_VERSION}"
)

# En Debug, ajouter une macro DEBUG_MODE
if(CMAKE_BUILD_TYPE STREQUAL "Debug")
    target_compile_definitions(mon_app PRIVATE DEBUG_MODE=1)
endif()

# ============================================
# INSTALLATION
# ============================================
install(TARGETS mon_app DESTINATION bin)

# ============================================
# INFORMATIONS FINALES
# ============================================
message(STATUS "Configuration terminÃ©e !")
message(STATUS "")
message(STATUS "Pour compiler:")
message(STATUS "  cmake --build ${CMAKE_BINARY_DIR}")
message(STATUS "")
message(STATUS "Pour changer de build type:")
message(STATUS "  cmake -B ${CMAKE_BINARY_DIR} -DCMAKE_BUILD_TYPE=Release")
message(STATUS "")
```

**Sortie lors de la configuration** :

```
===========================================
  MonApp 1.0.0
  Build type: Debug
===========================================
ğŸ› Configuration Debug:
  - Symboles de debug activÃ©s
  - Aucune optimisation
  - Sanitizers activÃ©s

Configuration terminÃ©e !

Pour compiler:
  cmake --build build

Pour changer de build type:
  cmake -B build -DCMAKE_BUILD_TYPE=Release
```

---

## RÃ©capitulatif : Quel build type choisir ?

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     GUIDE DE DÃ‰CISION                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                â”‚
â”‚  DÃ©veloppement quotidien â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> Debug           â”‚
â”‚  Debugging avec GDB/Valgrind â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> Debug           â”‚
â”‚  Tests unitaires â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> Debug           â”‚
â”‚                                                                â”‚
â”‚  Profiling (perf, gprof) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> RelWithDebInfo â”‚
â”‚  CI/CD tests optimisÃ©s â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> RelWithDebInfo â”‚
â”‚                                                                â”‚
â”‚  Production / DÃ©ploiement â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> Release        â”‚
â”‚  Benchmarks de performance â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> Release        â”‚
â”‚  Distribution finale â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> Release        â”‚
â”‚                                                                â”‚
â”‚  SystÃ¨mes embarquÃ©s â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> MinSizeRel     â”‚
â”‚  Containers Docker â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> MinSizeRel     â”‚
â”‚                                                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Conclusion

Les build types sont un concept fondamental de CMake qui vous permet de :
- âœ… **DÃ©velopper efficacement** avec Debug (symboles, assertions, sanitizers)
- âœ… **DÃ©ployer optimalement** avec Release (performance maximale)
- âœ… **Analyser prÃ©cisÃ©ment** avec RelWithDebInfo (profiling)
- âœ… **Optimiser l'espace** avec MinSizeRel (embarquÃ©)

**RÃ¨gle d'or** : DÃ©veloppez en Debug, testez en Release, dÃ©ployez en Release.

**Astuce finale** : CrÃ©ez des alias bash pour simplifier :
```bash
# Dans ~/.bashrc
alias cmake-debug="cmake -B build-debug -DCMAKE_BUILD_TYPE=Debug"
alias cmake-release="cmake -B build-release -DCMAKE_BUILD_TYPE=Release"
alias cmake-prof="cmake -B build-prof -DCMAKE_BUILD_TYPE=RelWithDebInfo"
```

---


â­ï¸ [Out-of-source builds](/13-build-systems/01.7-out-of-source-builds.md)
