üîù Retour au [Sommaire](/SOMMAIRE.md)

# 32.3.2 Branches et workflow

## Introduction

Imaginez que vous travaillez sur un projet C en production. Des clients l'utilisent quotidiennement. Soudain, vous voulez ajouter une nouvelle fonctionnalit√© qui va prendre 2 semaines de d√©veloppement. Comment faire sans casser le code en production ?

C'est l√† qu'interviennent les **branches Git**. Une branche est comme une ligne temporelle parall√®le o√π vous pouvez exp√©rimenter librement sans affecter la version stable.

Dans cette section, nous allons apprendre :
- Ce qu'est une branche Git et comment √ßa fonctionne
- Les workflows Git populaires (Git Flow, GitHub Flow, etc.)
- Comment organiser les branches dans un projet
- Les strat√©gies de fusion (merge vs rebase)
- Les bonnes pratiques pour le travail en √©quipe

---

## Qu'est-ce qu'une branche ?

### Concept de base

Une **branche** est un pointeur mobile vers un commit. C'est une ligne de d√©veloppement ind√©pendante qui vous permet de :

- Travailler sur une fonctionnalit√© sans toucher au code principal
- Exp√©rimenter sans risque
- Maintenir plusieurs versions en parall√®le (production, d√©veloppement, features)

### Analogie : Le livre dont vous √™tes le h√©ros

Imaginez un livre dont vous √™tes le h√©ros :

```
Page 1: L'aventure commence
‚îú‚îÄ> Choix A: Aller dans la for√™t (branche feature/forest)
‚îÇ   ‚îú‚îÄ> Page 34: Vous trouvez un tr√©sor
‚îÇ   ‚îî‚îÄ> Page 35: Vous rentrez au village
‚îÇ
‚îî‚îÄ> Choix B: Aller √† la montagne (branche feature/mountain)
    ‚îú‚îÄ> Page 67: Vous combattez un dragon
    ‚îî‚îÄ> Page 68: Vous devenez un h√©ros
```

Chaque choix est une "branche" : une histoire parall√®le qui peut se d√©rouler ind√©pendamment. √Ä la fin, vous pouvez choisir quelle histoire fusionner dans l'histoire principale.

### Visualisation Git

```
main branch:  
A---B---C---D---E   (production stable)  
     \         /
      F---G---H      (feature/nouvelle-fonction)
```

- `A, B, C, D, E` : Commits sur la branche principale
- `F, G, H` : Commits sur une branche de d√©veloppement
- Le merge final fusionne la feature dans main

---

## Branches par d√©faut

### La branche `main` (ou `master`)

Quand vous cr√©ez un d√©p√¥t Git, une branche par d√©faut est cr√©√©e :

- Historiquement : `master`
- Moderne : `main` (GitHub et GitLab utilisent maintenant `main`)

C'est votre **branche principale**, g√©n√©ralement :
- Le code en production
- Toujours stable et test√©e
- Prot√©g√©e (pas de push direct)

### V√©rifier votre branche actuelle

```bash
# Voir toutes les branches
git branch

# Voir la branche actuelle
git branch --show-current

# Voir toutes les branches avec d√©tails
git branch -vv

# Voir toutes les branches (locales et distantes)
git branch -a
```

---

## Cr√©er et utiliser des branches

### Cr√©er une nouvelle branche

```bash
# Cr√©er une branche (mais rester sur la branche actuelle)
git branch feature/export-json

# Cr√©er et basculer sur la nouvelle branche (recommand√©)
git checkout -b feature/export-json

# Ou avec la commande moderne (Git 2.23+)
git switch -c feature/export-json
```

### Basculer entre les branches

```bash
# Ancienne m√©thode
git checkout main  
git checkout feature/export-json  

# Nouvelle m√©thode (plus claire)
git switch main  
git switch feature/export-json  
```

### Pousser une branche vers le d√©p√¥t distant

```bash
# Premi√®re fois : cr√©er la branche distante
git push -u origin feature/export-json

# Pushs suivants
git push
```

### Supprimer une branche

```bash
# Supprimer une branche locale (apr√®s merge)
git branch -d feature/export-json

# Forcer la suppression (m√™me si pas merg√©e)
git branch -D feature/export-json

# Supprimer une branche distante
git push origin --delete feature/export-json
```

---

## Conventions de nommage des branches

Un bon nom de branche doit √™tre **descriptif** et **structur√©**.

### Format recommand√©

```
<type>/<description-courte>
```

**Types courants** :
- `feature/` : Nouvelle fonctionnalit√©
- `bugfix/` ou `fix/` : Correction de bug
- `hotfix/` : Correction urgente en production
- `refactor/` : Refactoring sans changement de comportement
- `docs/` : Documentation
- `test/` : Ajout de tests
- `chore/` : T√¢ches de maintenance
- `experimental/` : Exp√©rimentations

### Exemples de bons noms

‚úÖ **Bons noms** :
```bash
feature/json-export  
feature/user-authentication  
bugfix/memory-leak-parser  
hotfix/security-vulnerability-cve-2025-123  
refactor/split-large-functions  
docs/api-reference  
test/unit-tests-crypto-module  
chore/update-dependencies  
experimental/new-algorithm  
```

‚úÖ **Avec num√©ros d'issue** (encore mieux) :
```bash
feature/123-json-export  
bugfix/456-memory-leak  
hotfix/789-security-patch  
```

‚ùå **Mauvais noms** :
```bash
test              # Trop vague  
my-branch         # Pas descriptif  
fix               # Quel fix ?  
new-stuff         # Quoi comme "stuff" ?  
branch-2025-01-15 # Utiliser des dates comme noms  
```

### R√®gles de nommage

- **Minuscules** : `feature/json-export` pas `Feature/JSON-Export`
- **Tirets** : `feature/json-export` pas `feature/json_export`
- **Pas d'espaces** : `feature/json-export` pas `feature/json export`
- **Descriptif mais concis** : Max 40 caract√®res
- **R√©f√©rencer l'issue** si applicable : `feature/123-json-export`

---

## Workflows Git populaires

Un **workflow** est une convention sur comment organiser les branches dans un projet. Diff√©rents workflows existent pour diff√©rents besoins.

### 1. Git Flow (workflow traditionnel)

**Pour qui ?** Projets avec releases planifi√©es, plusieurs versions en production.

**Branches principales** :
- `main` (ou `master`) : Code en production
- `develop` : Code en d√©veloppement

**Branches secondaires** :
- `feature/*` : Nouvelles fonctionnalit√©s (depuis develop)
- `release/*` : Pr√©paration d'une release (depuis develop)
- `hotfix/*` : Corrections urgentes (depuis main)

**Sch√©ma** :
```
main:     A---B---C-------D-------E   (production: v1.0, v1.1, v1.2)
               \         /       /
develop:        F---G---H---I---J---K  (d√©veloppement continu)
                 \     /
feature/X:        L---M              (nouvelle feature)
```

**Workflow typique** :

1. **D√©velopper une feature** :
   ```bash
   git checkout develop
   git checkout -b feature/export-json
   # ... d√©veloppement ...
   git commit -m "Implement JSON export"
   git checkout develop
   git merge --no-ff feature/export-json
   git branch -d feature/export-json
   ```

2. **Pr√©parer une release** :
   ```bash
   git checkout develop
   git checkout -b release/1.1.0
   # ... tests, bugfixes mineurs, bump version ...
   git checkout main
   git merge --no-ff release/1.1.0
   git tag v1.1.0
   git checkout develop
   git merge --no-ff release/1.1.0
   git branch -d release/1.1.0
   ```

3. **Hotfix en production** :
   ```bash
   git checkout main
   git checkout -b hotfix/security-patch
   # ... correction urgente ...
   git checkout main
   git merge --no-ff hotfix/security-patch
   git tag v1.1.1
   git checkout develop
   git merge --no-ff hotfix/security-patch
   git branch -d hotfix/security-patch
   ```

**Avantages** :
- ‚úÖ Structure claire et pr√©visible
- ‚úÖ Plusieurs versions en parall√®le
- ‚úÖ S√©paration d√©veloppement/production

**Inconv√©nients** :
- ‚ùå Complexe pour petits projets
- ‚ùå Beaucoup de branches √† g√©rer
- ‚ùå Merge commits nombreux

**Quand l'utiliser ?**
- Logiciels avec versions releases (v1.0, v1.1, v2.0)
- Produits avec plusieurs versions support√©es en parall√®le
- √âquipes moyennes √† grandes (5+ d√©veloppeurs)

### 2. GitHub Flow (workflow simplifi√©)

**Pour qui ?** Projets web, d√©ploiement continu, petites √©quipes.

**Branches** :
- `main` : Code en production (toujours d√©ployable)
- `feature/*` : Toutes les autres branches (features, bugfixes, etc.)

**Principe** : Une seule branche principale, tout le reste est des branches de travail √©ph√©m√®res.

**Sch√©ma** :
```
main: A---B---C---D---E---F---G   (toujours d√©ployable)
           \     /   \     /
feature/X:  H---I     J---K       (branches courtes)
```

**Workflow typique** :

1. **Cr√©er une branche depuis main** :
   ```bash
   git checkout main
   git pull origin main
   git checkout -b feature/json-export
   ```

2. **D√©velopper et pusher r√©guli√®rement** :
   ```bash
   # D√©veloppement
   git add .
   git commit -m "Add JSON export function"
   git push -u origin feature/json-export

   # Continuer √† pusher
   git commit -m "Add tests for JSON export"
   git push
   ```

3. **Ouvrir une Pull Request** :
   - Sur GitHub, ouvrir une PR de `feature/json-export` vers `main`
   - Demander une code review
   - Discuter et ajuster si n√©cessaire

4. **Merger dans main** :
   ```bash
   # Via l'interface GitHub (recommand√©)
   # Ou en ligne de commande:
   git checkout main
   git merge feature/json-export
   git push origin main
   git branch -d feature/json-export
   ```

5. **D√©ployer** :
   - Le merge dans `main` d√©clenche automatiquement le d√©ploiement (CI/CD)

**Avantages** :
- ‚úÖ Simple et facile √† comprendre
- ‚úÖ Parfait pour d√©ploiement continu
- ‚úÖ Peu de branches √† g√©rer

**Inconv√©nients** :
- ‚ùå Pas adapt√© aux releases planifi√©es
- ‚ùå Difficile de maintenir plusieurs versions

**Quand l'utiliser ?**
- Applications web d√©ploy√©es continuellement
- Projets open-source sur GitHub
- Petites √† moyennes √©quipes (2-10 d√©veloppeurs)
- Pas besoin de releases versionn√©es

### 3. GitLab Flow

**Pour qui ?** Compromis entre Git Flow et GitHub Flow.

**Variante 1 : Production branch**
```
main:       A---B---C---D---E      (d√©veloppement)
                 \     \     \
production:       F-----G-----H    (production stable)
```

**Variante 2 : Environment branches**
```
main:        A---B---C---D---E     (d√©veloppement)
              \     \     \
staging:       F-----G-----H       (environnement de test)
                \     \
production:      I-----J           (production)
```

**Principe** :
- `main` est la branche de d√©veloppement (comme `develop` dans Git Flow)
- Des branches d'environnement (`staging`, `production`) repr√©sentent les environnements
- Le code est "promu" de `main` vers `staging` vers `production`

**Workflow** :

1. D√©velopper sur des branches feature depuis `main`
2. Merger dans `main` apr√®s review
3. Cherry-pick ou merge vers `staging` pour tests
4. Cherry-pick ou merge vers `production` apr√®s validation

**Avantages** :
- ‚úÖ Flexible selon les besoins
- ‚úÖ Support des environnements multiples
- ‚úÖ Moins complexe que Git Flow

**Inconv√©nients** :
- ‚ùå Peut devenir confus sans discipline
- ‚ùå Cherry-picking peut √™tre source d'erreurs

**Quand l'utiliser ?**
- Projets avec plusieurs environnements (dev, staging, prod)
- Besoin de contr√¥le sur ce qui est d√©ploy√© o√π
- √âquipes moyennes utilisant GitLab CI/CD

### 4. Trunk-Based Development

**Pour qui ?** √âquipes exp√©riment√©es avec forte culture CI/CD.

**Principe** : Tout le monde travaille sur `main` (ou sur des branches de tr√®s courte dur√©e, <1 jour).

**Sch√©ma** :
```
main: A---B---C---D---E---F---G---H   (tout le monde commit ici)
```

Ou avec des branches ultra-courtes :
```
main:       A---B---D---E---G---H
             \     /   /   /
feature/X:    C     (merge rapide)  
feature/Y:        F     (merge rapide)  
```

**R√®gles strictes** :
- Branches de feature < 24 heures
- Tests automatis√©s obligatoires
- Feature flags pour cacher le code incomplet
- Int√©gration continue tr√®s mature

**Avantages** :
- ‚úÖ Int√©gration continue vraie
- ‚úÖ Moins de conflits de merge
- ‚úÖ Feedback rapide

**Inconv√©nients** :
- ‚ùå N√©cessite discipline extr√™me
- ‚ùå Tests automatis√©s indispensables
- ‚ùå Pas pour d√©butants

**Quand l'utiliser ?**
- √âquipes senior avec expertise CI/CD
- D√©ploiement plusieurs fois par jour
- Culture DevOps mature

---

## Choisir le bon workflow pour votre projet C

### Projet C typique selon le contexte

| Type de projet | Workflow recommand√© | Raison |
|----------------|---------------------|--------|
| Biblioth√®que C open-source | GitHub Flow | Simple, PR-friendly, communaut√© |
| Logiciel embarqu√© | Git Flow | Releases versionn√©es, stabilit√© cruciale |
| Outil CLI syst√®me | GitHub Flow | D√©ploiement simple, it√©rations rapides |
| Daemon/Service Linux | GitLab Flow | Multiples environnements (dev/staging/prod) |
| Kernel module | Git Flow | Versions multiples, stabilit√© maximale |
| Projet √©tudiant/perso | GitHub Flow | Simplicit√©, apprentissage |

### Recommandations pour d√©butants

Si vous d√©butez avec Git, commencez par **GitHub Flow** :

```bash
# Toujours partir de main √† jour
git checkout main  
git pull  

# Cr√©er une branche pour chaque t√¢che
git checkout -b feature/ma-feature

# D√©velopper, commiter, pusher
git add .  
git commit -m "..."  
git push -u origin feature/ma-feature  

# Ouvrir une PR sur GitHub
# Merger apr√®s review
# Supprimer la branche
```

C'est simple, intuitif, et vous apprend les bases avant de passer √† des workflows plus complexes.

---

## Strat√©gies de fusion : Merge vs Rebase

Quand vous voulez int√©grer les changements d'une branche dans une autre, vous avez deux options principales.

### 1. Merge (fusion)

**Commande** :
```bash
git checkout main  
git merge feature/export-json  
```

**Ce qui se passe** :
```
Avant merge:  
main:     A---B---C  
               \
feature:        D---E

Apr√®s merge:  
main:     A---B---C---F    (F = commit de merge)  
               \     /
feature:        D---E
```

Git cr√©e un **commit de merge** qui a deux parents : le dernier commit de `main` et le dernier de `feature`.

**Avantages** :
- ‚úÖ Pr√©serve l'historique complet
- ‚úÖ Montre clairement quand une feature a √©t√© int√©gr√©e
- ‚úÖ S√ªr (non-destructif)

**Inconv√©nients** :
- ‚ùå Historique peut devenir complexe avec beaucoup de branches
- ‚ùå Commits de merge "polluent" l'historique

**Quand l'utiliser** :
- Pour int√©grer des branches de feature dans main
- Quand vous voulez pr√©server l'historique des branches
- Sur des branches partag√©es (main, develop)

### 2. Rebase (r√©application)

**Commande** :
```bash
git checkout feature/export-json  
git rebase main  
```

**Ce qui se passe** :
```
Avant rebase:  
main:     A---B---C  
               \
feature:        D---E

Apr√®s rebase:  
main:     A---B---C  
                   \
feature:            D'---E'  (D et E sont "rejou√©s" apr√®s C)
```

Git "rejoue" les commits de `feature` comme s'ils avaient √©t√© faits apr√®s le dernier commit de `main`.

**Avantages** :
- ‚úÖ Historique lin√©aire et propre
- ‚úÖ Pas de commits de merge
- ‚úÖ Facile √† lire avec `git log`

**Inconv√©nients** :
- ‚ùå R√©√©crit l'historique (change les hashes des commits)
- ‚ùå Dangereux sur des branches partag√©es
- ‚ùå Peut cr√©er des conflits complexes

**Quand l'utiliser** :
- Sur votre branche locale avant de merger
- Pour nettoyer l'historique avant une PR
- **JAMAIS** sur une branche publique partag√©e

### 3. Squash merge

**Commande** :
```bash
git checkout main  
git merge --squash feature/export-json  
git commit -m "Add JSON export feature"  
```

**Ce qui se passe** :
```
Avant squash:  
main:     A---B---C  
               \
feature:        D---E---F

Apr√®s squash:  
main:     A---B---C---G  (G contient tous les changements de D+E+F)  
```

Tous les commits de la branche feature sont "√©cras√©s" en un seul commit sur main.

**Avantages** :
- ‚úÖ Historique tr√®s propre sur main
- ‚úÖ Un commit = une feature compl√®te
- ‚úÖ Parfait pour les PRs avec beaucoup de commits WIP

**Inconv√©nients** :
- ‚ùå Perd l'historique d√©taill√© de la feature
- ‚ùå Difficile de revenir sur des changements sp√©cifiques

**Quand l'utiliser** :
- Lors du merge de PRs avec beaucoup de petits commits
- Quand la branche feature contient des commits "WIP" ou "fix typo"
- Pour garder l'historique de main minimal

### Comparaison visuelle

| Strat√©gie | Historique | Lisibilit√© | S√©curit√© | Utilisation |
|-----------|------------|------------|----------|-------------|
| **Merge** | Pr√©serv√© | Moyenne | Haute | Par d√©faut |
| **Rebase** | Lin√©aire | Haute | Moyenne | Branches locales |
| **Squash** | Simplifi√© | Tr√®s haute | Haute | PRs avec commits sales |

### Recommandations pratiques

Pour un projet C typique avec GitHub Flow :

```bash
# 1. Sur votre branche feature, rebasez r√©guli√®rement
git checkout feature/export-json  
git fetch origin  
git rebase origin/main  # Garde votre branche √† jour  

# 2. Avant de cr√©er la PR, nettoyez l'historique
git rebase -i origin/main  # Squash commits WIP, fix typos

# 3. Lors du merge de la PR, utilisez squash si beaucoup de commits
# Via l'interface GitHub: "Squash and merge"

# Ou en ligne de commande:
git checkout main  
git merge --squash feature/export-json  
git commit -m "feat: Add JSON export functionality"  
```

---

## Gestion des conflits

### Qu'est-ce qu'un conflit ?

Un conflit survient quand Git ne peut pas fusionner automatiquement deux changements car ils modifient les m√™mes lignes.

**Exemple** :
```c
// Version sur main (par Alice)
int calculate_sum(int a, int b) {
    return a + b + 1;  // Alice a ajout√© +1
}

// Version sur feature (par Bob)
int calculate_sum(int a, int b) {
    return a + b - 1;  // Bob a ajout√© -1
}
```

Git ne sait pas quelle version choisir ‚Üí **conflit**.

### R√©soudre un conflit

1. **Git marque le conflit** :
   ```bash
   git merge feature/bob-changes
   # Auto-merging math.c
   # CONFLICT (content): Merge conflict in math.c
   # Automatic merge failed; fix conflicts and then commit the result.
   ```

2. **Ouvrir le fichier en conflit** :
   ```c
   int calculate_sum(int a, int b) {
   <<<<<<< HEAD  (votre version sur main)
       return a + b + 1;
   =======
       return a + b - 1;
   >>>>>>> feature/bob-changes  (version de Bob)
   }
   ```

3. **R√©soudre manuellement** :
   ```c
   // Apr√®s discussion avec Bob, on d√©cide de garder +1
   int calculate_sum(int a, int b) {
       return a + b + 1;
   }
   ```

4. **Marquer comme r√©solu et commiter** :
   ```bash
   git add math.c
   git commit -m "Merge feature/bob-changes - keep +1 offset"
   ```

### Outils pour r√©soudre les conflits

**Ligne de commande** :
```bash
# Voir les fichiers en conflit
git status

# Annuler le merge si trop complexe
git merge --abort

# Voir les diff√©rences
git diff
```

**Outils graphiques** :
```bash
# Lancer un outil de merge visuel
git mergetool

# Outils populaires:
# - meld
# - kdiff3
# - vimdiff
# - VS Code (int√©gr√©)
```

**VS Code** :
VS Code d√©tecte automatiquement les conflits et affiche des boutons :
- "Accept Current Change" (garder votre version)
- "Accept Incoming Change" (garder leur version)
- "Accept Both Changes" (garder les deux)
- √âditer manuellement

### Pr√©venir les conflits

‚úÖ **Bonnes pratiques** :
- Pusher et puller fr√©quemment
- Communiquer avec l'√©quipe sur qui travaille sur quoi
- Garder les branches de feature petites et courtes
- Utiliser des modules/fichiers s√©par√©s quand possible
- Rebase r√©guli√®rement sur main

---

## Protection des branches

Pour √©viter les erreurs, prot√©gez vos branches importantes (main, develop).

### Sur GitHub

**Settings** ‚Üí **Branches** ‚Üí **Branch protection rules**

Options recommand√©es :
- ‚úÖ **Require pull request before merging** : Pas de push direct
- ‚úÖ **Require approvals** : Au moins 1 review
- ‚úÖ **Require status checks to pass** : CI doit passer
- ‚úÖ **Require branches to be up to date** : Forcer rebase/merge avant
- ‚úÖ **Include administrators** : M√™me r√®gles pour les admins

### Sur GitLab

**Settings** ‚Üí **Repository** ‚Üí **Protected branches**

Options :
- **Allowed to merge** : Qui peut merger (Maintainers, Developers, etc.)
- **Allowed to push** : Qui peut push (g√©n√©ralement "No one" pour main)
- **Require approval** : Nombre de reviews n√©cessaires

### Configuration locale

Emp√™cher les push accidentels :

```bash
# Dans le d√©p√¥t
git config branch.main.pushRemote no_push
```

Toute tentative de `git push` sur main √©chouera avec une erreur.

---

## Bonnes pratiques de gestion des branches

### 1. Dur√©e de vie des branches

‚úÖ **Branches courtes** :
- Feature : < 3-5 jours
- Bugfix : < 1 jour
- Hotfix : Quelques heures

‚ùå **Branches longues** :
- Augmentent les risques de conflits
- Retardent l'int√©gration
- Rendent la review difficile

**Solution** : D√©coupez les grandes features en sous-t√¢ches plus petites.

### 2. Une branche = Une t√¢che

Chaque branche doit avoir un objectif unique et clair.

‚ùå **Mauvais** :
```bash
git checkout -b my-changes  # Trop vague
# ... ajoute feature X ...
# ... corrige bug Y ...
# ... refactor Z ...
```

‚úÖ **Bon** :
```bash
git checkout -b feature/123-json-export   # Feature X
# ... d√©veloppe seulement JSON export ...

git checkout -b bugfix/456-memory-leak    # Bug Y s√©par√©
# ... corrige seulement memory leak ...
```

### 3. Synchroniser r√©guli√®rement

Gardez votre branche √† jour avec main :

```bash
# Option 1: Merge (cr√©e un commit de merge)
git checkout feature/my-feature  
git merge origin/main  

# Option 2: Rebase (historique lin√©aire)
git checkout feature/my-feature  
git rebase origin/main  
```

**Fr√©quence recommand√©e** : Au moins une fois par jour, ou avant d'ouvrir une PR.

### 4. Nettoyer les branches obsol√®tes

```bash
# Lister les branches merg√©es
git branch --merged main

# Supprimer toutes les branches merg√©es (sauf main)
git branch --merged main | grep -v "main" | xargs git branch -d

# Supprimer les branches distantes orphelines
git remote prune origin

# Voir les branches qui n'ont plus de remote
git branch -vv | grep ': gone]'
```

### 5. Convention de nommage stricte

D√©finissez et respectez une convention d'√©quipe :

```bash
# Format: <type>/<issue>-<description>
feature/123-add-logging  
bugfix/456-fix-parser-crash  
hotfix/789-security-cve-2025  
refactor/321-clean-memory-module  
docs/234-update-readme  
test/567-add-unit-tests  
```

### 6. Pull Requests / Merge Requests

Utilisez toujours des PRs, m√™me en solo :

**Pourquoi ?**
- Force une derni√®re relecture du code
- D√©clenche les tests CI/CD
- Documente les changements
- Permet les discussions

**Template de PR** (`.github/pull_request_template.md`) :
```markdown
## Description
Br√®ve description du changement.

## Type de changement
- [ ] Bugfix
- [ ] Feature
- [ ] Refactoring
- [ ] Documentation

## Checklist
- [ ] Code compile sans warnings
- [ ] Tests ajout√©s et passent
- [ ] Documentation mise √† jour
- [ ] Pas de nouveaux warnings Valgrind
- [ ] Code format√© avec clang-format

## Tests
Comment tester ce changement ?

## Screenshots (si applicable)

## Issues li√©es
Fixes #123  
See also #456  
```

---

## Workflows en √©quipe

### R√¥les typiques

Dans une √©quipe structur√©e :

- **Mainteneur** : Peut merger dans main, cr√©er des releases
- **D√©veloppeur** : Peut cr√©er des branches, ouvrir des PRs
- **Contributeur externe** : Doit fork, puis PR depuis son fork

### Workflow Pull Request typique

1. **D√©veloppeur** : Cr√©e une branche
   ```bash
   git checkout -b feature/123-json-export
   # ... d√©veloppement ...
   git push -u origin feature/123-json-export
   ```

2. **D√©veloppeur** : Ouvre une PR sur GitHub/GitLab
   - Titre clair
   - Description d√©taill√©e
   - R√©f√©rence l'issue (#123)
   - Assigne un reviewer

3. **Reviewer** : Review le code
   - Commente sur les lignes probl√©matiques
   - Demande des clarifications
   - Approuve ou demande des changements

4. **D√©veloppeur** : Corrige selon feedback
   ```bash
   # Faire les corrections
   git add .
   git commit -m "Address review comments"
   git push
   ```

5. **Mainteneur** : Merge la PR
   - Via l'interface (squash/merge/rebase selon la strat√©gie)
   - Ou en ligne de commande

6. **Tout le monde** : Met √† jour
   ```bash
   git checkout main
   git pull origin main
   ```

### R√©solution de conflits en √©quipe

Si votre branche entre en conflit avec main :

```bash
# Mettre √† jour votre branche
git checkout feature/my-feature  
git fetch origin  
git rebase origin/main  # ou git merge origin/main  

# R√©soudre les conflits
# ... √©diter les fichiers ...
git add .  
git rebase --continue  # si rebase  
# ou git commit si merge

# Forcer le push (seulement si rebase)
git push --force-with-lease origin feature/my-feature
```

**‚ö†Ô∏è Important** : `--force-with-lease` est plus s√ªr que `--force` car il v√©rifie que personne d'autre n'a push√© entre temps.

---

## Cas pratiques pour projets C

### Cas 1 : D√©velopper une nouvelle fonctionnalit√©

**Contexte** : Ajouter support SQLite dans votre application.

```bash
# 1. Partir de main √† jour
git checkout main  
git pull origin main  

# 2. Cr√©er une branche
git checkout -b feature/sqlite-support

# 3. D√©velopper par √©tapes
# Commit 1: Ajouter d√©pendance SQLite
vim CMakeLists.txt  # Ajouter find_package(SQLite3)  
git add CMakeLists.txt  
git commit -m "Add SQLite3 dependency to CMake"  

# Commit 2: Cr√©er module de base
vim src/database.h src/database.c  
git add src/database.*  
git commit -m "Create database module with init/close functions"  

# Commit 3: Impl√©menter CRUD
vim src/database.c  
git add src/database.c  
git commit -m "Implement CRUD operations for users table"  

# Commit 4: Tests
vim tests/test_database.c  
git add tests/test_database.c  
git commit -m "Add unit tests for database module"  

# 4. Pusher r√©guli√®rement
git push -u origin feature/sqlite-support

# 5. Ouvrir une PR sur GitHub

# 6. Apr√®s review et merge, nettoyer
git checkout main  
git pull  
git branch -d feature/sqlite-support  
```

### Cas 2 : Correction de bug urgente (hotfix)

**Contexte** : Bug critique en production, segfault d√©tect√©.

```bash
# 1. Partir de main (la production)
git checkout main  
git pull origin main  

# 2. Cr√©er une branche hotfix
git checkout -b hotfix/segfault-in-parser

# 3. Reproduire et corriger le bug
vim src/parser.c
# Ajouter NULL check
git add src/parser.c  
git commit -m "Fix segfault in parser when input is NULL  

Check for NULL input before dereferencing in parse_line().  
This fixes a crash reported in production.  

Fixes: #789"

# 4. Pusher imm√©diatement
git push -u origin hotfix/segfault-in-parser

# 5. Ouvrir une PR marqu√©e "urgent"

# 6. Apr√®s review express et merge
git checkout main  
git pull origin main  
# Taguer la version
git tag v1.2.1  
git push origin v1.2.1  

# 7. Backport vers develop si Git Flow
git checkout develop  
git merge main  
git push origin develop  
```

### Cas 3 : Refactoring important

**Contexte** : Refactoriser le module de configuration pour le rendre modulaire.

```bash
# 1. Cr√©er une branche
git checkout -b refactor/modular-config

# 2. Refactorer par √©tapes SANS changer le comportement
# √âtape 1: Extraire fonctions
vim src/config.c  
git add src/config.c  
git commit -m "refactor: Extract validation logic to validate_config()"  

# √âtape 2: Renommer pour clart√©
git add src/config.c  
git commit -m "refactor: Rename ambiguous variable names in config.c"  

# √âtape 3: R√©organiser structures
vim src/config.h src/config.c  
git add src/config.*  
git commit -m "refactor: Split config_t into config_parser_t and config_data_t"  

# 3. S'assurer que les tests passent √† CHAQUE commit
make test  # Apr√®s chaque commit

# 4. Ouvrir une PR "Refactor" (n√©cessite review attentive)
```

### Cas 4 : Contribution open-source

**Contexte** : Contribuer √† un projet C open-source sur GitHub.

```bash
# 1. Fork le projet sur GitHub (bouton "Fork")

# 2. Cloner VOTRE fork
git clone https://github.com/VOUS/projet-opensource.git  
cd projet-opensource  

# 3. Ajouter l'upstream (le d√©p√¥t original)
git remote add upstream https://github.com/ORIGINAL/projet-opensource.git

# 4. Cr√©er une branche pour votre contribution
git checkout -b feature/add-ipv6-support

# 5. D√©velopper
# ... commits ...

# 6. Garder votre branche √† jour avec upstream
git fetch upstream  
git rebase upstream/main  

# 7. Pusher vers VOTRE fork
git push origin feature/add-ipv6-support

# 8. Ouvrir une PR depuis votre fork vers le d√©p√¥t original
# Via l'interface GitHub

# 9. R√©pondre aux commentaires et mettre √† jour
# ... corrections ...
git push origin feature/add-ipv6-support  # Update la PR automatiquement

# 10. Apr√®s merge, synchroniser votre fork
git checkout main  
git fetch upstream  
git merge upstream/main  
git push origin main  
```

---

## Outils et visualisation

### Visualiser les branches

**Ligne de commande** :
```bash
# Log avec graphe
git log --oneline --graph --all --decorate

# Avec plus de d√©tails
git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --all
```

**Alias pratique** :
```bash
# Ajouter dans ~/.gitconfig
[alias]
    lg = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --all

# Utilisation:
git lg
```

**Outils graphiques** :
- **gitk** : Outil Tk/Tcl simple (`gitk --all`)
- **tig** : Interface ncurses (`tig`)
- **GitKraken** : Client GUI moderne
- **GitHub Desktop** : Simple et intuitif
- **VS Code** : Avec extension GitLens

### V√©rifier l'√©tat de vos branches

```bash
# Branches locales
git branch -vv

# Voir quelle branche track quelle remote
git branch -vv

# Branches distantes
git branch -r

# Toutes les branches
git branch -a

# Branches avec dernier commit
git branch -v
```

---

## Checklist : Avant de merger

Avant de merger une branche dans main, v√©rifiez :

- [ ] **Tous les commits sont atomiques** (voir section 32.3.1)
- [ ] **Les messages de commit sont clairs**
- [ ] **Le code compile sans warnings** (`make` ou `cmake --build`)
- [ ] **Tous les tests passent** (`make test`)
- [ ] **Pas de fuites m√©moire** (Valgrind clean)
- [ ] **Code format√©** (clang-format)
- [ ] **Documentation mise √† jour** (README, CHANGELOG, Doxygen)
- [ ] **PR approuv√©e** par au moins un reviewer
- [ ] **CI/CD passe** (GitHub Actions, GitLab CI)
- [ ] **Branche √† jour avec main** (rebas√© r√©cemment)
- [ ] **Pas de fichiers temporaires** (.o, executables, logs)

---

## Erreurs courantes et solutions

### Erreur 1 : Push forc√© sur une branche partag√©e

‚ùå **Ne JAMAIS faire** :
```bash
git push --force origin main
```

Cela r√©√©crit l'historique et casse le d√©p√¥t pour tous les autres !

‚úÖ **Solution** : N'utilisez `--force` que sur vos branches personnelles.

### Erreur 2 : Merge d'une branche non test√©e

‚ùå **Mauvais** :
```bash
git checkout main  
git merge feature/new-stuff  # Sans avoir test√© !  
```

‚úÖ **Bon** :
```bash
git checkout feature/new-stuff  
make clean && make && make test  # Tester d'abord  
git checkout main  
git merge feature/new-stuff  
```

### Erreur 3 : Oublier de mettre √† jour avant de cr√©er une branche

‚ùå **Mauvais** :
```bash
# main est vieille de 3 jours
git checkout -b feature/new  # Part d'une version obsol√®te
```

‚úÖ **Bon** :
```bash
git checkout main  
git pull origin main  # Mettre √† jour  
git checkout -b feature/new  # Part de la derni√®re version  
```

### Erreur 4 : Branches abandonn√©es

Probl√®me : Des dizaines de branches non merg√©es qui tra√Ænent.

‚úÖ **Solution** : Nettoyer r√©guli√®rement
```bash
# Voir les branches merg√©es
git branch --merged main

# Supprimer les branches locales merg√©es
git branch --merged main | grep -v "main" | xargs git branch -d

# Supprimer les branches distantes merg√©es (via GitHub/GitLab)
```

---

## Conclusion

La gestion des branches est une comp√©tence fondamentale pour tout d√©veloppeur travaillant en √©quipe ou maintenant un projet sur le long terme.

**Points cl√©s √† retenir** :

1. **Choisissez le bon workflow** pour votre projet (GitHub Flow pour d√©buter)
2. **Une branche = une t√¢che** : Branches courtes et focalis√©es
3. **Noms descriptifs** : `feature/123-json-export`, pas `ma-branche`
4. **Commits atomiques** : Voir section 32.3.1
5. **Pull Requests** : Toujours passer par des PRs pour merger dans main
6. **Protection de branches** : Prot√©gez main contre les push directs
7. **Synchronisation r√©guli√®re** : Rebase/merge main dans votre branche quotidiennement
8. **Nettoyage** : Supprimez les branches merg√©es

Avec ces pratiques, vous maintiendrez un historique Git propre, faciliterez la collaboration, et simplifierez le debugging.

---

## Ressources compl√©mentaires

- **Git Flow** : https://nvie.com/posts/a-successful-git-branching-model/
- **GitHub Flow** : https://docs.github.com/en/get-started/using-github/github-flow
- **GitLab Flow** : https://docs.gitlab.com/ee/topics/gitlab_flow.html
- **Atlassian Git Tutorials** : https://www.atlassian.com/git/tutorials/comparing-workflows
- **Pro Git Book - Branching** : https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell

**Prochaine section** : 32.3.3 Gestion des binaires - Nous verrons comment g√©rer les fichiers binaires dans Git et quelles sont les bonnes pratiques pour les projets C.

‚è≠Ô∏è [Gestion des binaires](/32-documentation-maintenance/03.3-gestion-binaires.md)
