üîù Retour au [Sommaire](/SOMMAIRE.md)

# 34.4.3 Static File Serving

## Introduction

Apr√®s avoir construit une architecture event-driven (34.4.1) et un parser HTTP (34.4.2), nous allons maintenant cr√©er la fonctionnalit√© essentielle d'un serveur web : **servir des fichiers statiques**.

Un serveur de fichiers statiques lit des fichiers depuis le disque (HTML, CSS, JavaScript, images, PDF, etc.) et les envoie aux clients via HTTP. C'est la base de tout site web classique.

---

## Qu'est-ce qu'un Fichier Statique ?

### D√©finition

Un **fichier statique** est un fichier qui :
- Existe sur le disque du serveur
- Est envoy√© **tel quel** au client (sans modification)
- N'est pas g√©n√©r√© dynamiquement

**Exemples de fichiers statiques :**
- `index.html` - Page d'accueil
- `style.css` - Feuille de style
- `script.js` - Code JavaScript
- `logo.png` - Image
- `document.pdf` - Document PDF
- `font.woff2` - Police de caract√®res

### Fichiers Statiques vs Dynamiques

| Type | Exemple | G√©n√©ration |
|------|---------|------------|
| **Statique** | `about.html` | Fichier fixe sur disque |
| **Dynamique** | `/api/users` | G√©n√©r√© par code (PHP, Python, etc.) |

**Notre serveur :** Nous nous concentrons sur les fichiers statiques.

---

## Architecture de Base

### Flux de traitement

```
1. Client demande: GET /images/logo.png HTTP/1.1

2. Serveur:
   ‚îú‚îÄ> Parser la requ√™te HTTP
   ‚îú‚îÄ> Extraire l'URI: /images/logo.png
   ‚îú‚îÄ> Convertir en chemin disque: /var/www/html/images/logo.png
   ‚îú‚îÄ> V√©rifier la s√©curit√© (pas de ../.. etc.)
   ‚îú‚îÄ> V√©rifier que le fichier existe
   ‚îú‚îÄ> D√©terminer le type MIME: image/png
   ‚îú‚îÄ> Lire le fichier
   ‚îú‚îÄ> G√©n√©rer r√©ponse HTTP avec headers appropri√©s
   ‚îî‚îÄ> Envoyer au client

3. Client re√ßoit l'image
```

### Configuration de base

```c
#define DOCUMENT_ROOT "/var/www/html"
#define DEFAULT_FILE "index.html"
#define MAX_PATH_LEN 4096
```

- `DOCUMENT_ROOT` : R√©pertoire racine contenant les fichiers √† servir
- `DEFAULT_FILE` : Fichier servi par d√©faut pour les r√©pertoires
- `MAX_PATH_LEN` : Longueur maximale d'un chemin

---

## Conversion URI vers Chemin Syst√®me

### Probl√®me

Le client envoie une **URI** (chemin HTTP) :
```
GET /docs/guide.html HTTP/1.1
```

Le serveur doit le convertir en **chemin syst√®me** :
```
/var/www/html/docs/guide.html
```

### Fonction de conversion

```c
#include <string.h>
#include <limits.h>
#include <stdlib.h>

int uri_to_path(const char *uri, const char *document_root,
                char *path, size_t path_size) {
    // Construire le chemin complet
    int written = snprintf(path, path_size, "%s%s", document_root, uri);

    if (written < 0 || (size_t)written >= path_size) {
        return -1;  // Chemin trop long
    }

    return 0;
}

// Exemple d'utilisation
char path[PATH_MAX];
if (uri_to_path("/docs/guide.html", "/var/www/html",
                path, sizeof(path)) == 0) {
    printf("Chemin: %s\n", path);
    // R√©sultat: /var/www/html/docs/guide.html
}
```

### Gestion des r√©pertoires

Si l'URI se termine par `/`, servir le fichier index par d√©faut :

```c
int uri_to_path_with_index(const char *uri, const char *document_root,
                           const char *index_file,
                           char *path, size_t path_size) {
    size_t uri_len = strlen(uri);

    // Si l'URI se termine par '/', ajouter index.html
    if (uri_len > 0 && uri[uri_len - 1] == '/') {
        snprintf(path, path_size, "%s%s%s",
                document_root, uri, index_file);
    } else {
        snprintf(path, path_size, "%s%s", document_root, uri);
    }

    return 0;
}

// Exemples
// /docs/        ‚Üí /var/www/html/docs/index.html
// /docs/guide/  ‚Üí /var/www/html/docs/guide/index.html
// /about.html   ‚Üí /var/www/html/about.html
```

---

## S√©curit√© : Pr√©venir Path Traversal

### Le probl√®me Path Traversal

**Attaque classique :** Un attaquant essaie d'acc√©der √† des fichiers hors du document root.

```http
GET /../../../etc/passwd HTTP/1.1
GET /../../../../../../root/.ssh/id_rsa HTTP/1.1
```

Si non prot√©g√©, le serveur pourrait exposer :
```
/var/www/html/../../../etc/passwd
= /etc/passwd  ‚ùå DANGER!
```

### Solution : Canonicalisation et v√©rification

```c
#include <stdlib.h>
#include <string.h>
#include <limits.h>

int is_safe_path(const char *uri, const char *document_root,
                 char *safe_path, size_t path_size) {
    char full_path[PATH_MAX];
    char resolved_root[PATH_MAX];
    char resolved_path[PATH_MAX];

    // 1. R√©soudre le document root en chemin absolu
    if (realpath(document_root, resolved_root) == NULL) {
        return -1;
    }

    // 2. Construire le chemin complet demand√©
    snprintf(full_path, sizeof(full_path), "%s%s", document_root, uri);

    // 3. R√©soudre le chemin (supprime .., ., liens symboliques)
    if (realpath(full_path, resolved_path) == NULL) {
        // Le fichier n'existe peut-√™tre pas encore, essayer sans r√©solution
        // ou retourner une erreur
        return -1;
    }

    // 4. V√©rifier que le chemin r√©solu est bien dans document_root
    size_t root_len = strlen(resolved_root);
    if (strncmp(resolved_path, resolved_root, root_len) != 0) {
        // Tentative de sortir du document root!
        return -1;
    }

    // 5. Le chemin est s√ªr
    strncpy(safe_path, resolved_path, path_size);
    safe_path[path_size - 1] = '\0';

    return 0;
}

// Utilisation
char safe_path[PATH_MAX];
if (is_safe_path(request_uri, DOCUMENT_ROOT, safe_path, sizeof(safe_path)) != 0) {
    // Chemin dangereux ou invalide
    send_error_response(client_fd, 403, "Forbidden");
    return;
}
```

**Ce que fait `realpath()` :**
- Convertit en chemin absolu
- R√©sout les liens symboliques
- Supprime `.` et `..`
- Retourne NULL si le fichier n'existe pas

**Note importante :** `realpath()` √©choue si le fichier n'existe pas. Pour certaines applications (upload), vous devrez g√©rer ce cas diff√©remment.

---

## V√©rification de l'Existence et des Permissions

### V√©rifier qu'un fichier existe

```c
#include <sys/stat.h>
#include <unistd.h>

typedef enum {
    FILE_NOT_FOUND,
    FILE_IS_REGULAR,
    FILE_IS_DIRECTORY,
    FILE_NO_ACCESS
} file_status_t;

file_status_t check_file(const char *path) {
    struct stat st;

    // stat() r√©cup√®re les informations sur le fichier
    if (stat(path, &st) != 0) {
        return FILE_NOT_FOUND;
    }

    // V√©rifier les permissions de lecture
    if (access(path, R_OK) != 0) {
        return FILE_NO_ACCESS;
    }

    // V√©rifier le type
    if (S_ISDIR(st.st_mode)) {
        return FILE_IS_DIRECTORY;
    }

    if (S_ISREG(st.st_mode)) {
        return FILE_IS_REGULAR;
    }

    // Ni fichier r√©gulier ni r√©pertoire (lien symbolique, device, etc.)
    return FILE_NO_ACCESS;
}
```

### Gestion des r√©pertoires

Si le chemin est un r√©pertoire, essayer de servir `index.html` :

```c
int resolve_path(const char *requested_path, const char *index_file,
                 char *final_path, size_t path_size) {
    file_status_t status = check_file(requested_path);

    switch (status) {
        case FILE_IS_REGULAR:
            // Fichier normal, utiliser tel quel
            strncpy(final_path, requested_path, path_size);
            return 0;

        case FILE_IS_DIRECTORY:
            // R√©pertoire, ajouter index.html
            snprintf(final_path, path_size, "%s/%s",
                    requested_path, index_file);

            // V√©rifier que l'index existe
            if (check_file(final_path) == FILE_IS_REGULAR) {
                return 0;
            }
            // Index n'existe pas
            return -1;

        case FILE_NOT_FOUND:
        case FILE_NO_ACCESS:
        default:
            return -1;
    }
}
```

---

## Lecture du Fichier

### M√©thode 1 : Lecture compl√®te en m√©moire

**Simple mais limit√©e aux petits fichiers :**

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>

char *read_file(const char *path, size_t *file_size) {
    FILE *fp = fopen(path, "rb");  // Mode binaire
    if (fp == NULL) {
        return NULL;
    }

    // Obtenir la taille du fichier
    struct stat st;
    if (fstat(fileno(fp), &st) != 0) {
        fclose(fp);
        return NULL;
    }

    *file_size = st.st_size;

    // Allouer un buffer
    char *buffer = malloc(*file_size);
    if (buffer == NULL) {
        fclose(fp);
        return NULL;
    }

    // Lire le fichier en entier
    size_t bytes_read = fread(buffer, 1, *file_size, fp);
    if (bytes_read != *file_size) {
        free(buffer);
        fclose(fp);
        return NULL;
    }

    fclose(fp);
    return buffer;  // L'appelant doit faire free()
}

// Utilisation
size_t file_size;
char *content = read_file("/var/www/html/index.html", &file_size);
if (content != NULL) {
    send_file_response(client_fd, content, file_size, "text/html");
    free(content);
}
```

**Avantages :**
- Simple √† impl√©menter
- Une seule lecture

**Inconv√©nients :**
- Consomme beaucoup de m√©moire pour les gros fichiers
- Pas adapt√© aux fichiers de plusieurs Mo/Go

### M√©thode 2 : Lecture par blocs

**Recommand√©e pour les gros fichiers :**

```c
#define READ_BUFFER_SIZE 8192

int send_file_chunked(int client_fd, const char *path,
                     const char *content_type) {
    FILE *fp = fopen(path, "rb");
    if (fp == NULL) {
        return -1;
    }

    // Obtenir la taille
    struct stat st;
    if (fstat(fileno(fp), &st) != 0) {
        fclose(fp);
        return -1;
    }

    size_t file_size = st.st_size;

    // Envoyer les headers HTTP
    char header[1024];
    int header_len = snprintf(header, sizeof(header),
        "HTTP/1.1 200 OK\r\n"
        "Content-Type: %s\r\n"
        "Content-Length: %zu\r\n"
        "Connection: close\r\n"
        "\r\n",
        content_type, file_size);

    if (write(client_fd, header, header_len) < 0) {
        fclose(fp);
        return -1;
    }

    // Lire et envoyer par blocs
    char buffer[READ_BUFFER_SIZE];
    size_t total_sent = 0;

    while (total_sent < file_size) {
        size_t to_read = READ_BUFFER_SIZE;
        if (file_size - total_sent < to_read) {
            to_read = file_size - total_sent;
        }

        size_t bytes_read = fread(buffer, 1, to_read, fp);
        if (bytes_read == 0) {
            break;  // Erreur ou EOF
        }

        ssize_t bytes_sent = write(client_fd, buffer, bytes_read);
        if (bytes_sent < 0) {
            fclose(fp);
            return -1;
        }

        total_sent += bytes_sent;
    }

    fclose(fp);
    return 0;
}
```

**Avantages :**
- Consommation m√©moire constante (8 KB)
- Peut g√©rer des fichiers de n'importe quelle taille

**Inconv√©nients :**
- Plusieurs lectures/√©critures (plus d'appels syst√®me)

### M√©thode 3 : sendfile() - Z√©ro copie (Linux)

**La plus performante :**

```c
#include <sys/sendfile.h>
#include <fcntl.h>
#include <unistd.h>

int send_file_zerocopy(int client_fd, const char *path,
                       const char *content_type) {
    // Ouvrir le fichier
    int file_fd = open(path, O_RDONLY);
    if (file_fd < 0) {
        return -1;
    }

    // Obtenir la taille
    struct stat st;
    if (fstat(file_fd, &st) != 0) {
        close(file_fd);
        return -1;
    }

    size_t file_size = st.st_size;

    // Envoyer les headers HTTP
    char header[1024];
    int header_len = snprintf(header, sizeof(header),
        "HTTP/1.1 200 OK\r\n"
        "Content-Type: %s\r\n"
        "Content-Length: %zu\r\n"
        "Connection: close\r\n"
        "\r\n",
        content_type, file_size);

    if (write(client_fd, header, header_len) < 0) {
        close(file_fd);
        return -1;
    }

    // Envoyer le fichier avec sendfile (z√©ro copie!)
    off_t offset = 0;
    ssize_t sent = sendfile(client_fd, file_fd, &offset, file_size);

    close(file_fd);

    if (sent != (ssize_t)file_size) {
        return -1;
    }

    return 0;
}
```

**Avantages de `sendfile()` :**
- **Z√©ro copie** : Les donn√©es vont directement du disque au socket
- Pas de passage par l'espace utilisateur
- Tr√®s performant (utilis√© par nginx, Apache)

**Fonctionnement :**
```
M√©thode traditionnelle:
Disque ‚Üí Kernel ‚Üí Espace Utilisateur ‚Üí Kernel ‚Üí Socket
        (DMA)      (copy)            (copy)    (DMA)

sendfile():
Disque ‚Üí Kernel ‚Üí Socket
        (DMA)    (DMA)
```

---

## D√©tection Automatique du Type MIME

Rappel de la section 34.4.2, am√©lioration avec cache :

```c
typedef struct {
    const char *extension;
    const char *mime_type;
} mime_entry_t;

static const mime_entry_t mime_table[] = {
    // Texte
    {".html", "text/html"},
    {".htm", "text/html"},
    {".css", "text/css"},
    {".js", "application/javascript"},
    {".json", "application/json"},
    {".xml", "application/xml"},
    {".txt", "text/plain"},
    {".csv", "text/csv"},

    // Images
    {".jpg", "image/jpeg"},
    {".jpeg", "image/jpeg"},
    {".png", "image/png"},
    {".gif", "image/gif"},
    {".svg", "image/svg+xml"},
    {".ico", "image/x-icon"},
    {".webp", "image/webp"},
    {".bmp", "image/bmp"},

    // Fonts
    {".woff", "font/woff"},
    {".woff2", "font/woff2"},
    {".ttf", "font/ttf"},
    {".otf", "font/otf"},

    // Documents
    {".pdf", "application/pdf"},
    {".doc", "application/msword"},
    {".docx", "application/vnd.openxmlformats-officedocument.wordprocessingml.document"},
    {".xls", "application/vnd.ms-excel"},
    {".xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"},

    // Archives
    {".zip", "application/zip"},
    {".tar", "application/x-tar"},
    {".gz", "application/gzip"},
    {".7z", "application/x-7z-compressed"},

    // Audio/Vid√©o
    {".mp3", "audio/mpeg"},
    {".wav", "audio/wav"},
    {".ogg", "audio/ogg"},
    {".mp4", "video/mp4"},
    {".webm", "video/webm"},
    {".avi", "video/x-msvideo"},

    {NULL, NULL}
};

const char *get_mime_type(const char *path) {
    // Trouver l'extension
    const char *dot = strrchr(path, '.');
    if (dot == NULL) {
        return "application/octet-stream";
    }

    // Chercher dans la table
    for (int i = 0; mime_table[i].extension != NULL; i++) {
        if (strcasecmp(dot, mime_table[i].extension) == 0) {
            return mime_table[i].mime_type;
        }
    }

    return "application/octet-stream";
}
```

---

## Mise en Cache (Optionnel)

Pour am√©liorer les performances, les navigateurs et serveurs utilisent le cache HTTP.

### Headers de cache

```c
void add_cache_headers(char *response, size_t response_size,
                      int *offset, time_t last_modified) {
    char time_buf[128];
    struct tm tm;

    // Date de derni√®re modification
    gmtime_r(&last_modified, &tm);
    strftime(time_buf, sizeof(time_buf),
            "%a, %d %b %Y %H:%M:%S GMT", &tm);

    *offset += snprintf(response + *offset, response_size - *offset,
                       "Last-Modified: %s\r\n", time_buf);

    // Cache-Control: permettre le cache pendant 1 heure
    *offset += snprintf(response + *offset, response_size - *offset,
                       "Cache-Control: max-age=3600\r\n");

    // ETag (identifiant unique bas√© sur l'inode et mtime)
    *offset += snprintf(response + *offset, response_size - *offset,
                       "ETag: \"%lx-%lx\"\r\n",
                       (unsigned long)st.st_ino,
                       (unsigned long)st.st_mtime);
}
```

### R√©pondre 304 Not Modified

Si le client a d√©j√† le fichier en cache :

```c
int check_if_modified(const http_request_t *request,
                     const struct stat *st) {
    // V√©rifier If-Modified-Since
    const char *if_modified = get_header_value(&request->headers,
                                               "If-Modified-Since");

    if (if_modified != NULL) {
        struct tm tm;
        if (strptime(if_modified, "%a, %d %b %Y %H:%M:%S GMT", &tm) != NULL) {
            time_t client_time = timegm(&tm);
            if (st->st_mtime <= client_time) {
                return 0;  // Pas modifi√©
            }
        }
    }

    return 1;  // Modifi√© ou pas de cache
}

// Utilisation
if (!check_if_modified(&request, &st)) {
    // Envoyer 304
    const char *response =
        "HTTP/1.1 304 Not Modified\r\n"
        "Connection: close\r\n"
        "\r\n";
    write(client_fd, response, strlen(response));
    return;
}
```

---

## Gestion des Erreurs

### 404 Not Found

```c
void send_404(int client_fd, const char *uri) {
    char body[512];
    snprintf(body, sizeof(body),
             "<!DOCTYPE html>\n"
             "<html>\n"
             "<head><title>404 Not Found</title></head>\n"
             "<body>\n"
             "<h1>404 Not Found</h1>\n"
             "<p>The requested URL <code>%s</code> was not found.</p>\n"
             "</body>\n"
             "</html>",
             uri);

    char response[2048];
    snprintf(response, sizeof(response),
             "HTTP/1.1 404 Not Found\r\n"
             "Content-Type: text/html\r\n"
             "Content-Length: %zu\r\n"
             "Connection: close\r\n"
             "\r\n"
             "%s",
             strlen(body), body);

    write(client_fd, response, strlen(response));
}
```

### 403 Forbidden

```c
void send_403(int client_fd) {
    const char *body =
        "<!DOCTYPE html>\n"
        "<html>\n"
        "<head><title>403 Forbidden</title></head>\n"
        "<body>\n"
        "<h1>403 Forbidden</h1>\n"
        "<p>You don't have permission to access this resource.</p>\n"
        "</body>\n"
        "</html>";

    char response[2048];
    snprintf(response, sizeof(response),
             "HTTP/1.1 403 Forbidden\r\n"
             "Content-Type: text/html\r\n"
             "Content-Length: %zu\r\n"
             "Connection: close\r\n"
             "\r\n"
             "%s",
             strlen(body), body);

    write(client_fd, response, strlen(response));
}
```

### 500 Internal Server Error

```c
void send_500(int client_fd) {
    const char *body =
        "<!DOCTYPE html>\n"
        "<html>\n"
        "<head><title>500 Internal Server Error</title></head>\n"
        "<body>\n"
        "<h1>500 Internal Server Error</h1>\n"
        "<p>The server encountered an error processing your request.</p>\n"
        "</body>\n"
        "</html>";

    char response[2048];
    snprintf(response, sizeof(response),
             "HTTP/1.1 500 Internal Server Error\r\n"
             "Content-Type: text/html\r\n"
             "Content-Length: %zu\r\n"
             "Connection: close\r\n"
             "\r\n"
             "%s",
             strlen(body), body);

    write(client_fd, response, strlen(response));
}
```

---

## Serveur Complet de Fichiers Statiques

Voici un serveur complet int√©grant tous les concepts :

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <limits.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/sendfile.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define PORT 8080
#define DOCUMENT_ROOT "./www"
#define INDEX_FILE "index.html"
#define BUFFER_SIZE 8192

// Structures HTTP (de la section 34.4.2)
// ... http_request_t, etc. ...

// Table MIME (d√©finie pr√©c√©demment)
// ... mime_table, get_mime_type() ...

int is_safe_path(const char *uri, const char *doc_root,
                char *safe_path, size_t size) {
    char full_path[PATH_MAX];
    char resolved_root[PATH_MAX];
    char resolved_path[PATH_MAX];

    if (realpath(doc_root, resolved_root) == NULL) {
        return -1;
    }

    snprintf(full_path, sizeof(full_path), "%s%s", doc_root, uri);

    if (realpath(full_path, resolved_path) == NULL) {
        // Le fichier n'existe pas, mais v√©rifier quand m√™me le chemin
        // On va accepter et laisser check_file() g√©rer l'erreur
        strncpy(safe_path, full_path, size);
        safe_path[size - 1] = '\0';
        return 0;
    }

    size_t root_len = strlen(resolved_root);
    if (strncmp(resolved_path, resolved_root, root_len) != 0) {
        return -1;  // Tentative de path traversal
    }

    strncpy(safe_path, resolved_path, size);
    safe_path[size - 1] = '\0';
    return 0;
}

int serve_file(int client_fd, const char *path) {
    // Ouvrir le fichier
    int file_fd = open(path, O_RDONLY);
    if (file_fd < 0) {
        return -1;
    }

    // Obtenir les infos
    struct stat st;
    if (fstat(file_fd, &st) != 0) {
        close(file_fd);
        return -1;
    }

    // V√©rifier que c'est un fichier r√©gulier
    if (!S_ISREG(st.st_mode)) {
        close(file_fd);
        return -1;
    }

    // D√©terminer le type MIME
    const char *mime_type = get_mime_type(path);

    // Construire les headers HTTP
    char header[1024];
    int header_len = snprintf(header, sizeof(header),
        "HTTP/1.1 200 OK\r\n"
        "Content-Type: %s\r\n"
        "Content-Length: %ld\r\n"
        "Connection: close\r\n"
        "\r\n",
        mime_type, st.st_size);

    // Envoyer les headers
    if (write(client_fd, header, header_len) < 0) {
        close(file_fd);
        return -1;
    }

    // Envoyer le fichier avec sendfile (z√©ro copie)
    off_t offset = 0;
    ssize_t sent = sendfile(client_fd, file_fd, &offset, st.st_size);

    close(file_fd);

    if (sent != st.st_size) {
        return -1;
    }

    return 0;
}

void handle_request(int client_fd, const http_request_t *request) {
    char safe_path[PATH_MAX];

    // V√©rifier la s√©curit√© du chemin
    if (is_safe_path(request->request_line.uri, DOCUMENT_ROOT,
                     safe_path, sizeof(safe_path)) != 0) {
        printf("Path traversal tentative: %s\n", request->request_line.uri);
        send_403(client_fd);
        return;
    }

    // V√©rifier si c'est un r√©pertoire
    struct stat st;
    if (stat(safe_path, &st) == 0 && S_ISDIR(st.st_mode)) {
        // Ajouter index.html
        size_t len = strlen(safe_path);
        if (len > 0 && safe_path[len - 1] != '/') {
            strncat(safe_path, "/", sizeof(safe_path) - len - 1);
        }
        strncat(safe_path, INDEX_FILE,
               sizeof(safe_path) - strlen(safe_path) - 1);
    }

    // V√©rifier que le fichier existe et est lisible
    if (access(safe_path, R_OK) != 0) {
        printf("Fichier non trouv√©: %s\n", safe_path);
        send_404(client_fd, request->request_line.uri);
        return;
    }

    // Servir le fichier
    printf("Servir: %s ‚Üí %s\n", request->request_line.uri, safe_path);
    if (serve_file(client_fd, safe_path) != 0) {
        send_500(client_fd);
    }
}

void handle_client(int client_fd) {
    char buffer[BUFFER_SIZE];

    // Lire la requ√™te
    ssize_t bytes_read = read(client_fd, buffer, sizeof(buffer) - 1);
    if (bytes_read <= 0) {
        close(client_fd);
        return;
    }

    buffer[bytes_read] = '\0';

    // Parser la requ√™te HTTP
    http_request_t request;
    if (parse_http_request(buffer, &request) != 0) {
        send_error_response(client_fd, 400, "Bad Request");
        close(client_fd);
        return;
    }

    // Log
    printf("%s %s %s\n",
           request.request_line.method,
           request.request_line.uri,
           request.request_line.version);

    // Ne g√©rer que GET et HEAD
    if (strcmp(request.request_line.method, "GET") == 0) {
        handle_request(client_fd, &request);
    } else if (strcmp(request.request_line.method, "HEAD") == 0) {
        // HEAD = comme GET mais sans body
        // TODO: impl√©menter
        send_error_response(client_fd, 501, "Not Implemented");
    } else {
        send_error_response(client_fd, 501, "Not Implemented");
    }

    close(client_fd);
}

int main(void) {
    int server_fd;
    struct sockaddr_in address;
    int opt = 1;

    // Cr√©er le r√©pertoire www s'il n'existe pas
    mkdir(DOCUMENT_ROOT, 0755);

    // Cr√©er le socket
    server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd < 0) {
        perror("socket");
        return EXIT_FAILURE;
    }

    // Options
    setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    // Configuration
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);

    // Bind
    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {
        perror("bind");
        close(server_fd);
        return EXIT_FAILURE;
    }

    // Listen
    if (listen(server_fd, 10) < 0) {
        perror("listen");
        close(server_fd);
        return EXIT_FAILURE;
    }

    printf("Serveur de fichiers statiques d√©marr√©\n");
    printf("Port: %d\n", PORT);
    printf("Document Root: %s\n", DOCUMENT_ROOT);
    printf("URL: http://localhost:%d/\n", PORT);

    // Boucle principale
    while (1) {
        struct sockaddr_in client_addr;
        socklen_t client_len = sizeof(client_addr);

        int client_fd = accept(server_fd,
                              (struct sockaddr *)&client_addr,
                              &client_len);

        if (client_fd < 0) {
            perror("accept");
            continue;
        }

        // Traiter le client
        handle_client(client_fd);
    }

    close(server_fd);
    return EXIT_SUCCESS;
}
```

---

## Pr√©paration de l'Environnement de Test

### Structure du r√©pertoire web

```bash
# Cr√©er la structure
mkdir -p www/images
mkdir -p www/css
mkdir -p www/js

# Cr√©er index.html
cat > www/index.html << 'EOF'
<!DOCTYPE html>
<html>
<head>
    <title>Mon Serveur C</title>
    <link rel="stylesheet" href="/css/style.css">
</head>
<body>
    <h1>Bienvenue sur mon serveur C!</h1>
    <img src="/images/logo.png" alt="Logo">
    <script src="/js/script.js"></script>
</body>
</html>
EOF

# Cr√©er style.css
cat > www/css/style.css << 'EOF'
body {
    font-family: Arial, sans-serif;
    max-width: 800px;
    margin: 50px auto;
    padding: 20px;
}

h1 {
    color: #333;
}
EOF

# Cr√©er script.js
cat > www/js/script.js << 'EOF'
console.log('Serveur C fonctionne!');
EOF

# T√©l√©charger une image de test (ou cr√©er une image simple)
# curl -o www/images/logo.png https://example.com/logo.png
```

### Compilation et test

```bash
# Compiler
gcc -Wall -Wextra -O2 -o static_server \
    static_server.c http_parser.c

# Lancer
./static_server

# Dans un autre terminal
curl http://localhost:8080/
curl http://localhost:8080/css/style.css
curl http://localhost:8080/images/logo.png

# Ou ouvrir dans un navigateur
firefox http://localhost:8080/
```

---

## Logging et Monitoring

### Log des requ√™tes (format Apache)

```c
void log_request(const http_request_t *request, int status_code,
                size_t bytes_sent) {
    time_t now = time(NULL);
    struct tm tm;
    localtime_r(&now, &tm);

    char time_buf[64];
    strftime(time_buf, sizeof(time_buf), "%d/%b/%Y:%H:%M:%S %z", &tm);

    // Format: IP - - [time] "METHOD URI VERSION" STATUS BYTES
    printf("127.0.0.1 - - [%s] \"%s %s %s\" %d %zu\n",
           time_buf,
           request->request_line.method,
           request->request_line.uri,
           request->request_line.version,
           status_code,
           bytes_sent);
}

// Exemple de sortie:
// 127.0.0.1 - - [28/Nov/2025:15:30:45 +0100] "GET /index.html HTTP/1.1" 200 1234
```

### Statistiques en temps r√©el

```c
typedef struct {
    unsigned long total_requests;
    unsigned long total_bytes_sent;
    unsigned long errors_404;
    unsigned long errors_403;
    unsigned long errors_500;
} server_stats_t;

server_stats_t stats = {0};

void update_stats(int status_code, size_t bytes_sent) {
    stats.total_requests++;
    stats.total_bytes_sent += bytes_sent;

    if (status_code == 404) stats.errors_404++;
    if (status_code == 403) stats.errors_403++;
    if (status_code == 500) stats.errors_500++;
}

void print_stats(void) {
    printf("\n=== Statistiques ===\n");
    printf("Requ√™tes totales: %lu\n", stats.total_requests);
    printf("Bytes envoy√©s: %lu (%.2f MB)\n",
           stats.total_bytes_sent,
           stats.total_bytes_sent / (1024.0 * 1024.0));
    printf("Erreurs 404: %lu\n", stats.errors_404);
    printf("Erreurs 403: %lu\n", stats.errors_403);
    printf("Erreurs 500: %lu\n", stats.errors_500);
    printf("==================\n\n");
}
```

---

## Optimisations Avanc√©es

### 1. Cache de fichiers en m√©moire

Pour les petits fichiers fr√©quemment demand√©s :

```c
#define MAX_CACHE_ENTRIES 100
#define MAX_CACHE_FILE_SIZE (100 * 1024)  // 100 KB

typedef struct {
    char path[PATH_MAX];
    char *content;
    size_t size;
    time_t cached_at;
    time_t mtime;  // Modification time du fichier
} cache_entry_t;

cache_entry_t file_cache[MAX_CACHE_ENTRIES];
int cache_count = 0;

cache_entry_t *get_from_cache(const char *path) {
    struct stat st;

    for (int i = 0; i < cache_count; i++) {
        if (strcmp(file_cache[i].path, path) == 0) {
            // V√©rifier si le fichier a √©t√© modifi√©
            if (stat(path, &st) == 0 && st.st_mtime == file_cache[i].mtime) {
                return &file_cache[i];
            }
            // Fichier modifi√©, invalider le cache
            free(file_cache[i].content);
            file_cache[i].content = NULL;
            return NULL;
        }
    }

    return NULL;
}

int add_to_cache(const char *path, char *content, size_t size) {
    if (cache_count >= MAX_CACHE_ENTRIES) {
        return -1;  // Cache plein
    }

    struct stat st;
    if (stat(path, &st) != 0) {
        return -1;
    }

    cache_entry_t *entry = &file_cache[cache_count++];
    strncpy(entry->path, path, sizeof(entry->path) - 1);
    entry->content = content;
    entry->size = size;
    entry->cached_at = time(NULL);
    entry->mtime = st.st_mtime;

    return 0;
}
```

### 2. Compression gzip

Pour les fichiers texte (HTML, CSS, JS) :

```c
#include <zlib.h>

int send_compressed(int client_fd, const char *path) {
    // Lire le fichier
    size_t file_size;
    char *content = read_file(path, &file_size);
    if (content == NULL) {
        return -1;
    }

    // Compresser avec zlib
    uLongf compressed_size = compressBound(file_size);
    char *compressed = malloc(compressed_size);

    if (compress2((Bytef *)compressed, &compressed_size,
                 (Bytef *)content, file_size, Z_DEFAULT_COMPRESSION) != Z_OK) {
        free(content);
        free(compressed);
        return -1;
    }

    // Envoyer avec header Content-Encoding: gzip
    char header[1024];
    snprintf(header, sizeof(header),
             "HTTP/1.1 200 OK\r\n"
             "Content-Type: %s\r\n"
             "Content-Length: %lu\r\n"
             "Content-Encoding: gzip\r\n"
             "Connection: close\r\n"
             "\r\n",
             get_mime_type(path), compressed_size);

    write(client_fd, header, strlen(header));
    write(client_fd, compressed, compressed_size);

    free(content);
    free(compressed);
    return 0;
}
```

### 3. Range Requests (T√©l√©chargement partiel)

Utile pour les vid√©os :

```c
int handle_range_request(int client_fd, const char *path,
                        const char *range_header) {
    // Parser "Range: bytes=0-1023"
    unsigned long start, end;
    if (sscanf(range_header, "bytes=%lu-%lu", &start, &end) != 2) {
        return -1;
    }

    int fd = open(path, O_RDONLY);
    if (fd < 0) return -1;

    struct stat st;
    fstat(fd, &st);

    if (end >= (unsigned long)st.st_size) {
        end = st.st_size - 1;
    }

    size_t content_length = end - start + 1;

    // R√©ponse 206 Partial Content
    char header[512];
    snprintf(header, sizeof(header),
             "HTTP/1.1 206 Partial Content\r\n"
             "Content-Type: %s\r\n"
             "Content-Length: %zu\r\n"
             "Content-Range: bytes %lu-%lu/%ld\r\n"
             "Connection: close\r\n"
             "\r\n",
             get_mime_type(path), content_length,
             start, end, st.st_size);

    write(client_fd, header, strlen(header));

    // Envoyer la portion demand√©e
    off_t offset = start;
    sendfile(client_fd, fd, &offset, content_length);

    close(fd);
    return 0;
}
```

---

## S√©curit√© : Checklist

- ‚úÖ **Path Traversal** : Utiliser `realpath()` et v√©rifier le pr√©fixe
- ‚úÖ **Permissions** : V√©rifier `access(path, R_OK)`
- ‚úÖ **Taille des requ√™tes** : Limiter √† MAX_REQUEST_SIZE
- ‚úÖ **Timeout** : Ne pas bloquer ind√©finiment sur un client
- ‚úÖ **Symlinks** : `realpath()` les r√©sout automatiquement
- ‚úÖ **Hidden files** : Optionnel, refuser les fichiers commen√ßant par `.`
- ‚úÖ **Directory listing** : Ne pas exposer le contenu des r√©pertoires
- ‚úÖ **Error messages** : Ne pas r√©v√©ler les chemins internes

### Refuser les fichiers cach√©s

```c
int is_hidden_file(const char *path) {
    const char *filename = strrchr(path, '/');
    if (filename == NULL) {
        filename = path;
    } else {
        filename++;  // Sauter le '/'
    }

    return (filename[0] == '.');
}

// Utilisation
if (is_hidden_file(safe_path)) {
    send_403(client_fd);
    return;
}
```

---

## Tests et Benchmarks

### Test de charge avec Apache Bench

```bash
# 1000 requ√™tes, 100 concurrentes
ab -n 1000 -c 100 http://localhost:8080/index.html

# R√©sultats attendus:
# Requests per second: 5000-10000 [#/sec]
# Time per request: 0.1-0.2 [ms]
```

### Test avec wrk

```bash
# 4 threads, 100 connexions, dur√©e 30s
wrk -t4 -c100 -d30s http://localhost:8080/

# R√©sultats typiques:
# Latency: 1-2ms (moyenne)
# Req/Sec: 10k-50k (selon la machine)
```

### V√©rification de la s√©curit√©

```bash
# Tenter path traversal
curl http://localhost:8080/../../../etc/passwd
# Doit retourner 403 Forbidden

# Tenter d'acc√©der √† un fichier cach√©
curl http://localhost:8080/.htaccess
# Doit retourner 403 Forbidden

# Requ√™te malform√©e
echo "INVALID REQUEST" | nc localhost 8080
# Doit retourner 400 Bad Request
```

---

## R√©sum√©

Servir des fichiers statiques en C n√©cessite :

1. **Conversion URI ‚Üí Chemin** : Mapper les URLs vers le syst√®me de fichiers
2. **S√©curit√©** : Pr√©venir path traversal avec `realpath()`
3. **V√©rifications** : Existence, permissions, type de fichier
4. **Lecture efficace** : `sendfile()` pour z√©ro copie
5. **Types MIME** : D√©tection automatique par extension
6. **Gestion des r√©pertoires** : Servir `index.html` par d√©faut
7. **Erreurs** : 404, 403, 500 avec messages appropri√©s
8. **Cache HTTP** : Last-Modified, ETag, 304 Not Modified
9. **Logging** : Format Apache pour les requ√™tes
10. **Optimisations** : Cache m√©moire, compression, range requests

**Votre serveur peut maintenant :**
- Servir n'importe quel type de fichier
- G√©rer les r√©pertoires et index files
- Prot√©ger contre les attaques path traversal
- Optimiser avec sendfile() et cache
- Logger toutes les requ√™tes

**Prochaine √©tape :** Int√©grer tout (event-driven + HTTP parsing + file serving) dans un serveur web complet et production-ready !

---

## Pour Aller Plus Loin

### Fonctionnalit√©s Avanc√©es

- **Virtual Hosts** : Servir plusieurs sites sur un m√™me serveur
- **URL Rewriting** : R√©√©criture d'URLs (comme Apache mod_rewrite)
- **Directory Listing** : G√©n√©rer automatiquement un index HTML
- **CGI/FastCGI** : Ex√©cuter des scripts dynamiques
- **WebDAV** : Permettre l'upload de fichiers
- **HTTPS/TLS** : Chiffrement avec OpenSSL

### Serveurs Open Source √† √âtudier

- **lighttpd** : Serveur l√©ger en C
- **nginx** : Architecture event-driven, code tr√®s optimis√©
- **thttpd** : Minimaliste, excellent pour apprendre

### Ressources

- **RFC 7231** : HTTP/1.1 Semantics (Content-Type, caching)
- **RFC 7232** : HTTP/1.1 Conditional Requests (If-Modified-Since)
- **sendfile(2)** : man page Linux

Vous avez maintenant toutes les connaissances pour cr√©er un serveur web statique performant et s√©curis√© en C !

‚è≠Ô∏è [Debugging de code complexe](/35-debugging-code-complexe/README.md)
