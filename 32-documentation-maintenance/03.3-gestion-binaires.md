üîù Retour au [Sommaire](/SOMMAIRE.md)

# 32.3.3 Gestion des binaires

## Introduction

Vous compilez votre projet C. Votre dossier contient maintenant des fichiers `.o`, un ex√©cutable, peut-√™tre quelques biblioth√®ques `.so`. Vous faites `git add .` et... **STOP !** üõë

Vous √™tes sur le point de faire une erreur courante : **commiter des fichiers binaires g√©n√©r√©s** dans votre d√©p√¥t Git. Dans cette section, nous allons comprendre pourquoi c'est probl√©matique et comment g√©rer correctement les binaires dans vos projets C.

Nous allons apprendre :
- Ce qu'est un fichier binaire et pourquoi Git n'aime pas √ßa
- Quels binaires ne JAMAIS commiter
- Comment configurer `.gitignore` pour un projet C
- Quand et comment versionner certains binaires
- Git LFS pour les gros fichiers binaires
- Les alternatives pour g√©rer les d√©pendances

---

## Qu'est-ce qu'un fichier binaire ?

### Fichiers texte vs fichiers binaires

**Fichier texte** :
- Contient des caract√®res lisibles (ASCII, UTF-8)
- √âditable avec un √©diteur de texte
- Exemples : `.c`, `.h`, `.txt`, `.md`, `.json`, `.xml`

```c
// fichier texte : main.c
#include <stdio.h>

int main() {
    printf("Hello\n");
    return 0;
}
```

**Fichier binaire** :
- Contient des octets bruts, non textuels
- Pas directement lisible par un humain
- N√©cessite un programme sp√©cifique pour √™tre interpr√©t√©
- Exemples : `.o`, `.exe`, `.so`, `.a`, `.dll`, `.png`, `.jpg`, `.pdf`

```bash
# Voir un fichier binaire (illisible)
$ cat main.o
‚ñíELF‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí@‚ñí‚ñí‚ñí‚ñí@‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí@‚ñí8‚ñí‚ñí@‚ñí‚ñí‚ñí...
```

### Pourquoi Git n'aime pas les binaires ?

Git est optimis√© pour les fichiers texte. Voici pourquoi les binaires posent probl√®me :

#### 1. **Pas de diff efficace**

Pour les fichiers texte, Git montre exactement ce qui a chang√© :

```diff
- printf("Hello");
+ printf("Hello World");
```

Pour les binaires, Git ne peut que dire "le fichier a chang√©" :

```bash
$ git diff main.o
Binary files a/main.o and b/main.o differ
```

Impossible de savoir **ce qui** a chang√© !

#### 2. **Pas de compression delta**

Git utilise la compression delta : il ne stocke que les diff√©rences entre versions.

**Pour un fichier texte** :
```
Version 1 (1 KB) + Delta (10 bytes) = Version 2
```
Git ne stocke que 10 bytes de diff√©rence.

**Pour un fichier binaire** :
```
Version 1 (500 KB) + Version 2 compl√®te (500 KB) = 1 MB
```
Git doit stocker les deux versions en entier !

#### 3. **Taille du d√©p√¥t explose**

Chaque commit d'un binaire ajoute toute la taille du fichier au d√©p√¥t.

**Exemple** : Commiter un ex√©cutable de 2 MB √† chaque modification :
- 10 commits ‚Üí +20 MB dans le d√©p√¥t
- 100 commits ‚Üí +200 MB
- 1000 commits ‚Üí +2 GB !

Le d√©p√¥t devient **√©norme** et le clonage **tr√®s lent**.

#### 4. **Impossible √† merger**

En cas de conflit sur un fichier texte, vous pouvez choisir manuellement les lignes √† garder.

Pour un binaire en conflit, Git ne peut pas vous aider. Vous devez choisir une version compl√®te ou l'autre, pas de fusion partielle.

---

## Fichiers binaires dans un projet C

### Fichiers g√©n√©r√©s par la compilation

Ces fichiers sont **cr√©√©s automatiquement** lors de la compilation. Ils ne doivent **JAMAIS** √™tre versionn√©s.

#### Fichiers objets

```bash
main.o          # GCC/Clang
parser.o
utils.o
*.obj           # MSVC (Windows)
```

**Pourquoi ?** Reconstruits √† chaque compilation. Inutile de les versionner.

#### Ex√©cutables

```bash
mon_programme   # Linux/Mac
mon_programme.exe  # Windows
a.out           # Sortie par d√©faut de gcc
```

**Pourquoi ?** D√©pendent de la plateforme et de l'environnement. Chacun doit compiler le sien.

#### Biblioth√®ques compil√©es

```bash
libmonprojet.a     # Biblioth√®que statique
libmonprojet.so    # Biblioth√®que partag√©e Linux
libmonprojet.dylib # Biblioth√®que partag√©e macOS
libmonprojet.dll   # Biblioth√®que Windows
```

**Pourquoi ?** Comme les ex√©cutables, doivent √™tre recompil√©s selon la plateforme.

#### Fichiers de build

```bash
CMakeCache.txt
CMakeFiles/
Makefile           # G√©n√©r√© par CMake
cmake_install.cmake
*.cmake
compile_commands.json
build/             # Dossier de build entier
```

**Pourquoi ?** G√©n√©r√©s par CMake ou autotools. Chaque d√©veloppeur les cr√©e localement.

#### Fichiers de debug

```bash
core              # Core dump
core.*
*.dSYM/           # Debug symbols macOS
*.pdb             # Debug symbols Windows
vgcore.*          # Valgrind core dumps
```

**Pourquoi ?** G√©n√©r√©s pendant le debugging. Inutiles pour les autres d√©veloppeurs.

### Fichiers binaires des outils

```bash
.vscode/          # Configuration VS Code (peut contenir des paths absolus)
.idea/            # Configuration IntelliJ/CLion
*.swp             # Fichiers swap Vim
*.swo
*~                # Fichiers backup
.DS_Store         # M√©tadonn√©es macOS
Thumbs.db         # Miniatures Windows
```

**Pourquoi ?** Sp√©cifiques √† votre environnement de d√©veloppement.

### Fichiers temporaires

```bash
*.log             # Logs
*.tmp
*.temp
*.bak
*.backup
*.orig            # Fichiers de merge
*.rej             # Rejects de patch
```

---

## Le fichier `.gitignore`

### Qu'est-ce que `.gitignore` ?

Le fichier `.gitignore` liste les fichiers et dossiers que Git doit **ignorer**. Ils ne seront pas track√©s, m√™me si vous faites `git add .`.

### Cr√©er un `.gitignore` pour projet C

√Ä la racine de votre projet, cr√©ez un fichier `.gitignore` :

```bash
# .gitignore pour projet C

###################
# Fichiers compil√©s
###################

# Fichiers objets
*.o
*.ko
*.obj
*.elf

# Biblioth√®ques pr√©compil√©es
*.lib
*.a
*.la
*.lo

# Biblioth√®ques partag√©es
*.dll
*.so
*.so.*
*.dylib

# Ex√©cutables
*.exe
*.out
*.app
a.out

###################
# Fichiers CMake
###################

CMakeCache.txt
CMakeFiles/
CMakeScripts/
cmake_install.cmake
install_manifest.txt
compile_commands.json
CTestTestfile.cmake
build/
build-*/

###################
# Fichiers Make
###################

*.d
.deps/
.dirstamp

###################
# Debug et profiling
###################

# Core dumps
core
core.*
vgcore.*

# Debug symbols
*.dSYM/
*.su
*.idb
*.pdb

# Profiling
gmon.out
*.gcov
*.gcda
*.gcno

# Coverage
*.info
coverage/
*.coverage

###################
# Valgrind
###################

valgrind-*.log
*.memcheck
*.helgrind
*.drd

###################
# √âditeurs et IDEs
###################

# VS Code
.vscode/*
!.vscode/settings.json    # Garder certains fichiers de config
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json

# CLion / IntelliJ
.idea/
cmake-build-*/

# Vim
*.swp
*.swo
*~
.*.swp

# Emacs
\#*\#
.\#*

# Sublime Text
*.sublime-workspace
*.sublime-project

###################
# OS
###################

# macOS
.DS_Store
.AppleDouble
.LSOverride

# Windows
Thumbs.db
ehthumbs.db
Desktop.ini

# Linux
.directory
.Trash-*

###################
# Temporaires
###################

*.tmp
*.temp
*.log
*.bak
*.backup
*.old
*.orig
*.rej

###################
# Documentation g√©n√©r√©e
###################

docs/html/
docs/latex/
docs/*.pdf

###################
# Tests et benchmarks
###################

test_results/
*.test
*.bench

###################
# D√©pendances (si locales)
###################

deps/
vendor/
lib/
external/

###################
# Packaging
###################

*.deb
*.rpm
*.tar.gz
*.zip
dist/
pkg/
```

### Syntaxe du `.gitignore`

```bash
# Commentaire

# Ignorer un fichier sp√©cifique
main.o

# Ignorer tous les fichiers avec extension .o
*.o

# Ignorer un dossier entier
build/

# Ignorer tous les fichiers dans un dossier
logs/*

# Mais garder le dossier lui-m√™me
!logs/.gitkeep

# Ignorer seulement √† la racine
/main.o        # Ignore main.o √† la racine
               # Mais pas src/main.o

# N√©gation (ne pas ignorer)
*.o
!important.o   # Tous les .o sauf important.o

# Patterns complexes
**/build/      # build/ √† n'importe quel niveau
src/**/*.o     # Tous les .o dans src/ et sous-dossiers
```

### Ajouter `.gitignore` au d√©p√¥t

Le `.gitignore` **doit √™tre versionn√©** :

```bash
git add .gitignore
git commit -m "Add .gitignore for C project"
git push
```

Ainsi, tous les d√©veloppeurs b√©n√©ficient des m√™mes r√®gles.

### `.gitignore` global (optionnel)

Pour ignorer des fichiers sur **tous** vos projets :

```bash
# Cr√©er un .gitignore global
vim ~/.gitignore_global

# Ajouter vos pr√©f√©rences personnelles
.DS_Store
*.swp
.vscode/
.idea/

# Configurer Git pour l'utiliser
git config --global core.excludesfile ~/.gitignore_global
```

---

## V√©rifier ce que Git ignore

### Voir les fichiers ignor√©s

```bash
# Lister tous les fichiers ignor√©s
git status --ignored

# Voir pourquoi un fichier est ignor√©
git check-ignore -v main.o
# Output: .gitignore:5:*.o    main.o
```

### Forcer l'ajout d'un fichier ignor√©

Si vous voulez vraiment ajouter un fichier normalement ignor√© :

```bash
git add -f fichier_ignore.o
```

**‚ö†Ô∏è Attention** : Faites-le seulement si vous savez ce que vous faites !

### Nettoyer les fichiers ignor√©s

```bash
# Voir ce qui serait supprim√©
git clean -xdn

# Supprimer les fichiers ignor√©s
git clean -xdf
```

**‚ö†Ô∏è Prudence** : Cette commande **supprime d√©finitivement** les fichiers !

---

## Quels binaires PEUVENT √™tre versionn√©s ?

Dans certains cas, il est acceptable de versionner des binaires.

### 1. Binaires de d√©pendances tierces

Si votre projet d√©pend de biblioth√®ques externes pr√©compil√©es :

**Cas d'usage** :
- Biblioth√®que propri√©taire sans sources
- DLL sp√©cifique √† une version
- Binaire rare ou difficile √† obtenir

**Structure recommand√©e** :
```
projet/
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ README.md              # Expliquer la provenance
‚îÇ   ‚îú‚îÄ‚îÄ linux/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ libfoo.so.1.2.3
‚îÇ   ‚îú‚îÄ‚îÄ macos/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ libfoo.1.2.3.dylib
‚îÇ   ‚îî‚îÄ‚îÄ windows/
‚îÇ       ‚îî‚îÄ‚îÄ foo.dll
```

**Dans `.gitignore`** :
```bash
# Ignorer les binaires g√©n√©r√©s
build/
*.o
*.exe

# MAIS ne pas ignorer les d√©pendances versionn√©es
!lib/**/*.so
!lib/**/*.dll
!lib/**/*.dylib
```

**‚ö†Ô∏è Important** : Documentez clairement l'origine de ces binaires dans un README.

### 2. Fichiers de test

Des fichiers binaires de r√©f√©rence pour tester votre programme :

```
tests/
‚îú‚îÄ‚îÄ fixtures/
‚îÇ   ‚îú‚îÄ‚îÄ sample.png           # Image de test
‚îÇ   ‚îú‚îÄ‚îÄ corrupt.bin          # Fichier binaire corrompu pour tester
‚îÇ   ‚îî‚îÄ‚îÄ reference_output.dat # Sortie de r√©f√©rence
```

**Justification** : Ces fichiers font partie de la logique de test. Tout le monde doit avoir les m√™mes pour que les tests soient reproductibles.

### 3. Ressources du projet

Assets n√©cessaires au fonctionnement du programme :

```
resources/
‚îú‚îÄ‚îÄ icon.ico
‚îú‚îÄ‚îÄ logo.png
‚îú‚îÄ‚îÄ font.ttf
‚îî‚îÄ‚îÄ default_config.dat
```

**Justification** : Partie int√©grante de l'application, pas g√©n√©r√©s.

### 4. Documentation compil√©e (avec prudence)

Parfois, vous voulez versionner un PDF de documentation :

```
docs/
‚îú‚îÄ‚îÄ user_manual.md    # Source (versionn√©)
‚îî‚îÄ‚îÄ user_manual.pdf   # Compil√© (optionnel)
```

**Alternative pr√©f√©r√©e** : G√©n√©rer le PDF dans le CI et le publier en release, pas dans Git.

---

## Git LFS (Large File Storage)

### Qu'est-ce que Git LFS ?

Git LFS est une extension qui g√®re efficacement les **gros fichiers binaires**. Au lieu de stocker le fichier binaire dans Git, LFS stocke un petit pointeur et met le vrai fichier sur un serveur s√©par√©.

**Sans LFS** :
```
Git d√©p√¥t : 2 GB (dont 1.9 GB de binaires)
Clone : T√©l√©charge tout (tr√®s lent)
```

**Avec LFS** :
```
Git d√©p√¥t : 100 MB (seulement des pointeurs)
LFS serveur : 1.9 GB (binaires)
Clone : Rapide, t√©l√©charge les binaires uniquement si n√©cessaire
```

### Installation

```bash
# Ubuntu/Debian
sudo apt install git-lfs

# macOS
brew install git-lfs

# Windows
# T√©l√©charger depuis https://git-lfs.github.com/

# Initialiser dans votre utilisateur (une fois)
git lfs install
```

### Utilisation basique

```bash
# Dans votre projet
cd mon-projet

# Tracker les gros fichiers binaires
git lfs track "*.so"
git lfs track "*.dll"
git lfs track "*.dylib"
git lfs track "tests/fixtures/*.bin"

# Cela cr√©e/modifie .gitattributes
git add .gitattributes
git commit -m "Configure Git LFS for shared libraries"

# Ajouter vos fichiers normalement
git add lib/libfoo.so
git commit -m "Add libfoo shared library"
git push
```

### V√©rifier ce qui est track√© par LFS

```bash
# Voir les patterns LFS
cat .gitattributes

# Lister les fichiers LFS
git lfs ls-files

# Statut LFS
git lfs status
```

### Exemple de `.gitattributes`

```bash
# .gitattributes

# Biblioth√®ques partag√©es
*.so filter=lfs diff=lfs merge=lfs -text
*.dll filter=lfs diff=lfs merge=lfs -text
*.dylib filter=lfs diff=lfs merge=lfs -text

# Archives
*.zip filter=lfs diff=lfs merge=lfs -text
*.tar.gz filter=lfs diff=lfs merge=lfs -text

# Fichiers de test
tests/fixtures/*.bin filter=lfs diff=lfs merge=lfs -text
tests/fixtures/*.dat filter=lfs diff=lfs merge=lfs -text

# Documentation PDF
docs/*.pdf filter=lfs diff=lfs merge=lfs -text

# Images et assets (si n√©cessaire)
# resources/*.png filter=lfs diff=lfs merge=lfs -text
```

### Limites de Git LFS

**‚ö†Ô∏è Attention** :

1. **Co√ªt** : GitHub facture le stockage LFS au-del√† de 1 GB gratuit
2. **Bande passante** : 1 GB/mois gratuit, puis facturation
3. **Compatibilit√©** : Tous les h√©bergeurs ne supportent pas LFS
4. **Complexit√©** : Ajoute une couche de complexit√©

**Alternative** : Pour de gros fichiers, consid√©rez plut√¥t :
- H√©berger sur un serveur de fichiers s√©par√©
- Utiliser un gestionnaire de packages (voir ci-dessous)
- T√©l√©charger √† la demande avec un script

---

## Alternatives √† Git pour les binaires

Pour les projets C avec beaucoup de d√©pendances binaires, Git n'est pas toujours la meilleure solution.

### 1. Gestionnaires de paquets

#### Conan (recommand√© pour C/C++)

**Conan** est un gestionnaire de paquets pour C/C++ :

```bash
# Installation
pip install conan

# Fichier conanfile.txt
[requires]
zlib/1.2.11
openssl/1.1.1k

[generators]
cmake

# Installer les d√©pendances
conan install . --output-folder=build --build=missing

# Les binaires sont t√©l√©charg√©s, pas dans Git
```

**Avantages** :
- ‚úÖ G√®re automatiquement les d√©pendances
- ‚úÖ Supporte plusieurs plateformes
- ‚úÖ Int√©gration CMake
- ‚úÖ Pas dans le d√©p√¥t Git

**Site** : https://conan.io/

#### vcpkg (Microsoft)

```bash
# Installer vcpkg
git clone https://github.com/Microsoft/vcpkg.git
cd vcpkg && ./bootstrap-vcpkg.sh

# Installer une biblioth√®que
./vcpkg install curl

# Int√©grer avec CMake
cmake -DCMAKE_TOOLCHAIN_FILE=/path/to/vcpkg/scripts/buildsystems/vcpkg.cmake ..
```

**Site** : https://vcpkg.io/

#### Gestionnaires syst√®me

```bash
# Ubuntu/Debian
sudo apt install libcurl4-openssl-dev

# Fedora
sudo dnf install libcurl-devel

# macOS
brew install curl
```

**Dans votre README** :
```markdown
## D√©pendances

```bash
# Ubuntu/Debian
sudo apt install libcurl4-openssl-dev libssl-dev

# Fedora
sudo dnf install libcurl-devel openssl-devel

# macOS
brew install curl openssl
```
```

### 2. Git Submodules

Pour inclure des projets entiers (avec sources) :

```bash
# Ajouter un submodule
git submodule add https://github.com/user/lib external/lib

# Cloner un projet avec submodules
git clone --recursive https://github.com/user/projet

# Ou apr√®s un clone normal
git submodule update --init --recursive

# Mettre √† jour les submodules
git submodule update --remote
```

**Structure** :
```
projet/
‚îú‚îÄ‚îÄ src/
‚îú‚îÄ‚îÄ external/          # Submodules
‚îÇ   ‚îú‚îÄ‚îÄ lib1/         # Pointe vers un commit sp√©cifique de lib1
‚îÇ   ‚îî‚îÄ‚îÄ lib2/         # Pointe vers un commit sp√©cifique de lib2
‚îî‚îÄ‚îÄ CMakeLists.txt
```

**Avantages** :
- ‚úÖ Sources disponibles, pas de binaires
- ‚úÖ Version pr√©cise (commit hash)

**Inconv√©nients** :
- ‚ùå Complexit√© (submodules sont souvent mal compris)
- ‚ùå N√©cessite compilation des d√©pendances

### 3. Script de t√©l√©chargement

Cr√©ez un script qui t√©l√©charge les binaires n√©cessaires :

```bash
#!/bin/bash
# scripts/download_deps.sh

DEPS_DIR="deps"
mkdir -p $DEPS_DIR

echo "T√©l√©chargement des d√©pendances..."

# T√©l√©charger libfoo
curl -L https://example.com/libfoo-1.2.3-linux.tar.gz \
  -o $DEPS_DIR/libfoo.tar.gz
tar -xzf $DEPS_DIR/libfoo.tar.gz -C $DEPS_DIR

# T√©l√©charger libbar
wget https://example.com/libbar.so -P $DEPS_DIR

echo "D√©pendances install√©es dans $DEPS_DIR/"
```

**Dans `.gitignore`** :
```bash
deps/
```

**Dans votre README** :
```markdown
## Installation

1. Cloner le projet
```bash
git clone https://github.com/user/projet
cd projet
```

2. T√©l√©charger les d√©pendances
```bash
./scripts/download_deps.sh
```

3. Compiler
```bash
mkdir build && cd build
cmake ..
make
```
```

### 4. Releases GitHub

Pour distribuer des binaires compil√©s (mais pas dans Git) :

```bash
# Compiler votre projet
make release

# Cr√©er une archive
tar -czf mon-projet-v1.0.0-linux-x64.tar.gz bin/

# Cr√©er une release sur GitHub
gh release create v1.0.0 \
  mon-projet-v1.0.0-linux-x64.tar.gz \
  -t "Version 1.0.0" \
  -n "Premi√®re release stable"
```

Les utilisateurs t√©l√©chargent le binaire depuis les Releases, pas depuis Git.

---

## Bonnes pratiques r√©capitulatives

### Do ‚úÖ

1. **Toujours avoir un `.gitignore`** d√®s le d√©but du projet
2. **Versionner le `.gitignore`** pour que toute l'√©quipe en b√©n√©ficie
3. **Ignorer tous les fichiers g√©n√©r√©s** (.o, ex√©cutables, .so, etc.)
4. **Utiliser un gestionnaire de paquets** (Conan, vcpkg) pour les d√©pendances
5. **Documenter les d√©pendances** dans le README
6. **Utiliser Git LFS** si vous devez absolument versionner de gros binaires
7. **Nettoyer r√©guli√®rement** avec `git clean` pour garder le d√©p√¥t propre
8. **Fournir des scripts** de t√©l√©chargement/installation des d√©pendances
9. **Publier les binaires en Releases**, pas dans Git

### Don't ‚ùå

1. **Ne commitez jamais les fichiers compil√©s** (.o, .exe, .so)
2. **Ne commitez pas les dossiers de build** (build/, CMakeFiles/)
3. **Ne commitez pas les fichiers temporaires** (*.log, *.tmp, core)
4. **Ne commitez pas les fichiers sp√©cifiques √† l'IDE** (.vscode/, .idea/)
5. **N'utilisez pas `git add .` sans v√©rifier** ‚Üí Toujours `git status` avant !
6. **Ne forcez pas l'ajout** avec `git add -f` de fichiers ignor√©s sans raison
7. **Ne versionnez pas de gros binaires** sans Git LFS
8. **Ne commitez pas de binaires propri√©taires** sans permission l√©gale

---

## Nettoyer un d√©p√¥t d√©j√† pollu√©

### Si vous avez accidentellement commit√© des binaires

#### Cas 1 : Commit pas encore push√©

**Solution simple** : Amender ou reset

```bash
# Voir le dernier commit
git log -1 --stat

# Si vous venez de commiter des binaires par erreur
git reset HEAD~1  # Annule le dernier commit

# Ajouter .gitignore
echo "*.o" >> .gitignore
echo "*.exe" >> .gitignore

# Re-commiter proprement
git add .gitignore src/
git commit -m "Add source files (without binaries)"
```

#### Cas 2 : Commit d√©j√† push√© (mais branche r√©cente)

**Solution** : Force push apr√®s correction

```bash
# Corriger localement (reset, amend, rebase)
git reset HEAD~1
git add .gitignore src/
git commit -m "Add source files (without binaries)"

# Force push (ATTENTION : coordonnez avec l'√©quipe)
git push --force-with-lease
```

**‚ö†Ô∏è Attention** : Ne faites √ßa que si personne n'a d√©j√† pull√© la mauvaise version !

#### Cas 3 : Binaires dans l'historique ancien

**Solution** : R√©√©crire l'historique avec `git filter-repo`

```bash
# Installer git-filter-repo
pip3 install git-filter-repo

# Supprimer tous les .o de l'historique
git filter-repo --path-glob '*.o' --invert-paths

# Supprimer un dossier entier
git filter-repo --path build/ --invert-paths

# Force push apr√®s nettoyage
git push origin --force --all
```

**‚ö†Ô∏è ATTENTION** :
- Cette op√©ration r√©√©crit **tout** l'historique
- Tous les d√©veloppeurs doivent re-cloner le d√©p√¥t
- Les forks existants deviennent incompatibles
- √Ä ne faire qu'en dernier recours

**Alternative plus s√ªre** : BFG Repo-Cleaner

```bash
# T√©l√©charger BFG
wget https://repo1.maven.org/maven2/com/madgag/bfg/1.14.0/bfg-1.14.0.jar

# Supprimer tous les fichiers > 10MB
java -jar bfg-1.14.0.jar --strip-blobs-bigger-than 10M mon-depot.git

# Nettoyer et compacter
cd mon-depot.git
git reflog expire --expire=now --all
git gc --prune=now --aggressive
```

---

## Exemples de `.gitignore` par type de projet

### Projet simple avec Makefile

```bash
# .gitignore

# Binaires
*.o
*.exe
*.out
main
mon_programme

# Makefile d√©pendances
*.d

# Temporaires
*.log
*.tmp

# √âditeur
*.swp
.vscode/
```

### Projet CMake

```bash
# .gitignore

# Build
build/
build-*/
CMakeCache.txt
CMakeFiles/
cmake_install.cmake
compile_commands.json

# Binaires
*.o
*.exe
*.out

# Tests
test_results/
Testing/

# Documentation g√©n√©r√©e
docs/html/
docs/latex/

# IDEs
.vscode/
.idea/
```

### Projet avec biblioth√®que partag√©e

```bash
# .gitignore

# Binaires compil√©s
*.o
*.lo
*.so
*.so.*
*.a
*.la
*.exe
*.dll
*.dylib

# Libtool
.libs/
.deps/

# Build
build/
.cmake/
CMakeCache.txt

# Tests
tests/*.test
tests/results/

# Documentation
docs/html/
docs/man/

# Packaging
*.deb
*.rpm
*.tar.gz
dist/
```

### Projet embarqu√© (firmware)

```bash
# .gitignore

# Binaires embarqu√©s
*.bin
*.hex
*.elf
*.map
*.lst
*.srec

# Fichiers objets
*.o
*.obj

# Linker
*.ld.generated

# Debug
*.dSYM/
*.su

# IDE embarqu√©
Debug/
Release/
.cproject
.project
.settings/

# Logs de flash
flash.log
```

---

## Checklist avant de commiter

Avant chaque `git add` et `git commit`, v√©rifiez :

- [ ] **`git status`** pour voir ce qui va √™tre commit√©
- [ ] **Pas de fichiers .o, .exe, .out** dans la liste
- [ ] **Pas de dossier build/** ou **CMakeFiles/**
- [ ] **`.gitignore` est √† jour** et versionn√©
- [ ] **Seulement les fichiers sources** (.c, .h, .txt, .md)
- [ ] **Fichiers de configuration** (CMakeLists.txt, Makefile)
- [ ] **Documentation** (README, LICENSE)
- [ ] **Tests** (fichiers de test .c)

Si quelque chose ne va pas :

```bash
# Retirer un fichier du staging
git reset HEAD fichier_indesirable.o

# Ajouter √† .gitignore
echo "*.o" >> .gitignore

# Re-v√©rifier
git status
```

---

## Cas pratiques

### Cas 1 : Premier commit d'un projet

```bash
# 1. Initialiser Git
git init

# 2. AVANT de commiter, cr√©er .gitignore
cat > .gitignore << 'EOF'
# Binaires
*.o
*.exe
*.out
build/

# Temporaires
*.log
*.tmp

# IDE
.vscode/
.idea/
EOF

# 3. V√©rifier ce qui sera commit√©
git status

# 4. Commiter si OK
git add .
git commit -m "Initial commit with proper .gitignore"
```

### Cas 2 : Ajouter Git √† un projet existant

```bash
# 1. Projet contient d√©j√† des binaires compil√©s
ls
# main  main.o  parser.o  utils.o  main.c  parser.c  utils.c

# 2. Cr√©er .gitignore
echo "*.o" > .gitignore
echo "main" >> .gitignore  # L'ex√©cutable

# 3. Initialiser Git
git init

# 4. V√©rifier (les binaires ne doivent pas appara√Ætre)
git status
# Untracked files:
#   .gitignore
#   main.c
#   parser.c
#   utils.c

# 5. Commiter les sources
git add .
git commit -m "Initial commit - sources only"
```

### Cas 3 : Int√©grer une d√©pendance externe

**Option A : Avec Conan**

```bash
# 1. Cr√©er conanfile.txt
cat > conanfile.txt << 'EOF'
[requires]
zlib/1.2.11
libcurl/7.80.0

[generators]
cmake
EOF

# 2. Ajouter √† Git
git add conanfile.txt
git commit -m "Add dependencies manifest with Conan"

# 3. Dans .gitignore
echo "build/" >> .gitignore
echo "conan/" >> .gitignore

# 4. Installation (chaque dev fait √ßa localement)
conan install . -of build
```

**Option B : Script de t√©l√©chargement**

```bash
# 1. Cr√©er script
cat > scripts/get_deps.sh << 'EOF'
#!/bin/bash
mkdir -p deps
curl -L https://example.com/libfoo.so -o deps/libfoo.so
EOF

chmod +x scripts/get_deps.sh

# 2. Commiter le script (pas les binaires)
git add scripts/get_deps.sh
git commit -m "Add dependency download script"

# 3. Dans .gitignore
echo "deps/" >> .gitignore
```

---

## Outils utiles

### Analyser la taille du d√©p√¥t

```bash
# Taille totale du d√©p√¥t
du -sh .git/

# Voir les plus gros fichiers de l'historique
git rev-list --objects --all | \
  git cat-file --batch-check='%(objecttype) %(objectname) %(objectsize) %(rest)' | \
  awk '/^blob/ {print substr($0,6)}' | \
  sort --numeric-sort --key=2 | \
  tail -20

# Avec git-sizer (outil externe)
git-sizer --verbose
```

### V√©rifier les fichiers track√©s

```bash
# Tous les fichiers track√©s par Git
git ls-files

# Fichiers track√©s avec taille
git ls-files -z | xargs -0 ls -lh

# Chercher des binaires track√©s par erreur
git ls-files | grep -E '\.(o|exe|so|dll)$'
```

### Templates `.gitignore`

GitHub maintient une collection de templates :

```bash
# T√©l√©charger le template C
curl https://raw.githubusercontent.com/github/gitignore/main/C.gitignore -o .gitignore

# Ou combiner plusieurs
curl https://raw.githubusercontent.com/github/gitignore/main/C.gitignore >> .gitignore
curl https://raw.githubusercontent.com/github/gitignore/main/CMake.gitignore >> .gitignore
```

**Source** : https://github.com/github/gitignore

---

## Conclusion

La gestion des binaires dans Git est un sujet crucial mais souvent n√©glig√©. Retenir l'essentiel :

1. **Git n'est pas fait pour les binaires** : Con√ßu pour du texte
2. **`.gitignore` est essentiel** : √Ä cr√©er d√®s le d√©but
3. **Ne commitez JAMAIS les fichiers g√©n√©r√©s** : .o, .exe, build/
4. **Utilisez des gestionnaires de paquets** : Conan, vcpkg
5. **Git LFS pour les gros binaires** : Si vraiment n√©cessaire
6. **Publiez les binaires en Releases** : Pas dans Git
7. **V√©rifiez avant chaque commit** : `git status` est votre ami

Un d√©p√¥t propre = Clonage rapide, historique clair, collaboration facilit√©e.

---

## Ressources compl√©mentaires

- **gitignore.io** : G√©n√©rateur de .gitignore personnalis√©
  https://www.toptal.com/developers/gitignore

- **GitHub gitignore templates** : Collection de templates
  https://github.com/github/gitignore

- **Git LFS** : Documentation officielle
  https://git-lfs.github.com/

- **Conan** : Package manager pour C/C++
  https://conan.io/

- **vcpkg** : Package manager Microsoft
  https://vcpkg.io/

- **git-filter-repo** : Outil pour nettoyer l'historique
  https://github.com/newren/git-filter-repo

- **BFG Repo-Cleaner** : Alternative pour nettoyer les gros fichiers
  https://rtyley.github.io/bfg-repo-cleaner/

**Prochaine section** : 32.4 Changelog et versioning s√©mantique) - Nous verrons comment documenter l'√©volution de votre projet et g√©rer les versions de mani√®re professionnelle.

‚è≠Ô∏è [Changelog et versioning s√©mantique](/32-documentation-maintenance/04-changelog-semver.md)
