üîù Retour au [Sommaire](/SOMMAIRE.md)

# 18.10.5 Atomics vs mutex

## Introduction

L'une des questions les plus fr√©quentes en programmation concurrente est : **"Dois-je utiliser des op√©rations atomiques ou des mutex ?"**

Cette section vous aidera √† faire le bon choix en comparant ces deux m√©canismes de synchronisation sur plusieurs crit√®res : performance, complexit√©, cas d'usage, et maintenabilit√©.

**R√©ponse courte** : Les deux ont leur place, et le choix d√©pend du contexte !

---

## Rappel : Qu'est-ce qu'un mutex ?

### D√©finition

Un **mutex** (Mutual Exclusion) est un verrou qui prot√®ge une **section critique** du code. Un seul thread peut d√©tenir le verrou √† la fois.

```c
#include <pthread.h>

pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
int compteur = 0;

void incrementer(void) {
    pthread_mutex_lock(&lock);      // Acqu√©rir le verrou
    compteur++;                      // Section critique
    pthread_mutex_unlock(&lock);    // Lib√©rer le verrou
}
```

### Caract√©ristiques cl√©s

- ‚úÖ **Simple √† comprendre** : Logique de verrouillage intuitive
- ‚úÖ **Prot√®ge plusieurs variables** : Toute la section critique
- ‚úÖ **Flexible** : Peut prot√©ger du code complexe
- ‚ùå **Overhead** : Appels syst√®me potentiels
- ‚ùå **Deadlock possible** : Si mal utilis√©
- ‚ùå **Contention** : Les threads attendent leur tour

---

## Rappel : Qu'est-ce qu'une op√©ration atomique ?

### D√©finition

Une **op√©ration atomique** s'ex√©cute de mani√®re indivisible, sans verrou, en utilisant des instructions mat√©rielles sp√©ciales.

```c
#include <stdatomic.h>

atomic_int compteur = 0;

void incrementer(void) {
    atomic_fetch_add(&compteur, 1);  // Op√©ration atomique
}
```

### Caract√©ristiques cl√©s

- ‚úÖ **Tr√®s rapide** : Instructions CPU natives
- ‚úÖ **Lock-free** : Pas de blocage
- ‚úÖ **Pas de deadlock** : Impossible par construction
- ‚ùå **Une seule variable** : Ne prot√®ge qu'une variable atomique
- ‚ùå **Complexit√©** : Memory ordering, CAS, etc.
- ‚ùå **Limit√©** : Seulement pour certains types

---

## Comparaison d√©taill√©e

### 1. Performance

#### Atomiques : Plus rapides pour les op√©rations simples

```c
// Benchmark typique sur x86-64 (1 million d'op√©rations)
atomic_int counter = 0;
atomic_fetch_add(&counter, 1);  // ~0.02s

pthread_mutex_t lock;
int counter = 0;
pthread_mutex_lock(&lock);
counter++;
pthread_mutex_unlock(&lock);    // ~0.15s
```

**Facteur de performance** : Les atomiques sont **5-10x plus rapides** que les mutex pour des op√©rations simples.

#### Pourquoi cette diff√©rence ?

**Mutex** :
1. Appel syst√®me possible (si contention)
2. Changement de contexte potentiel
3. File d'attente des threads
4. Overhead de gestion du verrou

**Atomiques** :
1. Instruction CPU directe (ex: `LOCK XADD` sur x86)
2. Pas d'appel syst√®me
3. Pas de changement de contexte
4. Overhead minimal

#### Mais attention √† la contention !

Avec **forte contention** (beaucoup de threads) :
- Les atomiques se d√©gradent (spinning, cache bouncing)
- Les mutex restent stables (ordonnancement par l'OS)

```
Performance relative (10 threads)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

Faible contention:
Atomiques: ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà (20x plus rapide)
Mutex:     ‚ñà

Forte contention:
Atomiques: ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà (2-3x plus rapide)
Mutex:     ‚ñà‚ñà‚ñà
```

---

### 2. Complexit√© et facilit√© d'utilisation

#### Mutex : Simple et intuitif

```c
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
int x = 0;
int y = 0;

void modifier(void) {
    pthread_mutex_lock(&lock);

    // Section critique : peut contenir N'IMPORTE QUOI
    x = x + 1;
    y = y * 2;
    printf("x=%d, y=%d\n", x, y);
    sleep(1);  // M√™me du code lent !

    pthread_mutex_unlock(&lock);
}
```

**Avantage** : Prot√®ge tout le code entre lock/unlock, quelle que soit la complexit√©.

#### Atomiques : Plus complexe

```c
atomic_int x = 0;
atomic_int y = 0;

void modifier(void) {
    // ‚ö†Ô∏è Chaque variable est atomique individuellement
    atomic_fetch_add(&x, 1);
    atomic_fetch_add(&y, y);  // ‚ùå Probl√®me : y peut changer entre-temps !

    // ‚ùå Impossible d'afficher x et y de mani√®re coh√©rente
    // ‚ùå Impossible de mettre sleep() de mani√®re atomique
}
```

**Probl√®me** : Les atomiques ne prot√®gent qu'UNE variable √† la fois. Pas de section critique multi-op√©rations.

#### Verdict

| Crit√®re | Mutex | Atomiques |
|---------|-------|-----------|
| **Courbe d'apprentissage** | üü¢ Facile | üü° Moyenne-Difficile |
| **Code complexe** | üü¢ Oui | üî¥ Non |
| **Plusieurs variables** | üü¢ Oui | üî¥ Non (sauf CAS avanc√©) |
| **Debugging** | üü¢ Plus simple | üî¥ Plus difficile |

---

### 3. Fonctionnalit√©s

#### Ce que peuvent faire les mutex

- ‚úÖ Prot√©ger plusieurs variables ensemble
- ‚úÖ Sections critiques de taille arbitraire
- ‚úÖ Code complexe (boucles, conditions, I/O)
- ‚úÖ Garanties d'exclusion mutuelle
- ‚úÖ Compatibilit√© avec variables de condition

```c
pthread_mutex_t lock;
pthread_cond_t cond;
int buffer[SIZE];
int count = 0;

void ajouter(int item) {
    pthread_mutex_lock(&lock);

    // Attendre que le buffer ait de la place
    while (count >= SIZE) {
        pthread_cond_wait(&cond, &lock);
    }

    buffer[count++] = item;
    pthread_cond_signal(&cond);

    pthread_mutex_unlock(&lock);
}
```

#### Ce que peuvent faire les atomiques

- ‚úÖ Op√©rations sur UNE variable
- ‚úÖ Compteurs, flags, pointeurs
- ‚úÖ Algorithmes lock-free (avanc√©)
- ‚úÖ Synchronisation l√©g√®re
- ‚ùå Sections critiques multi-variables (difficile)

```c
atomic_int compteur = 0;
atomic_bool flag = false;

void operer(void) {
    atomic_fetch_add(&compteur, 1);

    if (atomic_load(&compteur) > 100) {
        atomic_store(&flag, true);
    }
}
```

---

### 4. Cas d'usage typiques

#### Quand utiliser les MUTEX

**‚úÖ Sc√©narios id√©aux** :

1. **Plusieurs variables li√©es**
```c
// Transaction bancaire : les deux comptes doivent √™tre coh√©rents
pthread_mutex_lock(&lock);
compte_A -= montant;
compte_B += montant;
pthread_mutex_unlock(&lock);
```

2. **Sections critiques complexes**
```c
pthread_mutex_lock(&lock);
valider_entree();
calculer_resultat();
mettre_a_jour_stats();
enregistrer_log();
pthread_mutex_unlock(&lock);
```

3. **Avec variables de condition**
```c
pthread_mutex_lock(&lock);
while (!condition) {
    pthread_cond_wait(&cond, &lock);
}
// ... traiter ...
pthread_mutex_unlock(&lock);
```

4. **Code existant non thread-safe**
```c
// Prot√©ger une biblioth√®que externe
pthread_mutex_lock(&lib_lock);
resultat = bibliotheque_non_threadsafe();
pthread_mutex_unlock(&lib_lock);
```

#### Quand utiliser les ATOMIQUES

**‚úÖ Sc√©narios id√©aux** :

1. **Compteurs simples**
```c
atomic_ulong compteur_requetes;
atomic_fetch_add(&compteur_requetes, 1);
```

2. **Flags de synchronisation**
```c
atomic_bool arret_demande;
atomic_bool initialisation_terminee;
```

3. **Pointeurs partag√©s simples**
```c
_Atomic(configuration_t*) config_actuelle;
atomic_store(&config_actuelle, nouvelle_config);
```

4. **Optimisation de performance critique**
```c
// Hot path avec millions d'acc√®s/seconde
atomic_int cache_hits;
atomic_fetch_add_explicit(&cache_hits, 1, memory_order_relaxed);
```

---

## Exemples c√¥te √† c√¥te

### Exemple 1 : Compteur simple

#### Avec mutex
```c
#include <pthread.h>

pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
int compteur = 0;

void* worker(void* arg) {
    for (int i = 0; i < 100000; i++) {
        pthread_mutex_lock(&lock);
        compteur++;
        pthread_mutex_unlock(&lock);
    }
    return NULL;
}
```

**Lignes de code** : Plus verbeux
**Performance** : ~0.15s pour 1M d'incr√©ments
**Complexit√©** : Simple √† comprendre

#### Avec atomiques
```c
#include <stdatomic.h>

atomic_int compteur = 0;

void* worker(void* arg) {
    for (int i = 0; i < 100000; i++) {
        atomic_fetch_add(&compteur, 1);
    }
    return NULL;
}
```

**Lignes de code** : Plus concis
**Performance** : ~0.02s pour 1M d'incr√©ments
**Complexit√©** : Simple aussi (pour ce cas)

**Verdict** : Atomiques gagnent (plus rapides, aussi simples)

---

### Exemple 2 : Producer-Consumer simple

#### Avec mutex
```c
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
int buffer = 0;
bool plein = false;

void produire(int valeur) {
    pthread_mutex_lock(&lock);

    while (plein) {
        pthread_cond_wait(&cond, &lock);
    }

    buffer = valeur;
    plein = true;
    pthread_cond_signal(&cond);

    pthread_mutex_unlock(&lock);
}

int consommer(void) {
    pthread_mutex_lock(&lock);

    while (!plein) {
        pthread_cond_wait(&cond, &lock);
    }

    int valeur = buffer;
    plein = false;
    pthread_cond_signal(&cond);

    pthread_mutex_unlock(&lock);

    return valeur;
}
```

**Avantages** : Clair, utilise wait/signal efficacement

#### Avec atomiques (version na√Øve)
```c
atomic_int buffer = 0;
atomic_bool plein = false;

void produire(int valeur) {
    // Attendre activement (busy-wait)
    while (atomic_load(&plein)) {
        // Spin - gaspille du CPU !
    }

    atomic_store(&buffer, valeur);
    atomic_store(&plein, true);
}

int consommer(void) {
    while (!atomic_load(&plein)) {
        // Spin - gaspille du CPU !
    }

    int valeur = atomic_load(&buffer);
    atomic_store(&plein, false);

    return valeur;
}
```

**Probl√®mes** : Busy-waiting inefficace, gaspille du CPU

**Verdict** : Mutex gagnent (variables de condition essentielles ici)

---

### Exemple 3 : Plusieurs variables coh√©rentes

#### Avec mutex
```c
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
int x = 0;
int y = 0;

void deplacer(int dx, int dy) {
    pthread_mutex_lock(&lock);
    x += dx;
    y += dy;
    pthread_mutex_unlock(&lock);
}

void afficher(void) {
    pthread_mutex_lock(&lock);
    printf("Position: (%d, %d)\n", x, y);
    pthread_mutex_unlock(&lock);
}
```

**Garantie** : x et y sont toujours coh√©rents ensemble

#### Avec atomiques (incorrect)
```c
atomic_int x = 0;
atomic_int y = 0;

void deplacer(int dx, int dy) {
    atomic_fetch_add(&x, dx);
    atomic_fetch_add(&y, dy);  // ‚ö†Ô∏è Un autre thread peut lire entre les deux !
}

void afficher(void) {
    // ‚ö†Ô∏è Peut afficher x nouveau avec y ancien (incoh√©rent)
    int pos_x = atomic_load(&x);
    int pos_y = atomic_load(&y);
    printf("Position: (%d, %d)\n", pos_x, pos_y);
}
```

**Probl√®me** : Impossible de garantir la coh√©rence de x et y

**Verdict** : Mutex indispensables ici

---

## Tableau comparatif complet

| Crit√®re | Mutex | Atomiques |
|---------|-------|-----------|
| **Performance (ops simples)** | üü° Moyenne | üü¢ Excellente |
| **Performance (contention √©lev√©e)** | üü¢ Stable | üü° D√©grad√©e |
| **Facilit√© d'utilisation** | üü¢ Simple | üü° Complexe |
| **Protection multi-variables** | üü¢ Oui | üî¥ Non |
| **Sections critiques longues** | üü¢ Oui | üî¥ Non |
| **Variables de condition** | üü¢ Oui | üî¥ Non |
| **Lock-free** | üî¥ Non | üü¢ Oui |
| **Risque de deadlock** | üü° Oui | üü¢ Non |
| **Overhead m√©moire** | üü° Moyen (~40 bytes) | üü¢ Minimal (~4-8 bytes) |
| **Portabilit√©** | üü¢ Excellente | üü° Bonne (C11+) |
| **Debugging** | üü¢ Plus facile | üü° Plus difficile |
| **Scalabilit√© (faible contention)** | üü° Moyenne | üü¢ Excellente |

---

## Arbre de d√©cision : Que choisir ?

```
Combien de variables devez-vous prot√©ger ?
‚îÇ
‚îú‚îÄ UNE seule variable
‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ Op√©ration simple (incr√©ment, flag, etc.) ?
‚îÇ     ‚îÇ
‚îÇ     ‚îú‚îÄ OUI ‚Üí ATOMIQUES ‚úÖ
‚îÇ     ‚îÇ        (plus rapide, pas de deadlock)
‚îÇ     ‚îÇ
‚îÇ     ‚îî‚îÄ NON ‚Üí Algorithme complexe ?
‚îÇ        ‚îÇ
‚îÇ        ‚îú‚îÄ OUI ‚Üí Avez-vous l'expertise lock-free ?
‚îÇ        ‚îÇ  ‚îÇ
‚îÇ        ‚îÇ  ‚îú‚îÄ OUI ‚Üí ATOMIQUES (avec CAS) ‚úÖ
‚îÇ        ‚îÇ  ‚îÇ
‚îÇ        ‚îÇ  ‚îî‚îÄ NON ‚Üí MUTEX ‚úÖ
‚îÇ        ‚îÇ           (plus simple, plus s√ªr)
‚îÇ        ‚îÇ
‚îÇ        ‚îî‚îÄ NON ‚Üí ATOMIQUES ‚úÖ
‚îÇ
‚îî‚îÄ PLUSIEURS variables
   ‚îÇ
   ‚îî‚îÄ Doivent-elles √™tre coh√©rentes ensemble ?
      ‚îÇ
      ‚îú‚îÄ OUI ‚Üí MUTEX ‚úÖ
      ‚îÇ        (seule solution pratique)
      ‚îÇ
      ‚îî‚îÄ NON ‚Üí ATOMIQUES sur chaque variable ‚úÖ
               (si vraiment ind√©pendantes)
```

---

## Patterns d'utilisation

### Pattern 1 : Compteur de statistiques

**‚úÖ Utilisez : ATOMIQUES**

```c
atomic_ulong requetes_total = 0;
atomic_ulong requetes_erreur = 0;

void traiter_requete(void) {
    atomic_fetch_add(&requetes_total, 1);

    if (erreur) {
        atomic_fetch_add(&requetes_erreur, 1);
    }
}

// Les deux compteurs sont ind√©pendants
```

---

### Pattern 2 : Cache avec m√©tadonn√©es

**‚úÖ Utilisez : MUTEX**

```c
typedef struct {
    void* data;
    size_t taille;
    time_t timestamp;
    bool valide;
} cache_entry_t;

pthread_mutex_t cache_lock;
cache_entry_t cache;

void mettre_a_jour_cache(void* nouvelles_donnees, size_t taille) {
    pthread_mutex_lock(&cache_lock);

    free(cache.data);
    cache.data = nouvelles_donnees;
    cache.taille = taille;
    cache.timestamp = time(NULL);
    cache.valide = true;

    pthread_mutex_unlock(&cache_lock);
}

// Toutes les variables doivent √™tre coh√©rentes
```

---

### Pattern 3 : Flag d'arr√™t

**‚úÖ Utilisez : ATOMIQUES**

```c
atomic_bool doit_arreter = false;

void* worker(void* arg) {
    while (!atomic_load(&doit_arreter)) {
        // Travail
    }
    return NULL;
}

void demander_arret(void) {
    atomic_store(&doit_arreter, true);
}
```

---

### Pattern 4 : File d'attente (queue)

**‚úÖ Utilisez : MUTEX (sauf expertise lock-free)**

```c
typedef struct {
    int* buffer;
    size_t head;
    size_t tail;
    size_t size;
} queue_t;

pthread_mutex_t queue_lock;
pthread_cond_t not_empty;
pthread_cond_t not_full;

// N√©cessite mutex + cond pour wait/signal efficace
```

---

## Hybride : Combiner les deux

Parfois, la meilleure solution est de **combiner** mutex et atomiques !

### Exemple : Statistiques avec cache coh√©rent

```c
// Atomiques pour les statistiques haute fr√©quence
atomic_ulong total_requetes = 0;
atomic_ulong total_bytes = 0;

// Mutex pour les structures complexes
pthread_mutex_t stats_lock;
struct {
    char top_urls[10][256];
    int top_counts[10];
} statistiques_detaillees;

void traiter_requete(const char* url, size_t bytes) {
    // Atomiques : incr√©ment ultra-rapide
    atomic_fetch_add(&total_requetes, 1);
    atomic_fetch_add(&total_bytes, bytes);

    // Mutex : mise √† jour moins fr√©quente
    pthread_mutex_lock(&stats_lock);
    mettre_a_jour_top_urls(url);
    pthread_mutex_unlock(&stats_lock);
}
```

**Avantage** : Le meilleur des deux mondes !
- Atomiques pour le hot path (rapide)
- Mutex pour les donn√©es complexes (simple)

---

## Benchmarks r√©els

### Configuration de test

```c
#define NB_THREADS 4
#define NB_ITERATIONS 1000000

// Test 1 : Incr√©ment simple
// Test 2 : Lecture/√©criture mixte
// Test 3 : Forte contention
```

### R√©sultats typiques (x86-64, 4 cores)

#### Test 1 : Incr√©ment pur (1M op√©rations)

| M√©thode | Temps | Speedup |
|---------|-------|---------|
| Mutex | 0.28s | 1x |
| Atomiques seq_cst | 0.08s | 3.5x |
| Atomiques relaxed | 0.04s | 7x |

#### Test 2 : Lecture 90% / √âcriture 10%

| M√©thode | Temps | Speedup |
|---------|-------|---------|
| Mutex | 0.32s | 1x |
| RWLock | 0.15s | 2.1x |
| Atomiques acquire/release | 0.06s | 5.3x |

#### Test 3 : Forte contention (10 threads)

| M√©thode | Temps | Speedup |
|---------|-------|---------|
| Mutex | 0.45s | 1x |
| Atomiques | 0.18s | 2.5x |

**Observation** : Les atomiques restent plus rapides m√™me avec contention, mais l'avantage diminue.

---

## Anti-patterns : Ce qu'il ne faut PAS faire

### ‚ùå Anti-pattern 1 : Atomiques pour prot√©ger du code complexe

```c
// ‚ö†Ô∏è FAUX : Les atomiques ne prot√®gent QUE la variable
atomic_bool flag = false;

void traiter(void) {
    if (atomic_load(&flag)) {
        // ‚ùå Ce code n'est PAS prot√©g√© !
        donnees_partagees.x++;
        donnees_partagees.y++;
    }
}
```

**Solution** : Utilisez un mutex.

---

### ‚ùå Anti-pattern 2 : Mutex pour chaque op√©ration simple

```c
// ‚ö†Ô∏è Inefficace : overhead inutile
pthread_mutex_t lock;
int compteur = 0;

void incrementer_mille_fois(void) {
    for (int i = 0; i < 1000; i++) {
        pthread_mutex_lock(&lock);    // 1000 lock/unlock !
        compteur++;
        pthread_mutex_unlock(&lock);
    }
}
```

**Solution** : Utilisez des atomiques ou regroupez les op√©rations.

```c
atomic_int compteur = 0;

void incrementer_mille_fois(void) {
    atomic_fetch_add(&compteur, 1000);  // Une seule op√©ration !
}
```

---

### ‚ùå Anti-pattern 3 : M√©langer les deux sans raison

```c
// ‚ö†Ô∏è Confus : pourquoi √† la fois mutex et atomic ?
pthread_mutex_t lock;
atomic_int compteur = 0;

void incrementer(void) {
    pthread_mutex_lock(&lock);
    atomic_fetch_add(&compteur, 1);  // Atomique inutile ici
    pthread_mutex_unlock(&lock);
}
```

**Solution** : Choisissez l'un ou l'autre.

```c
// Simple avec mutex
pthread_mutex_t lock;
int compteur = 0;

void incrementer(void) {
    pthread_mutex_lock(&lock);
    compteur++;
    pthread_mutex_unlock(&lock);
}

// OU simple avec atomique
atomic_int compteur = 0;

void incrementer(void) {
    atomic_fetch_add(&compteur, 1);
}
```

---

## Conseils pratiques

### Pour les d√©butants

1. **Commencez par les mutex**
   - Plus simples √† comprendre
   - Moins de bugs subtils
   - Document√©s partout

2. **Passez aux atomiques quand vous √™tes √† l'aise**
   - Commencez par des compteurs simples
   - Utilisez seq_cst par d√©faut
   - Testez avec ThreadSanitizer

3. **Ne sur-optimisez pas pr√©matur√©ment**
   - Les mutex sont souvent "assez rapides"
   - Profilez avant d'optimiser
   - La clart√© prime sur la performance

### Pour les d√©veloppeurs interm√©diaires

1. **Utilisez atomiques pour les hot paths**
   - Identifiez les bottlenecks avec un profiler
   - Remplacez les mutex par atomiques si appropri√©
   - Mesurez l'am√©lioration

2. **Documentez vos choix**
   ```c
   // Atomique car incr√©ment√© des millions de fois/seconde
   atomic_ulong compteur_rapide;

   // Mutex car prot√®ge plusieurs champs coh√©rents
   pthread_mutex_t state_lock;
   ```

3. **Combinez intelligemment**
   - Atomiques pour les stats haute fr√©quence
   - Mutex pour les mises √† jour complexes

### Pour les experts

1. **Ma√Ætrisez les memory orders**
   - relaxed pour les compteurs ind√©pendants
   - acquire/release pour la synchronisation
   - seq_cst seulement si n√©cessaire

2. **Impl√©mentez des structures lock-free**
   - Mais seulement si vraiment n√©cessaire
   - Testez exhaustivement
   - Consid√©rez les biblioth√®ques existantes

3. **Optimisez les cache-lines**
   ```c
   // √âvitez le false sharing
   struct {
       atomic_int counter1;
       char padding[64];  // Cache line padding
       atomic_int counter2;
   };
   ```

---

## Migration : Passer de l'un √† l'autre

### Remplacer un mutex par des atomiques

**Avant (mutex)** :
```c
pthread_mutex_t lock;
int compteur = 0;

void incrementer(void) {
    pthread_mutex_lock(&lock);
    compteur++;
    pthread_mutex_unlock(&lock);
}
```

**Apr√®s (atomiques)** :
```c
atomic_int compteur = 0;

void incrementer(void) {
    atomic_fetch_add(&compteur, 1);
}
```

**Conditions** :
- ‚úÖ Une seule variable
- ‚úÖ Op√©ration simple
- ‚úÖ Pas de code complexe dans la section critique

---

### Remplacer des atomiques par un mutex

**Avant (atomiques - incorrect)** :
```c
atomic_int x = 0;
atomic_int y = 0;

void deplacer(void) {
    atomic_fetch_add(&x, 1);
    atomic_fetch_add(&y, 1);  // ‚ö†Ô∏è Incoh√©rent
}
```

**Apr√®s (mutex - correct)** :
```c
pthread_mutex_t lock;
int x = 0;
int y = 0;

void deplacer(void) {
    pthread_mutex_lock(&lock);
    x++;
    y++;  // ‚úÖ Coh√©rent
    pthread_mutex_unlock(&lock);
}
```

**Raisons** :
- ‚ùå Plusieurs variables doivent √™tre coh√©rentes
- ‚ùå Atomiques ne suffisent pas

---

## R√©sum√©

### R√®gles d'or

1. **Une variable simple** ‚Üí Atomiques
2. **Plusieurs variables li√©es** ‚Üí Mutex
3. **Code complexe** ‚Üí Mutex
4. **Performance critique** ‚Üí Atomiques (apr√®s profiling)
5. **En cas de doute** ‚Üí Mutex (plus s√ªr)

### Tableau de d√©cision rapide

| Situation | Mutex | Atomiques |
|-----------|:-----:|:---------:|
| Compteur simple | üü° OK | ‚úÖ Id√©al |
| Flag bool√©en | üü° OK | ‚úÖ Id√©al |
| Plusieurs variables | ‚úÖ Seul choix | ‚ùå Impossible |
| Section critique longue | ‚úÖ Seul choix | ‚ùå Impossible |
| Variables de condition | ‚úÖ Seul choix | ‚ùå Impossible |
| Hot path (millions d'ops/s) | üü° Possible | ‚úÖ Id√©al |
| D√©butant | ‚úÖ Recommand√© | üü° Apr√®s ma√Ætrise mutex |
| Code legacy √† prot√©ger | ‚úÖ Seul choix | ‚ùå Impossible |

### Ce qu'il faut retenir

1. **Les mutex sont plus simples** : Privil√©giez-les par d√©faut
2. **Les atomiques sont plus rapides** : Mais seulement pour des cas sp√©cifiques
3. **Ne m√©langez pas sans raison** : Choisissez l'outil appropri√©
4. **Testez avec des outils** : ThreadSanitizer, Helgrind
5. **Documentez vos choix** : Pour vous et vos coll√®gues

### Progression recommand√©e

```
D√©butant              Interm√©diaire              Expert
   |                        |                       |
 Mutex                 Atomiques              Lock-free
(toujours OK)        (optimisations)         (rarissime)
```

---

## Ressources compl√©mentaires

### Livres

- **"Programming with POSIX Threads"** - David Butenhof (mutex)
- **"C++ Concurrency in Action"** - Anthony Williams (atomiques, transf√©rable au C)
- **"The Art of Multiprocessor Programming"** - Herlihy & Shavit (th√©orie)

### Articles

- **"Mutexes and Condition Variables"** - POSIX documentation
- **"C11 atomics"** - cppreference.com
- **"Lock-Free vs. Wait-Free"** - Jeff Preshing

### Outils

- **perf** : Profiler Linux pour identifier les bottlenecks
- **ThreadSanitizer** : D√©tection de data races
- **cachegrind** : Analyse du comportement du cache

---

**üí° Conseil final** : Ne tombez pas dans le pi√®ge de l'optimisation pr√©matur√©e. Commencez avec des mutex (simples et s√ªrs), profilez votre code, et passez aux atomiques seulement si vous identifiez un vrai bottleneck. La clart√© et la correction du code doivent toujours primer sur une optimisation hypoth√©tique.

**üéØ R√®gle des 90/10** : Dans 90% des cas, les mutex suffisent. Les 10% restants justifient les atomiques. Ne r√©inventez pas la roue sans mesurer d'abord.

**‚ö†Ô∏è Avertissement** : Un bug de synchronisation (mutex ou atomiques) peut √™tre **silencieux pendant des mois** avant de causer un crash en production. Investissez du temps dans les tests et la validation, quelle que soit la m√©thode choisie.

‚è≠Ô∏è [Performance et cas d'usage](/18-threads-et-concurrence/10.6-performance-cas-usage.md)
