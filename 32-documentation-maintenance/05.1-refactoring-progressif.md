üîù Retour au [Sommaire](/SOMMAIRE.md)

# 32.5.1 Refactoring progressif

## Introduction

Vous h√©ritez d'un projet C √©crit il y a 10 ans. Le code fonctionne, mais c'est un cauchemar :
- Fonctions de 500 lignes
- Variables nomm√©es `a`, `b`, `tmp`, `data`
- Aucune documentation
- Macros partout
- Goto dans tous les sens
- Allocation m√©moire anarchique

Votre premi√®re r√©action : *"Il faut tout r√©√©crire !"*

**STOP** üõë

R√©√©crire compl√®tement un projet legacy est presque toujours une **mauvaise id√©e**. C'est long, risqu√©, et vous allez reproduire les m√™mes bugs (plus de nouveaux). La bonne approche est le **refactoring progressif** : am√©liorer le code petit √† petit, sans tout casser.

Dans cette section, nous allons apprendre :
- Pourquoi le refactoring progressif est pr√©f√©rable √† la r√©√©criture
- Les techniques de refactoring pour le code C legacy
- Comment refactoriser en toute s√©curit√©
- Les patterns de refactoring les plus utiles
- Comment mesurer les progr√®s

---

## Le mythe de la grande r√©√©criture

### Pourquoi "tout r√©√©crire" √©choue souvent

**Histoire vraie** : Netscape a d√©cid√© en 1998 de tout r√©√©crire. R√©sultat :
- 3 ans de d√©veloppement perdus
- Concurrence (Internet Explorer) a pris le march√©
- Le projet a failli couler l'entreprise
- Joel Spolsky a √©crit un article c√©l√®bre : "Things You Should Never Do"

**Probl√®mes de la r√©√©criture compl√®te** :

1. **Sous-estimation** : "√áa prendra 3 mois" ‚Üí 2 ans en r√©alit√©
2. **Perte de connaissances** : Le vieux code contient des ann√©es de bugfixes
3. **Bugs r√©introduits** : Tous les bugs corrig√©s au fil des ans reviennent
4. **Nouveaux bugs** : Le nouveau code en ajoute de nouveaux
5. **Fonctionnalit√©s oubli√©es** : Des cas limites g√©r√©s par l'ancien code sont oubli√©s
6. **Co√ªt d'opportunit√©** : Pendant la r√©√©criture, z√©ro nouvelle fonctionnalit√©

### L'approche progressive

**Principe** : Am√©liorer le code **petit √† petit**, en gardant le syst√®me fonctionnel √† chaque √©tape.

```
Code legacy (fonctionnel mais laid)
    ‚Üì
Refactoring 1 : Renommer les variables
    ‚Üì
Refactoring 2 : Extraire des fonctions
    ‚Üì
Refactoring 3 : Simplifier la logique
    ‚Üì
...
    ‚Üì
Code propre (fonctionnel et maintenable)
```

**Avantages** :
- ‚úÖ Syst√®me toujours fonctionnel
- ‚úÖ Am√©liorations continues et visibles
- ‚úÖ Risques r√©duits (changements isol√©s)
- ‚úÖ Connaissance pr√©serv√©e (bugfixes conserv√©s)
- ‚úÖ Possibilit√© d'arr√™ter √† tout moment (code d√©j√† meilleur)

---

## Principes du refactoring s√ªr

### 1. Le code doit toujours compiler et fonctionner

**R√®gle d'or** : Apr√®s chaque √©tape de refactoring, le code doit :
- ‚úÖ Compiler sans erreurs ni warnings
- ‚úÖ Passer tous les tests
- ‚úÖ Se comporter exactement comme avant

**Workflow** :
```bash
# 1. Faire un petit refactoring
vim src/parser.c

# 2. Compiler
make clean && make

# 3. Tester
make test

# 4. Si OK, commiter
git add src/parser.c
git commit -m "refactor: rename variable 'a' to 'buffer_size'"

# 5. R√©p√©ter
```

### 2. Petits pas, pas g√©ants

‚ùå **Mauvais** : Refactoriser 10 fichiers d'un coup
```
Commit : "Refactor everything"
- 20 files changed
- 2847 lines added, 2314 lines deleted
```

‚úÖ **Bon** : Un changement logique √† la fois
```
Commit 1: "refactor: rename variable 'n' to 'element_count'"
- 1 file changed
- 15 lines changed

Commit 2: "refactor: extract validate_input() function"
- 1 file changed
- 45 lines added, 30 lines deleted

Commit 3: "refactor: simplify error handling with early returns"
- 1 file changed
- 23 lines changed
```

### 3. Tests avant et apr√®s

**Id√©al** : Avoir des tests automatis√©s

```bash
# Avant refactoring
make test
# ‚úÖ All tests pass (12/12)

# Refactoring
vim src/parser.c

# Apr√®s refactoring
make test
# ‚úÖ All tests pass (12/12)
```

**Si pas de tests** : Tester manuellement de mani√®re rigoureuse
```bash
# Cr√©er un script de test manuel
cat > test_manual.sh << 'EOF'
#!/bin/bash
./mon_programme test1.txt > output1.txt
diff output1.txt expected1.txt || exit 1

./mon_programme test2.txt > output2.txt
diff output2.txt expected2.txt || exit 1

echo "‚úÖ All manual tests pass"
EOF

chmod +x test_manual.sh
./test_manual.sh
```

### 4. Conserver le comportement exact

**Refactoring** ‚â† **Changement de fonctionnalit√©**

```c
// AVANT (legacy)
int parse(char *input) {
    int i, n = 0;
    for (i = 0; input[i]; i++) {
        if (input[i] == ',') n++;
    }
    return n;
}

// APR√àS (refactoris√©) - M√äME comportement
int count_commas(const char *input) {
    if (input == NULL) return 0;  // ‚ö†Ô∏è ATTENTION : nouveau comportement !

    int comma_count = 0;
    for (int i = 0; input[i] != '\0'; i++) {
        if (input[i] == ',') {
            comma_count++;
        }
    }
    return comma_count;
}
```

**Probl√®me** : Le check `NULL` change le comportement ! L'ancien code crashait sur `NULL`, le nouveau retourne 0.

**Solution** : Si vous voulez ajouter le check `NULL`, faites-le dans un commit s√©par√© :

```bash
# Commit 1 : Refactoring pur (comportement identique)
git commit -m "refactor: rename and clarify parse() to count_commas()"

# Commit 2 : Am√©lioration (nouveau comportement)
git commit -m "feat: add NULL check in count_commas()"
```

### 5. Documenter l'intention

Dans les commits de refactoring, expliquez **pourquoi** :

‚ùå **Mauvais** :
```bash
git commit -m "refactor: change function"
```

‚úÖ **Bon** :
```bash
git commit -m "refactor: extract validate_input() for clarity

The parse() function was 300 lines long and hard to understand.
Extracting input validation into a separate function improves
readability and makes it easier to add validation rules."
```

---

## Techniques de refactoring pour le code C

### 1. Renommage de variables et fonctions

**Probl√®me** : Noms cryptiques ou trompeurs

```c
// AVANT
int f(int a, int b, char *s) {
    int n = a * b;
    char *p = s;
    // ...
}
```

**Solution** : Noms descriptifs

```c
// APR√àS
int calculate_buffer_size(int width, int height, char *format) {
    int total_pixels = width * height;
    char *format_ptr = format;
    // ...
}
```

**Strat√©gie** :
1. Identifier les pires noms (a, b, tmp, data, n, i utilis√©s hors boucles)
2. Renommer un par un
3. Compiler et tester apr√®s chaque renommage
4. Utiliser l'outil de refactoring de votre IDE (Ctrl+R dans VS Code)

**Outils** :
```bash
# Rechercher tous les usages d'une variable
grep -rn "variable_a_renommer" src/

# Renommer avec sed (prudence !)
sed -i 's/\bvariable_a_renommer\b/nouveau_nom/g' src/fichier.c
```

### 2. Extraction de fonction

**Probl√®me** : Fonctions trop longues (>50 lignes)

```c
// AVANT (fonction de 200 lignes)
int process_data(char *input) {
    // 50 lignes : validation de l'input
    if (input == NULL) return -1;
    if (strlen(input) < 10) return -1;
    // ... 48 lignes de validation ...

    // 80 lignes : parsing
    char *token = strtok(input, ",");
    // ... 78 lignes de parsing ...

    // 70 lignes : traitement
    for (int i = 0; i < count; i++) {
        // ... 68 lignes de traitement ...
    }

    return 0;
}
```

**Solution** : Extraire des sous-fonctions

```c
// APR√àS
static int validate_input(const char *input) {
    if (input == NULL) return -1;
    if (strlen(input) < 10) return -1;
    // ... 48 lignes de validation ...
    return 0;
}

static int parse_tokens(char *input, token_t **tokens, int *count) {
    char *token = strtok(input, ",");
    // ... 78 lignes de parsing ...
    return 0;
}

static int process_tokens(token_t *tokens, int count) {
    for (int i = 0; i < count; i++) {
        // ... 68 lignes de traitement ...
    }
    return 0;
}

int process_data(char *input) {
    if (validate_input(input) < 0) return -1;

    token_t *tokens = NULL;
    int count = 0;
    if (parse_tokens(input, &tokens, &count) < 0) return -1;

    if (process_tokens(tokens, count) < 0) {
        free(tokens);
        return -1;
    }

    free(tokens);
    return 0;
}
```

**Avantages** :
- Chaque fonction a une responsabilit√© claire
- Plus facile √† tester
- Plus facile √† comprendre
- R√©utilisable

**Strat√©gie** :
1. Identifier les blocs logiques dans la fonction
2. Copier le premier bloc dans une nouvelle fonction
3. Remplacer le bloc par un appel √† la nouvelle fonction
4. Compiler et tester
5. R√©p√©ter pour les autres blocs

### 3. Simplification de la logique

**Probl√®me** : Logique complexe et imbriqu√©e

```c
// AVANT
int check_valid(int a, int b, int c) {
    if (a > 0) {
        if (b > 0) {
            if (c > 0) {
                if (a + b > c && b + c > a && a + c > b) {
                    return 1;
                } else {
                    return 0;
                }
            } else {
                return 0;
            }
        } else {
            return 0;
        }
    } else {
        return 0;
    }
}
```

**Solution** : Early returns (retours anticip√©s)

```c
// APR√àS
int is_valid_triangle(int side_a, int side_b, int side_c) {
    // V√©rifications de base
    if (side_a <= 0) return 0;
    if (side_b <= 0) return 0;
    if (side_c <= 0) return 0;

    // In√©galit√© triangulaire
    if (side_a + side_b <= side_c) return 0;
    if (side_b + side_c <= side_a) return 0;
    if (side_a + side_c <= side_b) return 0;

    return 1;
}
```

**Autre exemple** : Inverser les conditions

```c
// AVANT (logique invers√©e, difficile √† lire)
if (!error && data != NULL) {
    process(data);
}

// APR√àS (logique positive, plus claire)
if (error || data == NULL) {
    return -1;  // Early return
}
process(data);
```

### 4. Remplacement de magic numbers

**Probl√®me** : Nombres litt√©raux sans signification

```c
// AVANT
if (status == 3) {
    buffer = malloc(1024);
    for (int i = 0; i < 256; i++) {
        // ...
    }
}
```

**Solution** : Constantes nomm√©es

```c
// APR√àS
#define STATUS_READY 3
#define BUFFER_SIZE 1024
#define MAX_ITERATIONS 256

if (status == STATUS_READY) {
    buffer = malloc(BUFFER_SIZE);
    for (int i = 0; i < MAX_ITERATIONS; i++) {
        // ...
    }
}
```

**Encore mieux** : Enum pour les √©tats

```c
typedef enum {
    STATUS_IDLE = 0,
    STATUS_INITIALIZING = 1,
    STATUS_RUNNING = 2,
    STATUS_READY = 3,
    STATUS_ERROR = 4
} status_t;

#define BUFFER_SIZE 1024
#define MAX_ITERATIONS 256

if (status == STATUS_READY) {
    buffer = malloc(BUFFER_SIZE);
    for (int i = 0; i < MAX_ITERATIONS; i++) {
        // ...
    }
}
```

### 5. √âlimination de code mort

**Probl√®me** : Code inutilis√© qui pollue

```c
// AVANT
int old_parse(char *input) {
    // Fonction qui n'est plus appel√©e nulle part
    return 0;
}

#if 0  // Code comment√© depuis des ann√©es
void ancient_function() {
    // ...
}
#endif

int current_parse(char *input) {
    // Nouvelle fonction utilis√©e
    // ...

    // int old_result = old_parse(input);  // Code comment√©

    return 0;
}
```

**Solution** : Supprimer impitoyablement

```c
// APR√àS
int current_parse(char *input) {
    // ...
    return 0;
}
```

**Justification** :
- Git conserve l'historique : vous pouvez retrouver l'ancien code si besoin
- Le code mort perturbe la lecture
- Il peut contenir des bugs qui n'affectent personne mais inqui√®tent

**Strat√©gie** :
```bash
# Trouver les fonctions non utilis√©es
cppcheck --enable=unusedFunction src/

# Ou avec GCC (lors de la compilation)
gcc -Wall -Wextra -Wunused src/*.c
```

### 6. R√©duction de la port√©e des variables

**Probl√®me** : Variables d√©clar√©es trop t√¥t

```c
// AVANT
void process() {
    int i, j, k;
    char buffer[1024];
    FILE *file;

    // 100 lignes de code...

    // 'i' n'est utilis√© que maintenant
    for (i = 0; i < 10; i++) {
        // ...
    }

    // 50 lignes de code...

    // 'file' n'est utilis√© que maintenant
    file = fopen("data.txt", "r");
}
```

**Solution** : D√©clarer au plus pr√®s de l'utilisation

```c
// APR√àS
void process() {
    // Code...

    // D√©claration juste avant utilisation
    for (int i = 0; i < 10; i++) {  // C99+ permet la d√©claration dans la boucle
        // ...
    }

    // Plus de code...

    FILE *file = fopen("data.txt", "r");
    if (file == NULL) {
        // Gestion erreur
        return;
    }
    // Utilisation de file
    fclose(file);
}
```

### 7. Remplacement de goto par des structures de contr√¥le

**Probl√®me** : goto rend le flux difficile √† suivre

```c
// AVANT
int process(char *data) {
    char *buffer = NULL;
    FILE *file = NULL;
    int ret = 0;

    if (data == NULL) {
        ret = -1;
        goto cleanup;
    }

    buffer = malloc(1024);
    if (buffer == NULL) {
        ret = -1;
        goto cleanup;
    }

    file = fopen("output.txt", "w");
    if (file == NULL) {
        ret = -1;
        goto cleanup;
    }

    // Traitement...

cleanup:
    if (buffer) free(buffer);
    if (file) fclose(file);
    return ret;
}
```

**Solution** : Extraction de fonctions et early returns

```c
// APR√àS
static char* allocate_buffer(void) {
    char *buffer = malloc(1024);
    if (buffer == NULL) {
        fprintf(stderr, "Failed to allocate buffer\n");
    }
    return buffer;
}

static FILE* open_output_file(void) {
    FILE *file = fopen("output.txt", "w");
    if (file == NULL) {
        fprintf(stderr, "Failed to open file\n");
    }
    return file;
}

int process(char *data) {
    if (data == NULL) {
        return -1;
    }

    char *buffer = allocate_buffer();
    if (buffer == NULL) {
        return -1;
    }

    FILE *file = open_output_file();
    if (file == NULL) {
        free(buffer);
        return -1;
    }

    // Traitement...

    fclose(file);
    free(buffer);
    return 0;
}
```

**Note** : Parfois, goto est acceptable pour le nettoyage en C. Si vous gardez goto, limitez-le √† `goto cleanup` √† la fin :

```c
int process(char *data) {
    char *buffer = NULL;
    FILE *file = NULL;
    int ret = -1;

    if (data == NULL) goto cleanup;

    buffer = malloc(1024);
    if (buffer == NULL) goto cleanup;

    file = fopen("output.txt", "w");
    if (file == NULL) goto cleanup;

    // Traitement...
    ret = 0;  // Succ√®s

cleanup:
    free(buffer);  // free(NULL) est safe
    if (file) fclose(file);
    return ret;
}
```

### 8. Unification de la gestion d'erreurs

**Probl√®me** : Plusieurs fa√ßons de g√©rer les erreurs

```c
// AVANT
int func1() {
    if (error) return -1;  // Retourne -1
}

int func2() {
    if (error) return 0;   // Retourne 0 (!)
}

int func3() {
    if (error) return NULL;  // Retourne NULL
}

void func4() {
    if (error) exit(1);  // Exit brutal
}
```

**Solution** : Convention coh√©rente

```c
// APR√àS : Convention unifi√©e
// 0 = succ√®s, -1 = erreur, errno set

int func1() {
    if (error) {
        errno = EINVAL;
        return -1;
    }
    return 0;
}

int func2() {
    if (error) {
        errno = EIO;
        return -1;
    }
    return 0;
}

// Pour les fonctions retournant pointeur :
// NULL = erreur, errno set
char* func3() {
    if (error) {
        errno = ENOMEM;
        return NULL;
    }
    return result;
}
```

---

## Strat√©gie de refactoring progressif

### Phase 1 : Pr√©paration (1-2 jours)

#### 1.1 Comprendre le code existant

```bash
# Analyser la structure du projet
tree -L 3 src/

# Compter les lignes de code
cloc src/

# Identifier les fichiers les plus gros
find src/ -name "*.c" -exec wc -l {} \; | sort -rn | head -10

# Trouver les fonctions les plus longues
cscope -R -b
# Ou utiliser ctags
```

#### 1.2 Ajouter des tests (si absent)

**Priorit√©** : Tests de non-r√©gression

```c
// tests/regression_test.c
// Capture le comportement actuel (m√™me s'il est bugg√©)

void test_parse_current_behavior() {
    // Test 1 : Cas normal
    char *result = parse("input1");
    assert(strcmp(result, "expected1") == 0);

    // Test 2 : Cas limite
    result = parse("");
    assert(result == NULL);  // Comportement actuel

    // Test 3 : Cas d'erreur
    result = parse(NULL);
    // Actuellement, √ßa crash - mais on documente ce comportement
    // Pour l'instant, on skip ce test
}
```

#### 1.3 Cr√©er une branche de refactoring

```bash
git checkout -b refactor/cleanup-parser
```

### Phase 2 : Quick wins (1 semaine)

Commencer par les refactorings faciles et visibles :

#### 2.1 Renommer les variables cryptiques

```bash
# Jour 1-2 : Renommer dans parser.c
git commit -m "refactor: rename 'n' to 'token_count' in parser.c"
git commit -m "refactor: rename 'buf' to 'line_buffer' in parser.c"
```

#### 2.2 Ajouter des constantes

```bash
# Jour 3 : Remplacer magic numbers
git commit -m "refactor: replace magic numbers with named constants"
```

#### 2.3 Simplifier les conditions

```bash
# Jour 4 : Early returns
git commit -m "refactor: simplify error handling with early returns"
```

#### 2.4 Supprimer le code mort

```bash
# Jour 5 : Nettoyage
git commit -m "refactor: remove unused functions and dead code"
```

### Phase 3 : Restructuration (2-4 semaines)

#### 3.1 Extraction de fonctions

**Principe** : Une fonction = une responsabilit√©

```c
// Avant : fonction monolithique
void process_file(const char *filename) {
    // 300 lignes qui font tout
}

// Apr√®s : d√©coup√© en sous-fonctions
void process_file(const char *filename) {
    FILE *file = open_and_validate_file(filename);
    if (file == NULL) return;

    char *content = read_file_content(file);
    fclose(file);
    if (content == NULL) return;

    data_t *parsed = parse_content(content);
    free(content);
    if (parsed == NULL) return;

    process_data(parsed);
    free_data(parsed);
}
```

#### 3.2 Cr√©er des types clairs

```c
// Avant : param√®tres multiples et confus
int process(char *a, int b, char *c, int d, int e);

// Apr√®s : structure qui encapsule
typedef struct {
    char *input_file;
    char *output_file;
    int buffer_size;
    int max_iterations;
    int verbosity_level;
} process_config_t;

int process(const process_config_t *config);
```

#### 3.3 Modulariser le code

```
Avant :
src/
  ‚îî‚îÄ‚îÄ main.c  (5000 lignes)

Apr√®s :
src/
  ‚îú‚îÄ‚îÄ main.c       (200 lignes)
  ‚îú‚îÄ‚îÄ parser.c     (800 lignes)
  ‚îú‚îÄ‚îÄ processor.c  (600 lignes)
  ‚îú‚îÄ‚îÄ output.c     (400 lignes)
  ‚îî‚îÄ‚îÄ utils.c      (300 lignes)
```

### Phase 4 : Optimisation (2 semaines)

Une fois le code propre, optimiser :

```c
// Exemple : Optimisation apr√®s refactoring
// Avant refactoring : code illisible et lent
// Apr√®s refactoring : code lisible mais toujours lent
// Maintenant : on peut optimiser en toute confiance

// Version lisible (apr√®s refactoring)
for (int i = 0; i < count; i++) {
    if (is_valid(data[i])) {  // Fonction extraite
        process(data[i]);
    }
}

// Version optimis√©e (apr√®s avoir profil√©)
// On d√©couvre que is_valid() est appel√© trop souvent
bool valid[count];
for (int i = 0; i < count; i++) {
    valid[i] = is_valid(data[i]);
}
for (int i = 0; i < count; i++) {
    if (valid[i]) {
        process(data[i]);
    }
}
```

---

## Mesurer les progr√®s

### M√©triques de qualit√© du code

#### 1. Complexit√© cyclomatique

Mesure le nombre de chemins dans le code.

```bash
# Avec lizard
pip install lizard
lizard src/

# R√©sultat :
# Function: parse_line
# NLOC: 45  CCN: 12  <-- Complexit√© cyclomatique
```

**Interpr√©tation** :
- CCN 1-10 : Simple, facile √† tester
- CCN 11-20 : Complexe, difficile √† tester
- CCN 21+ : Tr√®s complexe, refactoriser imp√©rativement

**Objectif** : R√©duire le CCN moyen du projet

#### 2. Longueur des fonctions

```bash
# Script pour trouver les fonctions longues
cat > find_long_functions.sh << 'EOF'
#!/bin/bash
for file in src/*.c; do
    # Simplification : compte les lignes entre { et }
    awk '/^[a-zA-Z_].*\(.*\)/ { fname=$1; start=NR }
         /^}/ { if (start) print fname, NR-start, FILENAME; start=0 }' "$file"
done | sort -k2 -rn | head -20
EOF

chmod +x find_long_functions.sh
./find_long_functions.sh
```

**Objectif** : Aucune fonction >100 lignes

#### 3. Couverture de tests

```bash
# Avec gcov/lcov
gcc -fprofile-arcs -ftest-coverage src/*.c -o test
./test
gcov src/*.c
lcov --capture --directory . --output-file coverage.info
genhtml coverage.info --output-directory coverage_html
```

**Objectif** : >80% de couverture

#### 4. Nombre de warnings

```bash
# Compiler avec warnings maximaux
make clean
make CFLAGS="-Wall -Wextra -Wpedantic -Werror"
```

**Objectif** : Z√©ro warning

### Tableau de bord de progr√®s

```markdown
# Refactoring Progress Report

## Semaine 1 (2025-01-08)
- ‚úÖ Renommer variables : parser.c, utils.c
- ‚úÖ Supprimer code mort : 450 lignes
- ‚úÖ Ajouter constantes : 23 magic numbers ‚Üí constantes

M√©triques :
- Longueur moy. fonctions : 87 ‚Üí 65 lignes
- CCN moyen : 15.2 ‚Üí 12.8
- Warnings : 34 ‚Üí 12

## Semaine 2 (2025-01-15)
- ‚úÖ Extraction fonctions : process_data() d√©coup√© en 5 fonctions
- ‚úÖ Simplification : 15 early returns ajout√©s
- üöß En cours : Modularisation de network.c

M√©triques :
- Longueur moy. fonctions : 65 ‚Üí 48 lignes
- CCN moyen : 12.8 ‚Üí 9.4
- Warnings : 12 ‚Üí 3

## Objectifs semaine 3
- [ ] Finir modularisation network.c
- [ ] Ajouter tests unitaires pour parser
- [ ] R√©duire CCN des 5 fonctions restantes >15
```

---

## G√©rer les risques

### Risque 1 : Casser le code en production

**Mitigation** :
```bash
# 1. Tests de r√©gression automatis√©s
make test

# 2. Tests manuels exhaustifs
./run_manual_tests.sh

# 3. Review du code
git diff main..refactor/cleanup-parser | less

# 4. D√©ploiement progressif
# - D'abord en staging
# - Puis en production avec feature flag
# - Rollback facile si probl√®me
```

### Risque 2 : Refactoring qui n'en finit pas

**Mitigation** :
- ‚è∞ Time-box : 1 mois maximum
- üéØ Objectifs clairs et mesurables
- üö¶ Crit√®res d'arr√™t d√©finis :
  ```
  Stop quand :
  - CCN moyen < 10
  - Fonctions < 50 lignes
  - 80% couverture de tests
  - 0 warning compilation
  ```

### Risque 3 : Conflit avec les nouvelles features

**Mitigation** :
```bash
# Option 1 : Freezer les features pendant le refactoring
# - P√©riode d√©di√©e au refactoring (2-4 semaines)
# - Pas de nouvelles features

# Option 2 : Refactoring continu
# - R√®gle : Toucher un fichier ‚Üí le nettoyer d'abord
# - "Leave the code better than you found it"

# Option 3 : Branche long-term
git checkout -b refactor/long-term
# Merge r√©gulier de main dans la branche
git merge main
# Puis merge de refactor quand pr√™t
```

---

## Bonnes pratiques

### 1. Boy Scout Rule

> *"Leave the code cleaner than you found it"* (Laisse le code plus propre que tu ne l'as trouv√©)

Principe : √Ä chaque fois que vous touchez un fichier, am√©liorez-le un peu.

```bash
# Vous devez corriger un bug dans old_code.c
vim src/old_code.c

# Avant de corriger le bug :
# 1. Renommer 2-3 variables mal nomm√©es
# 2. Extraire une petite fonction si possible
# 3. Ajouter des commentaires

# Puis corriger le bug

# Commit 1 : refactoring
git commit -m "refactor: improve readability of old_code.c"

# Commit 2 : bugfix
git commit -m "fix: correct buffer overflow in parse_line()"
```

### 2. Refactoriser avec un buddy

Refactoriser √† deux r√©duit les erreurs :
- Un code, l'autre review en temps r√©el
- Discussion sur les meilleures approches
- D√©tection imm√©diate des erreurs

### 3. Refactoriser en dehors des deadlines

‚ùå **Mauvais timing** :
```
Release dans 2 jours
‚Üí "On a le temps de refactoriser ce gros fichier !"
‚Üí Bug introduit
‚Üí Panic, rush, dette technique accrue
```

‚úÖ **Bon timing** :
```
Release vient de sortir
‚Üí P√©riode calme
‚Üí Temps pour refactoriser tranquillement
‚Üí Tests approfondis
‚Üí Pr√™t pour la prochaine release
```

### 4. Documenter les d√©cisions

```c
/**
 * parse_line() - Parse une ligne de configuration
 *
 * REFACTORING NOTES (2025-01-15):
 * Cette fonction a √©t√© refactoris√©e de 200 √† 50 lignes.
 *
 * Changements :
 * - Extraction de validate_line() pour la validation
 * - Extraction de split_tokens() pour le parsing
 * - Simplification de la logique avec early returns
 *
 * Ancien comportement pr√©serv√©, sauf :
 * - Maintenant retourne NULL sur input NULL (avant : segfault)
 * - errno est maintenant set correctement
 *
 * Tests : tests/test_parser.c (95% coverage)
 */
int parse_line(const char *line);
```

### 5. Garder les anciens tests

```c
// tests/legacy_behavior_test.c
// Ces tests documentent l'ancien comportement
// M√™me si le comportement √©tait bugg√©, on le documente

void test_old_behavior_empty_string() {
    // LEGACY: L'ancienne version retournait -1 sur cha√Æne vide
    // CURRENT: On retourne 0 (cha√Æne vide est valide)

    int result = parse("");
    assert(result == 0);  // Nouveau comportement

    // Ancien comportement document√© :
    // assert(result == -1);
}
```

---

## Exemple complet : Refactoriser une fonction legacy

### √âtape 0 : Code initial

```c
// parser.c - Code legacy (√©crit en 2010)
int p(char *s) {
    int i, j, k = 0, n = 0;
    char *t, *p, b[1024];

    if (!s) return -1;

    for (i = 0; s[i]; i++) {
        if (s[i] == ',') n++;
    }

    t = malloc((n + 1) * sizeof(char*));

    p = s;
    j = 0;
    for (i = 0; s[i]; i++) {
        if (s[i] == ',') {
            b[j] = 0;
            ((char**)t)[k++] = strdup(b);
            j = 0;
        } else {
            b[j++] = s[i];
        }
    }

    if (j > 0) {
        b[j] = 0;
        ((char**)t)[k] = strdup(b);
    }

    // ... traitement de t ...

    return 0;
}
```

**Probl√®mes** :
- Noms cryptiques (p, s, t, n, k, j, i, b)
- Logique difficile √† suivre
- Pas de gestion d'erreur malloc
- Buffer overflow possible (b[1024])
- Magic numbers
- Responsabilit√©s multiples

### √âtape 1 : Ajouter des tests

```c
// tests/test_parser.c
void test_parse_comma_separated() {
    // Test actuel : documenter le comportement
    int result = p("apple,banana,cherry");
    assert(result == 0);

    result = p("single");
    assert(result == 0);

    result = p(NULL);
    assert(result == -1);
}
```

### √âtape 2 : Renommer

```c
// Commit : "refactor: rename cryptic variables in p()"
int p(char *input_string) {
    int char_index, buffer_index, token_index = 0, comma_count = 0;
    char *token_array, *string_ptr, temp_buffer[1024];

    if (!input_string) return -1;

    // Compter les virgules
    for (char_index = 0; input_string[char_index]; char_index++) {
        if (input_string[char_index] == ',') comma_count++;
    }

    // Allouer tableau de tokens
    token_array = malloc((comma_count + 1) * sizeof(char*));

    // Parser les tokens
    string_ptr = input_string;
    buffer_index = 0;
    for (char_index = 0; input_string[char_index]; char_index++) {
        if (input_string[char_index] == ',') {
            temp_buffer[buffer_index] = '\0';
            ((char**)token_array)[token_index++] = strdup(temp_buffer);
            buffer_index = 0;
        } else {
            temp_buffer[buffer_index++] = input_string[char_index];
        }
    }

    if (buffer_index > 0) {
        temp_buffer[buffer_index] = '\0';
        ((char**)token_array)[token_index] = strdup(temp_buffer);
    }

    // ... traitement de token_array ...

    return 0;
}
```

### √âtape 3 : Renommer la fonction

```c
// Commit : "refactor: rename p() to parse_comma_separated_values()"
int parse_comma_separated_values(char *input_string) {
    // ... m√™me code ...
}
```

### √âtape 4 : Extraire count_commas

```c
// Commit : "refactor: extract count_commas() helper"

static int count_commas(const char *input_string) {
    int comma_count = 0;
    for (int i = 0; input_string[i] != '\0'; i++) {
        if (input_string[i] == ',') {
            comma_count++;
        }
    }
    return comma_count;
}

int parse_comma_separated_values(char *input_string) {
    if (!input_string) return -1;

    int comma_count = count_commas(input_string);

    // Allouer tableau de tokens
    token_array = malloc((comma_count + 1) * sizeof(char*));

    // ... reste du code ...
}
```

### √âtape 5 : Ajouter gestion d'erreur

```c
// Commit : "refactor: add error handling for malloc()"

int parse_comma_separated_values(char *input_string) {
    if (input_string == NULL) {
        errno = EINVAL;
        return -1;
    }

    int comma_count = count_commas(input_string);

    char **token_array = malloc((comma_count + 1) * sizeof(char*));
    if (token_array == NULL) {
        errno = ENOMEM;
        return -1;
    }

    // ... reste du code ...
}
```

### √âtape 6 : Extraire parse_tokens

```c
// Commit : "refactor: extract parse_tokens() helper"

#define MAX_TOKEN_LENGTH 1024

static char** parse_tokens(const char *input_string, int *token_count) {
    *token_count = count_commas(input_string) + 1;

    char **tokens = malloc(*token_count * sizeof(char*));
    if (tokens == NULL) {
        return NULL;
    }

    char temp_buffer[MAX_TOKEN_LENGTH];
    int buffer_index = 0;
    int token_index = 0;

    for (int i = 0; input_string[i] != '\0'; i++) {
        if (input_string[i] == ',') {
            temp_buffer[buffer_index] = '\0';
            tokens[token_index++] = strdup(temp_buffer);
            buffer_index = 0;
        } else {
            if (buffer_index < MAX_TOKEN_LENGTH - 1) {
                temp_buffer[buffer_index++] = input_string[i];
            }
        }
    }

    if (buffer_index > 0) {
        temp_buffer[buffer_index] = '\0';
        tokens[token_index] = strdup(temp_buffer);
    }

    return tokens;
}

int parse_comma_separated_values(char *input_string) {
    if (input_string == NULL) {
        errno = EINVAL;
        return -1;
    }

    int token_count;
    char **tokens = parse_tokens(input_string, &token_count);
    if (tokens == NULL) {
        errno = ENOMEM;
        return -1;
    }

    // ... traitement des tokens ...

    // Lib√©rer m√©moire
    for (int i = 0; i < token_count; i++) {
        free(tokens[i]);
    }
    free(tokens);

    return 0;
}
```

### √âtape 7 : Version finale propre

```c
// parser.c - Code refactoris√© (2025)

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

#define MAX_TOKEN_LENGTH 1024

/**
 * count_commas() - Compte le nombre de virgules dans une cha√Æne
 * @input: Cha√Æne d'entr√©e (ne doit pas √™tre NULL)
 *
 * Return: Nombre de virgules
 */
static int count_commas(const char *input) {
    int count = 0;
    for (int i = 0; input[i] != '\0'; i++) {
        if (input[i] == ',') {
            count++;
        }
    }
    return count;
}

/**
 * parse_tokens() - Parse une cha√Æne CSV en tokens
 * @input: Cha√Æne d'entr√©e (ne doit pas √™tre NULL)
 * @token_count: Pointeur o√π stocker le nombre de tokens
 *
 * Alloue un tableau de cha√Ænes (√† lib√©rer par l'appelant).
 *
 * Return: Tableau de tokens, ou NULL si erreur (errno set)
 */
static char** parse_tokens(const char *input, int *token_count) {
    *token_count = count_commas(input) + 1;

    char **tokens = malloc(*token_count * sizeof(char*));
    if (tokens == NULL) {
        return NULL;
    }

    char temp_buffer[MAX_TOKEN_LENGTH];
    int buffer_index = 0;
    int token_index = 0;

    for (int i = 0; input[i] != '\0'; i++) {
        if (input[i] == ',') {
            // Fin d'un token
            temp_buffer[buffer_index] = '\0';
            tokens[token_index] = strdup(temp_buffer);
            if (tokens[token_index] == NULL) {
                // √âchec strdup : lib√©rer ce qui a √©t√© allou√©
                for (int j = 0; j < token_index; j++) {
                    free(tokens[j]);
                }
                free(tokens);
                return NULL;
            }
            token_index++;
            buffer_index = 0;
        } else {
            // Ajouter caract√®re au buffer (avec protection overflow)
            if (buffer_index < MAX_TOKEN_LENGTH - 1) {
                temp_buffer[buffer_index++] = input[i];
            }
        }
    }

    // Dernier token (s'il reste des caract√®res)
    if (buffer_index > 0) {
        temp_buffer[buffer_index] = '\0';
        tokens[token_index] = strdup(temp_buffer);
        if (tokens[token_index] == NULL) {
            for (int j = 0; j < token_index; j++) {
                free(tokens[j]);
            }
            free(tokens);
            return NULL;
        }
    }

    return tokens;
}

/**
 * parse_comma_separated_values() - Parse une cha√Æne CSV
 * @input: Cha√Æne d'entr√©e au format "val1,val2,val3"
 *
 * Parse la cha√Æne et traite chaque token.
 *
 * Return: 0 en cas de succ√®s, -1 en cas d'erreur (errno set)
 */
int parse_comma_separated_values(const char *input) {
    if (input == NULL) {
        errno = EINVAL;
        return -1;
    }

    int token_count;
    char **tokens = parse_tokens(input, &token_count);
    if (tokens == NULL) {
        errno = ENOMEM;
        return -1;
    }

    // Traitement des tokens
    for (int i = 0; i < token_count; i++) {
        printf("Token %d: %s\n", i, tokens[i]);
        // ... traitement ...
    }

    // Lib√©ration m√©moire
    for (int i = 0; i < token_count; i++) {
        free(tokens[i]);
    }
    free(tokens);

    return 0;
}
```

**R√©sultat** :
- ‚úÖ Noms clairs et explicites
- ‚úÖ Fonctions courtes et focalis√©es
- ‚úÖ Gestion d'erreur compl√®te
- ‚úÖ Protection buffer overflow
- ‚úÖ Documentation Doxygen
- ‚úÖ Comportement pr√©serv√© (tests passent)
- ‚úÖ Lib√©ration m√©moire correcte

---

## Conclusion

Le refactoring progressif est un **art** autant qu'une **science**. Les principes cl√©s :

1. **Petits pas** : Changements incr√©mentaux
2. **Tests** : V√©rifier apr√®s chaque √©tape
3. **Commits atomiques** : Un changement logique = un commit
4. **Patience** : Rome ne s'est pas faite en un jour
5. **Pragmatisme** : Savoir quand arr√™ter

**Citation de Martin Fowler** (cr√©ateur du terme "refactoring") :

> *"Any fool can write code that a computer can understand. Good programmers write code that humans can understand."*

Le refactoring progressif transforme le code que **les machines comprennent** en code que **les humains comprennent**.

---

**Section suivante** : 32.5.2 Ajout de tests - Nous verrons comment ajouter des tests √† du code legacy pour s√©curiser le refactoring.

‚è≠Ô∏è [Ajout de tests](/32-documentation-maintenance/05.2-ajout-tests.md)
