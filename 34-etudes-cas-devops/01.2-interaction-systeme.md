üîù Retour au [Sommaire](/SOMMAIRE.md)

# 34.1.2 Interaction avec le syst√®me

## Introduction

Un outil CLI syst√®me efficace doit pouvoir interagir avec le syst√®me d'exploitation Linux : lire des fichiers, ex√©cuter des commandes, obtenir des informations syst√®me, g√©rer les processus, etc. Cette section vous guide √† travers les diff√©rentes fa√ßons d'interagir avec le syst√®me en C.

---

## 1. Appels syst√®me vs Biblioth√®que standard

### 1.1 Diff√©rences fondamentales

Il existe deux approches principales pour interagir avec le syst√®me :

**Biblioth√®que standard C (stdio.h)** :
- Fonctions portables (fonctionne sur Windows, Linux, etc.)
- I/O bufferis√© (plus performant pour petites op√©rations)
- API de haut niveau : `fopen()`, `fprintf()`, `fgets()`

**Appels syst√®me POSIX (unistd.h, fcntl.h)** :
- Sp√©cifique √† UNIX/Linux
- I/O non bufferis√© (acc√®s direct au noyau)
- API de bas niveau : `open()`, `read()`, `write()`
- Plus de contr√¥le, mais plus complexe

### 1.2 Tableau comparatif

| Op√©ration | Biblioth√®que C | Appel syst√®me |
|-----------|----------------|---------------|
| Ouvrir un fichier | `fopen()` | `open()` |
| Lire | `fread()`, `fgets()` | `read()` |
| √âcrire | `fwrite()`, `fprintf()` | `write()` |
| Fermer | `fclose()` | `close()` |
| Type de descripteur | `FILE*` | `int` (file descriptor) |

### 1.3 Quand utiliser quoi ?

**Utilisez la biblioth√®que standard C quand :**
- Vous voulez de la portabilit√©
- Vous manipulez du texte ligne par ligne
- Les performances ne sont pas critiques

**Utilisez les appels syst√®me quand :**
- Vous avez besoin de contr√¥le fin
- Vous travaillez avec des fichiers binaires volumineux
- Vous devez g√©rer les permissions, les verrous, etc.

---

## 2. Gestion des fichiers

### 2.1 Avec la biblioth√®que standard

```c
#include <stdio.h>
#include <stdlib.h>

int lire_fichier_texte(const char *chemin) {
    FILE *fp = fopen(chemin, "r");
    if (fp == NULL) {
        perror("Erreur ouverture fichier");
        return -1;
    }

    char ligne[256];
    int numero_ligne = 1;

    // Lire ligne par ligne
    while (fgets(ligne, sizeof(ligne), fp) != NULL) {
        printf("%3d: %s", numero_ligne++, ligne);
    }

    fclose(fp);
    return 0;
}

int ecrire_fichier(const char *chemin, const char *contenu) {
    FILE *fp = fopen(chemin, "w");
    if (fp == NULL) {
        perror("Erreur cr√©ation fichier");
        return -1;
    }

    fprintf(fp, "%s\n", contenu);
    fclose(fp);
    return 0;
}
```

**Modes d'ouverture :**
- `"r"` : Lecture (fichier doit exister)
- `"w"` : √âcriture (cr√©e ou √©crase)
- `"a"` : Ajout (cr√©e ou ajoute √† la fin)
- `"r+"` : Lecture/√©criture (fichier doit exister)
- `"w+"` : Lecture/√©criture (cr√©e ou √©crase)
- `"a+"` : Lecture/ajout

### 2.2 Avec les appels syst√®me

```c
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>

int copier_fichier(const char *source, const char *destination) {
    int fd_source, fd_dest;
    ssize_t bytes_lus, bytes_ecrits;
    char buffer[4096];

    // Ouvrir le fichier source en lecture
    fd_source = open(source, O_RDONLY);
    if (fd_source == -1) {
        perror("Erreur ouverture source");
        return -1;
    }

    // Cr√©er/ouvrir le fichier destination en √©criture
    // 0644 = rw-r--r--
    fd_dest = open(destination, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd_dest == -1) {
        perror("Erreur cr√©ation destination");
        close(fd_source);
        return -1;
    }

    // Copier par blocs
    while ((bytes_lus = read(fd_source, buffer, sizeof(buffer))) > 0) {
        bytes_ecrits = write(fd_dest, buffer, bytes_lus);
        if (bytes_ecrits != bytes_lus) {
            perror("Erreur √©criture");
            close(fd_source);
            close(fd_dest);
            return -1;
        }
    }

    if (bytes_lus == -1) {
        perror("Erreur lecture");
    }

    close(fd_source);
    close(fd_dest);
    return 0;
}
```

**Flags pour open() :**
- `O_RDONLY` : Lecture seule
- `O_WRONLY` : √âcriture seule
- `O_RDWR` : Lecture/√©criture
- `O_CREAT` : Cr√©er si n'existe pas
- `O_TRUNC` : Tronquer √† 0 octet
- `O_APPEND` : Ajouter √† la fin
- `O_EXCL` : √âchec si fichier existe (avec O_CREAT)

### 2.3 V√©rifier l'existence d'un fichier

```c
#include <unistd.h>
#include <stdio.h>

int fichier_existe(const char *chemin) {
    // access() retourne 0 si le fichier existe et est accessible
    return access(chemin, F_OK) == 0;
}

int fichier_lisible(const char *chemin) {
    return access(chemin, R_OK) == 0;
}

int fichier_modifiable(const char *chemin) {
    return access(chemin, W_OK) == 0;
}

int fichier_executable(const char *chemin) {
    return access(chemin, X_OK) == 0;
}

// Exemple d'utilisation
int main() {
    const char *fichier = "/etc/passwd";

    if (fichier_existe(fichier)) {
        printf("%s existe\n", fichier);

        if (fichier_lisible(fichier)) {
            printf("  - Lisible: OUI\n");
        }
        if (fichier_modifiable(fichier)) {
            printf("  - Modifiable: OUI\n");
        }
    } else {
        printf("%s n'existe pas\n", fichier);
    }

    return 0;
}
```

---

## 3. Obtenir des informations sur un fichier

### 3.1 stat() : Informations compl√®tes

```c
#include <sys/stat.h>
#include <stdio.h>
#include <time.h>
#include <pwd.h>
#include <grp.h>

void afficher_infos_fichier(const char *chemin) {
    struct stat st;

    // lstat() au lieu de stat() pour d√©tecter les liens symboliques
    // (stat() suit les liens et ne retourne jamais S_IFLNK)
    if (lstat(chemin, &st) == -1) {
        perror("lstat");
        return;
    }

    printf("Fichier: %s\n", chemin);
    printf("Taille: %ld octets\n", st.st_size);
    printf("Blocs: %ld\n", st.st_blocks);
    printf("Inode: %ld\n", st.st_ino);
    printf("Liens: %ld\n", st.st_nlink);

    // Propri√©taire
    struct passwd *pw = getpwuid(st.st_uid);
    struct group *gr = getgrgid(st.st_gid);
    printf("Propri√©taire: %s (%d)\n", pw ? pw->pw_name : "?", st.st_uid);
    printf("Groupe: %s (%d)\n", gr ? gr->gr_name : "?", st.st_gid);

    // Permissions
    printf("Permissions: ");
    printf((S_ISDIR(st.st_mode)) ? "d" : "-");
    printf((st.st_mode & S_IRUSR) ? "r" : "-");
    printf((st.st_mode & S_IWUSR) ? "w" : "-");
    printf((st.st_mode & S_IXUSR) ? "x" : "-");
    printf((st.st_mode & S_IRGRP) ? "r" : "-");
    printf((st.st_mode & S_IWGRP) ? "w" : "-");
    printf((st.st_mode & S_IXGRP) ? "x" : "-");
    printf((st.st_mode & S_IROTH) ? "r" : "-");
    printf((st.st_mode & S_IWOTH) ? "w" : "-");
    printf((st.st_mode & S_IXOTH) ? "x" : "-");
    printf("\n");

    // Type de fichier
    printf("Type: ");
    if (S_ISREG(st.st_mode)) printf("Fichier r√©gulier\n");
    else if (S_ISDIR(st.st_mode)) printf("R√©pertoire\n");
    else if (S_ISLNK(st.st_mode)) printf("Lien symbolique\n");
    else if (S_ISCHR(st.st_mode)) printf("P√©riph√©rique caract√®re\n");
    else if (S_ISBLK(st.st_mode)) printf("P√©riph√©rique bloc\n");
    else if (S_ISFIFO(st.st_mode)) printf("FIFO/pipe\n");
    else if (S_ISSOCK(st.st_mode)) printf("Socket\n");

    // Dates
    printf("Dernier acc√®s: %s", ctime(&st.st_atime));
    printf("Derni√®re modification: %s", ctime(&st.st_mtime));
    printf("Dernier changement: %s", ctime(&st.st_ctime));
}
```

**Diff√©rence entre les dates :**
- `st_atime` : Derni√®re lecture du fichier
- `st_mtime` : Derni√®re modification du contenu
- `st_ctime` : Dernier changement des m√©tadonn√©es (permissions, propri√©taire)

---

## 4. Manipulation de r√©pertoires

### 4.1 Lister le contenu d'un r√©pertoire

```c
#include <stdio.h>
#include <dirent.h>
#include <string.h>

void lister_repertoire(const char *chemin) {
    DIR *dir = opendir(chemin);
    if (dir == NULL) {
        perror("opendir");
        return;
    }

    struct dirent *entry;
    printf("Contenu de %s:\n", chemin);

    while ((entry = readdir(dir)) != NULL) {
        // Ignorer . et ..
        if (strcmp(entry->d_name, ".") == 0 ||
            strcmp(entry->d_name, "..") == 0) {
            continue;
        }

        // Type de fichier
        char type = '?';
        switch (entry->d_type) {
            case DT_REG: type = 'f'; break;  // Fichier
            case DT_DIR: type = 'd'; break;  // R√©pertoire
            case DT_LNK: type = 'l'; break;  // Lien symbolique
            case DT_FIFO: type = 'p'; break; // Pipe
            case DT_SOCK: type = 's'; break; // Socket
        }

        printf("  [%c] %s\n", type, entry->d_name);
    }

    closedir(dir);
}
```

### 4.2 Cr√©er et supprimer des r√©pertoires

```c
#include <sys/stat.h>
#include <unistd.h>
#include <stdio.h>

int creer_repertoire(const char *chemin) {
    // 0755 = rwxr-xr-x
    if (mkdir(chemin, 0755) == -1) {
        perror("mkdir");
        return -1;
    }
    printf("R√©pertoire cr√©√©: %s\n", chemin);
    return 0;
}

int supprimer_repertoire(const char *chemin) {
    if (rmdir(chemin) == -1) {
        perror("rmdir");
        return -1;
    }
    printf("R√©pertoire supprim√©: %s\n", chemin);
    return 0;
}

// Note: rmdir() ne fonctionne que sur des r√©pertoires VIDES
```

### 4.3 Parcours r√©cursif de r√©pertoires

```c
#include <stdio.h>
#include <dirent.h>
#include <string.h>
#include <sys/stat.h>
#include <stdlib.h>

void parcourir_recursif(const char *chemin, int profondeur) {
    DIR *dir = opendir(chemin);
    if (dir == NULL) {
        return;
    }

    struct dirent *entry;

    while ((entry = readdir(dir)) != NULL) {
        if (strcmp(entry->d_name, ".") == 0 ||
            strcmp(entry->d_name, "..") == 0) {
            continue;
        }

        // Afficher avec indentation
        for (int i = 0; i < profondeur; i++) {
            printf("  ");
        }
        printf("%s\n", entry->d_name);

        // Si c'est un r√©pertoire, parcourir r√©cursivement
        if (entry->d_type == DT_DIR) {
            char chemin_complet[1024];
            snprintf(chemin_complet, sizeof(chemin_complet),
                     "%s/%s", chemin, entry->d_name);
            parcourir_recursif(chemin_complet, profondeur + 1);
        }
    }

    closedir(dir);
}

// Utilisation
int main() {
    parcourir_recursif("/tmp", 0);
    return 0;
}
```

---

## 5. Ex√©cution de commandes syst√®me

### 5.1 system() : Solution simple

```c
#include <stdlib.h>
#include <stdio.h>

int executer_commande(const char *commande) {
    int status = system(commande);

    if (status == -1) {
        perror("system");
        return -1;
    }

    // V√©rifier le code de retour
    if (WIFEXITED(status)) {
        int exit_code = WEXITSTATUS(status);
        printf("Commande termin√©e avec code: %d\n", exit_code);
        return exit_code;
    }

    return -1;
}

// Exemples
int main() {
    // Lister les fichiers
    system("ls -la");

    // Obtenir l'uptime
    system("uptime");

    // Rechercher un processus
    system("ps aux | grep firefox");

    return 0;
}
```

**‚ö†Ô∏è Attention avec system() :**
- Lance un shell (`/bin/sh`)
- Risque de s√©curit√© si la commande contient des entr√©es utilisateur
- Moins performant (overhead du shell)

### 5.2 popen() : Capturer la sortie

```c
#include <stdio.h>
#include <stdlib.h>

void executer_et_lire(const char *commande) {
    FILE *fp = popen(commande, "r");
    if (fp == NULL) {
        perror("popen");
        return;
    }

    char ligne[256];
    printf("Sortie de '%s':\n", commande);

    while (fgets(ligne, sizeof(ligne), fp) != NULL) {
        printf("  %s", ligne);
    }

    int status = pclose(fp);
    if (status != 0) {
        fprintf(stderr, "Commande √©chou√©e avec code: %d\n", status);
    }
}

// Exemple: Obtenir la liste des processus
int main() {
    executer_et_lire("ps -e --no-headers | wc -l");
    return 0;
}
```

### 5.3 fork() + exec() : Contr√¥le total (avanc√©)

```c
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>

int executer_programme(const char *programme, char *const args[]) {
    pid_t pid = fork();

    if (pid == -1) {
        perror("fork");
        return -1;
    }

    if (pid == 0) {
        // Processus enfant: ex√©cuter le programme
        execvp(programme, args);

        // Si on arrive ici, execvp a √©chou√©
        perror("execvp");
        exit(1);
    } else {
        // Processus parent: attendre la fin
        int status;
        waitpid(pid, &status, 0);

        if (WIFEXITED(status)) {
            return WEXITSTATUS(status);
        }
        return -1;
    }
}

// Exemple: Ex√©cuter 'ls -la /tmp'
int main() {
    char *args[] = {"ls", "-la", "/tmp", NULL};
    int code = executer_programme("ls", args);
    printf("Code de retour: %d\n", code);
    return 0;
}
```

**Avantages de fork() + exec() :**
- Pas de shell interm√©diaire (plus s√ªr)
- Contr√¥le total sur stdin/stdout/stderr
- Meilleure gestion des erreurs

---

## 6. Variables d'environnement

### 6.1 Lire des variables d'environnement

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    // M√©thode 1: getenv()
    const char *home = getenv("HOME");
    const char *user = getenv("USER");
    const char *path = getenv("PATH");

    printf("HOME: %s\n", home ? home : "(non d√©fini)");
    printf("USER: %s\n", user ? user : "(non d√©fini)");
    printf("PATH: %s\n", path ? path : "(non d√©fini)");

    return 0;
}
```

### 6.2 Modifier des variables d'environnement

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    // D√©finir une variable
    setenv("MA_VARIABLE", "valeur", 1);  // 1 = overwrite si existe

    printf("MA_VARIABLE = %s\n", getenv("MA_VARIABLE"));

    // Modifier
    setenv("MA_VARIABLE", "nouvelle_valeur", 1);
    printf("MA_VARIABLE = %s\n", getenv("MA_VARIABLE"));

    // Supprimer
    unsetenv("MA_VARIABLE");
    printf("MA_VARIABLE = %s\n", getenv("MA_VARIABLE"));  // NULL

    return 0;
}
```

### 6.3 Acc√©der √† toutes les variables (environ)

```c
#include <stdio.h>

// Variable globale d√©finie par le syst√®me
extern char **environ;

int main() {
    printf("Variables d'environnement:\n");

    for (char **env = environ; *env != NULL; env++) {
        printf("  %s\n", *env);
    }

    return 0;
}
```

---

## 7. Informations syst√®me

### 7.1 Informations de base (uname)

```c
#include <sys/utsname.h>
#include <stdio.h>

void afficher_info_systeme() {
    struct utsname info;

    if (uname(&info) == -1) {
        perror("uname");
        return;
    }

    printf("Syst√®me d'exploitation: %s\n", info.sysname);
    printf("Nom de la machine: %s\n", info.nodename);
    printf("Version du noyau: %s\n", info.release);
    printf("Version: %s\n", info.version);
    printf("Architecture: %s\n", info.machine);
}
```

### 7.2 Utilisateur et processus courants

```c
#include <unistd.h>
#include <stdio.h>
#include <pwd.h>

void afficher_info_utilisateur() {
    // UID et GID
    uid_t uid = getuid();      // UID r√©el
    uid_t euid = geteuid();    // UID effectif
    gid_t gid = getgid();      // GID r√©el

    printf("UID: %d (effectif: %d)\n", uid, euid);
    printf("GID: %d\n", gid);

    // Nom d'utilisateur
    struct passwd *pw = getpwuid(uid);
    if (pw != NULL) {
        printf("Utilisateur: %s\n", pw->pw_name);
        printf("R√©pertoire home: %s\n", pw->pw_dir);
        printf("Shell: %s\n", pw->pw_shell);
    }

    // PID du processus
    printf("PID: %d\n", getpid());
    printf("PID parent: %d\n", getppid());
}
```

### 7.3 R√©pertoire courant

```c
#include <unistd.h>
#include <stdio.h>
#include <limits.h>

int main() {
    char cwd[PATH_MAX];

    if (getcwd(cwd, sizeof(cwd)) != NULL) {
        printf("R√©pertoire courant: %s\n", cwd);
    } else {
        perror("getcwd");
    }

    // Changer de r√©pertoire
    if (chdir("/tmp") == 0) {
        getcwd(cwd, sizeof(cwd));
        printf("Nouveau r√©pertoire: %s\n", cwd);
    }

    return 0;
}
```

### 7.4 Limites et ressources du syst√®me

```c
#include <sys/resource.h>
#include <stdio.h>

void afficher_limites() {
    struct rlimit limit;

    // Nombre max de fichiers ouverts
    if (getrlimit(RLIMIT_NOFILE, &limit) == 0) {
        printf("Fichiers ouverts max:\n");
        printf("  Soft: %ld\n", limit.rlim_cur);
        printf("  Hard: %ld\n", limit.rlim_max);
    }

    // Taille max de la pile
    if (getrlimit(RLIMIT_STACK, &limit) == 0) {
        printf("Taille pile:\n");
        printf("  Soft: %ld octets\n", limit.rlim_cur);
        printf("  Hard: %ld octets\n", limit.rlim_max);
    }

    // Nombre max de processus
    if (getrlimit(RLIMIT_NPROC, &limit) == 0) {
        printf("Processus max:\n");
        printf("  Soft: %ld\n", limit.rlim_cur);
        printf("  Hard: %ld\n", limit.rlim_max);
    }
}
```

---

## 8. Gestion des signaux

### 8.1 Capturer Ctrl+C (SIGINT)

```c
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

// Drapeau global
volatile sig_atomic_t interruption = 0;

void gestionnaire_sigint(int sig) {
    (void)sig;
    interruption = 1;
}

int main() {
    // Installer le gestionnaire
    signal(SIGINT, gestionnaire_sigint);

    printf("Appuyez sur Ctrl+C pour arr√™ter...\n");

    int compteur = 0;
    while (!interruption) {
        printf("Travail en cours... %d\n", compteur++);
        sleep(1);
    }

    printf("\nInterruption re√ßue, nettoyage...\n");
    // Faire le nettoyage n√©cessaire

    return 0;
}
```

### 8.2 Gestionnaire de signaux robuste

```c
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

volatile sig_atomic_t signal_recu = 0;

void gestionnaire_signaux(int sig) {
    signal_recu = sig;
}

int main() {
    struct sigaction sa;
    memset(&sa, 0, sizeof(sa));
    sa.sa_handler = gestionnaire_signaux;

    // Capturer plusieurs signaux
    sigaction(SIGINT, &sa, NULL);   // Ctrl+C
    sigaction(SIGTERM, &sa, NULL);  // kill
    sigaction(SIGHUP, &sa, NULL);   // Terminal ferm√©

    printf("Programme en cours (PID: %d)...\n", getpid());

    while (!signal_recu) {
        sleep(1);
    }

    printf("\nSignal %d re√ßu, arr√™t propre\n", signal_recu);
    return 0;
}
```

---

## 9. Lecture du syst√®me de fichiers /proc

Le r√©pertoire `/proc` sous Linux contient des informations sur les processus et le syst√®me.

### 9.1 Lire les informations CPU

```c
#include <stdio.h>
#include <string.h>

void afficher_info_cpu() {
    FILE *fp = fopen("/proc/cpuinfo", "r");
    if (fp == NULL) {
        perror("fopen");
        return;
    }

    char ligne[256];
    int cpu_count = 0;

    while (fgets(ligne, sizeof(ligne), fp) != NULL) {
        if (strncmp(ligne, "processor", 9) == 0) {
            cpu_count++;
        }
        if (strncmp(ligne, "model name", 10) == 0) {
            printf("%s", ligne);
        }
    }

    printf("Nombre de CPUs: %d\n", cpu_count);
    fclose(fp);
}
```

### 9.2 Lire les informations m√©moire

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

void afficher_info_memoire() {
    FILE *fp = fopen("/proc/meminfo", "r");
    if (fp == NULL) {
        perror("fopen");
        return;
    }

    char ligne[256];
    long mem_total = 0, mem_libre = 0, mem_disponible = 0;

    while (fgets(ligne, sizeof(ligne), fp) != NULL) {
        if (strncmp(ligne, "MemTotal:", 9) == 0) {
            sscanf(ligne, "MemTotal: %ld kB", &mem_total);
        } else if (strncmp(ligne, "MemFree:", 8) == 0) {
            sscanf(ligne, "MemFree: %ld kB", &mem_libre);
        } else if (strncmp(ligne, "MemAvailable:", 13) == 0) {
            sscanf(ligne, "MemAvailable: %ld kB", &mem_disponible);
        }
    }

    printf("M√©moire totale: %ld MB\n", mem_total / 1024);
    printf("M√©moire libre: %ld MB\n", mem_libre / 1024);
    printf("M√©moire disponible: %ld MB\n", mem_disponible / 1024);
    printf("M√©moire utilis√©e: %ld MB\n", (mem_total - mem_disponible) / 1024);

    fclose(fp);
}
```

### 9.3 Lire l'uptime

```c
#include <stdio.h>

void afficher_uptime() {
    FILE *fp = fopen("/proc/uptime", "r");
    if (fp == NULL) {
        perror("fopen");
        return;
    }

    double uptime, idle;
    fscanf(fp, "%lf %lf", &uptime, &idle);
    fclose(fp);

    int jours = (int)(uptime / 86400);
    int heures = (int)((uptime - (jours * 86400)) / 3600);
    int minutes = (int)((uptime - (jours * 86400) - (heures * 3600)) / 60);

    printf("Uptime: %d jours, %d heures, %d minutes\n", jours, heures, minutes);
}
```

---

## 10. Gestion des permissions et s√©curit√©

### 10.1 Changer les permissions

```c
#include <sys/stat.h>
#include <stdio.h>

int changer_permissions(const char *fichier, mode_t mode) {
    if (chmod(fichier, mode) == -1) {
        perror("chmod");
        return -1;
    }
    printf("Permissions chang√©es: %s\n", fichier);
    return 0;
}

// Exemples
int main() {
    // Rendre un fichier ex√©cutable (rwxr-xr-x)
    changer_permissions("script.sh", 0755);

    // Rendre un fichier priv√© (rw-------)
    changer_permissions("secret.txt", 0600);

    // Permissions standard pour fichier (rw-r--r--)
    changer_permissions("document.txt", 0644);

    return 0;
}
```

### 10.2 Changer le propri√©taire

```c
#include <unistd.h>
#include <stdio.h>
#include <pwd.h>
#include <grp.h>

int changer_proprietaire(const char *fichier, const char *utilisateur, const char *groupe) {
    // Obtenir l'UID de l'utilisateur
    struct passwd *pw = getpwnam(utilisateur);
    if (pw == NULL) {
        fprintf(stderr, "Utilisateur inconnu: %s\n", utilisateur);
        return -1;
    }

    // Obtenir le GID du groupe
    struct group *gr = getgrnam(groupe);
    if (gr == NULL) {
        fprintf(stderr, "Groupe inconnu: %s\n", groupe);
        return -1;
    }

    // Changer le propri√©taire
    if (chown(fichier, pw->pw_uid, gr->gr_gid) == -1) {
        perror("chown");
        return -1;
    }

    printf("Propri√©taire chang√©: %s -> %s:%s\n", fichier, utilisateur, groupe);
    return 0;
}

// Note: n√©cessite les privil√®ges root
```

---

## 11. Exemple complet : Outil d'information syst√®me

Voici un programme complet qui combine plusieurs techniques :

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/utsname.h>
#include <sys/statvfs.h>
#include <string.h>

void afficher_separateur() {
    printf("========================================\n");
}

void info_systeme() {
    struct utsname uts;
    if (uname(&uts) == 0) {
        printf("Syst√®me: %s %s\n", uts.sysname, uts.release);
        printf("Machine: %s\n", uts.machine);
        printf("Hostname: %s\n", uts.nodename);
    }
}

void info_disque() {
    struct statvfs stat;

    if (statvfs("/", &stat) == 0) {
        unsigned long total = (stat.f_blocks * stat.f_frsize) / (1024 * 1024 * 1024);
        unsigned long libre = (stat.f_bfree * stat.f_frsize) / (1024 * 1024 * 1024);
        unsigned long utilise = total - libre;
        int pourcentage = (int)((utilise * 100) / total);

        printf("Espace disque /:\n");
        printf("  Total: %lu GB\n", total);
        printf("  Utilis√©: %lu GB (%d%%)\n", utilise, pourcentage);
        printf("  Libre: %lu GB\n", libre);
    }
}

void info_memoire() {
    FILE *fp = fopen("/proc/meminfo", "r");
    if (fp) {
        char ligne[256];
        long total = 0, disponible = 0;

        while (fgets(ligne, sizeof(ligne), fp)) {
            if (strncmp(ligne, "MemTotal:", 9) == 0) {
                sscanf(ligne, "MemTotal: %ld kB", &total);
            } else if (strncmp(ligne, "MemAvailable:", 13) == 0) {
                sscanf(ligne, "MemAvailable: %ld kB", &disponible);
            }
        }
        fclose(fp);

        long utilise = total - disponible;
        int pourcentage = (int)((utilise * 100) / total);

        printf("M√©moire RAM:\n");
        printf("  Total: %ld MB\n", total / 1024);
        printf("  Utilis√©e: %ld MB (%d%%)\n", utilise / 1024, pourcentage);
        printf("  Disponible: %ld MB\n", disponible / 1024);
    }
}

void info_utilisateur() {
    char *user = getenv("USER");
    char *home = getenv("HOME");

    printf("Utilisateur: %s\n", user ? user : "inconnu");
    printf("R√©pertoire home: %s\n", home ? home : "inconnu");
    printf("PID: %d\n", getpid());
}

int main() {
    printf("\n");
    afficher_separateur();
    printf("  INFORMATIONS SYST√àME\n");
    afficher_separateur();
    printf("\n");

    info_systeme();
    printf("\n");

    info_utilisateur();
    printf("\n");

    info_memoire();
    printf("\n");

    info_disque();
    printf("\n");

    afficher_separateur();

    return 0;
}
```

---

## 12. Bonnes pratiques

### 12.1 Gestion des erreurs

```c
// Toujours v√©rifier les valeurs de retour
int fd = open("fichier.txt", O_RDONLY);  
if (fd == -1) {  
    perror("Erreur ouverture");  // Affiche l'erreur syst√®me
    return -1;
}

// Utiliser errno pour des informations d√©taill√©es
#include <errno.h>
if (mkdir("test", 0755) == -1) {
    if (errno == EEXIST) {
        printf("Le r√©pertoire existe d√©j√†\n");
    } else if (errno == EACCES) {
        printf("Permission refus√©e\n");
    } else {
        perror("mkdir");
    }
}
```

### 12.2 S√©curit√©

```c
// ‚ùå DANGEREUX - Injection de commande possible
char commande[256];  
sprintf(commande, "rm %s", nom_fichier);  // Si nom_fichier = "; rm -rf /"  
system(commande);  

// ‚úÖ S√âCURIS√â - Utiliser unlink directement
if (unlink(nom_fichier) == -1) {
    perror("unlink");
}

// ‚úÖ S√âCURIS√â - Valider les entr√©es utilisateur
if (strstr(nom_fichier, "..") != NULL || nom_fichier[0] == '/') {
    fprintf(stderr, "Nom de fichier invalide\n");
    return -1;
}
```

### 12.3 Nettoyage des ressources

```c
int traiter_fichier(const char *chemin) {
    int fd = open(chemin, O_RDONLY);
    if (fd == -1) {
        return -1;
    }

    char *buffer = malloc(4096);
    if (buffer == NULL) {
        close(fd);  // Ne pas oublier de fermer
        return -1;
    }

    // Traitement...

    // Nettoyage
    free(buffer);
    close(fd);
    return 0;
}
```

---

## 13. R√©capitulatif

### Tableau des fonctions principales

| Op√©ration | Fonction | En-t√™te |
|-----------|----------|---------|
| Ouvrir fichier | `open()` | `<fcntl.h>` |
| Lire fichier | `read()` | `<unistd.h>` |
| √âcrire fichier | `write()` | `<unistd.h>` |
| Info fichier | `stat()` | `<sys/stat.h>` |
| Lister r√©pertoire | `opendir()`, `readdir()` | `<dirent.h>` |
| Ex√©cuter commande | `system()`, `popen()` | `<stdlib.h>` |
| Variables env | `getenv()`, `setenv()` | `<stdlib.h>` |
| Info syst√®me | `uname()` | `<sys/utsname.h>` |
| Signaux | `signal()`, `sigaction()` | `<signal.h>` |
| Processus | `fork()`, `exec()` | `<unistd.h>` |

### Points cl√©s √† retenir

- ‚úÖ **Toujours v√©rifier les valeurs de retour** : Les appels syst√®me peuvent √©chouer
- ‚úÖ **Utiliser perror()** : Pour afficher des messages d'erreur clairs
- ‚úÖ **Nettoyer les ressources** : Fermer les fichiers, lib√©rer la m√©moire
- ‚úÖ **Valider les entr√©es** : Ne jamais faire confiance aux donn√©es utilisateur
- ‚úÖ **Privil√©gier les appels syst√®me directs** : Plut√¥t que `system()` quand possible
- ‚úÖ **Consulter les man pages** : `man 2 open`, `man 3 fopen`, etc.

---

## Conclusion

L'interaction avec le syst√®me Linux en C offre un contr√¥le puissant et pr√©cis. En ma√Ætrisant ces concepts, vous pouvez cr√©er des outils CLI professionnels capables de :

- Manipuler efficacement les fichiers et r√©pertoires
- Ex√©cuter et contr√¥ler d'autres programmes
- Obtenir des informations syst√®me d√©taill√©es
- G√©rer les signaux et les interruptions
- Cr√©er des outils de monitoring et d'administration

La cl√© est de toujours privil√©gier la robustesse et la s√©curit√©, en v√©rifiant syst√©matiquement les erreurs et en validant les entr√©es utilisateur.

‚è≠Ô∏è [Output format√©](/34-etudes-cas-devops/01.3-output-formate.md)
