ðŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 34.3.3 Daemonisation

## Introduction

Dans les sections prÃ©cÃ©dentes, nous avons crÃ©Ã© un agent de monitoring capable de collecter des mÃ©triques systÃ¨me (34.3.1) et de les exposer au format Prometheus (34.3.2). Cependant, notre programme s'exÃ©cute actuellement au premier plan et s'arrÃªte dÃ¨s qu'on ferme le terminal.

Pour qu'il fonctionne comme un vÃ©ritable **service systÃ¨me**, il doit devenir un **daemon** : un processus qui s'exÃ©cute en arriÃ¨re-plan, indÃ©pendamment de toute session utilisateur.

---

## Qu'est-ce qu'un Daemon ?

### DÃ©finition

Un **daemon** (prononcÃ© "dÃ©mon") est un processus qui :
- S'exÃ©cute en **arriÃ¨re-plan** (pas de terminal attachÃ©)
- DÃ©marre gÃ©nÃ©ralement au **boot** du systÃ¨me
- Continue de fonctionner mÃªme si l'utilisateur se dÃ©connecte
- N'a pas d'interaction directe avec l'utilisateur
- Ã‰crit ses logs dans des fichiers ou syslog (pas sur stdout)

**Exemples courants de daemons :**
- `sshd` : Serveur SSH
- `cron` : Planificateur de tÃ¢ches
- `systemd` : Gestionnaire de systÃ¨me
- `nginx` : Serveur web

### CaractÃ©ristiques d'un daemon

Un daemon correctement implÃ©mentÃ© doit :

1. **Se dÃ©tacher du terminal** : Ne pas bloquer le shell
2. **CrÃ©er sa propre session** : Devenir leader de session
3. **Fermer les descripteurs standard** : stdin, stdout, stderr
4. **Changer de rÃ©pertoire** : Ã‰viter de bloquer des montages
5. **DÃ©finir un umask appropriÃ©** : Permissions des fichiers crÃ©Ã©s
6. **GÃ©rer les signaux** : RÃ©pondre Ã  SIGTERM, SIGHUP, etc.
7. **CrÃ©er un fichier PID** : EmpÃªcher les exÃ©cutions multiples
8. **Logger correctement** : Utiliser syslog au lieu de printf

---

## Processus de Daemonisation Classique

### Les Ã©tapes standard

La daemonisation traditionnelle (style UNIX classique) suit ces Ã©tapes :

```
1. fork() : CrÃ©er un processus enfant
   â””â”€> Processus parent se termine
   â””â”€> L'enfant continue (orphelin â†’ adoptÃ© par init)

2. setsid() : CrÃ©er une nouvelle session
   â””â”€> Devient leader de session
   â””â”€> Se dÃ©tache du terminal de contrÃ´le

3. fork() Ã  nouveau (optionnel mais recommandÃ©)
   â””â”€> S'assurer de ne jamais pouvoir acquÃ©rir un terminal

4. chdir("/") : Changer le rÃ©pertoire de travail
   â””â”€> Ã‰viter de bloquer des systÃ¨mes de fichiers

5. umask(0) : DÃ©finir le masque de permissions
   â””â”€> ContrÃ´le total sur les fichiers crÃ©Ã©s

6. Fermer les descripteurs de fichiers
   â””â”€> Fermer stdin, stdout, stderr et tous les autres

7. Rediriger stdin/stdout/stderr vers /dev/null
   â””â”€> Ã‰viter les erreurs d'Ã©criture

8. CrÃ©er un fichier PID
   â””â”€> EmpÃªcher les instances multiples
```

### Pourquoi deux fork() ?

Le double `fork()` mÃ©rite une explication :

```
Ã‰tat initial : Processus avec terminal de contrÃ´le
    â”‚
    â”œâ”€â”€ fork() #1
    â”‚   â”œâ”€â”€ Parent : se termine
    â”‚   â””â”€â”€ Enfant : continue (devient orphelin)
    â”‚       â””â”€â”€ setsid() : devient leader de session
    â”‚           â””â”€â”€ Risque : peut acquÃ©rir un terminal de contrÃ´le
    â”‚
    â””â”€â”€ fork() #2 (depuis l'enfant)
        â”œâ”€â”€ Parent (ex-enfant) : se termine
        â””â”€â”€ Enfant : continue
            â””â”€â”€ N'est PAS leader de session
            â””â”€â”€ Ne peut JAMAIS acquÃ©rir de terminal de contrÃ´le âœ“
```

**Conclusion :** Le deuxiÃ¨me `fork()` garantit que le daemon ne pourra jamais ouvrir de terminal de contrÃ´le.

---

## ImplÃ©mentation en C

### Fonction de daemonisation complÃ¨te

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <syslog.h>
#include <signal.h>
#include <errno.h>

int daemonize(void) {
    pid_t pid, sid;

    // === Ã‰TAPE 1 : Premier fork() ===
    pid = fork();

    if (pid < 0) {
        // Erreur de fork
        perror("fork");
        return -1;
    }

    if (pid > 0) {
        // Processus parent : se terminer
        exit(EXIT_SUCCESS);
    }

    // === Ã€ partir d'ici : code exÃ©cutÃ© par l'enfant uniquement ===

    // === Ã‰TAPE 2 : CrÃ©er une nouvelle session ===
    sid = setsid();
    if (sid < 0) {
        syslog(LOG_ERR, "Ã‰chec de setsid: %s", strerror(errno));
        return -1;
    }

    // === Ã‰TAPE 3 : Ignorer SIGHUP ===
    // (Au cas oÃ¹ le terminal serait fermÃ©)
    signal(SIGHUP, SIG_IGN);

    // === Ã‰TAPE 4 : DeuxiÃ¨me fork() ===
    pid = fork();

    if (pid < 0) {
        syslog(LOG_ERR, "Ã‰chec du second fork: %s", strerror(errno));
        return -1;
    }

    if (pid > 0) {
        // Premier enfant : se terminer
        exit(EXIT_SUCCESS);
    }

    // === Ã€ partir d'ici : second enfant (le vrai daemon) ===

    // === Ã‰TAPE 5 : Changer le rÃ©pertoire de travail ===
    if (chdir("/") < 0) {
        syslog(LOG_ERR, "Ã‰chec de chdir: %s", strerror(errno));
        return -1;
    }

    // === Ã‰TAPE 6 : DÃ©finir le umask ===
    umask(0);

    // === Ã‰TAPE 7 : Fermer tous les descripteurs de fichiers ===
    int max_fd = sysconf(_SC_OPEN_MAX);
    if (max_fd < 0) {
        max_fd = 1024;  // Valeur par dÃ©faut raisonnable
    }

    for (int fd = 0; fd < max_fd; fd++) {
        close(fd);
    }

    // === Ã‰TAPE 8 : Rediriger stdin, stdout, stderr vers /dev/null ===
    int dev_null = open("/dev/null", O_RDWR);
    if (dev_null < 0) {
        syslog(LOG_ERR, "Impossible d'ouvrir /dev/null: %s", strerror(errno));
        return -1;
    }

    // Rediriger stdin (fd 0)
    dup2(dev_null, STDIN_FILENO);
    // Rediriger stdout (fd 1)
    dup2(dev_null, STDOUT_FILENO);
    // Rediriger stderr (fd 2)
    dup2(dev_null, STDERR_FILENO);

    if (dev_null > 2) {
        close(dev_null);
    }

    return 0;
}
```

### Explication dÃ©taillÃ©e

#### fork() et processus parent/enfant

```c
pid_t pid = fork();

if (pid < 0) {
    // Erreur
}
if (pid > 0) {
    // Code du parent (pid contient le PID de l'enfant)
}
// Code de l'enfant (pid == 0)
```

**AprÃ¨s `fork()` :**
- **Deux processus** exÃ©cutent le mÃªme code
- Le parent reÃ§oit le PID de l'enfant (valeur > 0)
- L'enfant reÃ§oit 0
- C'est comme si le programme se "dÃ©doublait"

#### setsid() - CrÃ©er une session

```c
sid = setsid();
```

**Ce que fait `setsid()` :**
1. CrÃ©e une nouvelle **session**
2. CrÃ©e un nouveau **groupe de processus**
3. Le processus devient le **leader** de ces deux
4. Se **dÃ©tache** du terminal de contrÃ´le

**Important :** `setsid()` Ã©choue si le processus est dÃ©jÃ  un leader de groupe. C'est pourquoi on fait `fork()` d'abord.

#### chdir("/") - Changer de rÃ©pertoire

```c
chdir("/");
```

**Pourquoi ?**
- Un processus maintient son rÃ©pertoire de travail ouvert
- Si le daemon reste dans `/home/user/monapp`, il empÃªche le dÃ©montage de `/home`
- Changer vers `/` (toujours disponible) Ã©vite ce problÃ¨me

**Alternative :** Certains daemons utilisent `/var/run` ou `/tmp`.

#### umask(0) - Permissions des fichiers

```c
umask(0);
```

**Ce que fait `umask()` :**
- DÃ©finit le masque de crÃ©ation de fichiers
- `umask(0)` donne un contrÃ´le total sur les permissions
- Le daemon peut ensuite dÃ©finir explicitement les permissions de chaque fichier

**Exemple :**
```c
umask(0);  
int fd = open("/var/log/myapp.log", O_CREAT | O_WRONLY, 0644);  
// Le fichier aura exactement les permissions 0644 (rw-r--r--)
```

#### Fermeture des descripteurs

```c
for (int fd = 0; fd < max_fd; fd++) {
    close(fd);
}
```

**Pourquoi fermer tous les descripteurs ?**
- Le processus hÃ©rite des descripteurs du parent
- Cela peut inclure des sockets, pipes, fichiers ouverts
- Un daemon ne doit pas conserver ces ressources

**Optimisation :** Sur Linux, on peut utiliser `closefrom()` ou lire `/proc/self/fd/`.

#### Redirection vers /dev/null

```c
int dev_null = open("/dev/null", O_RDWR);  
dup2(dev_null, STDIN_FILENO);  
dup2(dev_null, STDOUT_FILENO);  
dup2(dev_null, STDERR_FILENO);  
```

**Pourquoi ?**
- Certaines fonctions C (printf, scanf, etc.) supposent que 0, 1, 2 existent
- Si ces descripteurs n'existent pas, Ã©crire dessus cause des erreurs
- `/dev/null` absorbe toutes les Ã©critures (trou noir)

---

## Gestion des Signaux

### Signaux importants pour un daemon

Un daemon doit rÃ©pondre proprement aux signaux systÃ¨me :

| Signal    | Signification               | Action recommandÃ©e           |
|-----------|----------------------------|------------------------------|
| SIGTERM   | Demande de terminaison     | ArrÃªt propre (cleanup)       |
| SIGINT    | Interruption (Ctrl+C)      | ArrÃªt propre                 |
| SIGHUP    | Terminal dÃ©connectÃ©        | Recharger la configuration   |
| SIGUSR1   | Signal utilisateur 1       | Action custom (ex: debug)    |
| SIGUSR2   | Signal utilisateur 2       | Action custom (ex: stats)    |

### ImplÃ©mentation des handlers

```c
#include <signal.h>
#include <syslog.h>

// Variable globale pour contrÃ´ler la boucle principale
static volatile sig_atomic_t keep_running = 1;  
static volatile sig_atomic_t reload_config = 0;  

void signal_handler(int sig) {
    switch (sig) {
        case SIGTERM:
        case SIGINT:
            syslog(LOG_INFO, "Signal reÃ§u (%d), arrÃªt demandÃ©", sig);
            keep_running = 0;
            break;

        case SIGHUP:
            syslog(LOG_INFO, "Signal SIGHUP reÃ§u, rechargement config");
            reload_config = 1;
            break;

        case SIGUSR1:
            syslog(LOG_INFO, "Signal SIGUSR1 reÃ§u");
            // Action personnalisÃ©e (ex: basculer en mode debug)
            break;

        default:
            syslog(LOG_WARNING, "Signal non gÃ©rÃ©: %d", sig);
    }
}

void setup_signal_handlers(void) {
    struct sigaction sa;

    // Initialiser la structure
    memset(&sa, 0, sizeof(sa));
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    // Enregistrer les handlers
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGHUP, &sa, NULL);
    sigaction(SIGUSR1, &sa, NULL);

    // Ignorer SIGPIPE (pour les sockets)
    signal(SIGPIPE, SIG_IGN);
}
```

**Points clÃ©s :**
- `sig_atomic_t` : Type atomique garantissant la sÃ©curitÃ© des signaux
- `volatile` : EmpÃªche l'optimisation du compilateur
- Handlers simples : Ne faire que le minimum (modifier une variable)
- Pas d'appels complexes dans les handlers (risque de deadlock)

---

## Fichier PID

### Pourquoi un fichier PID ?

Le fichier PID (Process ID) permet de :
1. **EmpÃªcher les instances multiples** (un seul daemon Ã  la fois)
2. **Faciliter l'administration** (savoir quel processus est le daemon)
3. **Envoyer des signaux** (`kill -HUP $(cat /var/run/mydaemon.pid)`)

### ImplÃ©mentation

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <string.h>
#include <syslog.h>

#define PID_FILE "/var/run/monitoring_agent.pid"

int create_pid_file(const char *pid_file) {
    int fd;
    char pid_str[32];

    // Ouvrir le fichier PID (crÃ©er si n'existe pas)
    fd = open(pid_file, O_RDWR | O_CREAT, 0644);
    if (fd < 0) {
        syslog(LOG_ERR, "Impossible de crÃ©er le fichier PID %s: %s",
               pid_file, strerror(errno));
        return -1;
    }

    // Essayer de verrouiller le fichier (lock exclusif)
    if (lockf(fd, F_TLOCK, 0) < 0) {
        if (errno == EACCES || errno == EAGAIN) {
            // Fichier dÃ©jÃ  verrouillÃ© = daemon dÃ©jÃ  en cours
            syslog(LOG_ERR, "Daemon dÃ©jÃ  en cours d'exÃ©cution");
            close(fd);
            return -1;
        }
        syslog(LOG_ERR, "Ã‰chec du verrouillage du fichier PID: %s",
               strerror(errno));
        close(fd);
        return -1;
    }

    // Tronquer le fichier et Ã©crire le PID
    if (ftruncate(fd, 0) < 0) {
        syslog(LOG_ERR, "Ã‰chec de ftruncate: %s", strerror(errno));
        close(fd);
        return -1;
    }

    snprintf(pid_str, sizeof(pid_str), "%d\n", getpid());
    if (write(fd, pid_str, strlen(pid_str)) != (ssize_t)strlen(pid_str)) {
        syslog(LOG_ERR, "Ã‰chec d'Ã©criture du PID: %s", strerror(errno));
        close(fd);
        return -1;
    }

    // Garder le fichier ouvert (le lock persiste)
    // Il sera automatiquement libÃ©rÃ© Ã  la fin du processus
    return fd;
}

void remove_pid_file(const char *pid_file) {
    unlink(pid_file);
}
```

**Points importants :**
- `lockf()` crÃ©e un **verrou exclusif** sur le fichier
- Si le fichier est dÃ©jÃ  verrouillÃ©, une autre instance est en cours
- Le verrou est **automatiquement libÃ©rÃ©** quand le processus se termine
- Pas besoin de dÃ©verrouiller manuellement (mais on peut supprimer le fichier)

---

## Logging avec syslog

### Pourquoi syslog ?

Un daemon ne peut pas utiliser `printf()` car :
- stdout/stderr sont redirigÃ©s vers `/dev/null`
- Pas de terminal pour afficher les messages

**Solution :** Utiliser **syslog**, le systÃ¨me de logging standard d'UNIX.

### Utilisation de syslog

```c
#include <syslog.h>

void init_syslog(const char *ident) {
    // Ouvrir la connexion syslog
    // LOG_DAEMON : facility (type d'application)
    // LOG_PID : inclure le PID dans chaque message
    openlog(ident, LOG_PID | LOG_CONS, LOG_DAEMON);

    syslog(LOG_INFO, "Daemon dÃ©marrÃ©");
}

void close_syslog(void) {
    syslog(LOG_INFO, "Daemon arrÃªtÃ©");
    closelog();
}

// Exemples d'utilisation
void examples(void) {
    syslog(LOG_DEBUG, "Message de debug");
    syslog(LOG_INFO, "Information");
    syslog(LOG_NOTICE, "Notice");
    syslog(LOG_WARNING, "Avertissement");
    syslog(LOG_ERR, "Erreur: %s", strerror(errno));
    syslog(LOG_CRIT, "Critique");
    syslog(LOG_ALERT, "Alerte");
    syslog(LOG_EMERG, "Urgence");
}
```

### Niveaux de prioritÃ©

| Niveau      | Utilisation                                  |
|-------------|---------------------------------------------|
| LOG_DEBUG   | Informations de dÃ©bogage dÃ©taillÃ©es         |
| LOG_INFO    | Messages informatifs normaux                |
| LOG_NOTICE  | Conditions normales mais significatives     |
| LOG_WARNING | Avertissements                              |
| LOG_ERR     | Erreurs                                     |
| LOG_CRIT    | Conditions critiques                        |
| LOG_ALERT   | Action immÃ©diate requise                    |
| LOG_EMERG   | SystÃ¨me inutilisable                        |

### OÃ¹ vont les logs ?

Sur Ubuntu/Debian modernes avec systemd :
```bash
# Voir les logs du daemon
journalctl -u monitoring-agent.service

# Logs en temps rÃ©el
journalctl -u monitoring-agent.service -f

# Logs traditionnels (si rsyslog est installÃ©)
tail -f /var/log/syslog
```

---

## Agent de Monitoring DaemonisÃ© Complet

### Structure du projet

```
monitoring-agent/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.c
â”‚   â”œâ”€â”€ daemon.c
â”‚   â”œâ”€â”€ daemon.h
â”‚   â”œâ”€â”€ metrics.c
â”‚   â”œâ”€â”€ metrics.h
â”‚   â”œâ”€â”€ http_server.c
â”‚   â””â”€â”€ http_server.h
â”œâ”€â”€ Makefile
â””â”€â”€ monitoring-agent.service
```

### daemon.h

```c
#ifndef DAEMON_H
#define DAEMON_H

#include <signal.h>

// Daemonise le processus
int daemonize(void);

// CrÃ©e le fichier PID
int create_pid_file(const char *pid_file);

// Supprime le fichier PID
void remove_pid_file(const char *pid_file);

// Configure les handlers de signaux
void setup_signal_handlers(void);

// Variables globales pour le contrÃ´le du daemon
extern volatile sig_atomic_t keep_running;  
extern volatile sig_atomic_t reload_config;  

#endif
```

### daemon.c

```c
#include "daemon.h"
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <signal.h>
#include <syslog.h>
#include <errno.h>
#include <string.h>

volatile sig_atomic_t keep_running = 1;  
volatile sig_atomic_t reload_config = 0;  

static void signal_handler(int sig) {
    switch (sig) {
        case SIGTERM:
        case SIGINT:
            syslog(LOG_INFO, "Signal d'arrÃªt reÃ§u");
            keep_running = 0;
            break;
        case SIGHUP:
            syslog(LOG_INFO, "Signal SIGHUP reÃ§u");
            reload_config = 1;
            break;
    }
}

void setup_signal_handlers(void) {
    struct sigaction sa;

    memset(&sa, 0, sizeof(sa));
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGHUP, &sa, NULL);
    signal(SIGPIPE, SIG_IGN);
}

int daemonize(void) {
    pid_t pid, sid;

    pid = fork();
    if (pid < 0) {
        return -1;
    }
    if (pid > 0) {
        exit(EXIT_SUCCESS);
    }

    sid = setsid();
    if (sid < 0) {
        return -1;
    }

    signal(SIGHUP, SIG_IGN);

    pid = fork();
    if (pid < 0) {
        return -1;
    }
    if (pid > 0) {
        exit(EXIT_SUCCESS);
    }

    if (chdir("/") < 0) {
        return -1;
    }

    umask(0);

    int max_fd = sysconf(_SC_OPEN_MAX);
    if (max_fd < 0) {
        max_fd = 1024;
    }

    for (int fd = 0; fd < max_fd; fd++) {
        close(fd);
    }

    int dev_null = open("/dev/null", O_RDWR);
    if (dev_null < 0) {
        return -1;
    }

    dup2(dev_null, STDIN_FILENO);
    dup2(dev_null, STDOUT_FILENO);
    dup2(dev_null, STDERR_FILENO);

    if (dev_null > 2) {
        close(dev_null);
    }

    return 0;
}

int create_pid_file(const char *pid_file) {
    int fd;
    char pid_str[32];

    fd = open(pid_file, O_RDWR | O_CREAT, 0644);
    if (fd < 0) {
        syslog(LOG_ERR, "Impossible de crÃ©er %s: %s", pid_file, strerror(errno));
        return -1;
    }

    if (lockf(fd, F_TLOCK, 0) < 0) {
        if (errno == EACCES || errno == EAGAIN) {
            syslog(LOG_ERR, "Daemon dÃ©jÃ  en cours");
            close(fd);
            return -1;
        }
        close(fd);
        return -1;
    }

    if (ftruncate(fd, 0) < 0) {
        close(fd);
        return -1;
    }

    snprintf(pid_str, sizeof(pid_str), "%d\n", getpid());
    if (write(fd, pid_str, strlen(pid_str)) != (ssize_t)strlen(pid_str)) {
        close(fd);
        return -1;
    }

    return fd;
}

void remove_pid_file(const char *pid_file) {
    unlink(pid_file);
}
```

### main.c

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <syslog.h>
#include <getopt.h>
#include "daemon.h"
#include "http_server.h"
#include "metrics.h"

#define PID_FILE "/var/run/monitoring-agent.pid"
#define DEFAULT_PORT 8080

static void print_usage(const char *program_name) {
    fprintf(stderr, "Usage: %s [OPTIONS]\n", program_name);
    fprintf(stderr, "Options:\n");
    fprintf(stderr, "  -d, --daemon      ExÃ©cuter en tant que daemon\n");
    fprintf(stderr, "  -p, --port PORT   Port du serveur HTTP (dÃ©faut: 8080)\n");
    fprintf(stderr, "  -h, --help        Afficher cette aide\n");
}

int main(int argc, char *argv[]) {
    int daemon_mode = 0;
    int port = DEFAULT_PORT;
    int opt;
    int pid_fd = -1;

    // Options de ligne de commande
    static struct option long_options[] = {
        {"daemon", no_argument, 0, 'd'},
        {"port", required_argument, 0, 'p'},
        {"help", no_argument, 0, 'h'},
        {0, 0, 0, 0}
    };

    while ((opt = getopt_long(argc, argv, "dp:h", long_options, NULL)) != -1) {
        switch (opt) {
            case 'd':
                daemon_mode = 1;
                break;
            case 'p':
                port = atoi(optarg);
                if (port <= 0 || port > 65535) {
                    fprintf(stderr, "Port invalide: %s\n", optarg);
                    return EXIT_FAILURE;
                }
                break;
            case 'h':
                print_usage(argv[0]);
                return EXIT_SUCCESS;
            default:
                print_usage(argv[0]);
                return EXIT_FAILURE;
        }
    }

    // Initialiser syslog
    openlog("monitoring-agent", LOG_PID | LOG_CONS, LOG_DAEMON);

    // Daemoniser si demandÃ©
    if (daemon_mode) {
        syslog(LOG_INFO, "Daemonisation en cours...");

        if (daemonize() < 0) {
            syslog(LOG_ERR, "Ã‰chec de la daemonisation");
            closelog();
            return EXIT_FAILURE;
        }

        // CrÃ©er le fichier PID
        pid_fd = create_pid_file(PID_FILE);
        if (pid_fd < 0) {
            syslog(LOG_ERR, "Ã‰chec de crÃ©ation du fichier PID");
            closelog();
            return EXIT_FAILURE;
        }

        syslog(LOG_INFO, "Daemon dÃ©marrÃ© (PID: %d)", getpid());
    } else {
        printf("DÃ©marrage en mode foreground (PID: %d)\n", getpid());
        printf("Appuyez sur Ctrl+C pour arrÃªter\n");
    }

    // Configurer les handlers de signaux
    setup_signal_handlers();

    // CrÃ©er le serveur HTTP
    int server_fd = create_server_socket(port);
    if (server_fd < 0) {
        syslog(LOG_ERR, "Ã‰chec de crÃ©ation du serveur HTTP");
        if (daemon_mode) {
            remove_pid_file(PID_FILE);
        }
        closelog();
        return EXIT_FAILURE;
    }

    syslog(LOG_INFO, "Serveur HTTP dÃ©marrÃ© sur le port %d", port);

    // Boucle principale
    while (keep_running) {
        // VÃ©rifier si rechargement de config demandÃ©
        if (reload_config) {
            syslog(LOG_INFO, "Rechargement de la configuration");
            // TODO: Recharger la configuration ici
            reload_config = 0;
        }

        // Servir les requÃªtes HTTP
        run_server_iteration(server_fd, 1000);  // Timeout 1 seconde
    }

    // Nettoyage
    syslog(LOG_INFO, "ArrÃªt du daemon");
    close(server_fd);

    if (daemon_mode) {
        remove_pid_file(PID_FILE);
        close(pid_fd);
    }

    closelog();
    return EXIT_SUCCESS;
}
```

### Compilation

```bash
# Makefile simplifiÃ©
gcc -Wall -Wextra -O2 -o monitoring-agent \
    main.c daemon.c metrics.c http_server.c
```

### ExÃ©cution

```bash
# Mode foreground (dÃ©veloppement)
./monitoring-agent -p 8080

# Mode daemon (production)
sudo ./monitoring-agent -d -p 8080

# VÃ©rifier que le daemon tourne
ps aux | grep monitoring-agent  
cat /var/run/monitoring-agent.pid  

# Envoyer un signal SIGHUP (recharger config)
sudo kill -HUP $(cat /var/run/monitoring-agent.pid)

# ArrÃªter proprement
sudo kill -TERM $(cat /var/run/monitoring-agent.pid)
```

---

## IntÃ©gration avec systemd (Moderne)

### Pourquoi systemd ?

Sur les systÃ¨mes Linux modernes, **systemd** remplace les scripts init traditionnels. Avec systemd :
- **Pas besoin de daemoniser manuellement** : systemd gÃ¨re le fork()
- **Gestion des dÃ©pendances** : DÃ©marrer aprÃ¨s le rÃ©seau, par exemple
- **RedÃ©marrage automatique** en cas de crash
- **Logging intÃ©grÃ©** : `journalctl`
- **Gestion des ressources** : Limites CPU, mÃ©moire

### Fichier de service systemd

`/etc/systemd/system/monitoring-agent.service` :

```ini
[Unit]
Description=Monitoring Agent - Prometheus Exporter  
After=network.target  
Wants=network-online.target  

[Service]
Type=simple  
User=monitoring  
Group=monitoring  
ExecStart=/usr/local/bin/monitoring-agent -p 8080  
Restart=on-failure  
RestartSec=5s  

# SÃ©curitÃ©
NoNewPrivileges=true  
PrivateTmp=true  
ProtectSystem=strict  
ProtectHome=true  
ReadWritePaths=/var/log/monitoring-agent  

# Ressources
MemoryMax=512M  
CPUQuota=50%  

# Logging
StandardOutput=journal  
StandardError=journal  
SyslogIdentifier=monitoring-agent  

[Install]
WantedBy=multi-user.target
```

**Points clÃ©s :**

- `Type=simple` : systemd gÃ¨re le processus, pas de double fork
- `Restart=on-failure` : RedÃ©marrage automatique si crash
- `User=monitoring` : ExÃ©cution avec un utilisateur dÃ©diÃ© (non-root)
- Directives de sÃ©curitÃ© : Isolation du systÃ¨me de fichiers
- `StandardOutput=journal` : Logs dans journald (pas besoin de syslog)

### Simplification du code avec systemd

Si on utilise systemd, on peut **simplifier** :

```c
int main(int argc, char *argv[]) {
    // PAS de daemonize() - systemd s'en charge
    // PAS de fichier PID - systemd gÃ¨re
    // PAS besoin de fermer les descripteurs - systemd gÃ¨re

    // Juste le code mÃ©tier
    setup_signal_handlers();
    int server_fd = create_server_socket(8080);

    while (keep_running) {
        run_server_iteration(server_fd, 1000);
    }

    close(server_fd);
    return EXIT_SUCCESS;
}
```

**Avantage Ã©norme :** Code plus simple, plus maintenable.

### Commandes systemd

```bash
# Installer le service
sudo cp monitoring-agent.service /etc/systemd/system/  
sudo systemctl daemon-reload  

# CrÃ©er l'utilisateur monitoring
sudo useradd -r -s /bin/false monitoring

# DÃ©marrer le service
sudo systemctl start monitoring-agent

# Activer au boot
sudo systemctl enable monitoring-agent

# Voir le statut
sudo systemctl status monitoring-agent

# Voir les logs
sudo journalctl -u monitoring-agent -f

# RedÃ©marrer
sudo systemctl restart monitoring-agent

# ArrÃªter
sudo systemctl stop monitoring-agent
```

---

## Comparaison : Daemonisation manuelle vs systemd

| Aspect                    | Daemonisation manuelle | systemd            |
|---------------------------|------------------------|--------------------|
| **ComplexitÃ© du code**    | Ã‰levÃ©e (100+ lignes)   | Faible             |
| **Fichier PID**           | Manuel                 | GÃ©rÃ© par systemd   |
| **RedÃ©marrage auto**      | Non                    | Oui                |
| **Logging**               | syslog manuel          | journald auto      |
| **Gestion des signaux**   | Manuel                 | GÃ©rÃ© (mais SIGTERM toujours utile) |
| **Isolation sÃ©curitÃ©**    | Difficile              | Facile (directives)|
| **CompatibilitÃ©**         | Tous les UNIX          | Linux moderne      |

**Recommandation :**
- **SystÃ¨mes modernes (Ubuntu 16.04+)** : Utiliser systemd
- **CompatibilitÃ© maximale** : Daemonisation manuelle
- **Projet industriel** : systemd + code simplifiÃ©

---

## Bonnes pratiques

### 1. Mode foreground pour le dÃ©veloppement

Toujours offrir une option pour exÃ©cuter en foreground :

```c
if (daemon_mode) {
    daemonize();
} else {
    // Rester en foreground pour debug
    printf("Mode dÃ©veloppement\n");
}
```

### 2. Logs verbeux en dÃ©veloppement

```c
#ifdef DEBUG
    setlogmask(LOG_UPTO(LOG_DEBUG));  // Tous les logs
#else
    setlogmask(LOG_UPTO(LOG_INFO));   // INFO et plus
#endif
```

### 3. Configuration par fichier

Permettre de configurer via `/etc/monitoring-agent.conf` :

```c
typedef struct {
    int port;
    char pid_file[256];
    char log_level[16];
} config_t;

int load_config(config_t *config, const char *config_file) {
    // Parser le fichier de config (INI, JSON, ou autre)
    // Remplir la structure config
}
```

### 4. Rechargement de config sans redÃ©marrage

Sur SIGHUP, recharger la configuration :

```c
if (reload_config) {
    config_t new_config;
    if (load_config(&new_config, CONFIG_FILE) == 0) {
        // Appliquer la nouvelle config
        apply_config(&new_config);
        syslog(LOG_INFO, "Configuration rechargÃ©e");
    }
    reload_config = 0;
}
```

### 5. Gestion propre de l'arrÃªt

LibÃ©rer toutes les ressources :

```c
void cleanup(void) {
    close(server_fd);
    remove_pid_file(PID_FILE);
    // Fermer les connexions, libÃ©rer la mÃ©moire, etc.
}

// Dans main()
atexit(cleanup);
```

### 6. Tests de non-rÃ©gression

VÃ©rifier que le daemon :
- Ne peut pas Ãªtre lancÃ© deux fois
- RÃ©pond correctement aux signaux
- Se termine proprement
- RedÃ©marre aprÃ¨s un crash (si systemd)

---

## DÃ©bogage d'un daemon

### ProblÃ¨me : Le daemon ne dÃ©marre pas

**SymptÃ´mes :**
- Aucun processus ne tourne
- Pas de fichier PID crÃ©Ã©

**Diagnostic :**
```bash
# Essayer en mode foreground
./monitoring-agent

# VÃ©rifier les logs
journalctl -xe  
tail -f /var/log/syslog  

# VÃ©rifier les permissions
ls -l /var/run/
# Le daemon doit pouvoir Ã©crire dans /var/run
```

### ProblÃ¨me : Le daemon se termine immÃ©diatement

**Diagnostic :**
```bash
# Activer le logging de tous les appels systÃ¨me
strace -f ./monitoring-agent -d

# VÃ©rifier les signaux reÃ§us
# Chercher "killed by signal" dans les logs
```

### ProblÃ¨me : Fuites de descripteurs

**Diagnostic :**
```bash
# Voir les descripteurs ouverts
lsof -p $(cat /var/run/monitoring-agent.pid)

# Si trop nombreux, le daemon n'a peut-Ãªtre pas fermÃ© tous les fd
```

### DÃ©bogage avec GDB

Pour dÃ©boguer un daemon avec GDB :

```bash
# Option 1 : Attacher Ã  un daemon en cours
sudo gdb -p $(cat /var/run/monitoring-agent.pid)

# Option 2 : Lancer en foreground dans GDB
gdb ./monitoring-agent
(gdb) run   # Pas en mode daemon
```

---

## RÃ©sumÃ©

La daemonisation d'un agent de monitoring en C nÃ©cessite :

1. **Daemonisation classique** (optionnel avec systemd)
   - Double `fork()` pour se dÃ©tacher
   - `setsid()` pour crÃ©er une session
   - Fermer tous les descripteurs
   - Rediriger stdin/stdout/stderr vers `/dev/null`

2. **Gestion des signaux**
   - SIGTERM/SIGINT : ArrÃªt propre
   - SIGHUP : Rechargement de config
   - Handlers simples et sÃ»rs

3. **Fichier PID**
   - EmpÃªcher les instances multiples
   - Faciliter l'administration
   - Lock exclusif avec `lockf()`

4. **Logging**
   - Utiliser syslog au lieu de printf
   - Niveaux appropriÃ©s (DEBUG, INFO, ERR...)
   - Integration avec journald sur systemd

5. **systemd (recommandÃ©)**
   - Simplifie drastiquement le code
   - Gestion automatique du cycle de vie
   - Isolation et sÃ©curitÃ©

**Votre agent de monitoring peut maintenant :**
- Collecter des mÃ©triques systÃ¨me
- Les exposer au format Prometheus
- Fonctionner comme un service systÃ¨me fiable 24/7

---

## Pour aller plus loin

- **sd-daemon** : Librairie systemd pour notification de dÃ©marrage
- **Capabilities Linux** : PrivilÃ¨ges fins (CAP_NET_BIND_SERVICE) au lieu de root
- **Docker** : Conteneuriser le daemon (pas de daemonisation nÃ©cessaire)
- **Supervision** : IntÃ©grer avec Monit, Supervisor, ou systemd watchdog
- **Analyse de crash** : Core dumps avec `coredumpctl` (systemd)

**RÃ©fÃ©rences :**
- `man 7 daemon` : Guide complet sur les daemons
- `man 1 systemd.service` : Documentation systemd
- Stevens, "Advanced Programming in the UNIX Environment", Chapitre 13

â­ï¸ [Serveur web minimaliste](/34-etudes-cas-devops/04-serveur-web.md)
