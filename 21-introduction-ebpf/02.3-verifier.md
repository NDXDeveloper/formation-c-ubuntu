ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 21.2.3 Le VÃ©rificateur (Verifier)

## Introduction

Le **vÃ©rificateur eBPF** (BPF verifier) est le gardien ultime de la sÃ©curitÃ© du noyau Linux. C'est lui qui rend eBPF rÃ©volutionnaire : il garantit mathÃ©matiquement qu'un programme BPF ne peut **jamais** crasher le systÃ¨me, crÃ©er des boucles infinies, ou accÃ©der Ã  de la mÃ©moire interdite.

Sans le vÃ©rificateur, eBPF serait aussi dangereux qu'un module noyau classique. Avec lui, vous pouvez exÃ©cuter du code dans le noyau en toute confiance.

Dans cette section, nous allons explorer comment fonctionne cette piÃ¨ce maÃ®tresse d'eBPF.

---

## ğŸ¯ Qu'est-ce que le VÃ©rificateur ?

### DÃ©finition Simple

Le **vÃ©rificateur eBPF** est un composant du noyau Linux qui effectue une **analyse statique** exhaustive de chaque programme BPF **avant** de le charger en mÃ©moire. Si le programme passe toutes les vÃ©rifications, il est considÃ©rÃ© comme sÃ»r et peut Ãªtre exÃ©cutÃ©. Sinon, il est rejetÃ© avec un message d'erreur.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Programme BPF (bytecode)                  â”‚
â”‚   my_program.bpf.o                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         VÃ‰RIFICATEUR eBPF                   â”‚
â”‚                                             â”‚
â”‚  ğŸ” Analyse statique exhaustive :           â”‚
â”‚     â€¢ Pas de boucles infinies ?             â”‚
â”‚     â€¢ Tous les chemins se terminent ?       â”‚
â”‚     â€¢ AccÃ¨s mÃ©moire valides ?               â”‚
â”‚     â€¢ Pas de pointeurs NULL dÃ©rÃ©fÃ©rencÃ©s ?  â”‚
â”‚     â€¢ Taille du programme < limite ?        â”‚
â”‚     â€¢ Types corrects ?                      â”‚
â”‚                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚   âœ… SÃ›R   â”‚           âŒ DANGEREUX      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                       â”‚
         â–¼                       â–¼
  Programme chargÃ©          Rejet avec erreur
  et JIT compilÃ©            dÃ©taillÃ©e
```

### Analogie : Le ContrÃ´leur AÃ©rien

Imaginez le vÃ©rificateur comme un **contrÃ´leur aÃ©rien ultra-strict** :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   TOUR DE CONTRÃ”LE (VÃ©rificateur)           â”‚
â”‚                                             â”‚
â”‚   Un avion (programme BPF) demande          â”‚
â”‚   l'autorisation de dÃ©coller                â”‚
â”‚                                             â”‚
â”‚   Le contrÃ´leur vÃ©rifie :                   â”‚
â”‚   âœ“ Plan de vol complet et cohÃ©rent         â”‚
â”‚   âœ“ Carburant suffisant pour le trajet      â”‚
â”‚   âœ“ Pas de zones interdites                 â”‚
â”‚   âœ“ Altitude de croisiÃ¨re sÃ»re              â”‚
â”‚   âœ“ ProcÃ©dures d'urgence en place           â”‚
â”‚                                             â”‚
â”‚   SI TOUT est OK â†’ Autorisation de dÃ©coller â”‚
â”‚   SINON â†’ Vol annulÃ©                        â”‚
â”‚                                             â”‚
â”‚   Impossible de dÃ©coller sans validation !  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Le vÃ©rificateur garantit que l'avion (programme) ne peut **jamais** s'Ã©craser (crasher le kernel).

---

## ğŸ” Comment Fonctionne le VÃ©rificateur ?

### Analyse Statique : Deux Passes Principales

Le vÃ©rificateur effectue son analyse en **deux passes** :

#### Passe 1 : Analyse CFG (Control Flow Graph)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   PASSE 1 : Structure du Programme           â”‚
â”‚                                              â”‚
â”‚   Construction du graphe de flot de contrÃ´le â”‚
â”‚                                              â”‚
â”‚   Exemple de CFG :                           â”‚
â”‚                                              â”‚
â”‚        START                                 â”‚
â”‚          â”‚                                   â”‚
â”‚          â–¼                                   â”‚
â”‚      [Instruction 1]                         â”‚
â”‚          â”‚                                   â”‚
â”‚          â–¼                                   â”‚
â”‚      [if condition]                          â”‚
â”‚          â”‚                                   â”‚
â”‚      â”Œâ”€â”€â”€â”´â”€â”€â”€â”                               â”‚
â”‚      â–¼       â–¼                               â”‚
â”‚   [True]  [False]                            â”‚
â”‚      â”‚       â”‚                               â”‚
â”‚      â””â”€â”€â”€â”¬â”€â”€â”€â”˜                               â”‚
â”‚          â–¼                                   â”‚
â”‚        EXIT                                  â”‚
â”‚                                              â”‚
â”‚   VÃ©rifications :                            â”‚
â”‚   âœ“ Tous les chemins mÃ¨nent Ã  EXIT           â”‚
â”‚   âœ“ Pas de boucles arriÃ¨re non bornÃ©es       â”‚
â”‚   âœ“ Programme < 1M instructions              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Le vÃ©rificateur vÃ©rifie que :
- Chaque branche se termine (pas de chemin infini)
- Pas de sauts vers des instructions invalides
- Les boucles sont bornÃ©es (depuis Linux 5.3)

#### Passe 2 : Simulation d'ExÃ©cution

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   PASSE 2 : Simulation Symbolique            â”‚
â”‚                                              â”‚
â”‚   Le vÃ©rificateur "exÃ©cute" chaque chemin    â”‚
â”‚   possible et track l'Ã©tat des registres     â”‚
â”‚                                              â”‚
â”‚   Pour chaque instruction :                  â”‚
â”‚   â€¢ Ã‰tat des registres (type, valeur)        â”‚
â”‚   â€¢ Pointeurs valides ou non                 â”‚
â”‚   â€¢ Limites des tableaux respectÃ©es          â”‚
â”‚   â€¢ AccÃ¨s mÃ©moire autorisÃ©s                  â”‚
â”‚                                              â”‚
â”‚   Exemple :                                  â”‚
â”‚   r1 = map_lookup(&map, &key)                â”‚
â”‚   â†“                                          â”‚
â”‚   Ã‰tat : r1 = PTR_TO_MAP_VALUE_OR_NULL       â”‚
â”‚                                              â”‚
â”‚   if (r1 == NULL) goto error                 â”‚
â”‚   â†“                                          â”‚
â”‚   Chemin vrai : r1 = NULL                    â”‚
â”‚   Chemin faux : r1 = PTR_TO_MAP_VALUE âœ“      â”‚
â”‚                                              â”‚
â”‚   *r1 = 42                                   â”‚
â”‚   â†“                                          â”‚
â”‚   VÃ©rification : r1 DOIT Ãªtre non-NULL       â”‚
â”‚   âœ“ OK sur le chemin faux                    â”‚
â”‚   âœ— REJET sur le chemin vrai                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Cette passe est **cruciale** : le vÃ©rificateur simule **tous les chemins possibles** et vÃ©rifie que chaque accÃ¨s mÃ©moire est sÃ»r.

---

## âœ… Ce que le VÃ©rificateur VÃ©rifie

### 1. Terminaison Garantie

**RÃ¨gle** : Le programme doit **toujours** se terminer, quelles que soient les entrÃ©es.

```c
// âŒ REJETÃ‰ - Boucle infinie potentielle
SEC("xdp")
int bad_loop(struct xdp_md *ctx)
{
    int i = 0;
    while (i < some_variable) {  // some_variable peut Ãªtre Ã©norme !
        i++;
    }
    return XDP_PASS;
}

// âŒ REJETÃ‰ - Boucle arriÃ¨re non bornÃ©e (avant Linux 5.3)
SEC("xdp")
int bad_loop2(struct xdp_md *ctx)
{
    for (int i = 0; i < 1000000; i++) {  // Trop d'itÃ©rations
        // ...
    }
    return XDP_PASS;
}

// âœ… ACCEPTÃ‰ - Boucle bornÃ©e avec constante
SEC("xdp")
int good_loop(struct xdp_md *ctx)
{
    #pragma unroll
    for (int i = 0; i < 10; i++) {  // 10 = constante connue
        // ...
    }
    return XDP_PASS;
}

// âœ… ACCEPTÃ‰ - Boucle bornÃ©e vÃ©rifiable (Linux 5.3+)
SEC("xdp")
int good_loop2(struct xdp_md *ctx)
{
    for (int i = 0; i < 100 && i < len; i++) {  // Maximum garanti = 100
        // ...
    }
    return XDP_PASS;
}
```

**Pourquoi ?** Une boucle infinie bloquerait le noyau entier.

---

### 2. Taille du Programme

**RÃ¨gle** : Le programme doit contenir moins de **~1 million d'instructions** (limite configurable).

```c
// Compteur du vÃ©rificateur
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Instructions processed:       â”‚
â”‚  999,999 / 1,000,000           â”‚
â”‚                                â”‚
â”‚  âœ… OK                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Instructions processed:       â”‚
â”‚  1,000,001 / 1,000,000         â”‚
â”‚                                â”‚
â”‚  âŒ ERREUR: program too large  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Pourquoi ?** Pour garantir que la vÃ©rification se termine en temps raisonnable.

**Solution** : Utiliser des tail calls pour diviser un gros programme.

---

### 3. ValiditÃ© des Pointeurs

**RÃ¨gle** : Tous les pointeurs doivent Ãªtre **validÃ©s avant usage**.

```c
// âŒ REJETÃ‰ - Pointeur non vÃ©rifiÃ©
SEC("tracepoint/syscalls/sys_enter_open")
int bad_pointer(void *ctx)
{
    __u32 key = 0;
    __u64 *value = bpf_map_lookup_elem(&my_map, &key);

    *value = 42;  // âŒ ERREUR: R1 invalid mem access 'map_value_or_null'

    return 0;
}

// âœ… ACCEPTÃ‰ - Pointeur vÃ©rifiÃ©
SEC("tracepoint/syscalls/sys_enter_open")
int good_pointer(void *ctx)
{
    __u32 key = 0;
    __u64 *value = bpf_map_lookup_elem(&my_map, &key);

    if (value) {  // âœ“ VÃ©rification obligatoire
        *value = 42;  // OK : le vÃ©rificateur sait que value != NULL
    }

    return 0;
}
```

**Comment Ã§a marche ?** Le vÃ©rificateur track les **types de registres** :

```
AprÃ¨s bpf_map_lookup_elem() :
  R0 = PTR_TO_MAP_VALUE_OR_NULL

AprÃ¨s if (R0 == NULL) :
  Branche vraie  : R0 = SCALAR_VALUE (NULL)
  Branche fausse : R0 = PTR_TO_MAP_VALUE âœ“

Sur la branche fausse, *R0 est autorisÃ©
Sur la branche vraie, *R0 est INTERDIT
```

---

### 4. Limites des AccÃ¨s MÃ©moire

**RÃ¨gle** : Tous les accÃ¨s Ã  des buffers/tableaux doivent Ãªtre **vÃ©rifiÃ©s** pour ne pas dÃ©passer les limites.

```c
// âŒ REJETÃ‰ - DÃ©passement potentiel
SEC("xdp")
int bad_bounds(struct xdp_md *ctx)
{
    void *data = (void *)(long)ctx->data;
    void *data_end = (void *)(long)ctx->data_end;

    struct ethhdr *eth = data;

    // AccÃ¨s AVANT de vÃ©rifier les limites
    if (eth->h_proto == 0x0800) {  // âŒ ERREUR: invalid access to packet
        return XDP_DROP;
    }

    return XDP_PASS;
}

// âœ… ACCEPTÃ‰ - Limites vÃ©rifiÃ©es
SEC("xdp")
int good_bounds(struct xdp_md *ctx)
{
    void *data = (void *)(long)ctx->data;
    void *data_end = (void *)(long)ctx->data_end;

    struct ethhdr *eth = data;

    // âœ“ VÃ©rifier d'abord que eth + 1 <= data_end
    if ((void *)(eth + 1) > data_end) {
        return XDP_DROP;
    }

    // Maintenant l'accÃ¨s est sÃ»r
    if (eth->h_proto == 0x0800) {  // âœ“ OK
        return XDP_DROP;
    }

    return XDP_PASS;
}
```

**Pattern obligatoire pour XDP/TC** :

```c
void *data = (void *)(long)ctx->data;
void *data_end = (void *)(long)ctx->data_end;

struct my_header *hdr = data;

// TOUJOURS vÃ©rifier avant d'accÃ©der
if ((void *)(hdr + 1) > data_end)
    return XDP_DROP;

// Maintenant on peut lire hdr en sÃ©curitÃ©
__u16 field = hdr->some_field;
```

---

### 5. Utilisation des Registres

**RÃ¨gle** : Les registres doivent Ãªtre **initialisÃ©s** avant usage.

Le vÃ©rificateur track **10 registres** (R0-R9) + **1 frame pointer** (R10) :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   REGISTRES eBPF                     â”‚
â”‚                                      â”‚
â”‚   R0  : Valeur de retour             â”‚
â”‚   R1-R5 : Arguments de fonction      â”‚
â”‚   R6-R9 : Registres callee-saved     â”‚
â”‚   R10 : Frame pointer (stack)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```c
// âŒ REJETÃ‰ - Registre non initialisÃ©
SEC("xdp")
int bad_register(struct xdp_md *ctx)
{
    int result;

    // result n'est pas initialisÃ© !
    if (result > 0) {  // âŒ ERREUR: R1 !read_ok
        return XDP_DROP;
    }

    return XDP_PASS;
}

// âœ… ACCEPTÃ‰ - Registre initialisÃ©
SEC("xdp")
int good_register(struct xdp_md *ctx)
{
    int result = 0;  // âœ“ InitialisÃ©

    if (result > 0) {  // OK
        return XDP_DROP;
    }

    return XDP_PASS;
}
```

---

### 6. Profondeur de la Pile (Stack)

**RÃ¨gle** : Maximum **512 bytes** de pile par programme.

```c
// âŒ REJETÃ‰ - Pile trop grande
SEC("xdp")
int bad_stack(struct xdp_md *ctx)
{
    char buffer[4096];  // 4 KB > 512 bytes
    // âŒ ERREUR: combined stack size exceeds 512 bytes
    return XDP_PASS;
}

// âœ… ACCEPTÃ‰ - Pile raisonnable
SEC("xdp")
int good_stack(struct xdp_md *ctx)
{
    char buffer[256];  // 256 bytes < 512 bytes
    return XDP_PASS;
}

// âœ… SOLUTION - Utiliser une map per-CPU
struct {
    __uint(type, BPF_MAP_TYPE_PERCPU_ARRAY);
    __uint(max_entries, 1);
    __type(key, __u32);
    __type(value, char[4096]);
} buffer_map SEC(".maps");

SEC("xdp")
int good_stack_alternative(struct xdp_md *ctx)
{
    __u32 key = 0;
    char *buffer = bpf_map_lookup_elem(&buffer_map, &key);
    if (buffer) {
        // Utiliser buffer (4 KB disponible)
    }
    return XDP_PASS;
}
```

---

### 7. Appels de Fonctions

**RÃ¨gle** : Seules les **helper functions** et les fonctions **inline** sont autorisÃ©es.

```c
// âŒ REJETÃ‰ - Fonction non inline
int my_function(int x) {
    return x * 2;
}

SEC("xdp")
int bad_call(struct xdp_md *ctx)
{
    int result = my_function(42);  // âŒ ERREUR: function calls not allowed
    return XDP_PASS;
}

// âœ… ACCEPTÃ‰ - Fonction inline
static __always_inline int my_function(int x) {
    return x * 2;
}

SEC("xdp")
int good_call(struct xdp_md *ctx)
{
    int result = my_function(42);  // âœ“ OK : inlinÃ© par le compilateur
    return XDP_PASS;
}

// âœ… ACCEPTÃ‰ - Helper function
SEC("xdp")
int helper_call(struct xdp_md *ctx)
{
    __u64 ts = bpf_ktime_get_ns();  // âœ“ OK : helper officiel
    return XDP_PASS;
}
```

---

### 8. Types et Conversions

**RÃ¨gle** : Les types doivent Ãªtre **cohÃ©rents** et les conversions **explicites**.

```c
// âŒ REJETÃ‰ - Type mismatch
SEC("xdp")
int bad_types(struct xdp_md *ctx)
{
    __u32 *ptr32 = (__u32 *)ctx->data;
    __u64 value = *ptr32;  // Potentiellement dangereux

    // Le vÃ©rificateur peut rejeter selon le contexte
    return XDP_PASS;
}

// âœ… ACCEPTÃ‰ - Types explicites et vÃ©rifiÃ©s
SEC("xdp")
int good_types(struct xdp_md *ctx)
{
    void *data = (void *)(long)ctx->data;
    void *data_end = (void *)(long)ctx->data_end;

    struct ethhdr *eth = data;
    if ((void *)(eth + 1) > data_end)
        return XDP_DROP;

    __u16 proto = eth->h_proto;  // âœ“ Type correct
    return XDP_PASS;
}
```

---

## ğŸš« Erreurs Courantes du VÃ©rificateur

### Anatomie d'un Message d'Erreur

Voici un exemple typique d'erreur du vÃ©rificateur :

```
libbpf: load bpf program failed: Permission denied
libbpf: -- BEGIN DUMP LOG --
libbpf:
0: (bf) r6 = r1
1: (18) r1 = 0xffff88810a2b4000
3: (85) call bpf_map_lookup_elem#1
4: (15) if r0 == 0x0 goto pc+2
 R0=map_value(id=0,off=0,ks=4,vs=8,imm=0) R6=ctx(id=0,off=0,imm=0) R10=fp0
6: (79) r1 = *(u64 *)(r0 +0)
7: (b7) r0 = 0
8: (95) exit

from 4 to 7: R0=inv0 R6=ctx(id=0,off=0,imm=0) R10=fp0
7: (b7) r0 = 0
8: (95) exit
invalid access to map value, value_size=8 off=0 size=8
; value = *ptr;
9: R0=map_value_or_null(id=1,off=0,ks=4,vs=8,imm=0) R6=ctx(id=0,off=0,imm=0) R10=fp0
libbpf: -- END DUMP LOG --
```

### DÃ©coder le Message

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. Type d'erreur                                â”‚
â”‚     "invalid access to map value"                â”‚
â”‚     â†’ AccÃ¨s Ã  un pointeur non vÃ©rifiÃ©            â”‚
â”‚                                                  â”‚
â”‚  2. Contexte                                     â”‚
â”‚     "value_size=8 off=0 size=8"                  â”‚
â”‚     â†’ Taille de la valeur et offset              â”‚
â”‚                                                  â”‚
â”‚  3. Ligne de code source                         â”‚
â”‚     "; value = *ptr;"                            â”‚
â”‚     â†’ Ligne qui pose problÃ¨me                    â”‚
â”‚                                                  â”‚
â”‚  4. Ã‰tat des registres                           â”‚
â”‚     "R0=map_value_or_null"                       â”‚
â”‚     â†’ R0 peut Ãªtre NULL !                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Top 10 des Erreurs et Solutions

#### 1. "invalid mem access 'map_value_or_null'"

```c
// ProblÃ¨me : Pointeur non vÃ©rifiÃ©
__u64 *value = bpf_map_lookup_elem(&map, &key);
*value = 42;  // âŒ

// Solution : VÃ©rifier avant usage
if (value) {
    *value = 42;  // âœ“
}
```

#### 2. "invalid access to packet"

```c
// ProblÃ¨me : Limites non vÃ©rifiÃ©es
struct iphdr *ip = data;
__u8 proto = ip->protocol;  // âŒ

// Solution : VÃ©rifier les limites
if ((void *)(ip + 1) > data_end)
    return XDP_DROP;
__u8 proto = ip->protocol;  // âœ“
```

#### 3. "program too large, processed X insn"

```c
// ProblÃ¨me : Programme trop gros

// Solution 1 : Simplifier le code
// Solution 2 : Utiliser tail calls
bpf_tail_call(ctx, &prog_array, next_prog);
```

#### 4. "back-edge from insn X to Y"

```c
// ProblÃ¨me : Boucle non bornÃ©e
while (condition) { }  // âŒ

// Solution : Boucle avec limite fixe
#pragma unroll
for (int i = 0; i < 10; i++) { }  // âœ“
```

#### 5. "R1 !read_ok"

```c
// ProblÃ¨me : Registre non initialisÃ©
int x;
if (x > 0) { }  // âŒ

// Solution : Initialiser
int x = 0;  // âœ“
if (x > 0) { }
```

#### 6. "combined stack size exceeds 512 bytes"

```c
// ProblÃ¨me : Pile trop grande
char buf[4096];  // âŒ

// Solution : Utiliser une map
char *buf = bpf_map_lookup_elem(&buffer_map, &key);  // âœ“
```

#### 7. "function calls are not allowed"

```c
// ProblÃ¨me : Fonction non inline
int func(int x) { return x; }
func(42);  // âŒ

// Solution : Marquer inline
static __always_inline int func(int x) { return x; }
func(42);  // âœ“
```

#### 8. "cannot pass map_value_or_null into helper function"

```c
// ProblÃ¨me : Passer un pointeur non vÃ©rifiÃ© Ã  un helper
char *str = bpf_map_lookup_elem(&map, &key);
bpf_probe_read_user_str(buf, sizeof(buf), str);  // âŒ

// Solution : VÃ©rifier avant
if (str) {
    bpf_probe_read_user_str(buf, sizeof(buf), str);  // âœ“
}
```

#### 9. "infinite loop detected"

```c
// ProblÃ¨me : Boucle infinie possible
for (int i = 0; i < n; i++) { }  // n peut Ãªtre Ã©norme

// Solution : Limiter avec une constante
for (int i = 0; i < 100 && i < n; i++) { }  // âœ“
```

#### 10. "R0 leaks addr"

```c
// ProblÃ¨me : Fuite d'adresse kernel
return (__u64)some_kernel_ptr;  // âŒ

// Solution : Ne pas retourner d'adresses
return 0;  // âœ“
```

---

## ğŸ› ï¸ Techniques pour Passer la VÃ©rification

### 1. Utiliser des Helper Functions

Les helpers sont **prÃ©-vÃ©rifiÃ©s** par le noyau :

```c
// Au lieu de manipuler directement la mÃ©moire
char *ptr = (char *)ctx->data;
char c = *ptr;  // Complexe Ã  vÃ©rifier

// Utiliser un helper
char buf[16];
bpf_probe_read_kernel(&buf, sizeof(buf), ptr);  // âœ“ PrÃ©fÃ©rÃ©
```

### 2. Simplifier la Logique

```c
// âŒ Complexe pour le vÃ©rificateur
if (a && b && c && d && e && f) {
    // Code
}

// âœ… Plus simple
if (a && b) {
    if (c && d) {
        if (e && f) {
            // Code
        }
    }
}
```

### 3. Compiler avec -O2

L'optimisation aide le vÃ©rificateur :

```bash
# Sans optimisation : peut Ã©chouer
$ clang -target bpf -c program.bpf.c -o program.bpf.o

# Avec optimisation : plus de chances de passer
$ clang -O2 -target bpf -c program.bpf.c -o program.bpf.o
```

### 4. Utiliser BPF_CORE_READ

Pour la portabilitÃ© et la simplification :

```c
// âŒ Lecture directe (peut Ãªtre rejetÃ©e)
pid_t pid = task->pid;

// âœ… Via BPF_CORE_READ (helper safe)
pid_t pid = BPF_CORE_READ(task, pid);
```

### 5. Limiter la Profondeur d'Appels

```c
// âŒ Trop de niveaux d'inlining
static __always_inline int level1() {
    return level2();
}
static __always_inline int level2() {
    return level3();
}
// ... jusqu'Ã  level10

// âœ… Limiter Ã  3-4 niveaux max
```

### 6. Utiliser #pragma unroll

Pour les petites boucles :

```c
#pragma unroll
for (int i = 0; i < 8; i++) {
    // Le compilateur va dÃ©rouler la boucle
    // = pas de saut arriÃ¨re
}
```

### 7. Ã‰viter les Conditions Complexes

```c
// âŒ Difficile pour le vÃ©rificateur
if ((a > 0 && b < 10) || (c == 5 && d != 3)) {
    // ...
}

// âœ… SÃ©quencer les vÃ©rifications
bool cond1 = (a > 0 && b < 10);
bool cond2 = (c == 5 && d != 3);
if (cond1 || cond2) {
    // ...
}
```

---

## ğŸ¯ Le VÃ©rificateur et CO-RE

**CO-RE** (Compile Once - Run Everywhere) amÃ©liore grandement la portabilitÃ©, mais ajoute aussi de la complexitÃ© pour le vÃ©rificateur.

### Sans CO-RE (approche traditionnelle)

```c
// AccÃ¨s direct Ã  une structure kernel
struct task_struct *task = (void *)bpf_get_current_task();
pid_t pid = task->pid;  // Offset peut varier selon les versions !
```

**ProblÃ¨me** : L'offset de `pid` dans `task_struct` change selon les versions du noyau.

### Avec CO-RE

```c
#include <vmlinux.h>
#include <bpf/bpf_core_read.h>

struct task_struct *task = (void *)bpf_get_current_task();
pid_t pid = BPF_CORE_READ(task, pid);  // âœ“ Portable !
```

**BPF_CORE_READ** gÃ©nÃ¨re du code qui :
1. Utilise BTF (BPF Type Format) pour connaÃ®tre les offsets corrects
2. GÃ©nÃ¨re des relocations que libbpf rÃ©sout au chargement
3. Reste vÃ©rifiable par le vÃ©rificateur

---

## ğŸ“Š Impact du VÃ©rificateur sur les Performances

### Temps de VÃ©rification

Le vÃ©rificateur peut prendre du temps sur des programmes complexes :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ComplexitÃ© du programme               â”‚
â”‚                                        â”‚
â”‚  Simple (< 100 instructions)           â”‚
â”‚  VÃ©rification : < 1 ms                 â”‚
â”‚                                        â”‚
â”‚  Moyen (100-1000 instructions)         â”‚
â”‚  VÃ©rification : 1-10 ms                â”‚
â”‚                                        â”‚
â”‚  Complexe (1000-10000 instructions)    â”‚
â”‚  VÃ©rification : 10-100 ms              â”‚
â”‚                                        â”‚
â”‚  TrÃ¨s complexe (proche de la limite)   â”‚
â”‚  VÃ©rification : 100-1000 ms            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Optimisations du VÃ©rificateur

Le vÃ©rificateur s'amÃ©liore constamment :

| Version Linux | AmÃ©lioration |
|---------------|--------------|
| **5.3** | Boucles bornÃ©es acceptÃ©es |
| **5.10** | AmÃ©lioration tracking des registres |
| **5.13** | Support des fonctions (BPF2BPF calls) |
| **5.17** | VÃ©rificateur plus rapide (optimisations) |
| **6.0+** | Support amÃ©liorÃ© des structures complexes |

---

## ğŸ’¡ DÃ©bugger les Rejets du VÃ©rificateur

### 1. Activer les Logs Verbeux

```bash
# Avec bpftool
$ sudo bpftool prog load program.bpf.o /sys/fs/bpf/myprog \
    type xdp \
    verbose

# Avec libbpf (en code C)
libbpf_set_print(libbpf_print_fn);  // Activer les logs
```

### 2. Utiliser bpftool pour Inspecter

```bash
# Charger avec bpftool pour voir les logs dÃ©taillÃ©s
$ sudo bpftool prog load program.bpf.o /sys/fs/bpf/test type xdp

# Si Ã©chec, les logs du vÃ©rificateur s'affichent
```

### 3. Simplifier Progressivement

Si le vÃ©rificateur rejette, **commentez du code** jusqu'Ã  ce que Ã§a passe, puis ajoutez progressivement.

```c
SEC("xdp")
int my_program(struct xdp_md *ctx)
{
    // Commencer simple
    return XDP_PASS;  // âœ“ Passe

    // Ajouter progressivement
    // void *data = (void *)(long)ctx->data;
    // void *data_end = (void *)(long)ctx->data_end;
    // ...
}
```

### 4. Utiliser llvm-objdump

Voir le bytecode gÃ©nÃ©rÃ© :

```bash
$ llvm-objdump -S program.bpf.o

# Comprendre quelles instructions sont gÃ©nÃ©rÃ©es
```

---

## ğŸ“ RÃ©sumÃ©

Le **vÃ©rificateur eBPF** est le garant de la sÃ©curitÃ© :

**Ce qu'il garantit** :
- âœ… Terminaison (pas de boucles infinies)
- âœ… AccÃ¨s mÃ©moire sÃ»rs (pas de segfault)
- âœ… Pas de fuites d'informations kernel
- âœ… Taille raisonnable du programme
- âœ… Utilisation correcte des ressources

**Comment il fonctionne** :
1. **Analyse CFG** : Structure du programme
2. **Simulation symbolique** : Track l'Ã©tat des registres
3. **VÃ©rification exhaustive** : Tous les chemins possibles

**RÃ¨gles principales** :
- Pointeurs vÃ©rifiÃ©s avant usage
- Limites de tableaux/buffers respectÃ©es
- Boucles bornÃ©es
- Pile â‰¤ 512 bytes
- Seulement helpers et fonctions inline

**Erreurs courantes** :
- `map_value_or_null` â†’ VÃ©rifier les pointeurs
- `invalid access to packet` â†’ VÃ©rifier les limites
- `program too large` â†’ Simplifier ou tail calls
- `back-edge detected` â†’ Borner les boucles

**Techniques** :
- Compiler avec `-O2`
- Utiliser les helpers
- Simplifier la logique
- CO-RE pour la portabilitÃ©

---

## ğŸ¯ Prochaine Ã‰tape

Maintenant que vous comprenez comment le vÃ©rificateur garantit la sÃ©curitÃ©, explorons le **JIT compiler** qui transforme le bytecode eBPF en code machine ultra-rapide.

**ğŸ‘‰ Prochaine section : 21.2.4 JIT Compilation**

Le JIT compiler :
- Compile le bytecode en instructions natives (x86-64, ARM64, etc.)
- Performance Ã©quivalente au code C du noyau
- ActivÃ© par dÃ©faut sur la plupart des systÃ¨mes

**Ã€ bientÃ´t !** ğŸš€

---

## ğŸ“š RÃ©fÃ©rences

### Documentation Officielle
- [BPF Verifier Documentation](https://www.kernel.org/doc/html/latest/bpf/verifier.html)
- [BPF Design Q&A](https://www.kernel.org/doc/html/latest/bpf/bpf_design_QA.html)

### Articles Techniques
- [Understanding the BPF Verifier](https://pchaigno.github.io/bpf/2021/10/20/ebpf-verifier-overview.html)
- [A Deep Dive into eBPF Verifier](https://www.brendangregg.com/blog/2019-01-01/ebpf-verifier.html)

### Code Source
- [Kernel verifier.c](https://github.com/torvalds/linux/blob/master/kernel/bpf/verifier.c) - Code du vÃ©rificateur (complexe !)

### Outils
- [bpftool](https://github.com/libbpf/bpftool) - Pour dÃ©bugger les rejets
- [bpftrace](https://github.com/iovisor/bpftrace) - GÃ¨re automatiquement la vÃ©rification

â­ï¸ [JIT compilation](/21-introduction-ebpf/02.4-jit-compilation.md)
