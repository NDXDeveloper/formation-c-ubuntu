üîù Retour au [Sommaire](/SOMMAIRE.md)

# 32.5.2 Ajout de tests

## Introduction

Vous h√©ritez d'un projet C de 50 000 lignes. Z√©ro test. Aucun. Vous devez corriger un bug, mais vous avez peur :
- *"Si je change √ßa, est-ce que je vais casser autre chose ?"*
- *"Comment savoir si ma correction fonctionne vraiment ?"*
- *"Comment m'assurer que je ne r√©introduis pas le bug dans 6 mois ?"*

Sans tests, vous codez **√† l'aveugle**. Chaque modification est une roulette russe. Vous passez plus de temps √† d√©boguer qu'√† d√©velopper.

La solution ? **Ajouter des tests**. Mais comment tester du code qui n'a jamais √©t√© con√ßu pour √™tre test√© ?

Dans cette section, nous allons apprendre :
- Pourquoi les tests sont cruciaux pour le code legacy
- Les types de tests adapt√©s au legacy
- Les frameworks de test C (Unity, CUnit, Check)
- Comment rendre le code legacy testable
- La strat√©gie progressive d'ajout de tests
- Les patterns de test pour le code legacy

---

## Pourquoi ajouter des tests au code legacy ?

### Le probl√®me du code non test√©

**Code legacy sans tests** :

```
Changement n√©cessaire (bugfix, feature)
    ‚Üì
Modification du code
    ‚Üì
Compilation OK ?
    ‚Üì oui
Test manuel
    ‚Üì
√áa a l'air de marcher
    ‚Üì
Deploy en production
    ‚Üì
üí• Bug en production !
    ‚Üì
Rollback d'urgence
    ‚Üì
Investigation (heures/jours)
    ‚Üì
Correction
    ‚Üì
M√™me cycle...
```

**Code avec tests** :

```
Changement n√©cessaire
    ‚Üì
√âcrire un test qui √©choue (reproduit le bug)
    ‚Üì
Modifier le code
    ‚Üì
Tests automatis√©s
    ‚Üì tous passent
Deploy en production avec confiance
    ‚Üì
‚úÖ √áa marche
    ‚Üì
Le test emp√™chera la r√©gression
```

### Les b√©n√©fices concrets

#### 1. Filet de s√©curit√©

Les tests sont un **filet de s√©curit√©** qui vous permet de modifier le code sans peur :

```c
// Sans tests : peur de toucher
int legacy_function() {
    // 200 lignes de code spaghetti
    // "Je ne touche √† rien, √ßa marche"
}

// Avec tests : confiance pour refactoriser
int legacy_function() {
    // Tests me prot√®gent, je peux am√©liorer
}
```

#### 2. Documentation ex√©cutable

Les tests **documentent** le comportement du code :

```c
// Test = documentation vivante
void test_parse_handles_empty_string() {
    char *result = parse("");
    assert_string_equals("", result);
    free(result);
}
// Ce test documente : parse("") retourne une cha√Æne vide, pas NULL
```

C'est mieux que des commentaires qui deviennent obsol√®tes.

#### 3. D√©tection pr√©coce des bugs

Les tests d√©tectent les bugs **avant** la production :

```bash
# Sans tests
Developer ‚Üí Commit ‚Üí CI Build ‚Üí Deploy ‚Üí Production ‚Üí üí• Bug d√©couvert par users

# Avec tests
Developer ‚Üí Commit ‚Üí CI Build ‚Üí ‚ùå Tests fail ‚Üí Fix ‚Üí ‚úÖ Tests pass ‚Üí Deploy
```

#### 4. Facilite le refactoring

Avec des tests, vous pouvez refactoriser en toute confiance (voir section 32.5.1) :

```c
// Avant refactoring : tests passent
int old_messy_code() { ... }
test_old_messy_code(); // ‚úÖ Pass

// Apr√®s refactoring : tests passent toujours
int clean_refactored_code() { ... }
test_clean_refactored_code(); // ‚úÖ Pass

// M√™me comportement garanti
```

### Le d√©fi du code legacy

**Probl√®me** : Le code legacy n'a **pas √©t√© con√ßu** pour √™tre test√©.

Caract√©ristiques typiques :
- üö´ Couplage fort (d√©pendances partout)
- üö´ Fonctions g√©antes (impossible √† tester unitairement)
- üö´ √âtat global (variables globales)
- üö´ D√©pendances syst√®me (fichiers, r√©seau, base de donn√©es)
- üö´ Logique et I/O m√©lang√©es

**Exemple de code "intestable"** :

```c
// Impossible √† tester unitairement
int process_user_data() {
    // Lit depuis un fichier global
    FILE *f = fopen(GLOBAL_CONFIG_FILE, "r");

    // Utilise des variables globales
    global_buffer[0] = '\0';

    // Fait des appels syst√®me
    system("mkdir /tmp/data");

    // Acc√®de au r√©seau
    send_data_to_server(SERVER_URL);

    // √âcrit dans la base de donn√©es
    db_insert(GLOBAL_DB_CONNECTION, data);

    return 0;
}
```

Pour tester √ßa, il faut :
- Un fichier de config
- Un serveur r√©seau
- Une base de donn√©es
- Des permissions syst√®me

‚ùå Trop complexe pour un test unitaire !

---

## Types de tests pour le code legacy

### 1. Tests de caract√©risation

**Objectif** : Documenter le comportement **actuel** (m√™me s'il est bugg√©).

**Principe** : On capture ce que le code fait **maintenant**, pas ce qu'il devrait faire.

```c
// test_characterization.c
// Ces tests documentent le comportement actuel du code legacy

void test_current_behavior_empty_input() {
    // Ce que le code fait actuellement (m√™me si c'est un bug)
    int result = legacy_parse("");

    // On documente : actuellement √ßa retourne -1
    // (on pourrait penser que √ßa devrait retourner 0, mais ce n'est pas le cas)
    assert_int_equals(-1, result);
}

void test_current_behavior_null_input() {
    // Actuellement √ßa crash (segfault)
    // On ne peut pas tester √ßa facilement, on documente juste
    // KNOWN ISSUE: legacy_parse(NULL) causes segfault
}

void test_current_behavior_normal_input() {
    int result = legacy_parse("test,data");
    assert_int_equals(2, result);  // Comportement actuel
}
```

**Utilit√©** :
- Prot√®ge contre les r√©gressions
- Documente le comportement r√©el
- Base pour le refactoring

**Workflow** :
```
1. √âcrire des tests de caract√©risation (comportement actuel)
2. Refactoriser le code
3. Tests passent toujours ‚Üí comportement pr√©serv√©
4. Corriger les bugs (modifier les tests en cons√©quence)
```

### 2. Tests unitaires

**Objectif** : Tester une fonction **isol√©ment**.

**Principe** : Une fonction, un test, pas de d√©pendances externes.

```c
// test_unit.c

// Fonction pure : facile √† tester
int add(int a, int b) {
    return a + b;
}

void test_add_positive_numbers() {
    assert_int_equals(5, add(2, 3));
}

void test_add_negative_numbers() {
    assert_int_equals(-5, add(-2, -3));
}

void test_add_zero() {
    assert_int_equals(5, add(5, 0));
    assert_int_equals(5, add(0, 5));
}
```

**D√©fis avec le code legacy** :
- Fonctions trop grosses
- D√©pendances externes
- √âtat global

‚Üí Il faut refactoriser pour rendre testable (voir plus loin).

### 3. Tests d'int√©gration

**Objectif** : Tester plusieurs composants ensemble.

**Principe** : V√©rifier que les modules interagissent correctement.

```c
// test_integration.c

void test_parser_and_validator_integration() {
    // Parse puis valide
    data_t *data = parse_input("test,data,123");
    assert_not_null(data);

    int valid = validate_data(data);
    assert_true(valid);

    free_data(data);
}
```

**Pour le legacy** :
- Plus faciles √† √©crire que les tests unitaires
- Testent le syst√®me "tel qu'il est"
- Mais plus lents et plus fragiles

### 4. Tests de non-r√©gression

**Objectif** : Emp√™cher le retour de bugs d√©j√† corrig√©s.

**Principe** : Un bug = un test.

```c
// test_regression.c

void test_bug_123_buffer_overflow() {
    // Bug #123 : buffer overflow avec strings > 256 chars
    char large_input[300];
    memset(large_input, 'a', 299);
    large_input[299] = '\0';

    // Avant le fix, √ßa crashait
    // Apr√®s le fix, √ßa doit retourner une erreur proprement
    int result = parse(large_input);
    assert_int_equals(-1, result);
    assert_int_equals(EINVAL, errno);
}

void test_bug_456_null_pointer() {
    // Bug #456 : crash sur NULL
    // Maintenant doit retourner -1 sans crasher
    int result = parse(NULL);
    assert_int_equals(-1, result);
}
```

**R√®gle d'or** : Chaque bug fix√© doit avoir un test qui l'emp√™chera de revenir.

---

## Frameworks de test C

### Comparaison des frameworks populaires

| Framework | Complexit√© | D√©pendances | Mocking | Popularit√© |
|-----------|------------|-------------|---------|------------|
| **Unity** | Faible | Aucune | Non (externe) | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |
| **Check** | Moyenne | libcheck | Non | ‚≠ê‚≠ê‚≠ê‚≠ê |
| **CUnit** | Moyenne | libcunit | Non | ‚≠ê‚≠ê‚≠ê |
| **cmocka** | Moyenne | libcmocka | Oui | ‚≠ê‚≠ê‚≠ê‚≠ê |
| **assert.h** | Tr√®s faible | Standard C | Non | ‚≠ê‚≠ê |

**Recommandation pour d√©butants** : **Unity** (simple, portable, z√©ro d√©pendance).

### Unity : Le framework minimaliste

**Installation** :

```bash
# Cloner Unity
git clone https://github.com/ThrowTheSwitch/Unity.git libs/unity

# Ou t√©l√©charger juste unity.c et unity.h
wget https://raw.githubusercontent.com/ThrowTheSwitch/Unity/master/src/unity.c
wget https://raw.githubusercontent.com/ThrowTheSwitch/Unity/master/src/unity.h
```

**Structure de test Unity** :

```c
// test_example.c
#include "unity.h"
#include "my_module.h"

// Setup : appel√© avant chaque test
void setUp(void) {
    // Initialisation
}

// Teardown : appel√© apr√®s chaque test
void tearDown(void) {
    // Nettoyage
}

// Test 1
void test_add_function_positive_numbers(void) {
    TEST_ASSERT_EQUAL_INT(5, add(2, 3));
}

// Test 2
void test_add_function_zero(void) {
    TEST_ASSERT_EQUAL_INT(7, add(7, 0));
}

// Main
int main(void) {
    UNITY_BEGIN();
    RUN_TEST(test_add_function_positive_numbers);
    RUN_TEST(test_add_function_zero);
    return UNITY_END();
}
```

**Assertions Unity** :

```c
// √âgalit√©
TEST_ASSERT_EQUAL_INT(expected, actual);
TEST_ASSERT_EQUAL_UINT(expected, actual);
TEST_ASSERT_EQUAL_HEX32(expected, actual);

// Floats
TEST_ASSERT_EQUAL_FLOAT(expected, actual);
TEST_ASSERT_FLOAT_WITHIN(delta, expected, actual);

// Pointeurs
TEST_ASSERT_NULL(pointer);
TEST_ASSERT_NOT_NULL(pointer);
TEST_ASSERT_EQUAL_PTR(expected, actual);

// Cha√Ænes
TEST_ASSERT_EQUAL_STRING(expected, actual);
TEST_ASSERT_EQUAL_MEMORY(expected, actual, length);

// Bool√©ens
TEST_ASSERT_TRUE(condition);
TEST_ASSERT_FALSE(condition);

// Arrays
TEST_ASSERT_EQUAL_INT_ARRAY(expected, actual, length);
```

**Compilation** :

```bash
# Compiler le test
gcc -I libs/unity/src \
    test_example.c \
    my_module.c \
    libs/unity/src/unity.c \
    -o test_example

# Ex√©cuter
./test_example
```

**R√©sultat** :

```
test_example.c:12:test_add_function_positive_numbers:PASS
test_example.c:16:test_add_function_zero:PASS

-----------------------
2 Tests 0 Failures 0 Ignored
OK
```

### Check : Framework avec forking

**Avantage** : Isole chaque test dans un processus s√©par√© (segfault dans un test n'arr√™te pas les autres).

```c
// test_check.c
#include <check.h>
#include "my_module.h"

START_TEST(test_add) {
    ck_assert_int_eq(5, add(2, 3));
}
END_TEST

START_TEST(test_crash) {
    // Ce test va crasher mais n'arr√™tera pas les autres
    int *p = NULL;
    *p = 42;  // Segfault isol√©
}
END_TEST

Suite* make_suite(void) {
    Suite *s = suite_create("My Module");
    TCase *tc = tcase_create("Core");

    tcase_add_test(tc, test_add);
    tcase_add_test(tc, test_crash);
    suite_add_tcase(s, tc);

    return s;
}

int main(void) {
    Suite *s = make_suite();
    SRunner *sr = srunner_create(s);

    srunner_run_all(sr, CK_NORMAL);
    int failed = srunner_ntests_failed(sr);
    srunner_free(sr);

    return (failed == 0) ? 0 : 1;
}
```

**Installation** :

```bash
# Ubuntu/Debian
sudo apt install check

# Compilation
gcc test_check.c my_module.c -lcheck -o test_check
./test_check
```

### cmocka : Avec mocking int√©gr√©

**Avantage** : Support du mocking pour isoler les d√©pendances.

```c
// test_cmocka.c
#include <stdarg.h>
#include <stddef.h>
#include <setjmp.h>
#include <cmocka.h>

// Mock d'une fonction
int __wrap_read_from_file(const char *filename) {
    check_expected(filename);
    return (int)mock();
}

static void test_parse_with_mocked_file(void **state) {
    // Setup mock
    expect_string(__wrap_read_from_file, filename, "config.txt");
    will_return(__wrap_read_from_file, 42);

    // Test
    int result = parse_config();

    // V√©rification
    assert_int_equal(42, result);
}

int main(void) {
    const struct CMUnitTest tests[] = {
        cmocka_unit_test(test_parse_with_mocked_file),
    };
    return cmocka_run_group_tests(tests, NULL, NULL);
}
```

**Compilation avec mocking** :

```bash
gcc test_cmocka.c my_module.c -lcmocka \
    -Wl,--wrap=read_from_file \
    -o test_cmocka
```

---

## Rendre le code legacy testable

### Probl√®me : D√©pendances hardcod√©es

**Code intestable** :

```c
// Impossible √† tester : d√©pendance hardcod√©e
int process_data() {
    FILE *f = fopen("/etc/myapp/config.txt", "r");
    if (f == NULL) return -1;

    // Lit depuis le fichier r√©el
    char buffer[256];
    fgets(buffer, sizeof(buffer), f);
    fclose(f);

    return parse(buffer);
}
```

### Solution 1 : Injection de d√©pendances

**Principe** : Passer les d√©pendances en param√®tres.

```c
// Testable : d√©pendance inject√©e
int process_data_from_file(FILE *f) {
    if (f == NULL) return -1;

    char buffer[256];
    fgets(buffer, sizeof(buffer), f);

    return parse(buffer);
}

// Fonction wrapper pour production
int process_data() {
    FILE *f = fopen("/etc/myapp/config.txt", "r");
    int result = process_data_from_file(f);
    if (f) fclose(f);
    return result;
}

// Test : inject mock file
void test_process_data() {
    // Cr√©er un fichier temporaire pour le test
    FILE *test_file = tmpfile();
    fprintf(test_file, "test data\n");
    rewind(test_file);

    int result = process_data_from_file(test_file);

    assert_int_equals(0, result);
    fclose(test_file);
}
```

### Solution 2 : Abstraire les d√©pendances

**Principe** : Utiliser des pointeurs de fonctions.

```c
// file_io.h - Abstraction
typedef struct {
    FILE* (*open)(const char *path, const char *mode);
    int (*close)(FILE *f);
    char* (*read_line)(char *buf, int size, FILE *f);
} file_ops_t;

// Production : vraies fonctions
file_ops_t real_file_ops = {
    .open = fopen,
    .close = fclose,
    .read_line = fgets
};

// Code testable
int process_data_with_ops(const char *path, file_ops_t *ops) {
    FILE *f = ops->open(path, "r");
    if (f == NULL) return -1;

    char buffer[256];
    ops->read_line(buffer, sizeof(buffer), f);
    ops->close(f);

    return parse(buffer);
}

// Test : mock file ops
FILE* mock_open(const char *path, const char *mode) {
    // Retourner un FILE* de test
    return tmpfile();
}

char* mock_read_line(char *buf, int size, FILE *f) {
    strcpy(buf, "mock data");
    return buf;
}

void test_process_data_with_mock() {
    file_ops_t mock_ops = {
        .open = mock_open,
        .close = fclose,
        .read_line = mock_read_line
    };

    int result = process_data_with_ops("dummy.txt", &mock_ops);
    assert_int_equals(0, result);
}
```

### Solution 3 : Seam (couture)

**Principe** : Cr√©er des points d'injection dans le code existant.

```c
// my_module.c
#ifndef TESTING
    // Production : vraie fonction
    #define FILE_OPEN fopen
    #define FILE_CLOSE fclose
#else
    // Test : fonctions mockables
    extern FILE* (*FILE_OPEN)(const char*, const char*);
    extern int (*FILE_CLOSE)(FILE*);
#endif

int process_data() {
    FILE *f = FILE_OPEN("/etc/myapp/config.txt", "r");
    // ...
    FILE_CLOSE(f);
}
```

```c
// test_my_module.c
#define TESTING
#include "my_module.c"

// Mocks
FILE* mock_fopen(const char *path, const char *mode) {
    return tmpfile();
}

int mock_fclose(FILE *f) {
    return fclose(f);
}

// Inject mocks
FILE* (*FILE_OPEN)(const char*, const char*) = mock_fopen;
int (*FILE_CLOSE)(FILE*) = mock_fclose;

void test_process_data() {
    int result = process_data();
    assert_int_equals(0, result);
}
```

### Solution 4 : Extraire et surcharger

**Principe** : Extraire la logique testable.

```c
// Avant : logique et I/O m√©lang√©es
int process_user() {
    // Lit depuis fichier
    FILE *f = fopen("user.dat", "r");
    char name[50];
    fgets(name, 50, f);
    fclose(f);

    // Logique m√©tier
    if (strlen(name) < 3) return -1;
    if (name[0] < 'A' || name[0] > 'Z') return -1;

    // √âcrit dans fichier
    FILE *out = fopen("output.dat", "w");
    fprintf(out, "Valid: %s", name);
    fclose(out);

    return 0;
}

// Apr√®s : logique extraite et testable
int validate_name(const char *name) {
    // Logique pure, facile √† tester
    if (name == NULL) return -1;
    if (strlen(name) < 3) return -1;
    if (name[0] < 'A' || name[0] > 'Z') return -1;
    return 0;
}

int process_user() {
    // I/O
    FILE *f = fopen("user.dat", "r");
    char name[50];
    fgets(name, 50, f);
    fclose(f);

    // Appel logique testable
    if (validate_name(name) < 0) return -1;

    // I/O
    FILE *out = fopen("output.dat", "w");
    fprintf(out, "Valid: %s", name);
    fclose(out);

    return 0;
}

// Test : seulement la logique
void test_validate_name() {
    assert_int_equals(0, validate_name("Alice"));
    assert_int_equals(-1, validate_name("al"));  // Trop court
    assert_int_equals(-1, validate_name("alice"));  // Minuscule
}
```

---

## Strat√©gie progressive d'ajout de tests

### Phase 1 : Tests de fum√©e (Smoke tests)

**Objectif** : V√©rifier que le syst√®me d√©marre et fonctionne basiquement.

```c
// test_smoke.c
void test_program_starts() {
    // Le programme se lance sans crasher
    int ret = system("./my_program --version");
    TEST_ASSERT_EQUAL_INT(0, ret);
}

void test_basic_functionality() {
    // Fonctionnalit√© de base fonctionne
    int ret = system("./my_program test.txt > output.txt");
    TEST_ASSERT_EQUAL_INT(0, ret);

    // V√©rifie que la sortie existe
    FILE *f = fopen("output.txt", "r");
    TEST_ASSERT_NOT_NULL(f);
    fclose(f);
}
```

**Effort** : Tr√®s faible
**Valeur** : D√©tecte les crashes majeurs

### Phase 2 : Tests de caract√©risation

**Objectif** : Documenter le comportement actuel.

```c
// test_characterization.c
void test_current_parse_behavior() {
    // Ces tests documentent ce que le code fait ACTUELLEMENT

    // Cas 1 : Input normal
    int result = parse("a,b,c");
    TEST_ASSERT_EQUAL_INT(3, result);

    // Cas 2 : Input vide
    result = parse("");
    TEST_ASSERT_EQUAL_INT(-1, result);  // Comportement actuel

    // Cas 3 : Un seul √©l√©ment
    result = parse("single");
    TEST_ASSERT_EQUAL_INT(1, result);
}
```

**Effort** : Faible
**Valeur** : Protection contre r√©gressions

### Phase 3 : Tests de non-r√©gression

**Objectif** : Emp√™cher le retour de bugs connus.

```c
// test_regression.c
void test_bug_42_overflow() {
    // Bug #42 corrig√© le 2025-01-15
    // Buffer overflow avec input > 256 chars

    char large[300];
    memset(large, 'x', 299);
    large[299] = '\0';

    // Avant : crash
    // Apr√®s : erreur propre
    int result = parse(large);
    TEST_ASSERT_EQUAL_INT(-1, result);
}
```

**Effort** : Faible (un test par bug)
**Valeur** : √âvite de re-introduire les bugs

### Phase 4 : Tests unitaires des fonctions critiques

**Objectif** : Tester les fonctions importantes isol√©ment.

**Strat√©gie** : Commencer par les fonctions :
1. Les plus utilis√©es
2. Les plus modifi√©es r√©cemment
3. Les plus buggu√©es historiquement
4. Les plus critiques (s√©curit√©, donn√©es)

```c
// test_critical.c
void test_crypto_hash_function() {
    // Fonction critique : hashing de mots de passe
    char *hash = compute_hash("password123");
    TEST_ASSERT_NOT_NULL(hash);
    TEST_ASSERT_EQUAL_STRING("5f4dcc3b5aa765d61d8327deb882cf99", hash);
    free(hash);
}

void test_payment_calculation() {
    // Fonction critique : calcul de paiement
    double amount = calculate_payment(100.0, 0.20);  // 20% tax
    TEST_ASSERT_FLOAT_WITHIN(0.01, 120.0, amount);
}
```

**Effort** : Moyen √† √©lev√©
**Valeur** : Haute (prot√®ge les parties critiques)

### Phase 5 : Tests d'int√©gration

**Objectif** : Tester les interactions entre modules.

```c
// test_integration.c
void test_full_pipeline() {
    // Input ‚Üí Parse ‚Üí Validate ‚Üí Process ‚Üí Output

    // Setup
    create_test_input_file("test_input.txt", "test data");

    // Execute full pipeline
    int result = run_full_pipeline("test_input.txt", "test_output.txt");
    TEST_ASSERT_EQUAL_INT(0, result);

    // Verify output
    char *output = read_file("test_output.txt");
    TEST_ASSERT_EQUAL_STRING("processed: test data\n", output);

    // Cleanup
    free(output);
    remove("test_input.txt");
    remove("test_output.txt");
}
```

**Effort** : √âlev√©
**Valeur** : Teste le syst√®me r√©el

---

## Patterns de test pour le code legacy

### Pattern 1 : Golden Master (Test de r√©f√©rence)

**Principe** : Capturer la sortie actuelle comme r√©f√©rence, puis v√©rifier qu'elle ne change pas.

```c
// test_golden_master.c

// 1. G√©n√©rer le golden master (une fois)
void generate_golden_master() {
    // Ex√©cuter le programme avec input connu
    system("./legacy_program < test_input.txt > golden_output.txt");
    // Commiter golden_output.txt dans Git
}

// 2. Test : comparer √† la r√©f√©rence
void test_output_matches_golden_master() {
    // Ex√©cuter programme
    system("./legacy_program < test_input.txt > actual_output.txt");

    // Comparer avec golden master
    FILE *golden = fopen("golden_output.txt", "r");
    FILE *actual = fopen("actual_output.txt", "r");

    char golden_line[256], actual_line[256];
    int line = 1;

    while (fgets(golden_line, 256, golden) && fgets(actual_line, 256, actual)) {
        if (strcmp(golden_line, actual_line) != 0) {
            printf("Difference at line %d\n", line);
            printf("Expected: %s", golden_line);
            printf("Actual:   %s", actual_line);
            TEST_FAIL();
        }
        line++;
    }

    fclose(golden);
    fclose(actual);
}
```

**Utilit√©** : Id√©al pour du code complexe dont on ne comprend pas tout le comportement.

### Pattern 2 : Test Harness (Harnais de test)

**Principe** : Cr√©er une infrastructure pour faciliter les tests.

```c
// test_harness.h
typedef struct {
    char *temp_dir;
    FILE *mock_stdin;
    FILE *mock_stdout;
    FILE *mock_stderr;
} test_harness_t;

test_harness_t* setup_test_harness() {
    test_harness_t *harness = malloc(sizeof(test_harness_t));

    // Cr√©er r√©pertoire temporaire
    harness->temp_dir = mkdtemp(strdup("/tmp/test_XXXXXX"));

    // Rediriger stdin/stdout/stderr
    harness->mock_stdin = tmpfile();
    harness->mock_stdout = tmpfile();
    harness->mock_stderr = tmpfile();

    return harness;
}

void teardown_test_harness(test_harness_t *harness) {
    // Nettoyer
    system("rm -rf harness->temp_dir");
    fclose(harness->mock_stdin);
    fclose(harness->mock_stdout);
    fclose(harness->mock_stderr);
    free(harness);
}

// Utilisation
void test_with_harness() {
    test_harness_t *harness = setup_test_harness();

    // Test avec infrastructure propre
    // ...

    teardown_test_harness(harness);
}
```

### Pattern 3 : Spy (Espion)

**Principe** : Enregistrer les appels pour v√©rification ult√©rieure.

```c
// Fonction de production
void log_message(const char *msg);

// Spy pour tests
static int spy_log_call_count = 0;
static char spy_last_message[256];

void spy_log_message(const char *msg) {
    spy_log_call_count++;
    strncpy(spy_last_message, msg, 255);
}

// Test
void test_error_handling_logs_message() {
    // Reset spy
    spy_log_call_count = 0;

    // Inject spy
    #define log_message spy_log_message

    // Action qui devrait logger
    int result = parse_invalid_data();

    // V√©rifications
    TEST_ASSERT_EQUAL_INT(1, spy_log_call_count);
    TEST_ASSERT_EQUAL_STRING("Parse error", spy_last_message);
}
```

### Pattern 4 : Fake (Faux objet)

**Principe** : Remplacer une d√©pendance par une version simplifi√©e.

```c
// Production : vraie DB
typedef struct {
    void (*connect)(const char *host);
    int (*query)(const char *sql);
    void (*disconnect)();
} database_t;

database_t* real_database;

// Test : fake DB (en m√©moire)
static int fake_db_data[100];
static int fake_db_count = 0;

int fake_query(const char *sql) {
    // Simuler une requ√™te simple
    if (strstr(sql, "SELECT COUNT")) {
        return fake_db_count;
    }
    return 0;
}

void fake_connect(const char *host) {
    // Ne fait rien
}

void fake_disconnect() {
    // Ne fait rien
}

database_t fake_database = {
    .connect = fake_connect,
    .query = fake_query,
    .disconnect = fake_disconnect
};

// Test
void test_with_fake_database() {
    // Setup fake data
    fake_db_count = 42;

    // Inject fake
    database_t *old_db = real_database;
    real_database = &fake_database;

    // Test
    int count = get_user_count();
    TEST_ASSERT_EQUAL_INT(42, count);

    // Restore
    real_database = old_db;
}
```

---

## Organisation des tests

### Structure de projet recommand√©e

```
projet/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.c
‚îÇ   ‚îú‚îÄ‚îÄ parser.c
‚îÇ   ‚îú‚îÄ‚îÄ parser.h
‚îÇ   ‚îú‚îÄ‚îÄ validator.c
‚îÇ   ‚îî‚îÄ‚îÄ validator.h
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ unity/           # Framework Unity
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ unity.c
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ unity.h
‚îÇ   ‚îú‚îÄ‚îÄ test_parser.c    # Tests du parser
‚îÇ   ‚îú‚îÄ‚îÄ test_validator.c # Tests du validator
‚îÇ   ‚îú‚îÄ‚îÄ test_integration.c
‚îÇ   ‚îú‚îÄ‚îÄ test_runner.c    # Lance tous les tests
‚îÇ   ‚îî‚îÄ‚îÄ Makefile         # Build des tests
‚îú‚îÄ‚îÄ Makefile
‚îî‚îÄ‚îÄ CMakeLists.txt
```

### Makefile pour les tests

```makefile
# Makefile pour les tests

CC = gcc
CFLAGS = -Wall -Wextra -g -I../src -Iunity
LDFLAGS =

# Sources
SRC_DIR = ../src
TEST_DIR = .
UNITY_DIR = unity

# Fichiers
SRC_FILES = $(SRC_DIR)/parser.c $(SRC_DIR)/validator.c
TEST_FILES = test_parser.c test_validator.c test_integration.c
UNITY_FILES = $(UNITY_DIR)/unity.c

# Cibles
TESTS = test_parser test_validator test_integration

all: $(TESTS) run_all

test_parser: test_parser.c $(SRC_DIR)/parser.c $(UNITY_FILES)
	$(CC) $(CFLAGS) $^ -o $@ $(LDFLAGS)

test_validator: test_validator.c $(SRC_DIR)/validator.c $(UNITY_FILES)
	$(CC) $(CFLAGS) $^ -o $@ $(LDFLAGS)

test_integration: test_integration.c $(SRC_FILES) $(UNITY_FILES)
	$(CC) $(CFLAGS) $^ -o $@ $(LDFLAGS)

run_all: $(TESTS)
	@echo "Running all tests..."
	@./test_parser
	@./test_validator
	@./test_integration
	@echo "All tests completed!"

clean:
	rm -f $(TESTS) *.o

.PHONY: all run_all clean
```

### Test runner

```c
// test_runner.c
#include "unity.h"

// D√©clarations des tests
extern void test_parser_suite(void);
extern void test_validator_suite(void);

int main(void) {
    UNITY_BEGIN();

    // Ex√©cuter toutes les suites
    test_parser_suite();
    test_validator_suite();

    return UNITY_END();
}
```

---

## Int√©gration dans le CI/CD

### GitHub Actions

```yaml
# .github/workflows/tests.yml
name: Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Install dependencies
        run: sudo apt-get install -y check valgrind

      - name: Build tests
        run: |
          cd tests
          make all

      - name: Run tests
        run: |
          cd tests
          make run_all

      - name: Run with Valgrind
        run: |
          cd tests
          valgrind --leak-check=full --error-exitcode=1 ./test_parser
          valgrind --leak-check=full --error-exitcode=1 ./test_validator

      - name: Generate coverage
        run: |
          cd tests
          make coverage

      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./tests/coverage.info
```

### Makefile avec coverage

```makefile
# Ajouter au Makefile des tests

# Flags pour coverage
COVERAGE_CFLAGS = -fprofile-arcs -ftest-coverage
COVERAGE_LDFLAGS = -lgcov --coverage

test_parser_cov: test_parser.c $(SRC_DIR)/parser.c $(UNITY_FILES)
	$(CC) $(CFLAGS) $(COVERAGE_CFLAGS) $^ -o $@ $(LDFLAGS) $(COVERAGE_LDFLAGS)

coverage: test_parser_cov
	./test_parser_cov
	gcov parser.c
	lcov --capture --directory . --output-file coverage.info
	genhtml coverage.info --output-directory coverage_html
	@echo "Coverage report generated in coverage_html/index.html"
```

---

## Bonnes pratiques

### 1. Tests ind√©pendants

Chaque test doit pouvoir s'ex√©cuter seul :

```c
// ‚úÖ BON : Tests ind√©pendants
void test_parse_normal() {
    char *input = strdup("test");
    int result = parse(input);
    free(input);
    TEST_ASSERT_EQUAL_INT(0, result);
}

void test_parse_empty() {
    char *input = strdup("");
    int result = parse(input);
    free(input);
    TEST_ASSERT_EQUAL_INT(-1, result);
}

// ‚ùå MAUVAIS : Tests d√©pendants
static char *shared_buffer = NULL;

void test_parse_normal() {
    shared_buffer = strdup("test");
    int result = parse(shared_buffer);
    TEST_ASSERT_EQUAL_INT(0, result);
    // Oubli de free !
}

void test_parse_empty() {
    // Utilise shared_buffer de test pr√©c√©dent
    // Probl√®me si test_parse_normal n'a pas √©t√© ex√©cut√© avant !
    int result = parse(shared_buffer);
    free(shared_buffer);
    TEST_ASSERT_EQUAL_INT(-1, result);
}
```

### 2. Tests rapides

Les tests doivent s'ex√©cuter rapidement :

```c
// ‚úÖ BON : Test rapide (<1ms)
void test_add() {
    TEST_ASSERT_EQUAL_INT(5, add(2, 3));
}

// ‚ùå MAUVAIS : Test lent (>1s)
void test_slow() {
    sleep(5);  // Attente inutile
    // Test r√©seau r√©el
    int result = query_real_database("SELECT...");
    TEST_ASSERT_EQUAL_INT(42, result);
}
```

**Objectif** : Suite compl√®te en <10 secondes pour encourager l'ex√©cution fr√©quente.

### 3. Tests lisibles

Un test est de la documentation :

```c
// ‚ùå MAUVAIS : Test cryptique
void test_1() {
    int r = f("a", 1, 3);
    TEST_ASSERT_EQUAL_INT(4, r);
}

// ‚úÖ BON : Test auto-document√©
void test_calculate_total_price_with_tax() {
    double base_price = 100.0;
    double tax_rate = 0.20;  // 20%

    double total = calculate_total_price(base_price, tax_rate);

    double expected_total = 120.0;  // 100 + 20% tax
    TEST_ASSERT_FLOAT_WITHIN(0.01, expected_total, total);
}
```

### 4. Un concept par test

```c
// ‚ùå MAUVAIS : Teste trop de choses
void test_everything() {
    TEST_ASSERT_EQUAL_INT(5, add(2, 3));
    TEST_ASSERT_EQUAL_INT(-1, add(-2, 1));
    TEST_ASSERT_EQUAL_INT(0, add(0, 0));
    TEST_ASSERT_NULL(parse(NULL));
    TEST_ASSERT_EQUAL_STRING("test", format("test"));
}

// ‚úÖ BON : Un concept = un test
void test_add_positive_numbers() {
    TEST_ASSERT_EQUAL_INT(5, add(2, 3));
}

void test_add_negative_numbers() {
    TEST_ASSERT_EQUAL_INT(-1, add(-2, 1));
}

void test_add_zero() {
    TEST_ASSERT_EQUAL_INT(0, add(0, 0));
}
```

### 5. Arrange-Act-Assert (AAA)

Structure claire en 3 parties :

```c
void test_parse_csv_line() {
    // Arrange (Setup)
    const char *input = "John,Doe,30";
    person_t expected = {
        .first_name = "John",
        .last_name = "Doe",
        .age = 30
    };

    // Act (Execute)
    person_t *result = parse_csv_line(input);

    // Assert (Verify)
    TEST_ASSERT_NOT_NULL(result);
    TEST_ASSERT_EQUAL_STRING(expected.first_name, result->first_name);
    TEST_ASSERT_EQUAL_STRING(expected.last_name, result->last_name);
    TEST_ASSERT_EQUAL_INT(expected.age, result->age);

    // Cleanup
    free_person(result);
}
```

---

## Mesurer la couverture des tests

### Avec gcov/lcov

```bash
# 1. Compiler avec flags de coverage
gcc -fprofile-arcs -ftest-coverage \
    test_parser.c parser.c unity.c \
    -o test_parser

# 2. Ex√©cuter les tests
./test_parser

# 3. G√©n√©rer rapport
gcov parser.c

# 4. Rapport HTML avec lcov
lcov --capture --directory . --output-file coverage.info
genhtml coverage.info --output-directory coverage_html

# 5. Ouvrir rapport
xdg-open coverage_html/index.html
```

### Interpr√©ter la couverture

```
File 'parser.c'
Lines executed: 85.7% of 70
Branches executed: 80.0% of 25
```

**Lignes non couvertes** :
```c
45: if (input == NULL) return -1;    // ‚úÖ Couvert
46:     errno = EINVAL;              // ‚ùå Non couvert
```

**Action** : Ajouter un test qui passe `NULL` et v√©rifie `errno`.

**Objectifs r√©alistes** :
- 60% : Minimum acceptable
- 80% : Bon
- 90%+ : Excellent (mais attention au co√ªt)
- 100% : Rarement justifi√© (co√ªt/b√©n√©fice)

---

## Conclusion

Ajouter des tests √† du code legacy est un **investissement** qui paie rapidement :

- ‚úÖ **Confiance** : Modifier le code sans peur
- ‚úÖ **Qualit√©** : D√©tecter les bugs t√¥t
- ‚úÖ **Documentation** : Tests = sp√©cifications ex√©cutables
- ‚úÖ **Refactoring** : Filet de s√©curit√© pour am√©liorer le code
- ‚úÖ **V√©locit√©** : D√©veloppement plus rapide √† long terme

**Strat√©gie recommand√©e** :

1. **Semaine 1** : Tests de fum√©e et caract√©risation (quick wins)
2. **Semaine 2-3** : Tests de non-r√©gression (bugs connus)
3. **Mois 2** : Tests unitaires des fonctions critiques
4. **Mois 3+** : Augmenter progressivement la couverture

**Citation de Michael Feathers** (auteur de "Working Effectively with Legacy Code") :

> *"Code without tests is bad code. It doesn't matter how well written it is; it doesn't matter how pretty or object-oriented or well-encapsulated it is. With tests, we can change the behavior of our code quickly and verifiably. Without them, we really don't know if our code is getting better or worse."*

N'attendez pas le projet parfait pour commencer √† tester. Commencez maintenant, un test √† la fois.

---

**Section suivante** : 32.5.3 Modernisation - Nous verrons comment moderniser progressivement du code legacy vers les standards C modernes (C11, C17, C23).

‚è≠Ô∏è [Modernisation](/32-documentation-maintenance/05.3-modernisation.md)
