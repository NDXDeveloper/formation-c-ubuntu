ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 13.1.7 Out-of-source builds

## Introduction

Imaginez que vous travailliez dans un atelier de menuiserie. Vous avez vos plans (code source) d'un cÃ´tÃ©, et vous crÃ©ez vos piÃ¨ces (fichiers compilÃ©s) de l'autre cÃ´tÃ©. Vous ne voulez surtout pas mÃ©langer sciure et copeaux avec vos plans originaux, sinon c'est le chaos !

C'est exactement le principe des **out-of-source builds** : sÃ©parer proprement le code source (vos plans) des fichiers de compilation (la sciure). Cette pratique, bien que simple, est **fondamentale** pour un workflow CMake professionnel.

---

## In-source builds vs Out-of-source builds

### In-source builds (âŒ Ã€ Ã©viter)

Un **in-source build** compile directement dans le rÃ©pertoire du code source :

```bash
cd mon_projet
cmake .                # âŒ Build dans le rÃ©pertoire source
make
```

**RÃ©sultat** : Les fichiers gÃ©nÃ©rÃ©s polluent le rÃ©pertoire source

```
mon_projet/
â”œâ”€â”€ CMakeLists.txt
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.c
â”‚   â””â”€â”€ utils.c
â”œâ”€â”€ CMakeCache.txt        # âš ï¸ Fichier gÃ©nÃ©rÃ©
â”œâ”€â”€ CMakeFiles/           # âš ï¸ RÃ©pertoire gÃ©nÃ©rÃ©
â”œâ”€â”€ Makefile              # âš ï¸ Fichier gÃ©nÃ©rÃ©
â”œâ”€â”€ cmake_install.cmake   # âš ï¸ Fichier gÃ©nÃ©rÃ©
â”œâ”€â”€ main.o                # âš ï¸ Fichier compilÃ©
â”œâ”€â”€ utils.o               # âš ï¸ Fichier compilÃ©
â””â”€â”€ mon_app               # âš ï¸ ExÃ©cutable
```

**ProblÃ¨mes** :
- âŒ MÃ©lange code source et fichiers gÃ©nÃ©rÃ©s
- âŒ Difficile de nettoyer (quels fichiers supprimer ?)
- âŒ Impossible d'avoir plusieurs configurations (Debug/Release)
- âŒ Git devient compliquÃ© (il faut ignorer des dizaines de patterns)
- âŒ Risque d'effacer accidentellement des sources

### Out-of-source builds (âœ… RecommandÃ©)

Un **out-of-source build** compile dans un rÃ©pertoire sÃ©parÃ© :

```bash
cd mon_projet
cmake -B build            # âœ… Build dans un rÃ©pertoire sÃ©parÃ©
cmake --build build
```

**RÃ©sultat** : Le code source reste propre

```
mon_projet/
â”œâ”€â”€ CMakeLists.txt       # âœ… Code source propre
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.c
â”‚   â””â”€â”€ utils.c
â””â”€â”€ build/               # âœ… Tout ce qui est gÃ©nÃ©rÃ© est ici
    â”œâ”€â”€ CMakeCache.txt
    â”œâ”€â”€ CMakeFiles/
    â”œâ”€â”€ Makefile
    â”œâ”€â”€ main.o
    â”œâ”€â”€ utils.o
    â””â”€â”€ mon_app
```

**Avantages** :
- âœ… SÃ©paration claire : sources / builds
- âœ… Nettoyage facile : `rm -rf build`
- âœ… Plusieurs configurations possibles simultanÃ©ment
- âœ… Git simple : ignore juste `build/`
- âœ… Aucun risque pour les sources

---

## Pourquoi les out-of-source builds sont essentiels

### 1. PropretÃ© du rÃ©pertoire source

**Sans out-of-source** :
```bash
ls mon_projet/
# CMakeLists.txt  main.c  utils.c  CMakeCache.txt  CMakeFiles/
# Makefile  cmake_install.cmake  main.o  utils.o  mon_app
# âŒ Impossible de distinguer sources et artefacts de build !
```

**Avec out-of-source** :
```bash
ls mon_projet/
# CMakeLists.txt  src/  build/
# âœ… Clair et organisÃ© !
```

### 2. Nettoyage trivial

**Sans out-of-source** :
```bash
# Comment nettoyer ? ğŸ¤”
make clean  # Ne supprime pas tout
rm *.o      # Et les autres fichiers ?
# Risque de supprimer des sources !
```

**Avec out-of-source** :
```bash
# Nettoyage complet en une commande
rm -rf build
# âœ… Tout est supprimÃ©, sources intactes
```

### 3. Builds multiples simultanÃ©s

**ScÃ©nario rÃ©el** : Vous dÃ©veloppez en Debug mais voulez tester en Release

**Sans out-of-source** :
```bash
cmake -DCMAKE_BUILD_TYPE=Debug .
make
# Test...
# Pour tester en Release, il faut reconfigurer et recompiler TOUT
cmake -DCMAKE_BUILD_TYPE=Release .
make  # âŒ Recompilation complÃ¨te (5-10 minutes sur gros projet)
```

**Avec out-of-source** :
```bash
cmake -B build-debug -DCMAKE_BUILD_TYPE=Debug
cmake -B build-release -DCMAKE_BUILD_TYPE=Release

# Passer de l'un Ã  l'autre est instantanÃ© !
./build-debug/mon_app      # Version debug
./build-release/mon_app    # Version release
# âœ… Pas de recompilation !
```

### 4. Gestion Git simplifiÃ©e

**.gitignore sans out-of-source** (partiel) :
```gitignore
# âŒ Il faut lister tous les patterns possibles
CMakeCache.txt
CMakeFiles/
Makefile
cmake_install.cmake
*.o
*.a
*.so
mon_app
mon_autre_app
# ... des dizaines de patterns
# Risque d'oublier des fichiers gÃ©nÃ©rÃ©s
```

**.gitignore avec out-of-source** (complet) :
```gitignore
# âœ… Une seule ligne suffit !
build/
build-*/
```

### 5. Plusieurs architectures/compilateurs

```bash
# Build pour x86-64
cmake -B build-x86 -DCMAKE_C_COMPILER=gcc

# Build pour ARM (cross-compilation)
cmake -B build-arm -DCMAKE_TOOLCHAIN_FILE=arm-toolchain.cmake

# Build avec Clang
cmake -B build-clang -DCMAKE_C_COMPILER=clang

# Tous coexistent sans conflit !
ls
# build-x86/  build-arm/  build-clang/
```

---

## Comment faire des out-of-source builds

### MÃ©thode 1 : Option -B (CMake 3.13+, recommandÃ©e)

C'est la mÃ©thode moderne et la plus simple :

```bash
# Configuration + gÃ©nÃ©ration
cmake -B build

# Compilation
cmake --build build

# ExÃ©cution
./build/mon_app
```

**Explications** :
- `-B build` : CrÃ©e le rÃ©pertoire `build/` et gÃ©nÃ¨re dedans
- Si `build/` n'existe pas, CMake le crÃ©e automatiquement
- Simple, clair, explicite

### MÃ©thode 2 : CrÃ©er le rÃ©pertoire manuellement (ancienne mÃ©thode)

```bash
# CrÃ©er le rÃ©pertoire de build
mkdir build
cd build

# Configurer depuis le rÃ©pertoire de build
cmake ..

# Compiler
make

# Retourner Ã  la racine
cd ..

# ExÃ©cution
./build/mon_app
```

**Note** : Fonctionne avec toutes les versions de CMake, mais plus verbeux.

### MÃ©thode 3 : RÃ©pertoires nommÃ©s par configuration

```bash
# Build Debug
cmake -B build-debug -DCMAKE_BUILD_TYPE=Debug

# Build Release
cmake -B build-release -DCMAKE_BUILD_TYPE=Release

# Build avec sanitizers
cmake -B build-asan -DCMAKE_BUILD_TYPE=Debug \
    -DCMAKE_C_FLAGS="-fsanitize=address"

# Structure rÃ©sultante :
# build-debug/
# build-release/
# build-asan/
```

---

## Conventions de nommage des rÃ©pertoires de build

### Noms courants et leur signification

| Nom | Usage | Convention |
|-----|-------|-----------|
| `build/` | Build par dÃ©faut | Standard universel |
| `build-debug/` | Build en mode Debug | Explicite |
| `build-release/` | Build en mode Release | Explicite |
| `build-prof/` | Build pour profiling | RelWithDebInfo |
| `build-test/` | Build pour tests | Avec coverage |
| `build-static/` | Build statique | Static linking |
| `build-arm/` | Build pour ARM | Cross-compilation |
| `cmake-build-debug/` | Build Debug | Convention CLion/JetBrains |

### Pattern recommandÃ© pour projets professionnels

```
mon_projet/
â”œâ”€â”€ CMakeLists.txt
â”œâ”€â”€ src/
â”œâ”€â”€ include/
â”œâ”€â”€ tests/
â”œâ”€â”€ docs/
â”œâ”€â”€ build/              # Build par dÃ©faut (gitignored)
â”œâ”€â”€ build-debug/        # Debug (gitignored)
â”œâ”€â”€ build-release/      # Release (gitignored)
â””â”€â”€ build-*/            # Autres configs (gitignored)
```

**.gitignore** :
```gitignore
# Ignorer tous les rÃ©pertoires de build
build/
build-*/
cmake-build-*/

# Mais garder un README si nÃ©cessaire
!build/README.md
```

---

## GÃ©rer plusieurs configurations

### Workflow dÃ©veloppement complet

```bash
#!/bin/bash
# setup_builds.sh - Script pour configurer tous les builds

echo "ğŸ”§ Configuration des environnements de build..."

# Build Debug (dÃ©veloppement quotidien)
echo "ğŸ“¦ Debug..."
cmake -B build-debug \
    -DCMAKE_BUILD_TYPE=Debug \
    -DCMAKE_EXPORT_COMPILE_COMMANDS=ON

# Build Release (tests de performance)
echo "ğŸš€ Release..."
cmake -B build-release \
    -DCMAKE_BUILD_TYPE=Release

# Build avec sanitizers (dÃ©tection de bugs)
echo "ğŸ› Sanitizers..."
cmake -B build-sanitizers \
    -DCMAKE_BUILD_TYPE=Debug \
    -DCMAKE_C_FLAGS="-fsanitize=address,undefined"

# Build avec coverage (tests)
echo "ğŸ“Š Coverage..."
cmake -B build-coverage \
    -DCMAKE_BUILD_TYPE=Debug \
    -DCMAKE_C_FLAGS="--coverage"

echo "âœ… Tous les builds configurÃ©s !"
echo ""
echo "Utilisation :"
echo "  cmake --build build-debug      # DÃ©veloppement"
echo "  cmake --build build-release    # Performance"
echo "  cmake --build build-sanitizers # DÃ©tection bugs"
echo "  cmake --build build-coverage   # Tests coverage"
```

### Makefile wrapper (optionnel mais pratique)

CrÃ©er un `Makefile` Ã  la racine pour simplifier les commandes courantes :

```makefile
# Makefile wrapper pour CMake out-of-source builds

.PHONY: all debug release clean test help

# Build par dÃ©faut : Debug
all: debug

# Build Debug
debug:
	cmake -B build-debug -DCMAKE_BUILD_TYPE=Debug
	cmake --build build-debug

# Build Release
release:
	cmake -B build-release -DCMAKE_BUILD_TYPE=Release
	cmake --build build-release

# Tests
test: debug
	cd build-debug && ctest --output-on-failure

# Nettoyage
clean:
	rm -rf build-*

# Aide
help:
	@echo "Commandes disponibles :"
	@echo "  make          - Build Debug"
	@echo "  make debug    - Build Debug"
	@echo "  make release  - Build Release"
	@echo "  make test     - Lancer les tests"
	@echo "  make clean    - Nettoyer tous les builds"
```

**Utilisation** :
```bash
make           # Build debug
make release   # Build release
make test      # Tests
make clean     # Nettoyage
```

---

## ProtÃ©ger contre les in-source builds

Pour Ã©viter les erreurs, vous pouvez **interdire** les in-source builds dans votre CMakeLists.txt :

```cmake
# Interdire les in-source builds
if(CMAKE_SOURCE_DIR STREQUAL CMAKE_BINARY_DIR)
    message(FATAL_ERROR
        "âŒ ERREUR : Build in-source dÃ©tectÃ© !\n"
        "\n"
        "Les in-source builds polluent le rÃ©pertoire source.\n"
        "Veuillez utiliser un build out-of-source :\n"
        "\n"
        "  cmake -B build\n"
        "  cmake --build build\n"
        "\n"
        "Si vous avez dÃ©jÃ  polluÃ© le rÃ©pertoire source, nettoyez avec :\n"
        "  git clean -xdf\n"
    )
endif()
```

**RÃ©sultat si quelqu'un essaie `cmake .` :**
```
CMake Error at CMakeLists.txt:5 (message):
  âŒ ERREUR : Build in-source dÃ©tectÃ© !

  Les in-source builds polluent le rÃ©pertoire source.
  Veuillez utiliser un build out-of-source :

    cmake -B build
    cmake --build build

  Si vous avez dÃ©jÃ  polluÃ© le rÃ©pertoire source, nettoyez avec :
    git clean -xdf
```

---

## Cas particuliers et questions frÃ©quentes

### Q1 : OÃ¹ mettre le rÃ©pertoire de build ?

**RÃ©ponse** : Ã€ la racine du projet (mÃªme niveau que CMakeLists.txt principal).

âœ… **Bon** :
```
mon_projet/
â”œâ”€â”€ CMakeLists.txt
â”œâ”€â”€ src/
â””â”€â”€ build/         # âœ… Ã€ la racine
```

âŒ **Mauvais** :
```
mon_projet/
â”œâ”€â”€ CMakeLists.txt
â””â”€â”€ src/
    â””â”€â”€ build/     # âŒ Dans src/
```

### Q2 : Puis-je mettre build/ ailleurs (ex: /tmp) ?

**RÃ©ponse** : Oui, mais c'est rarement utile.

```bash
# Build dans /tmp
cmake -B /tmp/mon_projet_build

# Ou dans un rÃ©pertoire parent
cmake -B ../builds/mon_projet
```

**InconvÃ©nients** :
- Chemins plus complexes
- Moins intuitif pour les collaborateurs
- IDEs peuvent ne pas trouver le build

**Cas d'usage** : Disque SSD dÃ©diÃ© aux builds pour la vitesse.

### Q3 : Que faire si j'ai dÃ©jÃ  polluÃ© mon rÃ©pertoire avec un in-source build ?

**Nettoyage manuel** :
```bash
# Supprimer les fichiers CMake gÃ©nÃ©rÃ©s
rm -rf CMakeCache.txt CMakeFiles/ cmake_install.cmake Makefile

# Supprimer les fichiers objets
rm -f *.o *.a *.so

# Supprimer les exÃ©cutables (attention Ã  ne pas supprimer vos sources !)
rm -f mon_app
```

**Nettoyage avec Git (plus sÃ»r)** :
```bash
# Affiche ce qui serait supprimÃ© (sans supprimer)
git clean -xdn

# Supprime tous les fichiers non-trackÃ©s
git clean -xdf

# Ensuite, repartir proprement
cmake -B build
```

### Q4 : Comment partager un build entre dÃ©veloppeurs ?

**RÃ©ponse** : On ne partage JAMAIS les rÃ©pertoires de build !

âŒ **Mauvais** :
```bash
# Ne JAMAIS commiter build/ dans Git
git add build/
```

âœ… **Bon** :
```bash
# Chaque dÃ©veloppeur crÃ©e son propre build
# Utilisateur 1 :
cmake -B build

# Utilisateur 2 (autre machine) :
cmake -B build  # GÃ©nÃ¨re son propre build
```

**Pourquoi ?** Les builds contiennent des chemins absolus spÃ©cifiques Ã  chaque machine.

### Q5 : Out-of-source builds avec des IDEs ?

**Visual Studio Code** :
- Extension CMake Tools configure automatiquement en out-of-source
- RÃ©pertoire par dÃ©faut : `build/`

**CLion (JetBrains)** :
- Utilise `cmake-build-debug/`, `cmake-build-release/`
- âœ… Out-of-source par dÃ©faut

**Qt Creator** :
- CrÃ©e automatiquement des builds sÃ©parÃ©s
- RÃ©pertoires nommÃ©s : `build-Debug/`, `build-Release/`

**Tous les IDEs modernes utilisent out-of-source par dÃ©faut !**

---

## Exemples pratiques complets

### Exemple 1 : Projet simple

**Structure** :
```
calculator/
â”œâ”€â”€ CMakeLists.txt
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.c
â”‚   â””â”€â”€ calc.c
â””â”€â”€ include/
    â””â”€â”€ calc.h
```

**Workflow** :
```bash
cd calculator

# Configuration
cmake -B build

# Compilation
cmake --build build

# ExÃ©cution
./build/calculator

# Modification du code...
nano src/calc.c

# Recompilation (rapide, seul calc.c est recompilÃ©)
cmake --build build

# Nettoyage
rm -rf build
```

### Exemple 2 : Projet avec tests

**Structure** :
```
webserver/
â”œâ”€â”€ CMakeLists.txt
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.c
â”‚   â””â”€â”€ server.c
â”œâ”€â”€ tests/
â”‚   â””â”€â”€ test_server.c
â””â”€â”€ build/          # gitignored
```

**Workflow** :
```bash
# Build principal
cmake -B build -DCMAKE_BUILD_TYPE=Debug
cmake --build build

# Tests
cd build && ctest
cd ..

# Couverture de tests
cmake -B build-coverage \
    -DCMAKE_BUILD_TYPE=Debug \
    -DCMAKE_C_FLAGS="--coverage"
cmake --build build-coverage
cd build-coverage && ctest
```

### Exemple 3 : Projet cross-platform

**Structure** :
```
cross_app/
â”œâ”€â”€ CMakeLists.txt
â”œâ”€â”€ src/
â”œâ”€â”€ build-linux/      # Build Linux x86-64
â”œâ”€â”€ build-arm/        # Build ARM
â””â”€â”€ build-windows/    # Build Windows (cross-compilation)
```

**Workflow** :
```bash
# Build natif Linux
cmake -B build-linux
cmake --build build-linux

# Cross-compilation pour ARM
cmake -B build-arm \
    -DCMAKE_TOOLCHAIN_FILE=toolchain-arm.cmake
cmake --build build-arm

# Cross-compilation pour Windows (avec MinGW)
cmake -B build-windows \
    -DCMAKE_TOOLCHAIN_FILE=toolchain-mingw.cmake
cmake --build build-windows
```

---

## CI/CD et out-of-source builds

### GitHub Actions

```yaml
name: Build

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3

    - name: Configure CMake
      run: cmake -B build -DCMAKE_BUILD_TYPE=Release

    - name: Build
      run: cmake --build build

    - name: Test
      run: cd build && ctest --output-on-failure

    - name: Upload artifact
      uses: actions/upload-artifact@v3
      with:
        name: mon_app-linux
        path: build/mon_app
```

**Note** : Le rÃ©pertoire `build/` est crÃ©Ã© dans le runner, jamais commitÃ©.

### GitLab CI

```yaml
build:
  script:
    - cmake -B build -DCMAKE_BUILD_TYPE=Release
    - cmake --build build
    - cd build && ctest
  artifacts:
    paths:
      - build/mon_app
    expire_in: 1 week
```

### Docker

```dockerfile
FROM ubuntu:22.04

# Installer les dÃ©pendances
RUN apt-get update && apt-get install -y \
    build-essential cmake git

WORKDIR /app

# Copier les sources (pas build/)
COPY CMakeLists.txt .
COPY src/ src/

# Build out-of-source
RUN cmake -B build -DCMAKE_BUILD_TYPE=Release
RUN cmake --build build

# L'exÃ©cutable est dans build/
CMD ["./build/mon_app"]
```

---

## Comparaison visuelle : In-source vs Out-of-source

### ScÃ©nario : Modifier main.c puis recompiler

**In-source build** :
```
1. nano main.c                    # Ã‰diter
2. ls                             # ğŸ˜° Confusion : sources + fichiers gÃ©nÃ©rÃ©s
   main.c  main.o  mon_app  CMakeCache.txt  CMakeFiles/  Makefile ...
3. make                           # Compiler
4. ./mon_app                      # ExÃ©cuter (mais lequel si plusieurs exÃ©cutables ?)
5. git status                     # ğŸ˜± Git voit des dizaines de fichiers non-trackÃ©s
```

**Out-of-source build** :
```
1. nano src/main.c                # Ã‰diter
2. ls                             # ğŸ˜Š Clair : que des sources
   CMakeLists.txt  src/  build/
3. cmake --build build            # Compiler
4. ./build/mon_app                # ExÃ©cuter (clair et explicite)
5. git status                     # âœ… Propre : build/ est ignorÃ©
```

---

## RÃ©capitulatif : Checklist des bonnes pratiques

âœ… **Ã€ FAIRE** :
- [ ] Toujours utiliser `cmake -B build`
- [ ] Ajouter `build/` et `build-*/` au .gitignore
- [ ] Utiliser plusieurs rÃ©pertoires de build pour diffÃ©rentes configs
- [ ] Interdire les in-source builds dans CMakeLists.txt
- [ ] Documenter le workflow dans le README

âŒ **Ã€ Ã‰VITER** :
- [ ] Jamais utiliser `cmake .` (in-source build)
- [ ] Jamais commiter les rÃ©pertoires de build
- [ ] Jamais mÃ©langer sources et artefacts de build
- [ ] Jamais partager un rÃ©pertoire de build entre machines

---

## Template de README.md

Voici un exemple de documentation pour votre projet :

```markdown
# Mon Projet

## Compilation

Ce projet utilise CMake avec des **out-of-source builds** pour garder le rÃ©pertoire source propre.

### PrÃ©requis

```bash
sudo apt install build-essential cmake
```

### Build Debug (dÃ©veloppement)

```bash
cmake -B build-debug -DCMAKE_BUILD_TYPE=Debug
cmake --build build-debug
./build-debug/mon_app
```

### Build Release (production)

```bash
cmake -B build-release -DCMAKE_BUILD_TYPE=Release
cmake --build build-release
./build-release/mon_app
```

### Tests

```bash
cmake -B build-debug -DCMAKE_BUILD_TYPE=Debug
cmake --build build-debug
cd build-debug && ctest
```

### Nettoyage

```bash
rm -rf build-*
```

## Structure du projet

```
mon_projet/
â”œâ”€â”€ CMakeLists.txt       # Configuration CMake
â”œâ”€â”€ src/                 # Code source
â”œâ”€â”€ include/             # Headers publics
â”œâ”€â”€ tests/               # Tests unitaires
â””â”€â”€ build-*/             # RÃ©pertoires de build (gitignored)
```

**Note** : Les rÃ©pertoires `build-*` sont automatiquement crÃ©Ã©s par CMake et ne doivent jamais Ãªtre commitÃ©s dans Git.
```

---

## Conclusion

Les **out-of-source builds** sont une pratique fondamentale et non-nÃ©gociable dans un workflow CMake moderne. Ils permettent :

- âœ… **PropretÃ©** : SÃ©paration sources / builds
- âœ… **SimplicitÃ©** : Nettoyage trivial (`rm -rf build`)
- âœ… **FlexibilitÃ©** : Plusieurs configurations simultanÃ©es
- âœ… **SÃ©curitÃ©** : Aucun risque pour les sources
- âœ… **Professionnalisme** : Standard dans l'industrie

**RÃ¨gle d'or** : Toujours utiliser `cmake -B build`, jamais `cmake .`

**Ã€ retenir** :
```bash
# âœ… TOUJOURS faire ceci
cmake -B build
cmake --build build

# âŒ JAMAIS faire ceci
cmake .
make
```

Cette simple habitude vous Ã©vitera des heures de frustration et rendra vos projets infiniment plus maintenables !

---


â­ï¸ [IntÃ©gration VS Code et CLion](/13-build-systems/01.8-integration-ide.md)
