ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 15.3.4 rr (Time Travel Debugging)

## Introduction

**rr** (Record and Replay) est un outil rÃ©volutionnaire qui permet de "voyager dans le temps" lors du debugging. Imaginez pouvoir :
- ExÃ©cuter votre programme en arriÃ¨re (reverse execution)
- Revenir exactement au mÃªme point aprÃ¨s avoir ratÃ© un bug
- Rejouer des dizaines de fois le mÃªme crash, de maniÃ¨re **identique**
- DÃ©boguer des race conditions comme si elles Ã©taient des bugs dÃ©terministes

C'est exactement ce que rr fait : il **enregistre** l'exÃ©cution complÃ¨te de votre programme, puis vous permet de la **rejouer** autant de fois que nÃ©cessaire, avec un contrÃ´le total sur le temps.

### Le problÃ¨me du debugging traditionnel

Avec GDB classique :
```
Bug intermittent â†’ Crash â†’ Impossible de reproduire â†’ ğŸ˜¡
                    â†“
            RedÃ©marrer le programme
                    â†“
            Peut-Ãªtre que cette fois...
```

Avec rr :
```
Bug intermittent â†’ Enregistrement â†’ Replay infini â†’ TrouvÃ© ! ğŸ‰
                                    â†“
                        Revenir en arriÃ¨re, avancer
                        Analyser autant de fois que nÃ©cessaire
```

### Pourquoi rr est magique ?

- âœ… **DÃ©terminisme total** : Chaque replay est identique au premier
- âœ… **Reverse debugging** : ExÃ©cuter Ã  l'envers (reverse-continue, reverse-step)
- âœ… **Bugs intermittents** : Capturez-les une fois, debuggez-les Ã  l'infini
- âœ… **Race conditions** : Plus de non-dÃ©terminisme
- âœ… **ZÃ©ro modification du code** : Aucune instrumentation nÃ©cessaire
- âœ… **Compatible GDB** : Toutes les commandes GDB fonctionnent

---

## Concepts fondamentaux

### Enregistrement dÃ©terministe

rr fonctionne en deux phases :

```
Phase 1: RECORD                    Phase 2: REPLAY
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Programme rÃ©el                     Simulation exacte
    â†“                                    â†“
rr intercepte tous                 rr rejoue tout  
les Ã©vÃ©nements non-                identiquement  
dÃ©terministes  
    â†“                                    â†“
Trace sauvegardÃ©e â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ Debugging infini
```

**Ã‰vÃ©nements non-dÃ©terministes enregistrÃ©s :**
- Appels systÃ¨me (syscalls)
- Signaux
- Ordonnancement des threads
- Lectures depuis `/dev/random`, timers, etc.

**Ce qui est reproduit Ã  l'identique :**
- Toutes les instructions CPU
- Tous les accÃ¨s mÃ©moire
- L'ordre exact des threads
- Les valeurs retournÃ©es par les syscalls

### Overhead et performance

**Pendant l'enregistrement :**
- Ralentissement : environ **2x Ã  10x** plus lent
- DÃ©pend de l'intensitÃ© des syscalls

**Pendant le replay :**
- Aussi rapide que l'enregistrement (parfois plus rapide)
- Le replay est gratuit : vous pouvez le faire 1000 fois

---

## Installation

### Ubuntu/Debian

```bash
sudo apt-get update  
sudo apt-get install rr  
```

### Depuis les sources (pour la derniÃ¨re version)

```bash
# DÃ©pendances
sudo apt-get install cmake g++ make pkg-config \
    libcapstone-dev libz3-dev python3-pexpect

# Clone et build
git clone https://github.com/rr-debugger/rr.git  
cd rr  
mkdir build && cd build  
cmake ..  
make -j$(nproc)  
sudo make install  
```

### VÃ©rification

```bash
rr --version
```

### Configuration du systÃ¨me

rr nÃ©cessite le compteur de performance CPU. Activez-le :

```bash
# Temporaire (jusqu'au reboot)
sudo sysctl kernel.perf_event_paranoid=1

# Permanent
echo 'kernel.perf_event_paranoid=1' | sudo tee -a /etc/sysctl.conf  
sudo sysctl -p  
```

**Test :**

```bash
rr record ls
```

Si Ã§a fonctionne, rr est prÃªt !

---

## Utilisation basique : Record & Replay

### CrÃ©er un programme de test

```c
// time_travel_demo.c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int calcul_complexe(int n) {
    int resultat = 0;
    for (int i = 0; i < n; i++) {
        resultat += i * i;
    }
    return resultat;
}

int main() {
    printf("DÃ©but du programme\n");

    // Simulation d'un comportement alÃ©atoire
    srand(time(NULL));
    int valeur = rand() % 100;

    printf("Valeur alÃ©atoire : %d\n", valeur);

    int resultat = calcul_complexe(valeur);
    printf("RÃ©sultat : %d\n", resultat);

    // Simulation d'un crash si valeur > 50
    if (valeur > 50) {
        int *ptr = NULL;
        *ptr = 42;  // Segfault
    }

    printf("Fin normale\n");
    return 0;
}
```

Compilez avec les symboles de debug :

```bash
gcc -g -o time_travel_demo time_travel_demo.c
```

### Phase 1 : Enregistrer (Record)

```bash
rr record ./time_travel_demo
```

**Sortie possible :**
```
rr: Saving execution to trace directory `/home/user/.local/share/rr/time_travel_demo-0`.  
DÃ©but du programme  
Valeur alÃ©atoire : 73  
RÃ©sultat : 91588  
Segmentation fault  
```

Le programme crash, mais **rr a tout enregistrÃ©** ! La trace est sauvegardÃ©e.

### Phase 2 : Rejouer (Replay)

```bash
rr replay
```

Cela lance GDB avec la derniÃ¨re trace enregistrÃ©e. Vous Ãªtes maintenant dans une session GDB spÃ©ciale oÃ¹ vous pouvez :

```gdb
(rr) continue
```

Le programme s'exÃ©cute **exactement** comme lors de l'enregistrement :
- MÃªme valeur "alÃ©atoire" (73)
- MÃªme crash au mÃªme endroit

**La magie** : Vous pouvez rejouer autant de fois que vous voulez :

```bash
rr replay    # 1Ã¨re fois : valeur = 73  
rr replay    # 2Ã¨me fois : valeur = 73 (identique!)  
rr replay    # 3Ã¨me fois : valeur = 73 (toujours identique!)  
```

---

## Reverse Debugging : La vraie magie

### Commandes reverse

rr ajoute des commandes "inverse" Ã  GDB :

| Commande normale | Commande reverse | Description |
|------------------|------------------|-------------|
| `continue` | `reverse-continue` | Continuer en arriÃ¨re jusqu'au breakpoint prÃ©cÃ©dent |
| `step` | `reverse-step` | ExÃ©cuter l'instruction prÃ©cÃ©dente (en entrant dans les fonctions) |
| `next` | `reverse-next` | Ligne prÃ©cÃ©dente (sans entrer dans les fonctions) |
| `finish` | `reverse-finish` | Sortir de la fonction actuelle en arriÃ¨re |
| `stepi` | `reverse-stepi` | Instruction assembleur prÃ©cÃ©dente |

Alias courts : `rc`, `rs`, `rn`, `rf`, `rsi`

### Exemple pratique

Reprenons notre programme qui crash :

```bash
rr replay
```

Dans GDB :

```gdb
(rr) continue
# Programme crash

(rr) backtrace
#0  0x000055555555528a in main () at time_travel_demo.c:26

# On est au moment du crash, remontons le temps !
(rr) reverse-continue
# Revient au dÃ©but du programme

(rr) break calcul_complexe
(rr) continue
# ArrÃªt dans calcul_complexe

(rr) print n
$1 = 73

# Continuons puis revenons
(rr) finish
(rr) reverse-finish
# On est revenu au dÃ©but de calcul_complexe !

(rr) print n
$2 = 73   # MÃªme valeur, Ã©videmment
```

### Cas d'usage : Trouver oÃ¹ une variable change

Supposons qu'une variable `valeur` devienne incorrecte, mais vous ne savez pas oÃ¹.

```gdb
(rr) watch valeur
(rr) reverse-continue
# Retour au moment exact oÃ¹ valeur a Ã©tÃ© modifiÃ©e !

(rr) backtrace
# Vous voyez quelle fonction a modifiÃ© la variable
```

---

## Workflow typique avec rr

### ScÃ©nario : Bug intermittent qui apparaÃ®t 1 fois sur 10

**Ã‰tape 1 : Enregistrer jusqu'Ã  reproduire le bug**

```bash
#!/bin/bash
# run_until_crash.sh

for i in {1..100}; do
    echo "Tentative $i..."
    rr record ./mon_programme

    # Si le programme crash (exit code != 0)
    if [ $? -ne 0 ]; then
        echo "Bug capturÃ© Ã  la tentative $i!"
        break
    fi
done
```

**Ã‰tape 2 : Analyser la trace**

```bash
rr replay
```

**Ã‰tape 3 : Debugging interactif**

```gdb
# Aller directement Ã  la fin (au crash)
(rr) continue

# Remonter le temps pour comprendre la cause
(rr) reverse-continue

# Analyser l'Ã©tat
(rr) print variable_suspecte
(rr) backtrace

# Rejouer si nÃ©cessaire
(rr) run  # Recommence depuis le dÃ©but
```

---

## Commandes spÃ©cifiques Ã  rr

### Gestion des traces

```bash
# Lister toutes les traces enregistrÃ©es
rr ls

# Replay d'une trace spÃ©cifique
rr replay /chemin/vers/trace

# Supprimer une trace
rm -rf ~/.local/share/rr/mon_programme-0

# Pack de la trace (compression pour partage)
rr pack /chemin/vers/trace
```

### Dans GDB (rr replay)

```gdb
# Voir oÃ¹ nous sommes dans l'exÃ©cution
(rr) when
# Affiche : Event 12345

# Aller Ã  un Ã©vÃ©nement spÃ©cifique
(rr) run <event_number>

# Checkpoints (sauvegarder un point dans le temps)
(rr) checkpoint
# CrÃ©Ã© un point de sauvegarde

(rr) restart <checkpoint_id>
# Revenir instantanÃ©ment Ã  ce checkpoint
```

### Statistiques de la trace

```bash
# Informations sur la trace
rr dump /chemin/vers/trace
```

---

## Debugging de race conditions

Les race conditions sont le cauchemar des dÃ©veloppeurs. Avec rr, elles deviennent triviales Ã  dÃ©boguer.

### Programme avec race condition

```c
// race_condition.c
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

int compteur = 0;  // Variable partagÃ©e SANS protection

void* incrementer(void* arg) {
    for (int i = 0; i < 1000000; i++) {
        compteur++;  // Race condition !
    }
    return NULL;
}

int main() {
    pthread_t thread1, thread2;

    pthread_create(&thread1, NULL, incrementer, NULL);
    pthread_create(&thread2, NULL, incrementer, NULL);

    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);

    printf("Compteur final : %d\n", compteur);
    printf("Attendu : 2000000\n");

    return 0;
}
```

Compilez :

```bash
gcc -g -pthread -o race_condition race_condition.c
```

**Sans rr :**
```bash
./race_condition
# Compteur final : 1234567 (diffÃ©rent Ã  chaque fois!)
./race_condition
# Compteur final : 1456789 (impossible Ã  dÃ©boguer)
```

**Avec rr :**

```bash
rr record ./race_condition
```

**Sortie :**
```
Compteur final : 1342156
```

Maintenant, chaque `rr replay` donnera **exactement** 1342156. La race condition est figÃ©e dans le temps !

### Analyser la race condition

```bash
rr replay
```

Dans GDB :

```gdb
# Point d'arrÃªt sur la modification de compteur
(rr) watch compteur

# ExÃ©cuter
(rr) continue
# S'arrÃªte Ã  chaque modification

# Voir quel thread modifie
(rr) info threads
(rr) thread apply all backtrace

# Revenir en arriÃ¨re pour analyser
(rr) reverse-continue

# Comprendre l'ordre d'exÃ©cution des threads
(rr) when
```

Vous pouvez maintenant analyser mÃ©thodiquement l'ordre d'exÃ©cution qui cause le problÃ¨me !

---

## Debugging de problÃ¨mes complexes

### Cas 1 : Corruption mÃ©moire

```c
// memory_corruption.c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int *tableau = malloc(10 * sizeof(int));

    for (int i = 0; i <= 10; i++) {  // BUG : devrait Ãªtre i < 10
        tableau[i] = i * 10;
    }

    printf("Tableau rempli\n");

    // Plus tard dans le programme...
    int *autre = malloc(5 * sizeof(int));
    autre[0] = 42;

    printf("autre[0] = %d\n", autre[0]);

    free(tableau);
    free(autre);

    return 0;
}
```

Avec rr :

```bash
rr record ./memory_corruption  
rr replay  
```

```gdb
# Watchpoint sur la mÃ©moire corrompue
(rr) watch *(int*)0x5555555592a0  # Adresse de autre[0]

# ExÃ©cuter
(rr) continue
# S'arrÃªte quand tableau[10] Ã©crase autre[0]

# Backtrace pour voir la source
(rr) backtrace
```

### Cas 2 : Bug qui apparaÃ®t aprÃ¨s 1 million d'itÃ©rations

```bash
rr record ./long_running_program

# 30 minutes plus tard, le bug apparaÃ®t
# Maintenant vous pouvez le dÃ©boguer instantanÃ©ment !

rr replay
```

```gdb
# Aller directement Ã  la fin
(rr) continue

# Remonter pour comprendre
(rr) reverse-continue
```

### Cas 3 : Signal inattendu

```gdb
(rr) catch signal SIGSEGV
(rr) reverse-continue
# Retour au moment exact avant le signal
```

---

## Debugging multi-thread avancÃ©

rr excelle dans le debugging multi-thread car il enregistre l'ordonnancement exact.

### Programme multi-thread complexe

```bash
rr record ./serveur_multithread  
rr replay  
```

Dans GDB :

```gdb
# Voir tous les threads
(rr) info threads

# Basculer entre threads
(rr) thread 3

# Voir l'historique d'exÃ©cution de chaque thread
(rr) thread apply all where

# Suivre un thread spÃ©cifique
(rr) thread 2
(rr) watch variable_du_thread
(rr) continue
```

**Astuce** : Avec rr, vous pouvez "geler" l'exÃ©cution et naviguer entre les threads sans qu'ils continuent Ã  s'exÃ©cuter en arriÃ¨re-plan.

---

## Performance et limitations

### Overhead de l'enregistrement

**Facteurs affectant les performances :**

1. **IntensitÃ© des syscalls** : Plus il y a d'appels systÃ¨me, plus c'est lent
2. **Nombre de threads** : Multi-threading augmente l'overhead
3. **I/O intensif** : Beaucoup d'E/S ralentit l'enregistrement

**Benchmarks typiques :**
- Programme CPU-bound : 1.5x - 3x plus lent
- Programme avec beaucoup de syscalls : 5x - 10x plus lent
- Programme I/O intensif : 10x - 20x plus lent

### Limitations

#### 1. Architecture

rr fonctionne seulement sur :
- **x86-64** (Intel, AMD) âœ…
- **ARM64** (support expÃ©rimental) âš ï¸

Pas de support pour :
- x86 32-bit (ancien)
- Autres architectures

VÃ©rification :

```bash
rr record ls
# Si erreur : CPU incompatible ou perf_event dÃ©sactivÃ©
```

#### 2. Taille des traces

Les traces peuvent devenir **trÃ¨s grosses** :
- Programme simple : 10-100 MB
- Serveur web sous charge : plusieurs GB

**Solution :** Limiter la durÃ©e d'enregistrement ou utiliser des filtres.

#### 3. FonctionnalitÃ©s non supportÃ©es

- **Certains syscalls** : `rdtsc` direct, `perf_event_open` imbriquÃ©
- **Programmes qui dÃ©sactivent ASLR** manuellement
- **Code auto-modifiant** (JIT extrÃªme)

---

## IntÃ©gration avec les outils

### rr + Sanitizers (AddressSanitizer)

Combiner rr avec ASan pour un debugging ultra-puissant :

```bash
# Compiler avec ASan
gcc -g -fsanitize=address -o prog prog.c

# Enregistrer avec rr
rr record ./prog

# Rejouer
rr replay
```

ASan dÃ©tecte les erreurs, rr vous permet de les analyser en remontant le temps !

### rr + Valgrind ?

âŒ **Incompatible** : Vous ne pouvez pas utiliser rr et Valgrind ensemble (ils interceptent tous deux les syscalls).

**Workflow recommandÃ© :**
1. Utiliser Valgrind pour dÃ©tecter les fuites
2. Une fois dÃ©tectÃ©es, utiliser rr pour comprendre le flot d'exÃ©cution

### rr dans le CI/CD

Exemple avec GitHub Actions :

```yaml
name: Debug avec rr

on: [push]

jobs:
  debug:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2

    - name: Installer rr
      run: |
        sudo apt-get update
        sudo apt-get install rr
        sudo sysctl kernel.perf_event_paranoid=1

    - name: Compiler
      run: gcc -g -o test test.c

    - name: Enregistrer avec rr
      run: rr record ./test

    - name: Sauvegarder la trace
      if: failure()
      uses: actions/upload-artifact@v2
      with:
        name: rr-trace
        path: ~/.local/share/rr/
```

Si le test Ã©choue, vous pouvez tÃ©lÃ©charger la trace et la rejouer localement !

---

## Cas d'usage rÃ©els

### 1. Bug en production

**ScÃ©nario :** Votre serveur crash en production une fois par semaine.

**Solution :**

```bash
# Wrapper pour votre serveur
#!/bin/bash
while true; do
    rr record ./serveur --prod-config

    # Si crash, sauvegarder la trace
    if [ $? -ne 0 ]; then
        TRACE=$(rr ls | tail -1)
        rr pack $TRACE
        cp -r $TRACE /backup/crash_$(date +%Y%m%d_%H%M%S)

        # Alerter l'Ã©quipe
        echo "CRASH CAPTURÃ‰!" | mail -s "Serveur crash" ops@example.com
    fi

    sleep 1
done
```

Quand le crash arrive, vous avez la trace complÃ¨te pour l'analyser !

**âš ï¸ Attention** : L'overhead peut ne pas Ãªtre acceptable en production. Utilisez plutÃ´t sur un serveur de staging qui rÃ©plique la production.

### 2. Bug de rÃ©gression

**ScÃ©nario :** Un commit a introduit un bug, mais vous ne savez pas lequel.

**Solution :** Git bisect + rr

```bash
#!/bin/bash
# test_with_rr.sh

git checkout $1  
make clean && make  

rr record ./test_suite

if [ $? -eq 0 ]; then
    echo "Tests OK"
    exit 0
else
    echo "Tests KO - trace sauvegardÃ©e"
    exit 1
fi
```

```bash
git bisect start  
git bisect bad HEAD  
git bisect good v1.0  
git bisect run ./test_with_rr.sh  
```

Quand Git bisect trouve le commit fautif, vous avez la trace rr pour analyser !

### 3. Debugging d'un crash client

**ScÃ©nario :** Un client rapporte un crash, mais vous ne pouvez pas le reproduire.

**Solution :** Envoyez un binaire instrumentÃ© avec rr :

```bash
# Sur la machine du client
rr record ./application

# Packager la trace
rr pack ~/.local/share/rr/application-0

# Envoyer rr-trace.tar.bz2 au dÃ©veloppeur
```

Le dÃ©veloppeur peut rejouer exactement ce que le client a vÃ©cu !

---

## Bonnes pratiques

### 1. Enregistrez tÃ´t, analysez tard

Ne perdez pas de temps Ã  dÃ©boguer immÃ©diatement. Enregistrez d'abord :

```bash
# Session de reproduction de bug
rr record ./programme_problematique

# Plus tard, quand vous avez le temps
rr replay
```

### 2. Utilisez des checkpoints

Dans une longue session de replay :

```gdb
# CrÃ©er un checkpoint Ã  un point intÃ©ressant
(rr) checkpoint

# Explorer en avant
(rr) continue
# ... oups, je suis allÃ© trop loin

# Revenir au checkpoint
(rr) restart 1
```

### 3. Combinez avec des scripts GDB

```gdb
# script_rr.gdb
break fonction_critique  
commands  
    silent
    printf "Appel %d: arg=%d\n", ++$count, arg
    continue
end

set $count = 0  
run  
```

```bash
rr replay -x script_rr.gdb
```

### 4. Nettoyez les traces anciennes

Les traces occupent de l'espace :

```bash
# Supprimer les traces de plus de 7 jours
find ~/.local/share/rr -type d -mtime +7 -exec rm -rf {} +
```

### 5. Documentation

Quand vous packagez une trace pour un collÃ¨gue :

```bash
rr pack ~/.local/share/rr/mon_app-0

echo "Pour reproduire le bug :
1. Extraire la trace
2. rr replay /chemin/vers/trace
3. (rr) break fonction_x
4. (rr) continue
5. Analyser variable_y
" > README_trace.txt
```

---

## Comparaison avec d'autres outils

| Outil | Record/Replay | Reverse Debug | Overhead | Bugs dÃ©tectÃ©s |
|-------|---------------|---------------|----------|---------------|
| **rr** | âœ… Oui | âœ… Oui | 2x-10x | Tous types |
| **GDB seul** | âŒ Non | âš ï¸ LimitÃ© | 0x | Tous types |
| **Valgrind** | âŒ Non | âŒ Non | 10x-50x | MÃ©moire |
| **ASan** | âŒ Non | âŒ Non | 2x | MÃ©moire |
| **strace** | âš ï¸ Syscalls seulement | âŒ Non | 5x-10x | Syscalls |
| **Intel Pin** | âœ… Oui | âŒ Non | 10x-100x | Tous types |

**Conclusion :** rr est unique pour son ratio puissance/overhead.

---

## Troubleshooting

### ProblÃ¨me 1 : "rr needs /proc/sys/kernel/perf_event_paranoid <= 1"

**Solution :**

```bash
sudo sysctl kernel.perf_event_paranoid=1
```

Ou permanent :

```bash
echo 'kernel.perf_event_paranoid=1' | sudo tee -a /etc/sysctl.conf  
sudo sysctl -p  
```

### ProblÃ¨me 2 : "CPU model not supported"

**Cause :** Votre CPU ne supporte pas les fonctionnalitÃ©s nÃ©cessaires (ancien CPU ou VM).

**Solution :**
- Utiliser un CPU plus rÃ©cent (Intel post-2010, AMD post-2015)
- Sur VM, activer les "performance counters" dans la configuration

### ProblÃ¨me 3 : "Trace trop grosse"

**Solution :** Limiter la durÃ©e ou filtrer les syscalls :

```bash
# Timeout aprÃ¨s 60 secondes
timeout 60 rr record ./programme

# Ou limiter manuellement
rr record --num-cores=1 ./programme
```

### ProblÃ¨me 4 : Replay diffÃ©rent de l'enregistrement

**Cause rare :** IncompatibilitÃ© kernel ou rr buguÃ©.

**Solution :**
- VÃ©rifier que le kernel est stable
- Mettre Ã  jour rr
- Reporter le bug : https://github.com/rr-debugger/rr/issues

### ProblÃ¨me 5 : rr replay freeze

**Cause :** Deadlock ou boucle infinie dans l'enregistrement.

**Solution :**

```gdb
(rr) Ctrl+C
(rr) backtrace
# Analyser oÃ¹ Ã§a bloque

(rr) reverse-continue
# Revenir avant le blocage
```

---

## Ressources et documentation

### Documentation officielle

- Site web : https://rr-project.org/
- GitHub : https://github.com/rr-debugger/rr
- Wiki : https://github.com/rr-debugger/rr/wiki

### Articles et prÃ©sentations

- Talk original (Mozilla) : "Introducing rr" - Robert O'Callahan
- Blog posts : https://robert.ocallahan.org/

### CommunautÃ©

- Mailing list : rr-dev@mozilla.org
- IRC : #rr sur irc.mozilla.org

---

## RÃ©sumÃ© des commandes essentielles

### Enregistrement

```bash
# Enregistrer un programme
rr record ./programme

# Avec arguments
rr record ./programme arg1 arg2

# Lister les traces
rr ls

# Infos sur une trace
rr dump /chemin/vers/trace
```

### Replay

```bash
# Rejouer la derniÃ¨re trace
rr replay

# Rejouer une trace spÃ©cifique
rr replay /chemin/vers/trace

# Rejouer avec un script GDB
rr replay -x script.gdb
```

### Commandes GDB (pendant rr replay)

```gdb
# Reverse debugging
(rr) reverse-continue       # ou rc
(rr) reverse-step           # ou rs
(rr) reverse-next           # ou rn
(rr) reverse-finish         # ou rf
(rr) reverse-stepi          # ou rsi

# ContrÃ´le temporel
(rr) when                   # Ã‰vÃ©nement actuel
(rr) run <event>            # Aller Ã  un Ã©vÃ©nement

# Checkpoints
(rr) checkpoint             # CrÃ©er un checkpoint
(rr) restart <N>            # Revenir au checkpoint N
```

---

## Conclusion

rr (Record and Replay) est un **outil rÃ©volutionnaire** qui change complÃ¨tement la faÃ§on de dÃ©boguer. Il transforme le debugging d'un art incertain en une science exacte.

**Avantages majeurs :**

- âœ… **DÃ©terminisme absolu** : Chaque replay est identique
- âœ… **Reverse debugging** : Voyagez dans le temps
- âœ… **Bugs intermittents** : Capturez une fois, analysez Ã  l'infini
- âœ… **Race conditions** : Plus de non-dÃ©terminisme
- âœ… **ZÃ©ro modification du code** : Transparent pour votre application
- âœ… **Compatible GDB** : Toutes les commandes GDB fonctionnent + commandes reverse

**Quand utiliser rr :**

1. ğŸ› Bugs difficiles Ã  reproduire ou intermittents
2. ğŸ”„ Race conditions et problÃ¨mes multi-thread
3. ğŸ’¥ Crashes en production (enregistrement sur staging)
4. ğŸ” Analyse post-mortem dÃ©taillÃ©e
5. ğŸ§ª Tests de rÃ©gression avec Git bisect

**Limitations Ã  connaÃ®tre :**

- Architecture x86-64 uniquement (pour l'instant)
- Overhead 2x-10x pendant l'enregistrement
- Traces peuvent Ãªtre volumineuses
- Incompatible avec Valgrind

**Points clÃ©s Ã  retenir :**

1. **Record first, debug later** : Enregistrez d'abord, analysez quand vous avez le temps
2. **Combinez avec d'autres outils** : ASan + rr = puissance maximale
3. **Utilisez les checkpoints** : Pour naviguer efficacement
4. **Packagez les traces** : Partagez-les avec votre Ã©quipe
5. **Nettoyez rÃ©guliÃ¨rement** : Les traces occupent de l'espace

Avec rr, le debugging devient une exploration mÃ©thodique plutÃ´t qu'une chasse frustrante. C'est l'outil qui transforme "je n'arrive pas Ã  reproduire le bug" en "regardez, voici exactement ce qui s'est passÃ©" ! ğŸ•°ï¸ğŸ›ğŸ”

â­ï¸ [DÃ©tection de fuites avec Valgrind](/15-debogage-et-qualite/04-valgrind.md)
