üîù Retour au [Sommaire](/SOMMAIRE.md)

# 24.1.4 Limitations et portabilit√©

## Introduction

Bien que `__attribute__((cleanup))` soit extr√™mement utile, il est important de comprendre ses **limitations** et ses **impacts sur la portabilit√©** de votre code. Cette section vous aidera √† prendre des d√©cisions √©clair√©es sur quand et comment utiliser cette fonctionnalit√©.

---

## Limitations Techniques

### 1. Extension non-standard

**Le probl√®me :**

`__attribute__((cleanup))` n'est **pas dans le standard C**. C'est une extension sp√©cifique √† GCC (et Clang qui l'a impl√©ment√©e par compatibilit√©).

**Standards C officiels :**
- ‚ùå ANSI C (C89/C90) : Non disponible
- ‚ùå C99 : Non disponible
- ‚ùå C11 : Non disponible
- ‚ùå C17 : Non disponible
- ‚ùå C23 : Non disponible (toujours pas dans le standard)

**Ce que √ßa signifie :**

Si vous √©crivez du code qui doit √™tre **strictement conforme au standard C**, vous ne pouvez pas utiliser `cleanup`.

```c
// Ce code n'est PAS du C standard
void fonction(void) {
    _cleanup_free_ char *buffer = malloc(100);
    // ...
}
```

**Compilation avec `-std=c11 -pedantic` :**
```bash
$ gcc -std=c11 -pedantic -Wall program.c
warning: '__cleanup__' attribute is a GCC extension [-Wpedantic]
```

---

### 2. Support des compilateurs

**Tableau de compatibilit√© :**

| Compilateur | Version | Support cleanup | Notes |
|-------------|---------|-----------------|-------|
| **GCC** | Toutes versions r√©centes | ‚úÖ Oui | Support natif et stable |
| **Clang** | 3.0+ | ‚úÖ Oui | Compatible GCC |
| **Intel ICC** | R√©centes | ‚úÖ Oui | Compatible GCC |
| **MSVC** | Toutes | ‚ùå Non | Compilateur Microsoft Windows |
| **TinyCC** | Toutes | ‚ùå Non | Compilateur l√©ger |
| **CompCert** | Toutes | ‚ùå Non | Compilateur certifi√© |
| **Compilateurs embarqu√©s** | Variable | ‚ö†Ô∏è D√©pend | IAR, Keil, etc. - √† v√©rifier |

**Exemples de compilateurs incompatibles :**

```c
// Avec MSVC (Windows)
// error C2065: '__attribute__': undeclared identifier
_cleanup_free_ char *ptr = malloc(100);
```

---

### 3. Ordre d'ex√©cution des cleanup

**Le comportement :**

Les fonctions de cleanup sont appel√©es dans **l'ordre inverse de d√©claration** (LIFO - Last In, First Out).

**Exemple :**

```c
void exemple_ordre(void) {
    printf("1. D√©but\n");

    _cleanup_free_ char *a = malloc(10);
    printf("2. a d√©clar√©\n");

    _cleanup_free_ char *b = malloc(10);
    printf("3. b d√©clar√©\n");

    _cleanup_free_ char *c = malloc(10);
    printf("4. c d√©clar√©\n");

    printf("5. Fin du scope\n");
    // Ordre de cleanup : c, puis b, puis a
}
```

**Sortie :**
```
1. D√©but
2. a d√©clar√©
3. b d√©clar√©
4. c d√©clar√©
5. Fin du scope
[cleanup c]
[cleanup b]
[cleanup a]
```

**Limitation :** Vous ne pouvez **pas contr√¥ler** cet ordre. Si vous avez besoin d'un ordre sp√©cifique, vous devez :
- Soit ajuster l'ordre de d√©claration
- Soit g√©rer manuellement le nettoyage

---

### 4. Interactions avec setjmp/longjmp

**Probl√®me majeur :**

Les fonctions de cleanup **ne sont PAS appel√©es** si vous utilisez `longjmp()` pour sortir d'un scope.

```c
#include <setjmp.h>

jmp_buf env;

void fonction_avec_cleanup(void) {
    _cleanup_free_ char *buffer = malloc(1000);

    printf("Buffer allou√©\n");

    if (condition_erreur) {
        longjmp(env, 1);  // ‚ö†Ô∏è cleanup_free NE SERA PAS APPEL√â !
    }

    // cleanup_free sera appel√© ici
}

int main(void) {
    if (setjmp(env) == 0) {
        fonction_avec_cleanup();
    } else {
        printf("Erreur attrap√©e\n");
        // ‚ö†Ô∏è La m√©moire de buffer a fuit√© !
    }
    return 0;
}
```

**Pourquoi ?**

`longjmp()` restaure brutalement la pile d'ex√©cution sans d√©rouler normalement les stack frames. Les destructeurs automatiques ne sont pas appel√©s.

**Solution :**

Si vous utilisez `setjmp/longjmp`, vous **devez g√©rer manuellement** les ressources :

```c
void fonction_avec_cleanup_manuel(void) {
    char *buffer = malloc(1000);

    if (condition_erreur) {
        free(buffer);  // Nettoyage manuel avant longjmp
        longjmp(env, 1);
    }

    free(buffer);
}
```

---

### 5. Pas de cleanup dans les structures

**Limitation :**

Vous ne pouvez pas utiliser `cleanup` pour les membres d'une structure :

```c
// ‚ùå ERREUR : √áa ne compile pas
typedef struct {
    char *nom _cleanup_free_;  // ERREUR !
    int age;
} Personne;
```

**Pourquoi ?**

L'attribut `cleanup` ne s'applique qu'aux **variables locales** (automatiques), pas aux membres de structures.

**Solution :**

Cr√©er une fonction de nettoyage pour toute la structure :

```c
typedef struct {
    char *nom;
    char *prenom;
    int age;
} Personne;

static inline void cleanup_personne(Personne **p) {
    if (*p) {
        free((*p)->nom);
        free((*p)->prenom);
        free(*p);
        *p = NULL;
    }
}

#define _cleanup_personne_ __attribute__((cleanup(cleanup_personne)))

void utiliser_personne(void) {
    _cleanup_personne_ Personne *p = calloc(1, sizeof(Personne));

    p->nom = strdup("Dupont");
    p->prenom = strdup("Jean");
    p->age = 30;

    // Tout sera nettoy√© automatiquement
}
```

---

### 6. Variables globales et statiques

**Limitation :**

`cleanup` ne fonctionne **que pour les variables locales** (auto storage duration).

```c
// ‚ùå NE FONCTIONNE PAS
_cleanup_free_ char *global_buffer = NULL;  // Variable globale

void fonction(void) {
    // ‚ùå NE FONCTIONNE PAS
    static _cleanup_free_ char *static_buffer = NULL;  // Variable statique

    // ‚úÖ FONCTIONNE
    _cleanup_free_ char *local_buffer = malloc(100);  // Variable locale
}
```

**Pourquoi ?**

Les variables globales et statiques n'ont pas de "fin de scope" au sens habituel. Elles existent pendant toute la dur√©e du programme.

---

### 7. Interactions avec les optimisations du compilateur

**Comportement potentiellement surprenant :**

Avec les optimisations activ√©es (`-O2`, `-O3`), le compilateur peut r√©organiser le code, ce qui peut affecter le moment exact o√π les cleanup sont appel√©s.

```c
void fonction(void) {
    _cleanup_free_ char *buffer = malloc(100);

    faire_calcul_long();  // 1 seconde

    printf("Buffer: %p\n", buffer);

    // Le compilateur pourrait appeler cleanup_free ici
    // plut√¥t qu'√† la fin du scope si buffer n'est plus utilis√©

    faire_autre_chose();  // buffer n'est plus r√©f√©renc√©
}
```

**Impact :**

En pratique, c'est rarement un probl√®me, mais c'est important de comprendre que le cleanup peut √™tre appel√© **d√®s que la variable n'est plus utilis√©e**, pas n√©cessairement √† la fin du scope.

---

## Probl√®mes de Portabilit√©

### 1. Code multi-plateforme (Linux, Windows, macOS)

**Le d√©fi :**

Si votre code doit tourner sur plusieurs syst√®mes d'exploitation avec diff√©rents compilateurs :

| OS | Compilateur par d√©faut | Support cleanup |
|----|------------------------|-----------------|
| Linux | GCC | ‚úÖ Oui |
| macOS | Clang | ‚úÖ Oui |
| Windows | MSVC | ‚ùå Non |
| Windows | MinGW (GCC) | ‚úÖ Oui |

**Probl√®me Windows :**

```c
// Sur Linux/macOS : Compile et fonctionne
// Sur Windows avec MSVC : ERREUR de compilation
_cleanup_free_ char *buffer = malloc(100);
```

---

### 2. Solution : Compilation conditionnelle

**Pattern portable :**

```c
// cleanup_portable.h
#ifndef CLEANUP_PORTABLE_H
#define CLEANUP_PORTABLE_H

#include <stdio.h>
#include <stdlib.h>

// D√©tection du support de cleanup
#if defined(__GNUC__) || defined(__clang__)
    #define CLEANUP_SUPPORTED 1
    #define _cleanup_(func) __attribute__((cleanup(func)))
#else
    #define CLEANUP_SUPPORTED 0
    #define _cleanup_(func)
#endif

// Fonctions de cleanup (toujours d√©finies)
static inline void cleanup_free(void *p) {
    void **ptr = (void **)p;
    if (*ptr) {
        free(*ptr);
        *ptr = NULL;
    }
}

static inline void cleanup_fclose(FILE **f) {
    if (*f) {
        fclose(*f);
        *f = NULL;
    }
}

// Macros portables
#if CLEANUP_SUPPORTED
    #define _cleanup_free_ _cleanup_(cleanup_free)
    #define _cleanup_fclose_ _cleanup_(cleanup_fclose)
#else
    #define _cleanup_free_
    #define _cleanup_fclose_
#endif

#endif // CLEANUP_PORTABLE_H
```

**Utilisation avec fallback manuel :**

```c
#include "cleanup_portable.h"

void fonction_portable(void) {
    _cleanup_free_ char *buffer = malloc(100);
    _cleanup_fclose_ FILE *f = fopen("file.txt", "r");

    if (!buffer || !f) {
        #if !CLEANUP_SUPPORTED
            // Cleanup manuel si pas de support
            free(buffer);
            if (f) fclose(f);
        #endif
        return;
    }

    // ... code ...

    #if !CLEANUP_SUPPORTED
        // Cleanup manuel √† la fin
        free(buffer);
        fclose(f);
    #endif
}
```

**Inconv√©nients :**
- Code plus verbeux
- Duplication du nettoyage
- Risque d'oublier le fallback manuel

---

### 3. Alternative : goto cleanup pattern (portable)

**Pattern traditionnel compatible partout :**

```c
int fonction_traditionnelle(const char *fichier) {
    char *buffer = NULL;
    FILE *f = NULL;
    int resultat = -1;

    buffer = malloc(1024);
    if (!buffer) {
        goto cleanup;
    }

    f = fopen(fichier, "r");
    if (!f) {
        goto cleanup;
    }

    // Traitement
    size_t n = fread(buffer, 1, 1024, f);
    if (n > 0) {
        resultat = 0;
    }

cleanup:
    if (f) fclose(f);
    free(buffer);  // free(NULL) est s√ªr
    return resultat;
}
```

**Avantages :**
- ‚úÖ Fonctionne avec tous les compilateurs
- ‚úÖ Code standard C
- ‚úÖ Un seul point de nettoyage

**Inconv√©nients :**
- ‚ùå Plus verbeux
- ‚ùå N√©cessite une variable de retour
- ‚ùå Goto (certains le consid√®rent moins √©l√©gant)

---

### 4. Comparaison des approches

**Code avec cleanup (GCC/Clang uniquement) :**

```c
void avec_cleanup(void) {
    _cleanup_free_ char *a = malloc(100);
    _cleanup_free_ char *b = malloc(200);
    _cleanup_fclose_ FILE *f = fopen("file.txt", "r");

    if (!a || !b || !f) return;

    // Traitement

    // Nettoyage automatique
}
```

**Code portable (tous compilateurs) :**

```c
void portable_goto(void) {
    char *a = NULL;
    char *b = NULL;
    FILE *f = NULL;

    a = malloc(100);
    if (!a) goto cleanup;

    b = malloc(200);
    if (!b) goto cleanup;

    f = fopen("file.txt", "r");
    if (!f) goto cleanup;

    // Traitement

cleanup:
    if (f) fclose(f);
    free(b);
    free(a);
}
```

**Statistiques :**
- Cleanup : 7 lignes
- Goto : 16 lignes
- Diff√©rence : **+129% de code**

---

## Cas d'usage : Quand utiliser cleanup ?

### ‚úÖ Utilisez cleanup quand :

#### 1. Projet Linux/UNIX avec GCC ou Clang

```c
// Projet exclusivement Linux
// Compil√© avec GCC/Clang
#include "cleanup_patterns.h"

void fonction_linux(void) {
    _cleanup_free_ char *buffer = malloc(1024);
    _cleanup_close_ int fd = open("/proc/cpuinfo", O_RDONLY);
    // ...
}
```

**Contexte :**
- Applications serveur Linux
- Outils syst√®me
- D√©mons
- Projets systemd/GLib

---

#### 2. Code avec nombreux points de sortie

```c
// Fonction avec gestion d'erreurs complexe
int traiter_donnees(Data *input) {
    _cleanup_free_ char *temp1 = malloc(1000);
    _cleanup_free_ char *temp2 = malloc(2000);
    _cleanup_free_ char *result = malloc(3000);

    if (!temp1 || !temp2 || !result) return -ENOMEM;

    if (input->type == TYPE_A) {
        if (process_type_a(input, temp1) < 0) return -EINVAL;
    } else if (input->type == TYPE_B) {
        if (process_type_b(input, temp2) < 0) return -EINVAL;
    } else {
        return -ENOTSUP;
    }

    if (validate(temp1, temp2) < 0) return -EBADMSG;
    if (combine(temp1, temp2, result) < 0) return -EFAULT;

    return save_result(result);
    // 6 points de sortie, 0 lignes de cleanup manuel
}
```

---

#### 3. Nouveau projet o√π vous contr√¥lez l'environnement

```c
// Nouveau projet, toolchain moderne, Linux
// Pas de contraintes de portabilit√© legacy

// Dockerfile
FROM gcc:latest
COPY . /app
RUN gcc -o app app.c

// .devcontainer.json
{
    "image": "gcc:latest",
    "features": {
        "cleanup": "enabled"
    }
}
```

---

### ‚ùå N'utilisez PAS cleanup quand :

#### 1. Code multi-compilateur critique

```c
// ‚ùå MAUVAIS : Biblioth√®que publique
// Doit compiler avec MSVC, GCC, Clang, ICC, etc.

// cleanup_lib.h (biblioth√®que publique)
// N'utilisez PAS cleanup dans les headers publics !

// ‚úÖ BON : Code portable traditionnel
void *lib_create(void) {
    void *obj = malloc(sizeof(struct lib_object));
    if (!obj) return NULL;
    // ...
    return obj;
}

void lib_destroy(void *obj) {
    if (obj) {
        // Nettoyage manuel
        free(obj);
    }
}
```

---

#### 2. Code embarqu√© avec compilateurs propri√©taires

```c
// Microcontr√¥leurs avec compilateurs sp√©cialis√©s
// (IAR, Keil, Renesas, etc.)

// ‚ùå RISQU√â : cleanup peut ne pas √™tre support√©
_cleanup_free_ uint8_t *buffer = malloc(256);

// ‚úÖ S√õR : gestion manuelle
uint8_t *buffer = malloc(256);
if (buffer) {
    // utilisation
    free(buffer);
}
```

---

#### 3. Standard C strict requis

```c
// Projets avec contraintes de certification
// (Aerospace, Medical, Automotive - MISRA C)

// ‚ùå NON CONFORME : Extension GCC
_cleanup_free_ char *ptr = malloc(100);

// ‚úÖ CONFORME : C standard pur
char *ptr = malloc(100);
if (ptr) {
    // utilisation
    free(ptr);
}
```

---

#### 4. Interactions avec setjmp/longjmp

```c
#include <setjmp.h>

jmp_buf env;

void fonction_critique(void) {
    // ‚ùå DANGEREUX : cleanup ignor√© par longjmp
    _cleanup_free_ char *buffer = malloc(1000);

    if (error) {
        longjmp(env, 1);  // buffer fuite !
    }
}

// ‚úÖ S√õR : gestion manuelle
void fonction_critique_safe(void) {
    char *buffer = malloc(1000);

    if (error) {
        free(buffer);  // Nettoyage explicite
        longjmp(env, 1);
    }

    free(buffer);
}
```

---

## Strat√©gies de Migration

### 1. Migration progressive (code existant)

**Approche :**

1. Identifiez les fonctions √† fort risque de fuites
2. Migrez une fonction √† la fois
3. Testez avec Valgrind apr√®s chaque migration
4. Gardez les anciennes versions en commentaire

```c
// Version 1 : Code original (legacy)
void ancienne_fonction(void) {
    char *buffer = malloc(100);
    FILE *f = fopen("file.txt", "r");

    if (!buffer || !f) {
        if (f) fclose(f);
        free(buffer);
        return;
    }

    // traitement

    fclose(f);
    free(buffer);
}

// Version 2 : Avec cleanup (migr√©)
void nouvelle_fonction(void) {
    _cleanup_free_ char *buffer = malloc(100);
    _cleanup_fclose_ FILE *f = fopen("file.txt", "r");

    if (!buffer || !f) return;

    // traitement
}
```

---

### 2. Approche hybride (biblioth√®que)

**Pattern pour biblioth√®ques avec API publique :**

```c
// lib_public.h - API publique (portable)
#ifndef LIB_PUBLIC_H
#define LIB_PUBLIC_H

// Pas de cleanup dans les headers publics !
typedef struct lib_context lib_context_t;

lib_context_t *lib_create(void);
void lib_destroy(lib_context_t *ctx);
int lib_process(lib_context_t *ctx, const char *input);

#endif
```

```c
// lib_internal.c - Impl√©mentation interne (peut utiliser cleanup)
#include "lib_public.h"
#include "cleanup_patterns.h"  // Interne seulement !

struct lib_context {
    char *buffer;
    int fd;
};

int lib_process(lib_context_t *ctx, const char *input) {
    // ‚úÖ OK : Cleanup dans l'impl√©mentation interne
    _cleanup_free_ char *temp = malloc(1024);

    if (!temp) return -1;

    // traitement

    return 0;
}
```

**Avantages :**
- API publique portable
- Impl√©mentation interne moderne
- Meilleur des deux mondes

---

## D√©tection du Support au Runtime

### Test de disponibilit√©

```c
// feature_detect.h
#ifndef FEATURE_DETECT_H
#define FEATURE_DETECT_H

#if defined(__GNUC__) || defined(__clang__)
    #define HAS_CLEANUP 1
    #define HAS_ATTRIBUTE_CLEANUP 1
#else
    #define HAS_CLEANUP 0
    #define HAS_ATTRIBUTE_CLEANUP 0
#endif

// Fonction pour informer l'utilisateur
static inline void print_features(void) {
    printf("=== Features disponibles ===\n");
    #if HAS_CLEANUP
        printf("‚úÖ cleanup automatique : Oui\n");
    #else
        printf("‚ùå cleanup automatique : Non\n");
    #endif
}

#endif
```

---

## Alternatives √† cleanup

### 1. Macros de scope guard

```c
// Simple scope guard (portable)
#define SCOPE_EXIT \
    for (int _i = 1; _i; _i = 0)

void exemple_scope_guard(void) {
    char *buffer = malloc(100);

    SCOPE_EXIT {
        free(buffer);
        printf("Nettoyage effectu√©\n");
    }

    // Code qui peut √©chouer
    if (erreur) {
        return;  // Scope guard PAS ex√©cut√© !
    }
}
```

**Probl√®me :** Ne fonctionne que pour un nettoyage unique et pas sur `return` pr√©matur√©.

---

### 2. Wrapper de fonctions

```c
// Pattern wrapper pour √©viter cleanup
typedef void (*cleanup_fn)(void *);

typedef struct {
    void *resource;
    cleanup_fn cleanup;
} ManagedResource;

void managed_run(void *resource, cleanup_fn cleanup,
                 void (*action)(void *)) {
    action(resource);
    cleanup(resource);  // Toujours appel√©
}

// Utilisation
void ma_fonction_cleanup(void *ptr) {
    free(ptr);
}

void ma_fonction_action(void *ptr) {
    char *buffer = (char *)ptr;
    // Utiliser buffer
}

void exemple(void) {
    char *buffer = malloc(100);
    managed_run(buffer, ma_fonction_cleanup, ma_fonction_action);
}
```

**Inconv√©nients :** Tr√®s verbeux, difficile √† maintenir.

---

### 3. Pool d'allocation (arena)

```c
// Alternative : Allouer depuis un pool, lib√©rer tout √† la fin
typedef struct {
    char *memory;
    size_t used;
    size_t capacity;
} Arena;

void *arena_alloc(Arena *a, size_t size) {
    if (a->used + size > a->capacity) return NULL;
    void *ptr = a->memory + a->used;
    a->used += size;
    return ptr;
}

void arena_free_all(Arena *a) {
    free(a->memory);
    a->used = 0;
}

void fonction_avec_arena(void) {
    Arena arena = {0};
    arena.memory = malloc(10000);
    arena.capacity = 10000;

    // Allouer plusieurs fois
    char *a = arena_alloc(&arena, 100);
    char *b = arena_alloc(&arena, 200);
    char *c = arena_alloc(&arena, 300);

    // Utilisation

    // Une seule lib√©ration pour tout
    arena_free_all(&arena);
}
```

**Avantages :**
- Performance (pas de free individuels)
- Simple
- Portable

**Inconv√©nients :**
- Toutes les allocations ont la m√™me dur√©e de vie
- Pas adapt√© √† tous les cas

---

## Recommandations Finales

### Arbre de d√©cision

```
Votre code doit-il √™tre portable sur Windows/MSVC ?
‚îú‚îÄ OUI ‚Üí N'utilisez PAS cleanup
‚îÇ         Utilisez goto cleanup ou wrapper functions
‚îÇ
‚îî‚îÄ NON ‚Üí Votre code utilise setjmp/longjmp ?
         ‚îú‚îÄ OUI ‚Üí N'utilisez PAS cleanup
         ‚îÇ         G√©rez manuellement les ressources
         ‚îÇ
         ‚îî‚îÄ NON ‚Üí Vous d√©veloppez pour Linux/UNIX ?
                  ‚îú‚îÄ OUI ‚Üí ‚úÖ Utilisez cleanup !
                  ‚îÇ         C'est parfait pour votre cas
                  ‚îÇ
                  ‚îî‚îÄ NON ‚Üí √âvaluez votre toolchain
                           Testez le support de cleanup
```

---

### Guide pratique

**üü¢ Utilisez cleanup sans h√©siter :**
- Projets Linux/UNIX exclusifs
- Applications serveur
- Outils syst√®me
- Code moderne avec GCC/Clang
- Projets inspir√©s de systemd/GLib

**üü° Utilisez avec pr√©caution :**
- Biblioth√®ques avec API publique (interne OK, publique NON)
- Code avec certaines parties portables
- Projets avec plusieurs targets

**üî¥ √âvitez cleanup :**
- Code Windows/MSVC
- Projets multi-compilateurs critiques
- Code embarqu√© avec compilateurs propri√©taires
- Code avec setjmp/longjmp
- Standards stricts (MISRA-C, certification)

---

## M√©triques de Portabilit√©

### Test de compatibilit√©

```bash
#!/bin/bash
# test_cleanup_support.sh

cat > test_cleanup.c << 'EOF'
#include <stdlib.h>

static void cleanup(void **p) {
    free(*p);
}

int main(void) {
    __attribute__((cleanup(cleanup))) char *ptr = malloc(10);
    return 0;
}
EOF

# Test avec diff√©rents compilateurs
for compiler in gcc clang icc tcc; do
    if command -v $compiler &> /dev/null; then
        echo -n "Test $compiler: "
        if $compiler test_cleanup.c -o test_cleanup 2>/dev/null; then
            echo "‚úÖ Support√©"
        else
            echo "‚ùå Non support√©"
        fi
    fi
done

rm -f test_cleanup.c test_cleanup
```

---

## R√©sum√©

### Points cl√©s

| Aspect | D√©tail |
|--------|--------|
| **Standard** | ‚ùå Extension GCC, pas dans C standard |
| **GCC/Clang** | ‚úÖ Pleinement support√© et stable |
| **MSVC** | ‚ùå Non support√© |
| **Performance** | ‚úÖ Aucun overhead |
| **setjmp/longjmp** | ‚ùå Incompatible, cleanup ignor√© |
| **Structures** | ‚ùå Membres non support√©s |
| **Variables globales** | ‚ùå Non support√© |
| **Portabilit√©** | ‚ö†Ô∏è Linux/UNIX uniquement |

---

### Alternatives portables

1. **goto cleanup** (recommand√© pour portabilit√©)
2. **Wrapper functions** (verbeux mais s√ªr)
3. **Arena allocation** (cas sp√©cifiques)
4. **Code dupliqu√© avec #ifdef** (maintien difficile)

---

### Verdict final

`__attribute__((cleanup))` est une **excellente fonctionnalit√©** pour :
- ‚úÖ Code Linux/UNIX moderne
- ‚úÖ Projets avec toolchain contr√¥l√©
- ‚úÖ Am√©liorer la qualit√© du code C

Mais **ce n'est pas une solution universelle** pour :
- ‚ùå Code portable multi-plateforme
- ‚ùå Biblioth√®ques publiques critiques
- ‚ùå Environnements contraints

**Conseil :** Si vous d√©veloppez pour Linux avec GCC/Clang, utilisez cleanup ! Si vous avez des contraintes de portabilit√©, documentez-les clairement et choisissez l'approche appropri√©e.

---

**üìö Ressources compl√©mentaires :**
- [GCC Attribute Syntax](https://gcc.gnu.org/onlinedocs/gcc/Attribute-Syntax.html)
- [Clang Language Extensions](https://clang.llvm.org/docs/LanguageExtensions.html)
- [MISRA C:2012 Guidelines](https://www.misra.org.uk/)
- [Linux Kernel Coding Style](https://www.kernel.org/doc/html/latest/process/coding-style.html) (n'utilise pas cleanup)

**üîç Points d'attention :**
- Testez toujours sur votre toolchain cible
- Documentez vos choix d'architecture
- Pr√©parez des fallbacks si n√©cessaire
- Utilisez des tests automatis√©s pour v√©rifier la portabilit√©

‚è≠Ô∏è [Custom allocators](/24-gestion-memoire-avancee/02-custom-allocators.md)
