üîù Retour au [Sommaire](/SOMMAIRE.md)

# 34.2.2 Expressions r√©guli√®res

## Introduction

Les expressions r√©guli√®res (regex) sont des motifs de recherche puissants qui permettent de trouver, extraire et valider des patterns dans du texte. Pour un parser de logs, elles sont indispensables : les logs contiennent souvent des formats structur√©s (dates, IPs, URLs, codes d'erreur) qu'on doit extraire et analyser.

**Exemple typique de ligne de log :**
```
2025-01-15 14:30:45 [ERROR] 192.168.1.100 - Failed to connect to database (timeout=30s)
```

Avec une regex, on peut extraire :
- La date et l'heure : `2025-01-15 14:30:45`
- Le niveau : `ERROR`
- L'adresse IP : `192.168.1.100`
- Le message d'erreur
- Le timeout : `30`

---

## 1. Bases des expressions r√©guli√®res

### 1.1 Syntaxe fondamentale

Avant d'utiliser les regex en C, comprenons la syntaxe de base :

**Caract√®res litt√©raux :**
```
abc         # Correspond exactement √† "abc"  
hello       # Correspond √† "hello"  
```

**M√©tacaract√®res sp√©ciaux :**
```
.           # N'importe quel caract√®re (sauf \n)
^           # D√©but de ligne
$           # Fin de ligne
\           # √âchappement (ex: \. pour un point litt√©ral)
```

**Quantificateurs :**
```
*           # 0 ou plus occurrences
+           # 1 ou plus occurrences
?           # 0 ou 1 occurrence
{n}         # Exactement n occurrences
{n,}        # Au moins n occurrences
{n,m}       # Entre n et m occurrences
```

**Classes de caract√®res :**
```
[abc]       # Un caract√®re parmi a, b ou c
[a-z]       # Une lettre minuscule
[A-Z]       # Une lettre majuscule
[0-9]       # Un chiffre
[^abc]      # N'importe quel caract√®re SAUF a, b ou c
```

**Classes pr√©d√©finies (POSIX) :**
```
[:digit:]   # Chiffre (0-9)
[:alpha:]   # Lettre (a-z, A-Z)
[:alnum:]   # Alphanum√©rique
[:space:]   # Espace blanc
[:upper:]   # Majuscule
[:lower:]   # Minuscule
```

**Groupes et captures :**
```
(abc)       # Groupe capturant
(?:abc)     # Groupe non-capturant (pas en POSIX de base)
|           # Alternative (ou logique)
```

### 1.2 Exemples pratiques

**Adresse IP :**
```regex
[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}
```

**Date ISO (YYYY-MM-DD) :**
```regex
[0-9]{4}-[0-9]{2}-[0-9]{2}
```

**Heure (HH:MM:SS) :**
```regex
[0-9]{2}:[0-9]{2}:[0-9]{2}
```

**Adresse email simple :**
```regex
[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}
```

**Niveau de log :**
```regex
\[(DEBUG|INFO|WARN|ERROR|FATAL)\]
```

---

## 2. Expressions r√©guli√®res en C : POSIX regex

### 2.1 Biblioth√®que regex.h

En C, on utilise la biblioth√®que POSIX `regex.h` qui fournit des fonctions pour compiler et utiliser des regex.

**Fonctions principales :**
- `regcomp()` : Compiler une regex
- `regexec()` : Ex√©cuter une recherche
- `regerror()` : Obtenir un message d'erreur
- `regfree()` : Lib√©rer la regex compil√©e

### 2.2 Structure de base

```c
#include <stdio.h>
#include <regex.h>
#include <string.h>

int main() {
    regex_t regex;
    int ret;

    // 1. Compiler la regex
    const char *pattern = "[0-9]+";
    ret = regcomp(&regex, pattern, REG_EXTENDED);

    if (ret != 0) {
        fprintf(stderr, "Erreur de compilation de la regex\n");
        return 1;
    }

    // 2. Tester sur une cha√Æne
    const char *texte = "Il y a 42 pommes";
    ret = regexec(&regex, texte, 0, NULL, 0);

    if (ret == 0) {
        printf("Match trouv√©!\n");
    } else if (ret == REG_NOMATCH) {
        printf("Pas de match\n");
    }

    // 3. Lib√©rer la regex
    regfree(&regex);

    return 0;
}
```

### 2.3 Flags de compilation

```c
// REG_EXTENDED : Utiliser la syntaxe √©tendue (recommand√©)
regcomp(&regex, pattern, REG_EXTENDED);

// REG_ICASE : Ignorer la casse
regcomp(&regex, pattern, REG_EXTENDED | REG_ICASE);

// REG_NOSUB : Pas besoin des positions de capture
regcomp(&regex, pattern, REG_EXTENDED | REG_NOSUB);

// REG_NEWLINE : ^ et $ correspondent aux d√©buts/fins de ligne
regcomp(&regex, pattern, REG_EXTENDED | REG_NEWLINE);
```

---

## 3. Extraction de donn√©es avec des groupes

### 3.1 Capturer des sous-cha√Ænes

Pour extraire des parties du texte, on utilise des groupes capturants et `regmatch_t` :

```c
#include <stdio.h>
#include <regex.h>
#include <string.h>

int main() {
    regex_t regex;
    regmatch_t matches[10];  // Tableau pour stocker les captures

    // Pattern avec groupes capturants (parenth√®ses)
    const char *pattern = "([0-9]{4})-([0-9]{2})-([0-9]{2})";

    if (regcomp(&regex, pattern, REG_EXTENDED) != 0) {
        fprintf(stderr, "Erreur compilation regex\n");
        return 1;
    }

    const char *texte = "Date: 2025-01-15";

    // Ex√©cuter avec captures
    if (regexec(&regex, texte, 10, matches, 0) == 0) {
        printf("Match complet: %.*s\n",
               (int)(matches[0].rm_eo - matches[0].rm_so),
               texte + matches[0].rm_so);

        // Groupe 1: Ann√©e
        printf("Ann√©e: %.*s\n",
               (int)(matches[1].rm_eo - matches[1].rm_so),
               texte + matches[1].rm_so);

        // Groupe 2: Mois
        printf("Mois: %.*s\n",
               (int)(matches[2].rm_eo - matches[2].rm_so),
               texte + matches[2].rm_so);

        // Groupe 3: Jour
        printf("Jour: %.*s\n",
               (int)(matches[3].rm_eo - matches[3].rm_so),
               texte + matches[3].rm_so);
    }

    regfree(&regex);
    return 0;
}
```

**Sortie :**
```
Match complet: 2025-01-15  
Ann√©e: 2025  
Mois: 01  
Jour: 15  
```

### 3.2 Structure regmatch_t

```c
typedef struct {
    regoff_t rm_so;  // D√©but du match (offset)
    regoff_t rm_eo;  // Fin du match (offset)
} regmatch_t;

// rm_so = -1 signifie "pas de match"
// La longueur du match = rm_eo - rm_so
```

### 3.3 Fonction utilitaire d'extraction

```c
#include <stdlib.h>
#include <string.h>

// Extraire une sous-cha√Æne captur√©e
char *extraire_capture(const char *texte, regmatch_t *match) {
    if (match->rm_so == -1) {
        return NULL;
    }

    size_t longueur = match->rm_eo - match->rm_so;
    char *resultat = malloc(longueur + 1);

    if (resultat == NULL) {
        return NULL;
    }

    strncpy(resultat, texte + match->rm_so, longueur);
    resultat[longueur] = '\0';

    return resultat;
}

// Utilisation
regmatch_t matches[10];  
if (regexec(&regex, texte, 10, matches, 0) == 0) {  
    char *annee = extraire_capture(texte, &matches[1]);
    printf("Ann√©e: %s\n", annee);
    free(annee);
}
```

---

## 4. Parser une ligne de log compl√®te

### 4.1 Format de log typique

Prenons un format de log Apache/Nginx :

```
192.168.1.100 - - [15/Jan/2025:14:30:45 +0000] "GET /api/users HTTP/1.1" 200 1234
```

Composants √† extraire :
1. IP : `192.168.1.100`
2. Date : `15/Jan/2025:14:30:45 +0000`
3. M√©thode HTTP : `GET`
4. URL : `/api/users`
5. Code statut : `200`
6. Taille : `1234`

### 4.2 Impl√©mentation compl√®te

```c
#include <stdio.h>
#include <stdlib.h>
#include <regex.h>
#include <string.h>

typedef struct {
    char ip[16];
    char date[32];
    char methode[8];
    char url[256];
    int code_statut;
    long taille;
} LogEntry;

int parser_ligne_log(const char *ligne, LogEntry *entry) {
    regex_t regex;
    regmatch_t matches[7];

    // Pattern pour log Apache/Nginx
    const char *pattern =
        "^([0-9.]+) "                          // IP (groupe 1)
        "[^ ]+ [^ ]+ "                          // identit√© et user
        "\\[([^]]+)\\] "                       // Date (groupe 2)
        "\"([A-Z]+) "                          // M√©thode HTTP (groupe 3)
        "([^ ]+) "                              // URL (groupe 4)
        "[^\"]+\" "                             // Version HTTP
        "([0-9]+) "                             // Code statut (groupe 5)
        "([0-9]+)";                             // Taille (groupe 6)

    if (regcomp(&regex, pattern, REG_EXTENDED) != 0) {
        return -1;
    }

    if (regexec(&regex, ligne, 7, matches, 0) != 0) {
        regfree(&regex);
        return -1;
    }

    // Extraire IP
    snprintf(entry->ip, sizeof(entry->ip), "%.*s",
             (int)(matches[1].rm_eo - matches[1].rm_so),
             ligne + matches[1].rm_so);

    // Extraire date
    snprintf(entry->date, sizeof(entry->date), "%.*s",
             (int)(matches[2].rm_eo - matches[2].rm_so),
             ligne + matches[2].rm_so);

    // Extraire m√©thode
    snprintf(entry->methode, sizeof(entry->methode), "%.*s",
             (int)(matches[3].rm_eo - matches[3].rm_so),
             ligne + matches[3].rm_so);

    // Extraire URL
    snprintf(entry->url, sizeof(entry->url), "%.*s",
             (int)(matches[4].rm_eo - matches[4].rm_so),
             ligne + matches[4].rm_so);

    // Extraire code statut (conversion en int)
    char code_str[8];
    snprintf(code_str, sizeof(code_str), "%.*s",
             (int)(matches[5].rm_eo - matches[5].rm_so),
             ligne + matches[5].rm_so);
    entry->code_statut = atoi(code_str);

    // Extraire taille
    char taille_str[16];
    snprintf(taille_str, sizeof(taille_str), "%.*s",
             (int)(matches[6].rm_eo - matches[6].rm_so),
             ligne + matches[6].rm_so);
    entry->taille = atol(taille_str);

    regfree(&regex);
    return 0;
}

int main() {
    const char *ligne =
        "192.168.1.100 - - [15/Jan/2025:14:30:45 +0000] "
        "\"GET /api/users HTTP/1.1\" 200 1234";

    LogEntry entry;

    if (parser_ligne_log(ligne, &entry) == 0) {
        printf("IP: %s\n", entry.ip);
        printf("Date: %s\n", entry.date);
        printf("M√©thode: %s\n", entry.methode);
        printf("URL: %s\n", entry.url);
        printf("Code: %d\n", entry.code_statut);
        printf("Taille: %ld octets\n", entry.taille);
    } else {
        printf("Erreur de parsing\n");
    }

    return 0;
}
```

**Sortie :**
```
IP: 192.168.1.100  
Date: 15/Jan/2025:14:30:45 +0000  
M√©thode: GET  
URL: /api/users  
Code: 200  
Taille: 1234 octets  
```

---

## 5. Patterns courants pour les logs

### 5.1 Formats de date et heure

```c
// ISO 8601: 2025-01-15T14:30:45Z
const char *pattern_iso8601 =
    "[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}Z?";

// Format Apache: 15/Jan/2025:14:30:45 +0000
const char *pattern_apache_date =
    "[0-9]{2}/[A-Za-z]{3}/[0-9]{4}:[0-9]{2}:[0-9]{2}:[0-9]{2} [+-][0-9]{4}";

// Syslog: Jan 15 14:30:45
const char *pattern_syslog =
    "[A-Z][a-z]{2} [ 0-9][0-9] [0-9]{2}:[0-9]{2}:[0-9]{2}";

// Format personnalis√©: 2025-01-15 14:30:45.123
const char *pattern_custom =
    "[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}\\.[0-9]{3}";
```

### 5.2 Adresses IP et r√©seau

```c
// IPv4
const char *pattern_ipv4 =
    "[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}";

// IPv6 (simplifi√©)
const char *pattern_ipv6 =
    "[0-9a-fA-F:]+";

// Port
const char *pattern_port =
    ":[0-9]{1,5}";

// IP:Port
const char *pattern_ip_port =
    "([0-9.]+):([0-9]+)";
```

### 5.3 Niveaux de log

```c
// Niveaux standards
const char *pattern_niveau =
    "\\[(DEBUG|INFO|WARN|WARNING|ERROR|FATAL|CRITICAL)\\]";

// Ou sans crochets
const char *pattern_niveau_simple =
    "(DEBUG|INFO|WARN|ERROR)";

// Avec timestamp
const char *pattern_log_complet =
    "([0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}) "
    "\\[([A-Z]+)\\] "
    "(.+)";
```

### 5.4 URLs et chemins

```c
// URL HTTP(S)
const char *pattern_url =
    "https?://[a-zA-Z0-9.-]+(/[^ ]*)?";

// Chemin de fichier Unix
const char *pattern_chemin_unix =
    "/[a-zA-Z0-9_/./-]+";

// Chemin de fichier Windows
const char *pattern_chemin_windows =
    "[A-Z]:\\\\[a-zA-Z0-9_\\\\/-]+";
```

### 5.5 Codes d'erreur et statuts

```c
// Code HTTP
const char *pattern_http_code =
    " [0-9]{3} ";  // 200, 404, 500, etc.

// Code d'erreur syst√®me
const char *pattern_errno =
    "errno=([0-9]+)";

// Statut de processus
const char *pattern_exit_code =
    "exit code ([0-9]+)";
```

---

## 6. Recherche et remplacement

### 6.1 Trouver toutes les occurrences

Pour trouver tous les matches dans un texte :

```c
#include <stdio.h>
#include <regex.h>

void trouver_tous_matches(const char *texte, const char *pattern) {
    regex_t regex;
    regmatch_t match;

    if (regcomp(&regex, pattern, REG_EXTENDED) != 0) {
        return;
    }

    const char *p = texte;
    int offset = 0;
    int count = 0;

    while (regexec(&regex, p, 1, &match, 0) == 0) {
        count++;

        // Afficher le match
        printf("Match %d √† position %d: %.*s\n",
               count,
               offset + (int)match.rm_so,
               (int)(match.rm_eo - match.rm_so),
               p + match.rm_so);

        // Avancer apr√®s ce match
        offset += match.rm_eo;
        p += match.rm_eo;

        // √âviter boucle infinie sur match vide
        if (match.rm_so == match.rm_eo) {
            offset++;
            p++;
        }
    }

    printf("Total matches: %d\n", count);
    regfree(&regex);
}

// Exemple
int main() {
    const char *texte = "IPs: 192.168.1.1, 10.0.0.1, 172.16.0.1";
    trouver_tous_matches(texte, "[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}");
    return 0;
}
```

### 6.2 Extraction de toutes les IPs d'un log

```c
#include <stdio.h>
#include <stdlib.h>
#include <regex.h>
#include <string.h>

#define MAX_IPS 1000

int extraire_ips(const char *texte, char ips[][16], int max_ips) {
    regex_t regex;
    regmatch_t match;
    const char *pattern = "[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}";

    if (regcomp(&regex, pattern, REG_EXTENDED) != 0) {
        return 0;
    }

    const char *p = texte;
    int count = 0;

    while (count < max_ips && regexec(&regex, p, 1, &match, 0) == 0) {
        // Copier l'IP trouv√©e
        int longueur = match.rm_eo - match.rm_so;
        strncpy(ips[count], p + match.rm_so, longueur);
        ips[count][longueur] = '\0';
        count++;

        // Avancer
        p += match.rm_eo;
    }

    regfree(&regex);
    return count;
}

int main() {
    const char *log =
        "192.168.1.100 connected\n"
        "10.0.0.5 disconnected\n"
        "172.16.0.1 timeout\n";

    char ips[MAX_IPS][16];
    int nb_ips = extraire_ips(log, ips, MAX_IPS);

    printf("IPs trouv√©es: %d\n", nb_ips);
    for (int i = 0; i < nb_ips; i++) {
        printf("  %s\n", ips[i]);
    }

    return 0;
}
```

---

## 7. Gestion des erreurs

### 7.1 Messages d'erreur d√©taill√©s

```c
#include <stdio.h>
#include <stdlib.h>
#include <regex.h>

void afficher_erreur_regex(int errcode, regex_t *regex) {
    size_t taille = regerror(errcode, regex, NULL, 0);
    char *buffer = malloc(taille);

    if (buffer != NULL) {
        regerror(errcode, regex, buffer, taille);
        fprintf(stderr, "Erreur regex: %s\n", buffer);
        free(buffer);
    }
}

int main() {
    regex_t regex;

    // Pattern invalide (parenth√®se non ferm√©e)
    const char *pattern = "([0-9]+";

    int ret = regcomp(&regex, pattern, REG_EXTENDED);
    if (ret != 0) {
        afficher_erreur_regex(ret, &regex);
        return 1;
    }

    regfree(&regex);
    return 0;
}
```

### 7.2 Validation de patterns

```c
#include <regex.h>

int valider_pattern(const char *pattern) {
    regex_t regex;
    int ret = regcomp(&regex, pattern, REG_EXTENDED | REG_NOSUB);

    if (ret == 0) {
        regfree(&regex);
        return 1;  // Valide
    }

    return 0;  // Invalide
}

// Utilisation
if (!valider_pattern("[0-9]+")) {
    fprintf(stderr, "Pattern invalide\n");
}
```

---

## 8. Optimisation des performances

### 8.1 R√©utilisation de regex compil√©es

```c
// ‚ùå LENT : Recompiler √† chaque fois
void traiter_lignes_lent(char **lignes, int nb_lignes) {
    for (int i = 0; i < nb_lignes; i++) {
        regex_t regex;
        regcomp(&regex, "[0-9]+", REG_EXTENDED);
        regexec(&regex, lignes[i], 0, NULL, 0);
        regfree(&regex);
    }
}

// ‚úÖ RAPIDE : Compiler une fois
void traiter_lignes_rapide(char **lignes, int nb_lignes) {
    regex_t regex;
    regcomp(&regex, "[0-9]+", REG_EXTENDED);

    for (int i = 0; i < nb_lignes; i++) {
        regexec(&regex, lignes[i], 0, NULL, 0);
    }

    regfree(&regex);
}
```

### 8.2 √âviter les regex quand possible

Pour des patterns simples, les fonctions de cha√Ænes standard sont plus rapides :

```c
#include <string.h>

// ‚ùå Regex pour recherche simple
regex_t regex;  
regcomp(&regex, "ERROR", REG_EXTENDED);  
regexec(&regex, ligne, 0, NULL, 0);  

// ‚úÖ strstr() est beaucoup plus rapide
if (strstr(ligne, "ERROR") != NULL) {
    // Trouv√©
}

// ‚úÖ Pour comparer le d√©but
if (strncmp(ligne, "ERROR", 5) == 0) {
    // Ligne commence par ERROR
}
```

### 8.3 REG_NOSUB quand on n'a pas besoin des captures

```c
// Si on veut juste savoir si √ßa matche (pas besoin d'extraire)
regex_t regex;  
regcomp(&regex, pattern, REG_EXTENDED | REG_NOSUB);  

// Plus rapide car pas de calcul des positions
if (regexec(&regex, texte, 0, NULL, 0) == 0) {
    // Match trouv√©
}
```

### 8.4 Benchmark : regex vs strstr

```c
#include <stdio.h>
#include <string.h>
#include <regex.h>
#include <time.h>

#define ITERATIONS 100000

int main() {
    const char *texte = "2025-01-15 ERROR Something went wrong";
    clock_t debut, fin;

    // Test avec regex
    regex_t regex;
    regcomp(&regex, "ERROR", REG_EXTENDED | REG_NOSUB);

    debut = clock();
    for (int i = 0; i < ITERATIONS; i++) {
        regexec(&regex, texte, 0, NULL, 0);
    }
    fin = clock();

    double temps_regex = (double)(fin - debut) / CLOCKS_PER_SEC;
    printf("Regex: %.3f secondes\n", temps_regex);
    regfree(&regex);

    // Test avec strstr
    debut = clock();
    for (int i = 0; i < ITERATIONS; i++) {
        (void)strstr(texte, "ERROR");
    }
    fin = clock();

    double temps_strstr = (double)(fin - debut) / CLOCKS_PER_SEC;
    printf("strstr: %.3f secondes\n", temps_strstr);
    printf("Ratio: %.1fx plus rapide\n", temps_regex / temps_strstr);

    return 0;
}
```

**R√©sultat typique :**
```
Regex: 0.250 secondes  
strstr: 0.015 secondes  
Ratio: 16.7x plus rapide  
```

---

## 9. Alternatives aux regex POSIX

### 9.1 Biblioth√®que PCRE (Perl Compatible Regular Expressions)

PCRE est plus puissante et performante que POSIX regex :

**Installation :**
```bash
sudo apt-get install libpcre3-dev
```

**Exemple basique :**
```c
#include <stdio.h>
#include <string.h>
#include <pcre.h>

int main() {
    const char *error;
    int erroffset;

    // Compiler la regex
    pcre *re = pcre_compile(
        "(\\d{4})-(\\d{2})-(\\d{2})",  // Pattern
        0,                              // Options
        &error,
        &erroffset,
        NULL
    );

    if (re == NULL) {
        fprintf(stderr, "Erreur PCRE: %s\n", error);
        return 1;
    }

    const char *texte = "Date: 2025-01-15";
    int ovector[30];  // Tableau pour les captures

    int rc = pcre_exec(
        re,             // Regex compil√©e
        NULL,           // Pas d'extra
        texte,          // Texte
        strlen(texte),  // Longueur
        0,              // Offset de d√©part
        0,              // Options
        ovector,        // Tableau de sortie
        30              // Taille du tableau
    );

    if (rc > 0) {
        printf("Matches trouv√©s: %d\n", rc);

        // Extraire les captures
        for (int i = 0; i < rc; i++) {
            int start = ovector[2*i];
            int end = ovector[2*i+1];
            printf("Capture %d: %.*s\n", i, end - start, texte + start);
        }
    }

    pcre_free(re);
    return 0;
}
```

**Compiler :**
```bash
gcc -o programme programme.c -lpcre
```

**Avantages de PCRE :**
- ‚úÖ Plus rapide
- ‚úÖ Syntaxe plus riche (lookahead, lookbehind, etc.)
- ‚úÖ Meilleur support Unicode
- ‚úÖ Plus largement utilis√©

### 9.2 RE2 (Google)

RE2 est une biblioth√®que C++ tr√®s performante et s√ªre (pas de catastrophic backtracking).

```cpp
// Exemple en C++
#include <re2/re2.h>
#include <iostream>

int main() {
    std::string texte = "Date: 2025-01-15";
    std::string annee, mois, jour;

    if (RE2::PartialMatch(texte, "(\\d{4})-(\\d{2})-(\\d{2})",
                          &annee, &mois, &jour)) {
        std::cout << "Ann√©e: " << annee << std::endl;
        std::cout << "Mois: " << mois << std::endl;
        std::cout << "Jour: " << jour << std::endl;
    }

    return 0;
}
```

---

## 10. Cas d'usage pratiques

### 10.1 Filtrer les erreurs dans un log

```c
#include <stdio.h>
#include <regex.h>
#include <string.h>

void filtrer_erreurs(const char *fichier_log) {
    FILE *fp = fopen(fichier_log, "r");
    if (fp == NULL) {
        perror("fopen");
        return;
    }

    regex_t regex;
    const char *pattern = "\\[(ERROR|FATAL)\\]";

    if (regcomp(&regex, pattern, REG_EXTENDED) != 0) {
        fclose(fp);
        return;
    }

    char ligne[1024];
    int nb_erreurs = 0;

    while (fgets(ligne, sizeof(ligne), fp) != NULL) {
        if (regexec(&regex, ligne, 0, NULL, 0) == 0) {
            printf("%s", ligne);
            nb_erreurs++;
        }
    }

    printf("\nTotal erreurs: %d\n", nb_erreurs);

    regfree(&regex);
    fclose(fp);
}
```

### 10.2 Compter les requ√™tes par code HTTP

```c
#include <stdio.h>
#include <stdlib.h>
#include <regex.h>
#include <string.h>

typedef struct {
    int code;
    int count;
} CodeCount;

void analyser_codes_http(const char *fichier_log) {
    FILE *fp = fopen(fichier_log, "r");
    if (fp == NULL) return;

    regex_t regex;
    regmatch_t matches[2];

    // Chercher " XXX " (code HTTP)
    const char *pattern = "\" ([0-9]{3}) ";
    regcomp(&regex, pattern, REG_EXTENDED);

    CodeCount codes[10] = {0};
    int nb_codes = 0;

    char ligne[2048];

    while (fgets(ligne, sizeof(ligne), fp) != NULL) {
        if (regexec(&regex, ligne, 2, matches, 0) == 0) {
            // Extraire le code
            char code_str[4];
            int len = matches[1].rm_eo - matches[1].rm_so;
            strncpy(code_str, ligne + matches[1].rm_so, len);
            code_str[len] = '\0';

            int code = atoi(code_str);

            // Incr√©menter le compteur
            int trouve = 0;
            for (int i = 0; i < nb_codes; i++) {
                if (codes[i].code == code) {
                    codes[i].count++;
                    trouve = 1;
                    break;
                }
            }

            if (!trouve && nb_codes < 10) {
                codes[nb_codes].code = code;
                codes[nb_codes].count = 1;
                nb_codes++;
            }
        }
    }

    // Afficher les r√©sultats
    printf("Statistiques codes HTTP:\n");
    for (int i = 0; i < nb_codes; i++) {
        printf("  %d: %d requ√™tes\n", codes[i].code, codes[i].count);
    }

    regfree(&regex);
    fclose(fp);
}
```

### 10.3 Extraire les IPs uniques

```c
#include <stdio.h>
#include <stdlib.h>
#include <regex.h>
#include <string.h>

#define MAX_IPS 10000

typedef struct {
    char ip[16];
    int count;
} IPCount;

void analyser_ips(const char *fichier_log) {
    FILE *fp = fopen(fichier_log, "r");
    if (fp == NULL) return;

    regex_t regex;
    regmatch_t match;
    const char *pattern = "^([0-9.]+)";

    regcomp(&regex, pattern, REG_EXTENDED);

    IPCount *ips = calloc(MAX_IPS, sizeof(IPCount));
    int nb_ips = 0;

    char ligne[2048];

    while (fgets(ligne, sizeof(ligne), fp) != NULL) {
        if (regexec(&regex, ligne, 1, &match, 0) == 0) {
            char ip[16];
            int len = match.rm_eo - match.rm_so;
            strncpy(ip, ligne + match.rm_so, len);
            ip[len] = '\0';

            // Chercher si l'IP existe d√©j√†
            int trouve = 0;
            for (int i = 0; i < nb_ips; i++) {
                if (strcmp(ips[i].ip, ip) == 0) {
                    ips[i].count++;
                    trouve = 1;
                    break;
                }
            }

            if (!trouve && nb_ips < MAX_IPS) {
                strcpy(ips[nb_ips].ip, ip);
                ips[nb_ips].count = 1;
                nb_ips++;
            }
        }
    }

    // Afficher les IPs les plus fr√©quentes
    printf("Top 10 IPs:\n");
    for (int i = 0; i < (nb_ips < 10 ? nb_ips : 10); i++) {
        printf("  %s: %d requ√™tes\n", ips[i].ip, ips[i].count);
    }

    free(ips);
    regfree(&regex);
    fclose(fp);
}
```

---

## 11. R√©capitulatif

### 11.1 Quand utiliser les regex

‚úÖ **Utiliser regex quand :**
- Pattern complexe (dates, emails, URLs)
- Besoin d'extraire des sous-parties
- Validation de format
- Patterns variables

‚ùå **Ne PAS utiliser regex quand :**
- Recherche simple de cha√Æne fixe ‚Üí `strstr()`
- Comparaison de pr√©fixe ‚Üí `strncmp()`
- Recherche de caract√®re ‚Üí `strchr()`
- Performance critique sur gros volume

### 11.2 Fonctions essentielles

| Fonction | Usage |
|----------|-------|
| `regcomp()` | Compiler une regex |
| `regexec()` | Tester/chercher un match |
| `regerror()` | Obtenir message d'erreur |
| `regfree()` | Lib√©rer la regex |

### 11.3 Flags importants

| Flag | Effet |
|------|-------|
| `REG_EXTENDED` | Syntaxe √©tendue (recommand√©) |
| `REG_ICASE` | Ignorer la casse |
| `REG_NOSUB` | Pas de captures (plus rapide) |
| `REG_NEWLINE` | `^` et `$` pour chaque ligne |

### 11.4 Patterns courants √† m√©moriser

```c
// IP
"[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}"

// Date ISO
"[0-9]{4}-[0-9]{2}-[0-9]{2}"

// Heure
"[0-9]{2}:[0-9]{2}:[0-9]{2}"

// Email
"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}"

// URL
"https?://[a-zA-Z0-9.-]+(/[^ ]*)?"
```

---

## 12. Conclusion

Les expressions r√©guli√®res sont un outil puissant mais √† utiliser avec discernement :

**Points cl√©s :**
1. **Compiler une fois** : R√©utiliser les regex compil√©es
2. **Privil√©gier les fonctions simples** : `strstr()` est souvent suffisant
3. **Valider les patterns** : Tester sur des donn√©es r√©elles
4. **G√©rer les erreurs** : Utiliser `regerror()` pour le debug
5. **Choisir la bonne biblioth√®que** : POSIX pour la portabilit√©, PCRE pour la performance

Pour un parser de logs haute performance, l'approche optimale est souvent un m√©lange :
- Recherches simples avec `strstr()`/`strncmp()`
- Regex compil√©es r√©utilis√©es pour les patterns complexes
- Parsing manuel pour les formats tr√®s fixes

Dans la section suivante (34.2.3), nous verrons comment combiner lecture efficace de fichiers et regex pour cr√©er un syst√®me d'agr√©gation et de statistiques complet sur les logs.

‚è≠Ô∏è [Agr√©gation et statistiques](/34-etudes-cas-devops/02.3-agregation-statistiques.md)
