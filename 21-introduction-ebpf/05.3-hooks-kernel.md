ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 21.5.3 Attacher Ã  des hooks kernel

## Introduction

Dans les sections prÃ©cÃ©dentes, nous avons utilisÃ© un **tracepoint** (`tp/syscalls/sys_enter_execve`) pour intercepter les appels systÃ¨me. Mais eBPF offre bien plus de possibilitÃ©s ! Le kernel Linux expose de nombreux **points d'accroche** (hooks) oÃ¹ vous pouvez attacher vos programmes eBPF.

Dans cette section, nous allons explorer les diffÃ©rents types de hooks disponibles, comprendre quand utiliser chacun d'eux, et voir des exemples pratiques. Chaque type de hook a ses avantages et ses cas d'usage spÃ©cifiques.

## Vue d'ensemble des hooks eBPF

Imaginez le kernel Linux comme une grande usine avec de nombreuses portes et fenÃªtres par lesquelles vous pouvez observer ce qui se passe Ã  l'intÃ©rieur. eBPF vous permet de placer des "observateurs" Ã  ces diffÃ©rents endroits :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    KERNEL LINUX                         â”‚
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ Tracepoints â”‚  â”‚   Kprobes    â”‚  â”‚   Kretprobes â”‚    â”‚
â”‚  â”‚ Points fixesâ”‚  â”‚Fonctions     â”‚  â”‚Retours de    â”‚    â”‚
â”‚  â”‚ prÃ©dÃ©finis  â”‚  â”‚kernel        â”‚  â”‚fonctions     â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚         â”‚                â”‚                 â”‚            â”‚
â”‚         â†“                â†“                 â†“            â”‚
â”‚  [Votre code eBPF s'exÃ©cute ici]                        â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  ESPACE UTILISATEUR                     â”‚
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚   Uprobes    â”‚  â”‚   USDT       â”‚  â”‚   Uretprobes â”‚   â”‚
â”‚  â”‚ Fonctions    â”‚  â”‚ Tracepoints  â”‚  â”‚ Retours de   â”‚   â”‚
â”‚  â”‚ userspace    â”‚  â”‚ userspace    â”‚  â”‚ fonctions    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Les principaux types de hooks

| Type | StabilitÃ© | Performance | Usage typique |
|------|-----------|-------------|---------------|
| **Tracepoints** | âœ… Stable (API garantie) | âš¡ Excellent | Appels systÃ¨me, Ã©vÃ©nements kernel |
| **Kprobes** | âš ï¸ Instable (peut changer) | âš¡ Bon | N'importe quelle fonction kernel |
| **Kretprobes** | âš ï¸ Instable | âš¡ Bon | Retour de fonctions kernel |
| **Uprobes** | âš ï¸ DÃ©pend du binaire | âš¡ Moyen | Fonctions en espace utilisateur |
| **USDT** | âœ… Stable (si fourni) | âš¡ Bon | Points de trace applicatifs |
| **Raw tracepoints** | âš ï¸ Moins stable | âš¡ Excellent | Performance maximale |
| **Fentry/Fexit** | âœ… Stable (rÃ©cent) | âš¡ Excellent | Alternative moderne aux kprobes |
| **LSM** | âœ… Stable | âš¡ Excellent | SÃ©curitÃ© (Linux Security Modules) |
| **XDP** | âœ… Stable | âš¡ Ultra-rapide | Traitement rÃ©seau bas niveau |

## 1. Tracepoints : Les points d'entrÃ©e stables

### Qu'est-ce qu'un tracepoint ?

Les **tracepoints** sont des points d'instrumentation **prÃ©dÃ©finis** et **stables** dans le kernel Linux. Ils sont placÃ©s stratÃ©giquement par les dÃ©veloppeurs du kernel Ã  des endroits importants (appels systÃ¨me, scheduling, I/O, rÃ©seau, etc.).

**Avantages :**
- âœ… API stable : Ne changent pas entre les versions du kernel
- âœ… Documentation : Bien documentÃ©s
- âœ… Performance : Overhead minimal
- âœ… Arguments structurÃ©s : DonnÃ©es accessibles facilement

**InconvÃ©nients :**
- âŒ LimitÃ©s : Seulement oÃ¹ les dÃ©veloppeurs les ont placÃ©s
- âŒ Pas de personnalisation : Vous ne pouvez pas ajouter vos propres tracepoints

### DÃ©couvrir les tracepoints disponibles

```bash
# Lister tous les tracepoints
sudo ls /sys/kernel/debug/tracing/events/

# Exemples de catÃ©gories :
# - syscalls/     (appels systÃ¨me)
# - sched/        (ordonnancement)
# - net/          (rÃ©seau)
# - block/        (I/O disque)
# - kmem/         (mÃ©moire)
# - signal/       (signaux)
```

Pour voir les tracepoints d'une catÃ©gorie :

```bash
# Tracepoints des appels systÃ¨me
sudo ls /sys/kernel/debug/tracing/events/syscalls/

# Tracepoints du scheduler
sudo ls /sys/kernel/debug/tracing/events/sched/
```

Pour voir les dÃ©tails d'un tracepoint :

```bash
# Format des arguments de sys_enter_open
sudo cat /sys/kernel/debug/tracing/events/syscalls/sys_enter_open/format
```

Sortie exemple :
```
name: sys_enter_open  
ID: 623  
format:  
    field:unsigned short common_type;
    field:unsigned char common_flags;
    field:unsigned char common_preempt_count;
    field:int common_pid;

    field:int __syscall_nr;
    field:const char * filename;
    field:int flags;
    field:umode_t mode;
```

### Exemple : Tracer les ouvertures de fichiers

```c
// opensnoop.bpf.c
#include <linux/bpf.h>
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>

char LICENSE[] SEC("license") = "GPL";

// Structure pour stocker les informations d'ouverture
struct open_event {
    __u32 pid;
    __u32 uid;
    char comm[16];
    char filename[256];
    int flags;
};

struct {
    __uint(type, BPF_MAP_TYPE_RINGBUF);
    __uint(max_entries, 256 * 1024);
} events SEC(".maps");

SEC("tp/syscalls/sys_enter_open")  
int trace_open_enter(struct trace_event_raw_sys_enter *ctx)  
{
    struct open_event *event;

    // RÃ©server de l'espace dans le ring buffer
    event = bpf_ringbuf_reserve(&events, sizeof(*event), 0);
    if (!event) {
        return 0;
    }

    // Remplir la structure
    event->pid = bpf_get_current_pid_tgid() >> 32;
    event->uid = bpf_get_current_uid_gid();
    bpf_get_current_comm(&event->comm, sizeof(event->comm));

    // Lire le nom du fichier depuis les arguments du syscall
    // ctx->args[0] contient le pointeur vers le filename
    bpf_probe_read_user_str(&event->filename, sizeof(event->filename),
                            (void *)ctx->args[0]);
    event->flags = ctx->args[1];

    // Envoyer l'Ã©vÃ©nement
    bpf_ringbuf_submit(event, 0);

    return 0;
}
```

**Points importants :**
- `struct trace_event_raw_sys_enter *ctx` : Structure contenant les arguments de l'appel systÃ¨me
- `ctx->args[0]` : Premier argument (`filename`)
- `ctx->args[1]` : DeuxiÃ¨me argument (`flags`)
- `bpf_probe_read_user_str()` : Lit une chaÃ®ne depuis l'espace utilisateur en toute sÃ©curitÃ©

### Tracepoints courants

```c
// Tracer la crÃ©ation de processus
SEC("tp/sched/sched_process_fork")  
int trace_fork(struct trace_event_raw_sched_process_fork *ctx)  
{
    __u32 parent_pid = ctx->parent_pid;
    __u32 child_pid = ctx->child_pid;
    bpf_printk("Fork: parent=%d, child=%d\n", parent_pid, child_pid);
    return 0;
}

// Tracer la fin de processus
SEC("tp/sched/sched_process_exit")  
int trace_exit(struct trace_event_raw_sched_process_template *ctx)  
{
    __u32 pid = bpf_get_current_pid_tgid() >> 32;
    bpf_printk("Exit: PID=%d\n", pid);
    return 0;
}

// Tracer les allocations mÃ©moire
SEC("tp/kmem/kmalloc")  
int trace_kmalloc(struct trace_event_raw_kmem_alloc *ctx)  
{
    size_t bytes_req = ctx->bytes_req;
    bpf_printk("kmalloc: %lu bytes\n", bytes_req);
    return 0;
}
```

## 2. Kprobes : Instrumenter n'importe quelle fonction kernel

### Qu'est-ce qu'un kprobe ?

Les **kprobes** (kernel probes) vous permettent d'attacher du code eBPF Ã  **n'importe quelle fonction** du kernel Linux, mÃªme celles qui n'ont pas de tracepoint.

**Avantages :**
- âœ… FlexibilitÃ© totale : N'importe quelle fonction kernel
- âœ… Puissant : AccÃ¨s aux arguments et variables locales

**InconvÃ©nients :**
- âŒ Instable : Les noms/signatures de fonctions peuvent changer entre versions kernel
- âŒ Plus difficile : NÃ©cessite de connaÃ®tre les internals du kernel
- âŒ Pas toujours portable : Code spÃ©cifique Ã  une version kernel

### DÃ©couvrir les fonctions kernel disponibles

```bash
# Lister toutes les fonctions kernel que vous pouvez instrumenter
sudo cat /proc/kallsyms | grep ' T ' | head -20

# Exemples :
# ffffffffa1234567 T tcp_sendmsg
# ffffffffa1234568 T tcp_recvmsg
# ffffffffa1234569 T do_sys_open
```

### Exemple : Tracer tcp_sendmsg

```c
// tcpsnoop.bpf.c
#include <linux/bpf.h>
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>

char LICENSE[] SEC("license") = "GPL";

// Attacher Ã  la fonction tcp_sendmsg du kernel
SEC("kprobe/tcp_sendmsg")  
int BPF_KPROBE(trace_tcp_send, struct sock *sk, struct msghdr *msg, size_t size)  
{
    __u32 pid = bpf_get_current_pid_tgid() >> 32;

    // sk contient les informations de la socket
    // size contient le nombre d'octets envoyÃ©s

    bpf_printk("TCP send: PID=%d, bytes=%lu\n", pid, size);

    return 0;
}
```

**Macro BPF_KPROBE :**
Cette macro simplifie l'accÃ¨s aux arguments de la fonction. Sans elle, vous devriez utiliser `PT_REGS_PARM1(ctx)`, `PT_REGS_PARM2(ctx)`, etc.

### Kretprobe : Intercepter le retour d'une fonction

Les **kretprobes** s'attachent au **retour** d'une fonction, ce qui vous permet de capturer la valeur de retour.

```c
// Tracer le retour de do_sys_open
SEC("kretprobe/do_sys_open")  
int BPF_KRETPROBE(trace_open_return, long ret)  
{
    __u32 pid = bpf_get_current_pid_tgid() >> 32;

    // ret contient le file descriptor (ou -errno en cas d'erreur)
    if (ret < 0) {
        bpf_printk("open failed: PID=%d, errno=%ld\n", pid, -ret);
    } else {
        bpf_printk("open success: PID=%d, fd=%ld\n", pid, ret);
    }

    return 0;
}
```

### Combiner kprobe et kretprobe

Pattern courant : Mesurer la durÃ©e d'une fonction.

```c
struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 10240);
    __type(key, __u32);    // PID
    __type(value, __u64);  // Timestamp de dÃ©but
} start_times SEC(".maps");

SEC("kprobe/vfs_read")  
int BPF_KPROBE(trace_read_enter)  
{
    __u64 pid_tgid = bpf_get_current_pid_tgid();
    __u32 pid = pid_tgid >> 32;
    __u64 ts = bpf_ktime_get_ns();

    bpf_map_update_elem(&start_times, &pid, &ts, BPF_ANY);
    return 0;
}

SEC("kretprobe/vfs_read")  
int BPF_KRETPROBE(trace_read_exit, ssize_t ret)  
{
    __u64 pid_tgid = bpf_get_current_pid_tgid();
    __u32 pid = pid_tgid >> 32;
    __u64 *start_ts;

    start_ts = bpf_map_lookup_elem(&start_times, &pid);
    if (!start_ts) {
        return 0;
    }

    __u64 duration_ns = bpf_ktime_get_ns() - *start_ts;
    __u64 duration_us = duration_ns / 1000;

    bpf_printk("vfs_read: PID=%d, duration=%llu Âµs, bytes=%ld\n",
               pid, duration_us, ret);

    bpf_map_delete_elem(&start_times, &pid);
    return 0;
}
```

## 3. Fentry/Fexit : Alternative moderne aux kprobes

### Qu'est-ce que fentry/fexit ?

Introduits dans les kernels rÃ©cents (>= 5.5), **fentry** et **fexit** sont des alternatives plus performantes et plus sÃ»res aux kprobes/kretprobes.

**Avantages sur kprobes :**
- âœ… Plus rapide : Pas de breakpoint, attachement direct
- âœ… Plus sÃ»r : VÃ©rification plus stricte par le verifier
- âœ… AccÃ¨s direct aux arguments : Pas besoin de PT_REGS
- âœ… Moins d'overhead

**InconvÃ©nients :**
- âŒ NÃ©cessite un kernel rÃ©cent (>= 5.5)
- âŒ NÃ©cessite BTF (BPF Type Format) activÃ©

### VÃ©rifier si votre kernel supporte fentry/fexit

```bash
# VÃ©rifier si BTF est activÃ©
ls /sys/kernel/btf/vmlinux

# Si le fichier existe, vous pouvez utiliser fentry/fexit
```

### Exemple : MÃªme fonctionnalitÃ© avec fentry/fexit

```c
// Version moderne avec fentry/fexit
SEC("fentry/tcp_sendmsg")  
int BPF_PROG(trace_tcp_send_entry, struct sock *sk, struct msghdr *msg, size_t size)  
{
    __u32 pid = bpf_get_current_pid_tgid() >> 32;
    bpf_printk("TCP send: PID=%d, bytes=%lu\n", pid, size);
    return 0;
}

SEC("fexit/tcp_sendmsg")  
int BPF_PROG(trace_tcp_send_exit, struct sock *sk, struct msghdr *msg, size_t size, int ret)  
{
    __u32 pid = bpf_get_current_pid_tgid() >> 32;
    bpf_printk("TCP send done: PID=%d, ret=%d\n", pid, ret);
    return 0;
}
```

**DiffÃ©rence clÃ© :** Avec `fexit`, vous avez accÃ¨s Ã  la fois aux **arguments d'entrÃ©e** et Ã  la **valeur de retour** !

## 4. Uprobes : Instrumenter des programmes userspace

### Qu'est-ce qu'un uprobe ?

Les **uprobes** (user probes) permettent d'attacher du code eBPF Ã  des **fonctions dans l'espace utilisateur** (programmes, bibliothÃ¨ques).

**Cas d'usage :**
- Tracer des fonctions dans vos propres applications
- Instrumenter des bibliothÃ¨ques (libc, OpenSSL, etc.)
- Profiler des applications sans modifier leur code

### Exemple : Tracer les appels Ã  malloc() dans libc

```c
// malloc_trace.bpf.c
#include <linux/bpf.h>
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>

char LICENSE[] SEC("license") = "GPL";

// Attacher Ã  la fonction malloc de la libc
SEC("uprobe//lib/x86_64-linux-gnu/libc.so.6:malloc")  
int trace_malloc_enter(struct pt_regs *ctx)  
{
    size_t size = PT_REGS_PARM1(ctx);  // Premier argument = taille
    __u32 pid = bpf_get_current_pid_tgid() >> 32;

    bpf_printk("malloc: PID=%d, size=%lu\n", pid, size);
    return 0;
}

// Tracer le retour de malloc (pour avoir l'adresse allouÃ©e)
SEC("uretprobe//lib/x86_64-linux-gnu/libc.so.6:malloc")  
int trace_malloc_exit(struct pt_regs *ctx)  
{
    void *ptr = (void *)PT_REGS_RC(ctx);  // Valeur de retour
    __u32 pid = bpf_get_current_pid_tgid() >> 32;

    bpf_printk("malloc returned: PID=%d, ptr=%p\n", pid, ptr);
    return 0;
}
```

**Comment attacher :**

Depuis userspace, vous devez spÃ©cifier le chemin du binaire/bibliothÃ¨que :

```c
// Dans le code userspace
struct bpf_link *link;

// Attacher Ã  malloc dans libc
link = bpf_program__attach_uprobe(
    skel->progs.trace_malloc_enter,
    false,  // false = uprobe (true = uretprobe)
    -1,     // -1 = tous les processus
    "/lib/x86_64-linux-gnu/libc.so.6",
    0       // Offset (0 = rÃ©solution automatique du symbole "malloc")
);
```

### Trouver l'offset d'une fonction

Si le symbole n'est pas disponible, vous devez trouver l'offset manuellement :

```bash
# Avec objdump
objdump -t /lib/x86_64-linux-gnu/libc.so.6 | grep malloc

# Avec nm
nm -D /lib/x86_64-linux-gnu/libc.so.6 | grep malloc

# Sortie exemple :
# 00000000000a1234 T malloc
```

L'offset est `0xa1234`.

### Tracer vos propres applications

```c
// myapp.c
#include <stdio.h>

void my_function(int x, const char *str) {
    printf("my_function called: x=%d, str=%s\n", x, str);
}

int main() {
    my_function(42, "hello");
    return 0;
}
```

Compiler avec symboles de debug :
```bash
gcc -g myapp.c -o myapp
```

Programme eBPF :
```c
SEC("uprobe/./myapp:my_function")  
int trace_my_function(struct pt_regs *ctx)  
{
    int x = PT_REGS_PARM1(ctx);
    char str[64];
    bpf_probe_read_user_str(str, sizeof(str), (void *)PT_REGS_PARM2(ctx));

    bpf_printk("my_function: x=%d, str=%s\n", x, str);
    return 0;
}
```

## 5. USDT : Tracepoints dans l'espace utilisateur

### Qu'est-ce que USDT ?

**USDT** (User Statically-Defined Tracing) sont des tracepoints placÃ©s **par les dÃ©veloppeurs** dans leurs applications. C'est l'Ã©quivalent userspace des tracepoints kernel.

**Applications avec USDT :**
- Node.js
- Python
- Ruby
- PostgreSQL
- MySQL
- Java (via JVM)

### DÃ©couvrir les USDT disponibles

```bash
# Lister les USDT d'un binaire
sudo bpftrace -l 'usdt:/usr/bin/python3:*'

# Exemples de sortie :
# usdt:/usr/bin/python3:python:function__entry
# usdt:/usr/bin/python3:python:function__return
# usdt:/usr/bin/python3:python:gc__start
```

### Exemple : Tracer les appels de fonctions Python

```c
SEC("usdt//usr/bin/python3:python:function__entry")  
int trace_python_function(struct pt_regs *ctx)  
{
    // Les arguments sont spÃ©cifiques Ã  chaque USDT
    // Pour python:function__entry :
    // arg0 = filename
    // arg1 = function name
    // arg2 = line number

    char funcname[64];
    bpf_usdt_readarg_p(1, ctx, &funcname, sizeof(funcname));

    bpf_printk("Python function called: %s\n", funcname);
    return 0;
}
```

## 6. Hooks spÃ©cialisÃ©s

### XDP (eXpress Data Path) : Traitement rÃ©seau ultra-rapide

**XDP** permet de traiter les paquets rÃ©seau **avant** qu'ils n'entrent dans la pile rÃ©seau du kernel. C'est le point d'accroche le plus rapide possible.

```c
SEC("xdp")  
int xdp_drop_icmp(struct xdp_md *ctx)  
{
    void *data_end = (void *)(long)ctx->data_end;
    void *data = (void *)(long)ctx->data;

    struct ethhdr *eth = data;

    // VÃ©rifier qu'on a assez de donnÃ©es
    if ((void *)(eth + 1) > data_end) {
        return XDP_PASS;
    }

    // Dropper tous les paquets ICMP
    if (eth->h_proto == bpf_htons(ETH_P_IP)) {
        struct iphdr *ip = (void *)(eth + 1);
        if ((void *)(ip + 1) > data_end) {
            return XDP_PASS;
        }

        if (ip->protocol == IPPROTO_ICMP) {
            return XDP_DROP;  // Drop le paquet
        }
    }

    return XDP_PASS;  // Laisser passer le paquet
}
```

**Valeurs de retour XDP :**
- `XDP_PASS` : Continuer le traitement normal
- `XDP_DROP` : Dropper le paquet
- `XDP_TX` : Renvoyer le paquet sur la mÃªme interface
- `XDP_REDIRECT` : Rediriger vers une autre interface

**Attacher un programme XDP :**
```bash
# Avec ip
sudo ip link set dev eth0 xdp obj xdp_prog.o

# DÃ©tacher
sudo ip link set dev eth0 xdp off
```

### TC (Traffic Control) : Filtrage rÃ©seau avancÃ©

```c
SEC("tc")  
int tc_ingress(struct __sk_buff *skb)  
{
    // Traiter les paquets entrants
    return TC_ACT_OK;
}
```

### LSM (Linux Security Modules) : Hooks de sÃ©curitÃ©

Depuis Linux 5.7, vous pouvez attacher eBPF aux hooks LSM pour implÃ©menter des politiques de sÃ©curitÃ©.

```c
SEC("lsm/file_open")  
int BPF_PROG(file_open_hook, struct file *file)  
{
    // Autoriser ou refuser l'ouverture de fichiers
    // selon vos critÃ¨res

    char filename[256];
    bpf_probe_read_kernel_str(filename, sizeof(filename),
                              file->f_path.dentry->d_name.name);

    // Bloquer l'ouverture de /etc/shadow par exemple
    if (bpf_strncmp(filename, 10, "shadow") == 0) {
        return -EPERM;  // Permission denied
    }

    return 0;  // Autoriser
}
```

## Comment choisir le bon type de hook ?

### Arbre de dÃ©cision

```
Que voulez-vous tracer ?
â”‚
â”œâ”€ Appel systÃ¨me ?
â”‚  â””â”€ Utilisez un TRACEPOINT (tp/syscalls/...)
â”‚     â†’ Stable, performant, bien documentÃ©
â”‚
â”œâ”€ Fonction kernel spÃ©cifique ?
â”‚  â”œâ”€ Kernel rÃ©cent (>= 5.5) avec BTF ?
â”‚  â”‚  â””â”€ Utilisez FENTRY/FEXIT
â”‚  â”‚     â†’ Plus rapide, plus sÃ»r
â”‚  â””â”€ Kernel ancien ?
â”‚     â””â”€ Utilisez KPROBE/KRETPROBE
â”‚        â†’ Fonctionne partout, mais instable
â”‚
â”œâ”€ Fonction dans une application/bibliothÃ¨que ?
â”‚  â”œâ”€ L'application a des USDT ?
â”‚  â”‚  â””â”€ Utilisez USDT
â”‚  â”‚     â†’ Stable, supportÃ© par l'application
â”‚  â””â”€ Pas de USDT ?
â”‚     â””â”€ Utilisez UPROBE/URETPROBE
â”‚        â†’ Flexible mais peut casser entre versions
â”‚
â”œâ”€ Traitement rÃ©seau ultra-rapide ?
â”‚  â””â”€ Utilisez XDP
â”‚     â†’ Le plus rapide possible
â”‚
â”œâ”€ SÃ©curitÃ© et contrÃ´le d'accÃ¨s ?
â”‚  â””â”€ Utilisez LSM
â”‚     â†’ IntÃ©gration avec la sÃ©curitÃ© Linux
â”‚
â””â”€ Ã‰vÃ©nements systÃ¨me gÃ©nÃ©raux ?
   â””â”€ Utilisez TRACEPOINTS (tp/sched/, tp/net/, etc.)
      â†’ Large couverture, stable
```

## Techniques avancÃ©es : Filtrage et optimisation

### Filtrage prÃ©coce

Filtrez les Ã©vÃ©nements le plus tÃ´t possible pour minimiser l'overhead :

```c
SEC("tp/syscalls/sys_enter_open")  
int trace_open(struct trace_event_raw_sys_enter *ctx)  
{
    __u32 pid = bpf_get_current_pid_tgid() >> 32;

    // Filtrer : seulement les PIDs > 1000 (exclure les processus systÃ¨me)
    if (pid <= 1000) {
        return 0;
    }

    // Filtrer : seulement notre UID
    __u32 uid = bpf_get_current_uid_gid();
    if (uid != 1000) {
        return 0;
    }

    // Traitement...
    return 0;
}
```

### Utiliser tail calls pour organiser le code

Les **tail calls** permettent de chaÃ®ner des programmes eBPF (utile pour contourner la limite de taille).

```c
struct {
    __uint(type, BPF_MAP_TYPE_PROG_ARRAY);
    __uint(max_entries, 10);
    __type(key, __u32);
    __type(value, __u32);
} prog_array SEC(".maps");

SEC("tp/syscalls/sys_enter_open")  
int main_prog(struct trace_event_raw_sys_enter *ctx)  
{
    // Faire un tail call vers un autre programme
    bpf_tail_call(ctx, &prog_array, 0);

    // Ce code ne sera jamais exÃ©cutÃ© si le tail call rÃ©ussit
    return 0;
}

SEC("tp/syscalls/sys_enter_open")  
int sub_prog(struct trace_event_raw_sys_enter *ctx)  
{
    // Suite du traitement
    bpf_printk("Sub program executed\n");
    return 0;
}
```

## Debugging et inspection

### Voir les programmes attachÃ©s

```bash
# Lister tous les programmes eBPF
sudo bpftool prog list

# Voir les dÃ©tails d'un programme
sudo bpftool prog show id 123

# Voir le type d'attachement
sudo bpftool prog show id 123 --json | jq '.attach_type'
```

### Voir les points d'attachement actifs

```bash
# Avec bpftrace
sudo bpftrace -l 'kprobe:*' | wc -l    # Nombre de kprobes disponibles  
sudo bpftrace -l 'tracepoint:*' | head # Premiers tracepoints  

# Avec perf
sudo perf list | grep Tracepoint
```

### DÃ©tacher un programme

```c
// Depuis userspace
bpf_link__destroy(link);

// Ou simplement arrÃªter le programme userspace
// Les programmes eBPF sont automatiquement dÃ©tachÃ©s
```

## Limites et considÃ©rations

### Limites de taille de code

Les programmes eBPF ont des limites :
- **Historiquement** : 4096 instructions BPF
- **Aujourd'hui** (kernel >= 5.2) : 1 million d'instructions (avec complexitÃ© vÃ©rifiÃ©e)

Si vous dÃ©passez, utilisez :
- Des **tail calls** pour diviser le code
- Des **fonctions BPF** (inlining automatique)

### Overhead et performance

**Impact minimal** :
- Tracepoints : ~100-200 ns d'overhead
- Fentry/Fexit : ~50-100 ns
- Kprobes : ~200-500 ns

**Impact notable** :
- Uprobes : ~1-2 Âµs (nÃ©cessite un context switch partiel)

**Conseil** : Mesurez toujours l'impact dans votre environnement avec `perf stat`.

### SÃ©curitÃ©

- Les programmes eBPF s'exÃ©cutent avec les **privilÃ¨ges kernel**
- Le **verifier** vÃ©rifie la sÃ»retÃ©, mais ne peut pas tout dÃ©tecter
- Testez en environnement isolÃ© d'abord

## RÃ©sumÃ©

Vous avez maintenant une vue complÃ¨te des diffÃ©rents types de hooks eBPF :

| Hook | Quand utiliser | StabilitÃ© | Performance |
|------|----------------|-----------|-------------|
| **Tracepoints** | Ã‰vÃ©nements systÃ¨me standards | â­â­â­ | â­â­â­ |
| **Kprobes** | N'importe quelle fonction kernel (ancien) | â­ | â­â­ |
| **Fentry/Fexit** | N'importe quelle fonction kernel (moderne) | â­â­â­ | â­â­â­ |
| **Uprobes** | Fonctions userspace | â­ | â­ |
| **USDT** | Applications avec support natif | â­â­â­ | â­â­ |
| **XDP** | Traitement rÃ©seau trÃ¨s rapide | â­â­â­ | â­â­â­ |
| **LSM** | SÃ©curitÃ© | â­â­â­ | â­â­â­ |

**Recommandations gÃ©nÃ©rales :**

- âœ… **PrivilÃ©giez les tracepoints** quand ils existent (stable et performant)
- âœ… **Utilisez fentry/fexit** pour les kernels rÃ©cents (meilleur que kprobes)
- âœ… **Ã‰vitez uprobes** si possible (overhead Ã©levÃ©)
- âœ… **Utilisez USDT** si l'application le supporte (stable et documentÃ©)
- âœ… **Filtrez tÃ´t** pour minimiser l'overhead
- âœ… **Testez l'impact** sur les performances dans votre environnement

**Prochaine Ã©tape :** Maintenant que vous maÃ®trisez les diffÃ©rents hooks, la prochaine section vous montrera comment construire des outils d'observabilitÃ© complets en combinant ces techniques.

## Ressources complÃ©mentaires

- **Liste des tracepoints :** `sudo bpftrace -l`
- **Documentation BPF :** https://www.kernel.org/doc/html/latest/bpf/
- **BPF helpers reference :** https://man7.org/linux/man-pages/man7/bpf-helpers.7.html
- **Brendan Gregg's blog :** http://www.brendangregg.com/ebpf.html
- **Livre "BPF Performance Tools"** par Brendan Gregg

---

*Note : Les exemples de cette section supposent un kernel Linux >= 5.8. Sur des versions plus anciennes, certaines fonctionnalitÃ©s (fentry/fexit, LSM) peuvent ne pas Ãªtre disponibles.*

â­ï¸ [eBPF dans l'Ã©cosystÃ¨me moderne](/21-introduction-ebpf/06-ecosysteme-moderne.md)
