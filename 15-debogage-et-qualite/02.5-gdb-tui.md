ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 15.2.5 GDB TUI Mode

## Introduction

Jusqu'Ã  prÃ©sent, vous avez utilisÃ© GDB en **mode ligne de commande** : vous tapez des commandes, GDB affiche des rÃ©sultats en texte brut. C'est puissant, mais cela peut devenir difficile Ã  suivre, surtout quand vous devez constamment taper `list` pour voir le code source, `info registers` pour les registres, etc.

Le **mode TUI** (Text User Interface) transforme GDB en une interface **semi-graphique** directement dans votre terminal. Il divise l'Ã©cran en plusieurs **fenÃªtres** (ou panneaux) qui affichent simultanÃ©ment :
- Le **code source** avec une ligne mise en surbrillance
- Le **dÃ©sassemblage** (instructions assembleur)
- Les **registres** du processeur
- La **fenÃªtre de commandes** GDB

Le mode TUI vous permet de **voir et dÃ©boguer** de maniÃ¨re beaucoup plus intuitive, tout en restant dans votre terminal prÃ©fÃ©rÃ©.

### Analogie

Imaginez que vous dÃ©boguez avec un GPS :
- **Mode ligne de commande** : Vous entendez seulement des instructions vocales ("tournez Ã  gauche dans 100m")
- **Mode TUI** : Vous voyez la carte, votre position actuelle, et vous entendez les instructions

Le mode TUI ne remplace pas les commandes GDB - il les **complÃ¨te** en vous donnant une vue visuelle de ce qui se passe.

---

## 1. Activer le Mode TUI

### MÃ©thode 1 : Depuis GDB

Si GDB est dÃ©jÃ  lancÃ© :

```gdb
(gdb) tui enable
```

Ou utilisez le raccourci clavier : **Ctrl+X puis A**

### MÃ©thode 2 : Au DÃ©marrage

Lancer GDB directement en mode TUI :

```bash
gdb -tui ./programme
```

### DÃ©sactiver le Mode TUI

Pour revenir au mode ligne de commande :

```gdb
(gdb) tui disable
```

Ou Ã  nouveau : **Ctrl+X puis A** (toggle)

### Premier Contact

DÃ¨s que vous activez le mode TUI, votre terminal ressemble Ã  ceci :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ main.c                                   â”‚
â”‚                                          â”‚
â”‚ 5    int main() {                        â”‚
â”‚ 6        int x = 5;                      â”‚
â”‚ 7        int y = 10;                     â”‚
â”‚>8        int somme = x + y;              â”‚  â† Ligne actuelle
â”‚ 9        printf("Somme : %d\n", somme);  â”‚
â”‚ 10       return 0;                       â”‚
â”‚ 11   }                                   â”‚
â”‚                                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ (gdb) _                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

La **ligne actuelle** oÃ¹ GDB est arrÃªtÃ© est marquÃ©e avec `>` et est mise en surbrillance.

---

## 2. Les DiffÃ©rents Layouts (Dispositions)

Le mode TUI propose plusieurs **layouts** (dispositions de fenÃªtres). Vous pouvez basculer entre eux selon vos besoins.

### Layout "src" : Code Source (par dÃ©faut)

```gdb
layout src
```

Affiche uniquement le **code source** C.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          CODE SOURCE                     â”‚
â”‚                                          â”‚
â”‚  Votre code C ici                        â”‚
â”‚                                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚          COMMANDES GDB                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

C'est le layout par dÃ©faut quand vous activez TUI.

### Layout "asm" : Assembleur

```gdb
layout asm
```

Affiche le **code assembleur** (dÃ©sassemblage).

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          CODE ASSEMBLEUR                 â”‚
â”‚                                          â”‚
â”‚  0x555555555149 <main>    push   %rbp    â”‚
â”‚  0x55555555514a <main+1>  mov    %rsp    â”‚
â”‚                                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚          COMMANDES GDB                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Utile pour le dÃ©bogage bas niveau ou l'analyse de performance.

### Layout "split" : Code Source ET Assembleur

```gdb
layout split
```

Affiche les **deux** simultanÃ©ment !

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          CODE SOURCE                     â”‚
â”‚  8    int somme = x + y;                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚          CODE ASSEMBLEUR                 â”‚
â”‚  0x555555555149    mov  -0x8(%rbp),%eax  â”‚
â”‚  0x55555555514c    add  -0x4(%rbp),%eax  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚          COMMANDES GDB                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Vous voyez exactement quelle ligne C correspond Ã  quelles instructions assembleur.

### Layout "regs" : Avec Registres

```gdb
layout regs
```

Ajoute une fenÃªtre montrant les **registres du processeur** en temps rÃ©el :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ rax  0x5    rbx  0x0    rcx  0x7fff...   â”‚
â”‚ rdx  0xa    rsi  0x0    rdi  0x1         â”‚
â”‚ ...                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚          CODE SOURCE                     â”‚
â”‚  8    int somme = x + y;                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚          COMMANDES GDB                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Les registres qui **changent** sont mis en surbrillance automatiquement.

### Layout CombinÃ©s

Vous pouvez combiner `regs` avec d'autres layouts :

```gdb
layout src
layout regs
```

Ou directement :

```gdb
layout split
layout regs
```

Cela affiche registres + source + assembleur !

### Changer de Layout Rapidement

Utilisez **Ctrl+X puis 1** ou **Ctrl+X puis 2** pour basculer entre les layouts.

---

## 3. Navigation dans le Code

### DÃ©filement avec les FlÃ¨ches

En mode TUI, les flÃ¨ches du clavier ont un **double rÃ´le** :

**ProblÃ¨me** : Par dÃ©faut, les flÃ¨ches dÃ©filent dans l'historique des commandes (comme dans le terminal).

**Solution** : Basculer le focus entre la fenÃªtre de code et la fenÃªtre de commandes.

### Basculer le Focus

**Ctrl+X puis O** (lettre O majuscule) : Bascule le focus entre les fenÃªtres.

- Focus sur la **fenÃªtre de code** : Les flÃ¨ches dÃ©filent le code source
- Focus sur la **fenÃªtre de commandes** : Les flÃ¨ches naviguent dans l'historique

### DÃ©filer Manuellement

Quand le focus est sur le code :

- **FlÃ¨che Haut/Bas** : DÃ©file ligne par ligne
- **Page Up/Down** : DÃ©file page par page
- **Home** : Va au dÃ©but du fichier
- **End** : Va Ã  la fin du fichier

### Centrer sur la Ligne Actuelle

Si vous avez dÃ©filÃ© et ne voyez plus la ligne actuelle :

```gdb
update
```

Ou : **Ctrl+L** (rafraÃ®chit l'affichage et centre sur la ligne actuelle)

---

## 4. Raccourcis Clavier Essentiels

Le mode TUI ajoute des raccourcis clavier spÃ©cifiques. La plupart commencent par **Ctrl+X**.

### Raccourcis TUI Principaux

| Raccourci | Action |
|-----------|--------|
| **Ctrl+X puis A** | Active/dÃ©sactive le mode TUI |
| **Ctrl+X puis O** | Change le focus de fenÃªtre |
| **Ctrl+X puis 1** | Layout simple (source ou asm) |
| **Ctrl+X puis 2** | Layout split (source + asm) |
| **Ctrl+L** | RafraÃ®chit l'Ã©cran |

### Utilisation Pratique

**Exemple typique** :

1. Lancez GDB : `gdb -tui ./programme`
2. Placez un breakpoint : `break main`
3. Lancez : `run`
4. Steppez : `next` (la ligne actuelle se dÃ©place visuellement)
5. Changez de layout pour voir l'assembleur : `layout split`
6. Observez les registres : `layout regs`

Vous voyez **tout en temps rÃ©el** : code source, assembleur, registres qui changent !

---

## 5. Travailler en Mode TUI

### Exemple de Session ComplÃ¨te

Prenons ce programme simple :

```c
#include <stdio.h>

int addition(int a, int b) {
    return a + b;
}

int main() {
    int x = 5;
    int y = 10;
    int resultat = addition(x, y);
    printf("RÃ©sultat : %d\n", resultat);
    return 0;
}
```

**Session de dÃ©bogage** :

```bash
$ gdb -tui ./programme
```

Votre Ã©cran montre :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ main.c                                   â”‚
â”‚                                          â”‚
â”‚ 1    #include <stdio.h>                  â”‚
â”‚ 2                                        â”‚
â”‚ 3    int addition(int a, int b) {        â”‚
â”‚ 4        return a + b;                   â”‚
â”‚ 5    }                                   â”‚
â”‚ 6                                        â”‚
â”‚ 7    int main() {                        â”‚
â”‚ 8        int x = 5;                      â”‚
â”‚                                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ (gdb) _                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```gdb
(gdb) break main
Breakpoint 1 at 0x1149: file main.c, line 8.

(gdb) run
Starting program: ./programme
```

L'Ã©cran met Ã  jour automatiquement :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ main.c                                   â”‚
â”‚                                          â”‚
â”‚ 5    }                                   â”‚
â”‚ 6                                        â”‚
â”‚ 7    int main() {                        â”‚
â”‚>8        int x = 5;                      â”‚  â† Ligne actuelle !
â”‚ 9        int y = 10;                     â”‚
â”‚ 10       int resultat = addition(x, y);  â”‚
â”‚ 11       printf("RÃ©sultat : %d\n", res); â”‚
â”‚                                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Breakpoint 1, main () at main.c:8        â”‚
â”‚ (gdb) _                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

La ligne 8 est **mise en surbrillance** avec `>`.

```gdb
(gdb) next
```

L'Ã©cran se met Ã  jour, la surbrillance passe Ã  la ligne 9 :

```
â”‚ 7    int main() {                        â”‚
â”‚ 8        int x = 5;                      â”‚
â”‚>9        int y = 10;                     â”‚  â† Maintenant ici !
â”‚ 10       int resultat = addition(x, y);  â”‚
```

Vous voyez le **flux d'exÃ©cution** visuellement !

```gdb
(gdb) step
```

Vous entrez dans la fonction `addition()` :

```
â”‚ 2                                        â”‚
â”‚ 3    int addition(int a, int b) {        â”‚
â”‚>4        return a + b;                   â”‚  â† Dans la fonction
â”‚ 5    }                                   â”‚
â”‚ 6                                        â”‚
```

### Avantage : Contexte Visuel Permanent

Contrairement au mode ligne de commande oÃ¹ vous devez taper `list` pour voir le code, en mode TUI :
- Le code est **toujours visible**
- La ligne actuelle est **toujours mise en surbrillance**
- Vous voyez le **contexte** (les lignes avant et aprÃ¨s)

---

## 6. Affichage des Registres en Direct

Le layout `regs` est particuliÃ¨rement impressionnant.

### Activer les Registres

```gdb
layout split
layout regs
```

Votre Ã©cran ressemble maintenant Ã  :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ rax  0x5        rbx  0x0       rip  ...  â”‚
â”‚ rcx  0xa        rdx  0x7fff... rsp  ...  â”‚
â”‚ rdi  0x1        rsi  0x0       rbp  ...  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚          CODE SOURCE                     â”‚
â”‚ 8    int x = 5;                          â”‚
â”‚>9    int y = 10;                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚          CODE ASSEMBLEUR                 â”‚
â”‚ 0x1149    mov    $0x5,-0x8(%rbp)         â”‚
â”‚>0x1150    mov    $0xa,-0x4(%rbp)         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ (gdb) _                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Quand vous faites `next`, les registres qui **changent** sont **mis en surbrillance** (souvent en couleur).

### Cas d'Usage

C'est extrÃªmement utile pour :
- Comprendre comment les variables sont stockÃ©es
- Observer les passages de paramÃ¨tres
- DÃ©boguer du code optimisÃ©
- Apprendre l'assembleur

### Types de Registres AffichÃ©s

Par dÃ©faut, GDB affiche les **registres gÃ©nÃ©raux**. Vous pouvez changer :

```gdb
tui reg general    # Registres gÃ©nÃ©raux (rax, rbx, etc.)
tui reg float      # Registres Ã  virgule flottante
tui reg system     # Registres systÃ¨me
tui reg vector     # Registres vectoriels (SSE, AVX)
tui reg all        # Tous les registres
```

---

## 7. Breakpoints et Watchpoints Visuels

### Breakpoints MarquÃ©s

En mode TUI, les breakpoints sont **visuellement marquÃ©s** dans le code source :

```
â”‚ 7    int main() {                        â”‚
â”‚B+8       int x = 5;                      â”‚  â† B+ = Breakpoint actif
â”‚ 9        int y = 10;                     â”‚
â”‚B-10      int resultat = addition(x, y);  â”‚  â† B- = Breakpoint dÃ©sactivÃ©
```

**LÃ©gende** :
- **B+** : Breakpoint actif
- **B-** : Breakpoint dÃ©sactivÃ©
- **>** : Ligne actuelle

### Ajouter un Breakpoint

MÃªme chose qu'avant, mais vous voyez le rÃ©sultat immÃ©diatement :

```gdb
(gdb) break 10
Breakpoint 2 at 0x555555555160: file main.c, line 10.
```

Le `B+` apparaÃ®t instantanÃ©ment sur la ligne 10 dans la fenÃªtre de code.

---

## 8. Commandes SpÃ©cifiques au TUI

### Commandes `tui`

| Commande | Action |
|----------|--------|
| `tui enable` | Active le mode TUI |
| `tui disable` | DÃ©sactive le mode TUI |
| `layout <nom>` | Change le layout (src, asm, split, regs) |
| `focus <fenÃªtre>` | Change le focus (src, asm, regs, cmd) |
| `refresh` | RafraÃ®chit l'affichage |
| `update` | Recentre sur la ligne actuelle |
| `winheight <fenÃªtre> +N` | Augmente la hauteur d'une fenÃªtre de N lignes |
| `winheight <fenÃªtre> -N` | Diminue la hauteur d'une fenÃªtre de N lignes |

### Exemples d'Ajustement

**Agrandir la fenÃªtre de code source** :

```gdb
winheight src +10
```

**RÃ©duire la fenÃªtre de registres** :

```gdb
winheight regs -5
```

**Changer le focus** :

```gdb
focus cmd    # Focus sur la fenÃªtre de commandes
focus src    # Focus sur le code source
```

---

## 9. ProblÃ¨mes Courants et Solutions

### ProblÃ¨me 1 : Affichage Corrompu

**SymptÃ´me** : Les fenÃªtres se chevauchent, le texte est mÃ©langÃ©.

**Cause** : Redimensionnement du terminal, ou sorties de programme qui interfÃ¨rent.

**Solution** : Appuyez sur **Ctrl+L** pour rafraÃ®chir, ou :

```gdb
refresh
```

### ProblÃ¨me 2 : Sortie du Programme Pollue l'Affichage

**SymptÃ´me** : Le `printf()` de votre programme Ã©crit dans la fenÃªtre de code.

**Cause** : Les sorties standard se mÃ©langent avec le TUI.

**Solution 1** : Utilisez une configuration pour rediriger les sorties :

```gdb
tty /dev/pts/X  # Redirige vers un autre terminal
```

**Solution 2** : DÃ©sactivez temporairement le TUI avant d'exÃ©cuter :

```gdb
tui disable
continue
tui enable
```

**Solution 3** : Utilisez `set logging` pour capturer les sorties :

```gdb
set logging file output.txt
set logging on
```

### ProblÃ¨me 3 : Les FlÃ¨ches Ne DÃ©filent Pas le Code

**SymptÃ´me** : Les flÃ¨ches naviguent dans l'historique des commandes au lieu de dÃ©filer le code.

**Cause** : Le focus est sur la fenÃªtre de commandes, pas sur le code.

**Solution** : Appuyez sur **Ctrl+X puis O** pour basculer le focus.

### ProblÃ¨me 4 : Le Code N'ApparaÃ®t Pas

**SymptÃ´me** : La fenÃªtre de code affiche "No Source Available".

**Cause** : Le programme n'a pas Ã©tÃ© compilÃ© avec `-g`.

**Solution** : Recompilez avec les symboles de dÃ©bogage :

```bash
gcc -g -o programme programme.c
```

### ProblÃ¨me 5 : Le Terminal Est Trop Petit

**SymptÃ´me** : Les fenÃªtres sont trop petites pour Ãªtre utiles.

**Solution** : Agrandissez votre terminal Ã  au moins **80x24** caractÃ¨res. IdÃ©alement, **120x40** ou plus pour une meilleure expÃ©rience.

---

## 10. Avantages et Limitations

### Avantages du Mode TUI

- âœ… **Vue contextuelle** : Vous voyez le code en permanence
- âœ… **Suivi visuel** : La ligne actuelle est toujours mise en surbrillance
- âœ… **Breakpoints visibles** : Vous voyez oÃ¹ sont vos points d'arrÃªt
- âœ… **Registres en direct** : Observez les changements en temps rÃ©el
- âœ… **Pas besoin de `list`** : Le code est dÃ©jÃ  affichÃ©
- âœ… **Plus rapide** : Moins de commandes Ã  taper
- âœ… **PÃ©dagogique** : Excellent pour apprendre l'assembleur

### Limitations

- âŒ **Sorties du programme** : Les `printf()` peuvent polluer l'affichage
- âŒ **Taille du terminal** : NÃ©cessite un terminal assez grand
- âŒ **CompatibilitÃ©** : Peut ne pas fonctionner dans tous les Ã©mulateurs de terminal
- âŒ **Affichage corrompu** : Peut nÃ©cessiter des rafraÃ®chissements frÃ©quents
- âŒ **Pas de souris** : Contrairement aux IDE, pas d'interaction Ã  la souris
- âŒ **Courbe d'apprentissage** : Les raccourcis clavier prennent du temps Ã  maÃ®triser

---

## 11. Quand Utiliser le Mode TUI ?

### Utilisez le Mode TUI Pour :

- âœ… **DÃ©bogage interactif** : Stepping ligne par ligne
- âœ… **Analyse de code** : Comprendre le flux d'exÃ©cution
- âœ… **Apprentissage** : Voir la correspondance C â†” assembleur
- âœ… **Petits programmes** : OÃ¹ le code tient dans une fenÃªtre
- âœ… **DÃ©bogage rapide** : Quand vous n'avez pas accÃ¨s Ã  un IDE

### N'Utilisez PAS le Mode TUI Pour :

- âŒ **Programmes avec beaucoup de sorties** : Les `printf()` pollueront l'affichage
- âŒ **TrÃ¨s gros fichiers** : Navigation difficile
- âŒ **Terminaux limitÃ©s** : SSH avec latence, terminaux anciens
- âŒ **DÃ©bogage distant** : Mieux vaut utiliser GDB standard

---

## 12. Comparaison : TUI vs Standard

### Mode Standard

**Avantages** :
- Stable et fiable
- Fonctionne partout
- Sorties du programme propres
- Scriptable facilement

**InconvÃ©nients** :
- NÃ©cessite de taper `list` constamment
- Pas de vue d'ensemble
- Difficile de suivre le flux

### Mode TUI

**Avantages** :
- Vue contextuelle permanente
- Suivi visuel de l'exÃ©cution
- Registres en temps rÃ©el
- Plus intuitif

**InconvÃ©nients** :
- Peut Ãªtre instable
- Sorties du programme problÃ©matiques
- NÃ©cessite un grand terminal

### Recommandation

**DÃ©butants** : Commencez avec le mode standard pour bien comprendre les commandes, puis passez au TUI.

**Utilisateurs avancÃ©s** : Utilisez le TUI pour les sessions interactives, le mode standard pour les scripts et l'automatisation.

---

## 13. Alternatives Modernes au TUI

### GDB Dashboard

**GDB Dashboard** est un script Python qui amÃ©liore considÃ©rablement l'interface de GDB :

```bash
# Installation
wget -P ~ https://git.io/.gdbinit

# Lancement automatique
gdb ./programme
```

**Avantages** :
- Interface beaucoup plus riche
- Couleurs et formatage
- Plusieurs panneaux (code, registres, pile, threads)
- Plus stable que TUI

**InconvÃ©nient** : NÃ©cessite Python.

### GEF (GDB Enhanced Features)

Pour le reverse engineering et l'exploitation binaire :

```bash
# Installation
bash -c "$(curl -fsSL https://gef.blah.cat/sh)"
```

**Avantages** :
- SpÃ©cialisÃ© pour la sÃ©curitÃ©
- Analyse de l'assembleur
- DÃ©tection de protections

### Voltron

Interface graphique pour GDB dans un terminal sÃ©parÃ© :

```bash
pip install voltron
```

Ouvre plusieurs terminaux avec diffÃ©rentes vues (registres, pile, code, etc.).

### CGDB

Un frontend amÃ©liorÃ© pour GDB :

```bash
sudo apt install cgdb
cgdb ./programme
```

Interface similaire Ã  TUI mais plus stable et avec plus de fonctionnalitÃ©s.

### Comparaison

| Outil | ComplexitÃ© | FonctionnalitÃ©s | StabilitÃ© |
|-------|------------|-----------------|-----------|
| TUI natif | â˜…â˜†â˜† | â˜…â˜…â˜† | â˜…â˜…â˜† |
| GDB Dashboard | â˜…â˜…â˜† | â˜…â˜…â˜… | â˜…â˜…â˜… |
| GEF | â˜…â˜…â˜… | â˜…â˜…â˜… | â˜…â˜…â˜… |
| CGDB | â˜…â˜…â˜† | â˜…â˜…â˜† | â˜…â˜…â˜… |

---

## 14. Configuration du TUI

### Fichier `.gdbinit`

Vous pouvez personnaliser GDB avec un fichier `~/.gdbinit` :

```bash
# ~/.gdbinit

# Active TUI automatiquement
#tui enable  # DÃ©commentez si vous le voulez toujours actif

# Layout par dÃ©faut
set tui border-kind ascii
set tui active-border-kind bold

# Historique
set history save on
set history filename ~/.gdb_history
set history size 10000

# Affichage
set print pretty on
set print array on
```

### Couleurs

GDB TUI supporte les couleurs si votre terminal les supporte :

```bash
# Dans .gdbinit
set style enabled on
set style sources on
```

### Hauteurs de FenÃªtre par DÃ©faut

Vous pouvez dÃ©finir des hauteurs prÃ©fÃ©rÃ©es :

```bash
# Dans .gdbinit
define hook-run
    layout src
    winheight src +10
end
```

---

## 15. Cas Pratique : DÃ©boguer un Bug

### Le Programme (avec bug)

```c
#include <stdio.h>
#include <stdlib.h>

int* creer_tableau(int taille) {
    int tableau[taille];  // Bug : allouÃ© sur la pile !
    for (int i = 0; i < taille; i++) {
        tableau[i] = i * 10;
    }
    return tableau;  // Retourne un pointeur vers la pile locale !
}

int main() {
    int *data = creer_tableau(5);
    for (int i = 0; i < 5; i++) {
        printf("data[%d] = %d\n", i, data[i]);
    }
    return 0;
}
```

### Session de DÃ©bogage avec TUI

```bash
$ gcc -g -o bug bug.c
$ gdb -tui ./bug
```

```gdb
(gdb) layout split
(gdb) break creer_tableau
(gdb) run
```

**Ã‰cran TUI** :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4    int* creer_tableau(int taille) {      â”‚
â”‚>5        int tableau[taille];              â”‚
â”‚ 6        for (int i = 0; i < taille; i++)  â”‚
â”‚ 7            tableau[i] = i * 10;          â”‚
â”‚ 8        }                                 â”‚
â”‚ 9        return tableau;                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0x1149    push   %rbp                      â”‚
â”‚>0x114a    mov    %rsp,%rbp                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Breakpoint 1, creer_tableau at bug.c:5     â”‚
â”‚ (gdb) _                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```gdb
(gdb) next  # Alloue tableau
(gdb) print &tableau[0]
$1 = (int *) 0x7fffffffdca0

(gdb) next  # Boucle for
(gdb) next
(gdb) ...  # Remplissage

(gdb) next  # Sur le return
```

**Sur la ligne 9** :

```
â”‚>9        return tableau;                   â”‚
```

```gdb
(gdb) print tableau
$2 = {0, 10, 20, 30, 40}

(gdb) print &tableau[0]
$3 = (int *) 0x7fffffffdca0  # Adresse de la pile !

(gdb) finish
```

**De retour dans main()** :

```gdb
(gdb) print data
$4 = (int *) 0x7fffffffdca0  # MÃªme adresse

(gdb) print *data@5
$5 = {32767, 0, 1431654400, 32767, 0}  # DonnÃ©es corrompues !
```

Avec le TUI, vous **voyez visuellement** :
1. L'allocation sur la **pile locale** (ligne 5)
2. Le **retour** de cette adresse de pile (ligne 9)
3. L'utilisation de cette adresse **invalide** dans main()

Le split layout montre mÃªme l'assembleur qui manipule le pointeur de pile `%rbp`, rendant le bug Ã©vident.

---

## 16. Trucs et Astuces

### Astuce 1 : Commandes Shell dans TUI

Vous pouvez exÃ©cuter des commandes shell depuis GDB TUI :

```gdb
(gdb) shell ls -la
(gdb) shell cat fichier.txt
```

### Astuce 2 : Enregistrer une Session

Capturez tout dans un fichier :

```gdb
set logging on
set logging file debug_session.txt
```

Puis faites votre dÃ©bogage. Tout sera enregistrÃ©.

### Astuce 3 : Alias pour Layouts

Dans votre `.gdbinit` :

```bash
# Alias pratiques
define src
    layout src
    layout regs
end

define asm
    layout asm
    layout regs
end

define both
    layout split
    layout regs
end
```

Puis en session : tapez juste `src`, `asm`, ou `both`.

### Astuce 4 : Utiliser tmux avec TUI

Pour une expÃ©rience optimale, utilisez **tmux** :

```bash
# Terminal 1 : GDB TUI
tmux
gdb -tui ./programme

# Terminal 2 : Sorties du programme
# (CrÃ©ez un split tmux avec Ctrl+B puis ")
tail -f /tmp/output.log
```

Dans GDB :

```gdb
set logging file /tmp/output.log
set logging redirect on
set logging on
```

Les sorties de votre programme iront dans le deuxiÃ¨me terminal !

### Astuce 5 : Mode TUI + Python

GDB avec Python permet des scripts puissants :

```python
# script.py
import gdb

class HelloWorld(gdb.Command):
    def __init__(self):
        super(HelloWorld, self).__init__("hello", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        print("Hello from GDB!")

HelloWorld()
```

```gdb
(gdb) source script.py
(gdb) hello
Hello from GDB!
```

---

## 17. RÃ©sumÃ© des Commandes TUI

### Activation

| Commande | Action |
|----------|--------|
| `tui enable` | Active le mode TUI |
| `tui disable` | DÃ©sactive le mode TUI |
| `Ctrl+X puis A` | Toggle TUI on/off |

### Layouts

| Commande | Action |
|----------|--------|
| `layout src` | Code source uniquement |
| `layout asm` | Assembleur uniquement |
| `layout split` | Source + Assembleur |
| `layout regs` | Ajoute les registres |
| `Ctrl+X puis 1` | Layout simple |
| `Ctrl+X puis 2` | Layout split |

### Navigation

| Commande | Action |
|----------|--------|
| `Ctrl+X puis O` | Change le focus de fenÃªtre |
| `Ctrl+L` | RafraÃ®chit l'affichage |
| `update` | Recentre sur la ligne actuelle |
| `FlÃ¨ches` | DÃ©file (si focus sur code) |

### Ajustement

| Commande | Action |
|----------|--------|
| `focus <fenÃªtre>` | Change le focus (src, asm, regs, cmd) |
| `winheight <fenÃªtre> +/-N` | Ajuste la hauteur |
| `refresh` | RafraÃ®chit tout |

---

## Conclusion

Le mode TUI transforme GDB en un outil de dÃ©bogage **beaucoup plus visuel et intuitif**. Au lieu de taper constamment `list` et de perdre le contexte, vous avez une **vue permanente** du code, de l'assembleur, et des registres.

### Points ClÃ©s Ã  Retenir

1. **Activation** : `tui enable` ou `Ctrl+X puis A`
2. **Layouts** : `src`, `asm`, `split`, `regs`
3. **Navigation** : `Ctrl+X puis O` pour changer le focus
4. **RafraÃ®chissement** : `Ctrl+L` si l'affichage est corrompu
5. **DÃ©sactivation** : `tui disable` pour revenir au mode standard

### Progression RecommandÃ©e

1. **DÃ©butant** : Utilisez le mode standard pour apprendre les commandes GDB
2. **IntermÃ©diaire** : Essayez TUI avec `layout src` uniquement
3. **AvancÃ©** : Explorez `layout split` et `layout regs`
4. **Expert** : ConsidÃ©rez GDB Dashboard ou CGDB pour plus de fonctionnalitÃ©s

### Prochaines Ã‰tapes

Maintenant que vous maÃ®trisez le mode TUI, vous Ãªtes prÃªt pour :
- **15.3 GDB avancÃ©** : Core dumps, debugging distant, time travel debugging
- **15.4 Valgrind** : DÃ©tection de fuites mÃ©moire et corruption
- **15.5 Valgrind avancÃ©** : Helgrind, Cachegrind, Callgrind

Le mode TUI est un **excellent complÃ©ment** aux compÃ©tences de base de GDB (breakpoints, stepping, backtrace, inspection). Il ne remplace pas ces compÃ©tences - il les **amplifie** en rendant l'information plus accessible visuellement.

---

**ğŸ’¡ Astuce finale :** Si le mode TUI semble instable ou problÃ©matique sur votre systÃ¨me, ne vous dÃ©couragez pas. Essayez **CGDB** (`sudo apt install cgdb`) qui offre une expÃ©rience similaire mais gÃ©nÃ©ralement plus stable. Ou explorez **GDB Dashboard** qui est extrÃªmement populaire et riche en fonctionnalitÃ©s. Le mode TUI natif est un bon point de dÃ©part, mais l'Ã©cosystÃ¨me GDB offre de nombreuses alternatives modernes !

â­ï¸ [GDB avancÃ©](/15-debogage-et-qualite/03-gdb-avance.md)
