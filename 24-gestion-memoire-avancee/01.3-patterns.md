üîù Retour au [Sommaire](/SOMMAIRE.md)

# 24.1.3 Patterns pour fichiers, m√©moire, locks

## Introduction

Maintenant que nous avons compris comment systemd et GLib utilisent `__attribute__((cleanup))`, cr√©ons notre propre **biblioth√®que de patterns r√©utilisables** pour les cas d'usage les plus courants.

Cette section vous fournit des **recettes pr√™tes √† l'emploi** que vous pouvez copier dans vos projets. Chaque pattern est accompagn√© d'exemples d'utilisation.

---

## Organisation : Cr√©er votre fichier cleanup.h

Commen√ßons par cr√©er un fichier d'en-t√™te centralis√© qui contiendra tous nos patterns :

```c
// cleanup.h - Biblioth√®que de patterns cleanup r√©utilisables
#ifndef CLEANUP_H
#define CLEANUP_H

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>

//
// ============================================================================
// SECTION 1 : GESTION M√âMOIRE
// ============================================================================
//

/**
 * cleanup_free - Lib√®re automatiquement la m√©moire allou√©e
 * @p: Pointeur vers le pointeur √† lib√©rer
 */
static inline void cleanup_free(void *p) {
    void **ptr = (void **)p;
    if (*ptr) {
        free(*ptr);
        *ptr = NULL;
    }
}

#define _cleanup_free_ __attribute__((cleanup(cleanup_free)))

//
// ============================================================================
// SECTION 2 : GESTION FICHIERS
// ============================================================================
//

/**
 * cleanup_fclose - Ferme automatiquement un FILE*
 * @f: Pointeur vers le FILE*
 */
static inline void cleanup_fclose(FILE **f) {
    if (*f) {
        fclose(*f);
        *f = NULL;
    }
}

#define _cleanup_fclose_ __attribute__((cleanup(cleanup_fclose)))

/**
 * cleanup_close - Ferme automatiquement un descripteur de fichier
 * @fd: Pointeur vers le descripteur
 */
static inline void cleanup_close(int *fd) {
    if (*fd >= 0) {
        close(*fd);
        *fd = -1;
    }
}

#define _cleanup_close_ __attribute__((cleanup(cleanup_close)))

//
// ============================================================================
// SECTION 3 : GESTION THREADS ET LOCKS
// ============================================================================
//

/**
 * cleanup_mutex_unlock - D√©verrouille automatiquement un mutex
 * @m: Pointeur vers le pointeur de mutex
 */
static inline void cleanup_mutex_unlock(pthread_mutex_t **m) {
    if (*m) {
        pthread_mutex_unlock(*m);
    }
}

#define _cleanup_mutex_unlock_ __attribute__((cleanup(cleanup_mutex_unlock)))

#endif // CLEANUP_H
```

---

## Pattern 1 : Gestion de la M√©moire

### 1.1 Lib√©ration simple avec malloc

**Pattern de base :**

```c
#include "cleanup.h"

void exemple_malloc_simple(void) {
    _cleanup_free_ char *buffer = malloc(1024);

    if (!buffer) {
        fprintf(stderr, "Erreur d'allocation\n");
        return;  // Pas de fuite m√™me si buffer est NULL
    }

    // Utilisation du buffer
    sprintf(buffer, "Hello, cleanup!");
    printf("%s\n", buffer);

    // free(buffer) automatique
}
```

---

### 1.2 Multiples allocations

**Cas d'usage :** Plusieurs allocations dans la m√™me fonction

```c
void exemple_multiples_allocations(void) {
    _cleanup_free_ char *nom = NULL;
    _cleanup_free_ char *prenom = NULL;
    _cleanup_free_ char *email = NULL;

    nom = strdup("Dupont");
    if (!nom) return;

    prenom = strdup("Jean");
    if (!prenom) return;  // nom sera lib√©r√© automatiquement

    email = strdup("jean.dupont@example.com");
    if (!email) return;  // nom ET prenom seront lib√©r√©s automatiquement

    printf("Utilisateur: %s %s <%s>\n", prenom, nom, email);

    // Toute la m√©moire est lib√©r√©e automatiquement
}
```

**Ordre de lib√©ration :** `email`, puis `prenom`, puis `nom` (ordre inverse de d√©claration)

---

### 1.3 Tableaux dynamiques

**Pattern pour tableaux d'entiers :**

```c
// Fonction de cleanup pour tableaux
static inline void cleanup_array_free(int **array) {
    if (*array) {
        free(*array);
        *array = NULL;
    }
}

#define _cleanup_array_ __attribute__((cleanup(cleanup_array_free)))

void exemple_tableau_dynamique(void) {
    size_t taille = 100;
    _cleanup_array_ int *nombres = malloc(taille * sizeof(int));

    if (!nombres) {
        return;
    }

    // Initialiser le tableau
    for (size_t i = 0; i < taille; i++) {
        nombres[i] = i * i;
    }

    // Afficher les 10 premiers
    for (size_t i = 0; i < 10; i++) {
        printf("%d ", nombres[i]);
    }
    printf("\n");

    // free(nombres) automatique
}
```

---

### 1.4 Tableaux de cha√Ænes (string arrays)

**Pattern pour tableaux de strings :**

```c
// Fonction de cleanup pour tableaux de cha√Ænes
static inline void cleanup_strv_free(char ***strv) {
    if (*strv) {
        for (size_t i = 0; (*strv)[i] != NULL; i++) {
            free((*strv)[i]);
        }
        free(*strv);
        *strv = NULL;
    }
}

#define _cleanup_strv_ __attribute__((cleanup(cleanup_strv_free)))

void exemple_tableau_chaines(void) {
    // Allouer un tableau de 4 cha√Ænes (+ NULL terminal)
    _cleanup_strv_ char **lignes = malloc(5 * sizeof(char *));

    if (!lignes) return;

    lignes[0] = strdup("Premi√®re ligne");
    lignes[1] = strdup("Deuxi√®me ligne");
    lignes[2] = strdup("Troisi√®me ligne");
    lignes[3] = strdup("Quatri√®me ligne");
    lignes[4] = NULL;  // Important : marqueur de fin

    // Affichage
    for (size_t i = 0; lignes[i] != NULL; i++) {
        printf("%zu: %s\n", i + 1, lignes[i]);
    }

    // Toutes les cha√Ænes ET le tableau seront lib√©r√©s automatiquement
}
```

---

### 1.5 Structures avec allocations imbriqu√©es

**Pattern pour structures complexes :**

```c
typedef struct {
    char *nom;
    char *email;
    int *scores;
    size_t nb_scores;
} Utilisateur;

// Fonction de cleanup pour Utilisateur
static inline void cleanup_utilisateur(Utilisateur **u) {
    if (*u) {
        free((*u)->nom);
        free((*u)->email);
        free((*u)->scores);
        free(*u);
        *u = NULL;
    }
}

#define _cleanup_utilisateur_ __attribute__((cleanup(cleanup_utilisateur)))

Utilisateur *creer_utilisateur(const char *nom, const char *email) {
    _cleanup_utilisateur_ Utilisateur *u = calloc(1, sizeof(Utilisateur));

    if (!u) return NULL;

    u->nom = strdup(nom);
    if (!u->nom) return NULL;  // u sera lib√©r√© automatiquement

    u->email = strdup(email);
    if (!u->email) return NULL;  // u ET u->nom seront lib√©r√©s

    u->scores = malloc(10 * sizeof(int));
    if (!u->scores) return NULL;  // Tout sera lib√©r√©

    u->nb_scores = 10;

    // D√©sactiver le cleanup et retourner
    Utilisateur *resultat = u;
    u = NULL;  // Important !
    return resultat;
}

void utiliser_utilisateur(void) {
    _cleanup_utilisateur_ Utilisateur *user = creer_utilisateur("Alice", "alice@example.com");

    if (!user) {
        fprintf(stderr, "Erreur cr√©ation utilisateur\n");
        return;
    }

    // Utilisation
    printf("Utilisateur: %s <%s>\n", user->nom, user->email);

    // Tout est lib√©r√© automatiquement
}
```

---

## Pattern 2 : Gestion des Fichiers

### 2.1 Fichiers avec FILE*

**Pattern de base :**

```c
void lire_fichier_texte(const char *chemin) {
    _cleanup_fclose_ FILE *f = fopen(chemin, "r");

    if (!f) {
        perror("fopen");
        return;
    }

    char ligne[256];
    while (fgets(ligne, sizeof(ligne), f)) {
        printf("%s", ligne);
    }

    // fclose(f) automatique
}
```

---

### 2.2 Lecture compl√®te d'un fichier

**Pattern pour charger un fichier entier en m√©moire :**

```c
char *lire_fichier_complet(const char *chemin, size_t *taille_out) {
    _cleanup_fclose_ FILE *f = NULL;
    _cleanup_free_ char *contenu = NULL;
    long taille;

    f = fopen(chemin, "rb");
    if (!f) {
        perror("fopen");
        return NULL;
    }

    // Obtenir la taille du fichier
    if (fseek(f, 0, SEEK_END) != 0) {
        perror("fseek");
        return NULL;  // f sera ferm√©, contenu lib√©r√©
    }

    taille = ftell(f);
    if (taille < 0) {
        perror("ftell");
        return NULL;
    }

    rewind(f);

    // Allouer la m√©moire
    contenu = malloc(taille + 1);
    if (!contenu) {
        fprintf(stderr, "Erreur allocation m√©moire\n");
        return NULL;  // f sera ferm√©
    }

    // Lire le contenu
    if (fread(contenu, 1, taille, f) != (size_t)taille) {
        fprintf(stderr, "Erreur de lecture\n");
        return NULL;  // f ET contenu seront nettoy√©s
    }

    contenu[taille] = '\0';

    if (taille_out) {
        *taille_out = taille;
    }

    // D√©sactiver le cleanup pour contenu
    char *resultat = contenu;
    contenu = NULL;
    return resultat;  // f ferm√©, resultat retourn√© (l'appelant doit lib√©rer)
}
```

---

### 2.3 Descripteurs de fichiers (file descriptors)

**Pattern pour les appels syst√®me POSIX :**

```c
#include <fcntl.h>
#include <unistd.h>

void lire_fichier_fd(const char *chemin) {
    _cleanup_close_ int fd = -1;
    char buffer[1024];
    ssize_t nb_lus;

    fd = open(chemin, O_RDONLY);
    if (fd < 0) {
        perror("open");
        return;
    }

    while ((nb_lus = read(fd, buffer, sizeof(buffer) - 1)) > 0) {
        buffer[nb_lus] = '\0';
        printf("%s", buffer);
    }

    if (nb_lus < 0) {
        perror("read");
        return;  // fd sera ferm√© automatiquement
    }

    // close(fd) automatique
}
```

---

### 2.4 Fichiers temporaires

**Pattern pour cr√©er et nettoyer des fichiers temporaires :**

```c
#include <string.h>

// Structure pour g√©rer un fichier temporaire
typedef struct {
    char *chemin;
    FILE *fichier;
} FichierTemp;

static inline void cleanup_fichier_temp(FichierTemp **ft) {
    if (*ft) {
        if ((*ft)->fichier) {
            fclose((*ft)->fichier);
        }
        if ((*ft)->chemin) {
            unlink((*ft)->chemin);  // Supprimer le fichier
            free((*ft)->chemin);
        }
        free(*ft);
        *ft = NULL;
    }
}

#define _cleanup_temp_ __attribute__((cleanup(cleanup_fichier_temp)))

void exemple_fichier_temporaire(void) {
    _cleanup_temp_ FichierTemp *temp = calloc(1, sizeof(FichierTemp));

    if (!temp) return;

    // Cr√©er un nom de fichier temporaire
    temp->chemin = strdup("/tmp/mon_fichier_XXXXXX");
    if (!temp->chemin) return;

    // Cr√©er le fichier temporaire
    int fd = mkstemp(temp->chemin);
    if (fd < 0) {
        perror("mkstemp");
        return;
    }

    temp->fichier = fdopen(fd, "w+");
    if (!temp->fichier) {
        close(fd);
        return;
    }

    // Utiliser le fichier temporaire
    fprintf(temp->fichier, "Donn√©es temporaires\n");
    fflush(temp->fichier);

    printf("Fichier temporaire cr√©√©: %s\n", temp->chemin);

    // Le fichier sera automatiquement ferm√© ET supprim√©
}
```

---

## Pattern 3 : Gestion des Locks (Multi-threading)

### 3.1 Mutex automatique

**Pattern de base pour pthread_mutex :**

```c
#include <pthread.h>

// Variable globale prot√©g√©e
static int compteur_global = 0;
static pthread_mutex_t mutex_compteur = PTHREAD_MUTEX_INITIALIZER;

void incrementer_compteur(void) {
    // Verrouiller automatiquement le mutex
    _cleanup_mutex_unlock_ pthread_mutex_t *lock = &mutex_compteur;
    pthread_mutex_lock(lock);

    // Section critique
    compteur_global++;
    printf("Compteur: %d\n", compteur_global);

    // pthread_mutex_unlock automatique, m√™me en cas d'erreur
}

void incrementer_avec_condition(int valeur) {
    _cleanup_mutex_unlock_ pthread_mutex_t *lock = &mutex_compteur;
    pthread_mutex_lock(lock);

    // Section critique avec plusieurs points de sortie
    if (valeur < 0) {
        fprintf(stderr, "Valeur invalide\n");
        return;  // Unlock automatique
    }

    if (compteur_global + valeur > 1000) {
        fprintf(stderr, "D√©passement de limite\n");
        return;  // Unlock automatique
    }

    compteur_global += valeur;
    printf("Compteur: %d\n", compteur_global);

    // Unlock automatique
}
```

---

### 3.2 Read-Write Lock

**Pattern pour pthread_rwlock :**

```c
// Fonctions de cleanup pour rwlock
static inline void cleanup_rwlock_unlock(pthread_rwlock_t **lock) {
    if (*lock) {
        pthread_rwlock_unlock(*lock);
    }
}

#define _cleanup_rwlock_ __attribute__((cleanup(cleanup_rwlock_unlock)))

// Structure de donn√©es partag√©e
typedef struct {
    char *donnees;
    pthread_rwlock_t rwlock;
} DonneesPartagees;

void lire_donnees(DonneesPartagees *dp) {
    // Verrou en lecture
    _cleanup_rwlock_ pthread_rwlock_t *lock = &dp->rwlock;
    pthread_rwlock_rdlock(lock);

    printf("Lecture: %s\n", dp->donnees);

    // Unlock automatique
}

void ecrire_donnees(DonneesPartagees *dp, const char *nouvelles_donnees) {
    // Verrou en √©criture
    _cleanup_rwlock_ pthread_rwlock_t *lock = &dp->rwlock;
    pthread_rwlock_wrlock(lock);

    free(dp->donnees);
    dp->donnees = strdup(nouvelles_donnees);

    if (!dp->donnees) {
        fprintf(stderr, "Erreur allocation\n");
        return;  // Unlock automatique
    }

    printf("√âcriture: %s\n", dp->donnees);

    // Unlock automatique
}
```

---

### 3.3 S√©maphores POSIX

**Pattern pour sem_t :**

```c
#include <semaphore.h>

static inline void cleanup_sem_post(sem_t **sem) {
    if (*sem) {
        sem_post(*sem);
    }
}

#define _cleanup_sem_ __attribute__((cleanup(cleanup_sem_post)))

void travailler_avec_semaphore(sem_t *semaphore) {
    // Attendre le s√©maphore
    if (sem_wait(semaphore) != 0) {
        perror("sem_wait");
        return;
    }

    // Le s√©maphore sera automatiquement post√©
    _cleanup_sem_ sem_t *sem = semaphore;

    // Section critique
    printf("Acc√®s √† la ressource prot√©g√©e\n");
    sleep(1);  // Simuler du travail

    if (une_erreur_survient()) {
        fprintf(stderr, "Erreur\n");
        return;  // sem_post automatique
    }

    printf("Travail termin√©\n");

    // sem_post automatique
}
```

---

## Pattern 4 : Patterns Combin√©s

### 4.1 Fichier + Lock (Thread-safe)

**Pattern pour acc√®s concurrent √† un fichier :**

```c
typedef struct {
    FILE *fichier;
    pthread_mutex_t mutex;
} FichierProtege;

void ecrire_log_thread_safe(FichierProtege *fp, const char *message) {
    _cleanup_mutex_unlock_ pthread_mutex_t *lock = &fp->mutex;
    pthread_mutex_lock(lock);

    // Fichier pas g√©r√© par cleanup car c'est une ressource partag√©e
    fprintf(fp->fichier, "[%ld] %s\n", time(NULL), message);
    fflush(fp->fichier);

    // Unlock automatique
}
```

---

### 4.2 Allocation + Fichier

**Pattern pour traiter des donn√©es charg√©es depuis un fichier :**

```c
void traiter_fichier_complet(const char *chemin) {
    _cleanup_fclose_ FILE *f = NULL;
    _cleanup_free_ char *contenu = NULL;
    _cleanup_free_ char *resultat = NULL;
    long taille;

    f = fopen(chemin, "r");
    if (!f) {
        perror("fopen");
        return;
    }

    fseek(f, 0, SEEK_END);
    taille = ftell(f);
    rewind(f);

    contenu = malloc(taille + 1);
    if (!contenu) return;  // f ferm√©

    fread(contenu, 1, taille, f);
    contenu[taille] = '\0';

    // Traitement : convertir en majuscules
    resultat = malloc(taille + 1);
    if (!resultat) return;  // f ET contenu nettoy√©s

    for (long i = 0; i < taille; i++) {
        resultat[i] = toupper(contenu[i]);
    }
    resultat[taille] = '\0';

    printf("R√©sultat:\n%s\n", resultat);

    // Tout est nettoy√© automatiquement : f, contenu, resultat
}
```

---

### 4.3 Multi-ressources avec gestion d'erreurs

**Pattern pour g√©rer plusieurs ressources avec propagation d'erreur :**

```c
int fonction_complexe(const char *fichier_entree, const char *fichier_sortie) {
    _cleanup_fclose_ FILE *f_in = NULL;
    _cleanup_fclose_ FILE *f_out = NULL;
    _cleanup_free_ char *buffer = NULL;
    _cleanup_close_ int lock_fd = -1;
    int retour = -1;  // Valeur par d√©faut : erreur

    // Acqu√©rir un verrou fichier
    lock_fd = open("/tmp/mon_app.lock", O_CREAT | O_RDWR, 0600);
    if (lock_fd < 0) {
        perror("lock");
        return -1;
    }

    // Ouvrir fichiers
    f_in = fopen(fichier_entree, "r");
    if (!f_in) {
        perror("fopen input");
        return -1;  // lock_fd ferm√© automatiquement
    }

    f_out = fopen(fichier_sortie, "w");
    if (!f_out) {
        perror("fopen output");
        return -1;  // lock_fd ET f_in nettoy√©s
    }

    // Allouer buffer
    buffer = malloc(4096);
    if (!buffer) {
        return -1;  // Tout nettoy√©
    }

    // Traitement
    size_t n;
    while ((n = fread(buffer, 1, 4096, f_in)) > 0) {
        if (fwrite(buffer, 1, n, f_out) != n) {
            perror("fwrite");
            return -1;  // Tout nettoy√©
        }
    }

    if (ferror(f_in)) {
        perror("fread");
        return -1;  // Tout nettoy√©
    }

    retour = 0;  // Succ√®s !
    return retour;  // Tout nettoy√©, m√™me en cas de succ√®s
}
```

---

## Pattern 5 : Biblioth√®que Compl√®te R√©utilisable

Voici une biblioth√®que compl√®te que vous pouvez inclure dans vos projets :

```c
// cleanup_patterns.h - Biblioth√®que compl√®te de patterns cleanup
#ifndef CLEANUP_PATTERNS_H
#define CLEANUP_PATTERNS_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include <fcntl.h>

//==============================================================================
// M√âMOIRE
//==============================================================================

static inline void cleanup_free(void *p) {
    void **ptr = (void **)p;
    if (*ptr) {
        free(*ptr);
        *ptr = NULL;
    }
}
#define _cleanup_free_ __attribute__((cleanup(cleanup_free)))

static inline void cleanup_strv_free(char ***strv) {
    if (*strv) {
        for (size_t i = 0; (*strv)[i] != NULL; i++) {
            free((*strv)[i]);
        }
        free(*strv);
        *strv = NULL;
    }
}
#define _cleanup_strv_ __attribute__((cleanup(cleanup_strv_free)))

//==============================================================================
// FICHIERS
//==============================================================================

static inline void cleanup_fclose(FILE **f) {
    if (*f) {
        fclose(*f);
        *f = NULL;
    }
}
#define _cleanup_fclose_ __attribute__((cleanup(cleanup_fclose)))

static inline void cleanup_close(int *fd) {
    if (*fd >= 0) {
        close(*fd);
        *fd = -1;
    }
}
#define _cleanup_close_ __attribute__((cleanup(cleanup_close)))

//==============================================================================
// THREADS ET LOCKS
//==============================================================================

static inline void cleanup_mutex_unlock(pthread_mutex_t **m) {
    if (*m) {
        pthread_mutex_unlock(*m);
    }
}
#define _cleanup_mutex_unlock_ __attribute__((cleanup(cleanup_mutex_unlock)))

static inline void cleanup_rwlock_unlock(pthread_rwlock_t **lock) {
    if (*lock) {
        pthread_rwlock_unlock(*lock);
    }
}
#define _cleanup_rwlock_ __attribute__((cleanup(cleanup_rwlock_unlock)))

//==============================================================================
// UTILITAIRES
//==============================================================================

// Macro g√©n√©rique pour cr√©er vos propres cleanups
#define _cleanup_(fonction) __attribute__((cleanup(fonction)))

// D√©sactiver temporairement le cleanup
#define STEAL(var) ({ __typeof__(var) _tmp = var; var = NULL; _tmp; })

#endif // CLEANUP_PATTERNS_H
```

---

## Utilisation de la biblioth√®que

### Exemple complet

```c
#include <stdio.h>
#include "cleanup_patterns.h"

int traiter_fichier_utilisateurs(const char *chemin) {
    _cleanup_fclose_ FILE *f = NULL;
    _cleanup_strv_ char **lignes = NULL;
    _cleanup_free_ char *ligne_courante = NULL;
    int nb_utilisateurs = 0;

    f = fopen(chemin, "r");
    if (!f) {
        perror("fopen");
        return -1;
    }

    // Allouer tableau de lignes (max 100)
    lignes = calloc(101, sizeof(char *));
    if (!lignes) {
        return -1;  // f ferm√© automatiquement
    }

    ligne_courante = malloc(256);
    if (!ligne_courante) {
        return -1;  // f ET lignes nettoy√©s
    }

    // Lire les lignes
    while (fgets(ligne_courante, 256, f) && nb_utilisateurs < 100) {
        // Retirer le \n
        ligne_courante[strcspn(ligne_courante, "\n")] = '\0';

        // Sauvegarder la ligne
        lignes[nb_utilisateurs] = strdup(ligne_courante);
        if (!lignes[nb_utilisateurs]) {
            return -1;  // Tout nettoy√©
        }

        nb_utilisateurs++;
    }

    lignes[nb_utilisateurs] = NULL;  // Marqueur de fin

    // Afficher les utilisateurs
    printf("=== %d utilisateurs trouv√©s ===\n", nb_utilisateurs);
    for (int i = 0; lignes[i] != NULL; i++) {
        printf("%d. %s\n", i + 1, lignes[i]);
    }

    return nb_utilisateurs;
    // Tout est automatiquement nettoy√© : f, lignes, ligne_courante
}

int main(void) {
    int resultat = traiter_fichier_utilisateurs("utilisateurs.txt");

    if (resultat >= 0) {
        printf("\nTraitement r√©ussi !\n");
    } else {
        fprintf(stderr, "\nErreur lors du traitement\n");
    }

    return resultat >= 0 ? 0 : 1;
}
```

---

## La macro STEAL : D√©sactiver le cleanup

### Pourquoi STEAL ?

Parfois, vous voulez **retourner** une ressource sans qu'elle soit lib√©r√©e :

```c
// Macro STEAL (d√©finie dans cleanup_patterns.h)
#define STEAL(var) ({ __typeof__(var) _tmp = var; var = NULL; _tmp; })
```

### Exemple d'utilisation

```c
char *creer_message(const char *texte) {
    _cleanup_free_ char *buffer = malloc(256);

    if (!buffer) {
        return NULL;
    }

    snprintf(buffer, 256, "Message: %s", texte);

    // Retourner buffer sans le lib√©rer
    return STEAL(buffer);  // buffer mis √† NULL, pas de cleanup
}

void utiliser_message(void) {
    _cleanup_free_ char *msg = creer_message("Hello");

    if (!msg) return;

    printf("%s\n", msg);

    // msg sera lib√©r√© automatiquement
}
```

---

## Bonnes Pratiques

### ‚úÖ DO : √Ä faire

1. **Toujours initialiser les pointeurs**
```c
// ‚úÖ BON
_cleanup_free_ char *ptr = NULL;

// ‚ùå MAUVAIS
_cleanup_free_ char *ptr;  // Valeur ind√©termin√©e !
```

2. **V√©rifier NULL dans les fonctions de cleanup**
```c
static inline void cleanup_mafonction(Type **p) {
    if (*p) {  // ‚Üê Important !
        // cleanup
        *p = NULL;
    }
}
```

3. **Mettre les ressources d√©pendantes dans le bon ordre**
```c
void exemple(void) {
    // D√©clar√© en premier = nettoy√© en dernier
    _cleanup_fclose_ FILE *f = fopen("file.txt", "r");

    // D√©clar√© en second = nettoy√© en premier
    _cleanup_free_ char *data = malloc(1024);

    // data utilise f, donc data doit √™tre nettoy√© AVANT f
    // L'ordre de d√©claration est correct !
}
```

4. **Utiliser STEAL pour retourner des ressources**
```c
char *fonction_qui_retourne(void) {
    _cleanup_free_ char *buffer = malloc(100);
    // ...
    return STEAL(buffer);  // OK
}
```

5. **Documenter vos fonctions de cleanup**
```c
/**
 * cleanup_mafonction - Nettoie automatiquement une ressource
 * @p: Pointeur vers le pointeur de ressource
 *
 * Cette fonction est appel√©e automatiquement quand la variable
 * sort de son scope. Elle lib√®re la ressource et met le pointeur √† NULL.
 */
static inline void cleanup_mafonction(Type **p) {
    // ...
}
```

---

### ‚ùå DON'T : √Ä √©viter

1. **Ne pas oublier l'initialisation**
```c
// ‚ùå DANGEREUX
_cleanup_free_ char *ptr;
if (condition) {
    ptr = malloc(100);
}
// Si condition est fausse, cleanup_free recevra une valeur al√©atoire !
```

2. **Ne pas appeler free manuellement**
```c
// ‚ùå MAUVAIS - Double free !
_cleanup_free_ char *ptr = malloc(100);
// ...
free(ptr);  // Ne faites pas √ßa !
// cleanup_free sera quand m√™me appel√© ‚Üí double free
```

3. **Ne pas utiliser cleanup pour des ressources partag√©es**
```c
// ‚ùå MAUVAIS
void mauvaise_idee(FILE *fichier_partage) {
    _cleanup_fclose_ FILE *f = fichier_partage;
    // ...
}
// fichier_partage sera ferm√© alors qu'il est peut-√™tre encore utilis√© ailleurs !
```

4. **Ne pas oublier le marqueur NULL pour les tableaux**
```c
// ‚ùå MAUVAIS - Pas de marqueur de fin
_cleanup_strv_ char **lignes = malloc(10 * sizeof(char *));
lignes[0] = strdup("test");
// cleanup_strv_free va lire au-del√† car pas de NULL !

// ‚úÖ BON
_cleanup_strv_ char **lignes = calloc(11, sizeof(char *));  // +1 pour NULL
lignes[0] = strdup("test");
lignes[1] = NULL;  // Marqueur de fin
```

---

## Debugging avec cleanup

### Activer des traces de cleanup

Pendant le d√©veloppement, il peut √™tre utile de tracer les cleanups :

```c
#ifdef DEBUG_CLEANUP
    #define CLEANUP_TRACE(msg) fprintf(stderr, "[CLEANUP] %s\n", msg)
#else
    #define CLEANUP_TRACE(msg)
#endif

static inline void cleanup_free_debug(void *p) {
    void **ptr = (void **)p;
    if (*ptr) {
        CLEANUP_TRACE("Lib√©ration m√©moire");
        free(*ptr);
        *ptr = NULL;
    }
}
```

**Compilation avec traces :**
```bash
gcc -DDEBUG_CLEANUP -o programme programme.c
```

---

## Performances

### Overhead du cleanup ?

**R√©ponse courte :** Aucun overhead !

Le compilateur g√©n√®re **exactement le m√™me code** que si vous aviez √©crit le cleanup manuellement.

**Preuve :**

Code avec cleanup :
```c
void avec(void) {
    _cleanup_free_ char *p = malloc(100);
    faire_quelque_chose(p);
}
```

Code manuel :
```c
void sans(void) {
    char *p = malloc(100);
    faire_quelque_chose(p);
    free(p);
}
```

**Assembleur g√©n√©r√© (identique) :**
```assembly
call   malloc
# ...
call   faire_quelque_chose
# ...
call   free
ret
```

---

## Cas d'usage r√©els

### 1. Serveur HTTP simple

```c
void traiter_requete_http(int client_fd) {
    _cleanup_free_ char *buffer = malloc(4096);
    _cleanup_free_ char *reponse = NULL;

    if (!buffer) return;

    ssize_t n = read(client_fd, buffer, 4095);
    if (n <= 0) return;  // buffer lib√©r√© automatiquement

    buffer[n] = '\0';

    // Parser la requ√™te HTTP
    if (strncmp(buffer, "GET ", 4) != 0) {
        return;  // buffer lib√©r√©
    }

    // G√©n√©rer la r√©ponse
    reponse = malloc(8192);
    if (!reponse) return;  // buffer lib√©r√©

    snprintf(reponse, 8192,
        "HTTP/1.1 200 OK\r\n"
        "Content-Type: text/html\r\n"
        "\r\n"
        "<html><body>Hello World!</body></html>");

    write(client_fd, reponse, strlen(reponse));

    // buffer ET reponse lib√©r√©s automatiquement
}
```

---

### 2. Parsing de fichier de configuration

```c
typedef struct {
    char *cle;
    char *valeur;
} ConfigEntree;

typedef struct {
    ConfigEntree *entrees;
    size_t nb_entrees;
} Configuration;

static inline void cleanup_config(Configuration **c) {
    if (*c) {
        for (size_t i = 0; i < (*c)->nb_entrees; i++) {
            free((*c)->entrees[i].cle);
            free((*c)->entrees[i].valeur);
        }
        free((*c)->entrees);
        free(*c);
        *c = NULL;
    }
}

#define _cleanup_config_ __attribute__((cleanup(cleanup_config)))

Configuration *charger_config(const char *fichier) {
    _cleanup_fclose_ FILE *f = NULL;
    _cleanup_config_ Configuration *config = NULL;
    _cleanup_free_ char *ligne = NULL;

    f = fopen(fichier, "r");
    if (!f) return NULL;

    config = calloc(1, sizeof(Configuration));
    if (!config) return NULL;  // f ferm√©

    config->entrees = malloc(100 * sizeof(ConfigEntree));
    if (!config->entrees) return NULL;  // Tout nettoy√©

    ligne = malloc(256);
    if (!ligne) return NULL;  // Tout nettoy√©

    while (fgets(ligne, 256, f) && config->nb_entrees < 100) {
        // Format attendu : cle=valeur
        char *sep = strchr(ligne, '=');
        if (!sep) continue;

        *sep = '\0';
        char *cle = ligne;
        char *valeur = sep + 1;

        // Retirer \n
        valeur[strcspn(valeur, "\n")] = '\0';

        config->entrees[config->nb_entrees].cle = strdup(cle);
        config->entrees[config->nb_entrees].valeur = strdup(valeur);
        config->nb_entrees++;
    }

    // Retourner config
    return STEAL(config);
}
```

---

## Conclusion

Les patterns `cleanup` permettent d'√©crire du **code C moderne, s√ªr et maintenable** :

‚úÖ **Pas de fuites de ressources**
‚úÖ **Code plus lisible**
‚úÖ **Moins de bugs**
‚úÖ **Maintenance facilit√©e**
‚úÖ **Aucun overhead de performance**

**R√©sum√© des patterns :**

| Ressource | Pattern | Macro |
|-----------|---------|-------|
| M√©moire malloc | `cleanup_free` | `_cleanup_free_` |
| Tableau de strings | `cleanup_strv_free` | `_cleanup_strv_` |
| FILE* | `cleanup_fclose` | `_cleanup_fclose_` |
| Descripteur FD | `cleanup_close` | `_cleanup_close_` |
| pthread_mutex | `cleanup_mutex_unlock` | `_cleanup_mutex_unlock_` |
| pthread_rwlock | `cleanup_rwlock_unlock` | `_cleanup_rwlock_` |

**Prochaines √©tapes :**
1. Copiez `cleanup_patterns.h` dans votre projet
2. Commencez par utiliser `_cleanup_free_` et `_cleanup_fclose_`
3. Cr√©ez vos propres patterns pour vos types personnalis√©s
4. √âtudiez le code de systemd et GLib pour plus d'exemples

**Le cleanup en C est l'√©quivalent de RAII en C++, `defer` en Go, et `with` en Python - utilisez-le !** üöÄ

---

**üìö R√©f√©rences :**
- [systemd cleanup patterns](https://github.com/systemd/systemd/blob/main/src/basic/macro.h)
- [GLib auto-cleanup](https://docs.gtk.org/glib/auto-cleanup.html)
- [GCC Cleanup Attribute](https://gcc.gnu.org/onlinedocs/gcc/Common-Variable-Attributes.html#index-cleanup-variable-attribute)

‚è≠Ô∏è [Limitations et portabilit√©](/24-gestion-memoire-avancee/01.4-limitations-portabilite.md)
