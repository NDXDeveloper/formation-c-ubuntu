ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 21.4.3 Compilation et Chargement

## Introduction

La **compilation** et le **chargement** d'un programme eBPF sont les Ã©tapes cruciales qui transforment votre code C en bytecode exÃ©cutable dans le kernel Linux. Comprendre ce processus est essentiel pour :

- Debugger les erreurs de compilation
- Optimiser les performances de vos programmes
- Comprendre les messages d'erreur du verifier
- Choisir les bonnes options de compilation

Ce processus peut sembler complexe au premier abord, mais nous allons le dÃ©composer Ã©tape par Ã©tape de maniÃ¨re accessible.

---

## Vue d'ensemble du processus

Le parcours d'un programme eBPF, de l'Ã©criture Ã  l'exÃ©cution, passe par plusieurs Ã©tapes :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    1. DÃ‰VELOPPEMENT                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  program.bpf.c (Code source C)                                  â”‚
â”‚  â”œâ”€ #include <linux/bpf.h>                                      â”‚
â”‚  â”œâ”€ #include <bpf/bpf_helpers.h>                                â”‚
â”‚  â””â”€ SEC("kprobe/...") int my_program(...) { ... }               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    2. COMPILATION                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Clang/LLVM                                                     â”‚
â”‚  â”œâ”€ PrÃ©processeur : Expansion des macros, includes              â”‚
â”‚  â”œâ”€ Compilation : C â†’ LLVM IR (Intermediate Representation)     â”‚
â”‚  â”œâ”€ Optimisation : Passes d'optimisation LLVM                   â”‚
â”‚  â””â”€ Backend BPF : LLVM IR â†’ Bytecode eBPF                       â”‚
â”‚                                                                 â”‚
â”‚  Sortie : program.bpf.o (Fichier objet ELF)                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    3. CHARGEMENT (Userspace)                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  libbpf / loader.c                                              â”‚
â”‚  â”œâ”€ Lecture du fichier .o (ELF parsing)                         â”‚
â”‚  â”œâ”€ Extraction du bytecode eBPF                                 â”‚
â”‚  â”œâ”€ Relocation des symboles (CO-RE)                             â”‚
â”‚  â”œâ”€ CrÃ©ation des maps                                           â”‚
â”‚  â””â”€ Syscall bpf(BPF_PROG_LOAD, ...)                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    4. VÃ‰RIFICATION (Kernel)                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  eBPF Verifier                                                  â”‚
â”‚  â”œâ”€ VÃ©rification de la sÃ©curitÃ©                                 â”‚
â”‚  â”‚  â”œâ”€ Pas de boucles infinies                                  â”‚
â”‚  â”‚  â”œâ”€ Pas d'accÃ¨s mÃ©moire invalides                            â”‚
â”‚  â”‚  â”œâ”€ Pas de pointeurs kernel exposÃ©s                          â”‚
â”‚  â”‚  â””â”€ Terminaison garantie                                     â”‚
â”‚  â”œâ”€ Analyse statique du flot de contrÃ´le                        â”‚
â”‚  â””â”€ Validation des accÃ¨s maps                                   â”‚
â”‚                                                                 â”‚
â”‚  Si OK â†’ Continuer                                              â”‚
â”‚  Si KO â†’ Rejet avec log dÃ©taillÃ©                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    5. JIT COMPILATION                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  JIT Compiler (Just-In-Time)                                    â”‚
â”‚  â”œâ”€ Bytecode eBPF â†’ Code machine natif (x86-64, ARM64, etc.)    â”‚
â”‚  â”œâ”€ Optimisations spÃ©cifiques Ã  l'architecture                  â”‚
â”‚  â””â”€ Code prÃªt Ã  s'exÃ©cuter directement sur le CPU               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    6. ATTACHEMENT                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Attachement au hook                                            â”‚
â”‚  â”œâ”€ Tracepoint, kprobe, uprobe, XDP, TC, etc.                   â”‚
â”‚  â”œâ”€ CrÃ©ation d'un bpf_link                                      â”‚
â”‚  â””â”€ Le programme est maintenant actif                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    7. EXÃ‰CUTION                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Le programme eBPF s'exÃ©cute Ã  chaque fois que l'Ã©vÃ©nement      â”‚
â”‚  auquel il est attachÃ© se produit                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Explorons maintenant chaque Ã©tape en dÃ©tail.

---

## Ã‰tape 1 : PrÃ©paration du code source

### Structure d'un programme eBPF minimal

```c
// program.bpf.c
#include <linux/bpf.h>
#include <bpf/bpf_helpers.h>

// Section spÃ©ciale qui indique le type de programme et oÃ¹ l'attacher
SEC("kprobe/sys_execve")
int trace_execve(struct pt_regs *ctx) {
    // Logique du programme
    bpf_printk("execve() called!\n");
    return 0;
}

// Licence obligatoire (GPL pour accÃ©der Ã  certaines fonctions kernel)
char LICENSE[] SEC("license") = "GPL";
```

### Les includes essentiels

**linux/bpf.h** : DÃ©finitions de base eBPF
```c
#include <linux/bpf.h>
// Contient : types eBPF, enums, structures de base
```

**bpf/bpf_helpers.h** : Fonctions helper
```c
#include <bpf/bpf_helpers.h>
// Contient : bpf_printk, bpf_map_lookup_elem, etc.
```

**vmlinux.h** : Types kernel complets (CO-RE)
```c
#include "vmlinux.h"
// Contient : TOUTES les structures kernel (task_struct, socket, etc.)
// GÃ©nÃ©rÃ© via : bpftool btf dump file /sys/kernel/btf/vmlinux format c > vmlinux.h
```

### La macro SEC() : DÃ©finir le type de programme

```c
// Syntaxe : SEC("type/hook_name")

// Exemples :
SEC("kprobe/sys_execve")           // Kprobe sur sys_execve
SEC("tracepoint/sched/sched_process_exec")  // Tracepoint
SEC("xdp")                         // XDP (attach manuel)
SEC("tc")                          // Traffic Control
SEC("cgroup/skb")                  // Cgroup skb filter
```

**Important :** La section dÃ©termine automatiquement le type de programme lors du chargement.

### La licence

```c
char LICENSE[] SEC("license") = "GPL";
```

**Pourquoi GPL ?**
- Certaines fonctions kernel sont "GPL-only"
- Si votre programme les utilise, il DOIT Ãªtre GPL
- Sinon, vous obtenez une erreur au chargement

**Licences acceptÃ©es :**
- `"GPL"`
- `"GPL v2"`
- `"Dual BSD/GPL"`
- `"Dual MIT/GPL"`

---

## Ã‰tape 2 : Compilation avec Clang

### Commande de compilation de base

```bash
clang -O2 -target bpf -c program.bpf.c -o program.bpf.o
```

**DÃ©composition :**
- `clang` : Compilateur LLVM/Clang (requis pour eBPF)
- `-O2` : Niveau d'optimisation (recommandÃ©)
- `-target bpf` : Cible le backend BPF de LLVM
- `-c` : Compiler sans linker (produire un .o)
- `program.bpf.c` : Fichier source
- `-o program.bpf.o` : Fichier de sortie

### Options de compilation importantes

#### 1. **Optimisation (-O2)**

```bash
# Sans optimisation (NE PAS FAIRE)
clang -O0 -target bpf -c program.bpf.c -o program.bpf.o
# ProblÃ¨me : Code non optimisÃ© peut dÃ©passer la limite du verifier

# Avec optimisation (RECOMMANDÃ‰)
clang -O2 -target bpf -c program.bpf.c -o program.bpf.o
# BÃ©nÃ©fice : Code compact, passe le verifier
```

**Niveaux d'optimisation :**
- `-O0` : Pas d'optimisation (debugging uniquement)
- `-O1` : Optimisations basiques
- `-O2` : Optimisations recommandÃ©es (dÃ©faut)
- `-O3` : Optimisations agressives (rarement nÃ©cessaire)
- `-Os` : Optimiser pour la taille (utile pour programmes complexes)

#### 2. **Debug symbols (-g)**

```bash
clang -O2 -g -target bpf -c program.bpf.c -o program.bpf.o
```

**BÃ©nÃ©fices :**
- âœ… Meilleurs messages d'erreur du verifier
- âœ… Code source visible dans `bpftool prog dump xlated`
- âœ… Debugging plus facile
- âœ… BTF inclus automatiquement

**Recommandation :** Toujours utiliser `-g`, mÃªme en production (overhead nÃ©gligeable).

#### 3. **Include paths (-I)**

```bash
# Ajouter un rÃ©pertoire d'includes
clang -O2 -target bpf -I./include -c program.bpf.c -o program.bpf.o

# Plusieurs rÃ©pertoires
clang -O2 -target bpf -I./include -I./headers -c program.bpf.c -o program.bpf.o
```

**Cas d'usage :** Inclure vmlinux.h ou headers custom.

#### 4. **Defines (-D)**

```bash
# DÃ©finir une macro de prÃ©processeur
clang -O2 -target bpf -DDEBUG -c program.bpf.c -o program.bpf.o
```

**Utilisation dans le code :**
```c
#ifdef DEBUG
    bpf_printk("Debug: value=%d\n", value);
#endif
```

#### 5. **Warnings (-Wall, -Wextra)**

```bash
clang -O2 -target bpf -Wall -Wextra -c program.bpf.c -o program.bpf.o
```

**Recommandation :** Toujours activer les warnings.

### Commande complÃ¨te recommandÃ©e

```bash
clang -O2 -g \
    -target bpf \
    -Wall -Wextra \
    -I./include \
    -D__TARGET_ARCH_x86 \
    -c program.bpf.c \
    -o program.bpf.o
```

### VÃ©rifier la compilation

```bash
# VÃ©rifier que c'est bien un objet ELF
$ file program.bpf.o
program.bpf.o: ELF 64-bit LSB relocatable, eBPF, version 1 (SYSV), not stripped

# Voir les sections
$ llvm-objdump -h program.bpf.o
Sections:
Idx Name          Size     VMA              Type
  0               00000000 0000000000000000
  1 .text         00000000 0000000000000000 TEXT
  2 kprobe/sys_execve 000000b0 0000000000000000 TEXT
  3 .rodata       0000001d 0000000000000000 DATA
  4 .BTF          00000abc 0000000000000000
  5 .BTF.ext      00000123 0000000000000000

# Voir le bytecode
$ llvm-objdump -d program.bpf.o
```

---

## Ã‰tape 3 : Le fichier objet ELF

Le fichier `.bpf.o` est un **fichier ELF** (Executable and Linkable Format) contenant :

### Structure du fichier

```
program.bpf.o (Fichier ELF)
â”œâ”€â”€ Section .text              (vide gÃ©nÃ©ralement)
â”œâ”€â”€ Section kprobe/sys_execve  (bytecode eBPF du programme)
â”œâ”€â”€ Section .maps              (dÃ©finitions des BPF maps)
â”œâ”€â”€ Section .rodata            (donnÃ©es read-only)
â”œâ”€â”€ Section .data              (donnÃ©es read-write)
â”œâ”€â”€ Section .bss               (donnÃ©es non initialisÃ©es)
â”œâ”€â”€ Section .BTF               (informations de types)
â”œâ”€â”€ Section .BTF.ext           (extensions BTF pour CO-RE)
â”œâ”€â”€ Section license            (chaÃ®ne de licence)
â””â”€â”€ Relocation entries         (pour CO-RE)
```

### Inspecter les sections

```bash
# Lister les sections
$ llvm-readelf -S program.bpf.o

Section Headers:
  [Nr] Name              Type            Address          Off    Size
  [ 1] .text             PROGBITS        0000000000000000 000040 000000
  [ 2] kprobe/sys_execve PROGBITS        0000000000000000 000040 0000b0
  [ 3] .rodata           PROGBITS        0000000000000000 0000f0 00001d
  [ 4] license           PROGBITS        0000000000000000 00010d 000004
  [ 5] .maps             PROGBITS        0000000000000000 000120 000020
  [ 6] .BTF              PROGBITS        0000000000000000 000140 000abc
  [ 7] .BTF.ext          PROGBITS        0000000000000000 000bfc 000123
```

### Extraire le bytecode

```bash
# Disassembler le bytecode eBPF
$ llvm-objdump -d program.bpf.o

program.bpf.o:  file format elf64-bpf

Disassembly of section kprobe/sys_execve:

0000000000000000 <trace_execve>:
       0:       85 00 00 00 0e 00 00 00 call 14
       1:       b7 00 00 00 00 00 00 00 r0 = 0
       2:       95 00 00 00 00 00 00 00 exit
```

**Lecture du bytecode :**
- Chaque ligne = 1 instruction (8 bytes)
- Format : `code dst src off imm`
- Exemple : `85 00 00 00 0e 00 00 00` = `call 14` (appeler helper #14)

---

## Ã‰tape 4 : Chargement avec libbpf

### Le code userspace minimal

```c
// loader.c
#include <stdio.h>
#include <bpf/libbpf.h>

int main() {
    struct bpf_object *obj;
    struct bpf_program *prog;
    struct bpf_link *link;
    int err;

    // 1. Ouvrir le fichier objet
    obj = bpf_object__open_file("program.bpf.o", NULL);
    if (libbpf_get_error(obj)) {
        fprintf(stderr, "Failed to open BPF object\n");
        return 1;
    }

    // 2. Charger dans le kernel
    err = bpf_object__load(obj);
    if (err) {
        fprintf(stderr, "Failed to load BPF object: %d\n", err);
        goto cleanup;
    }

    // 3. Trouver le programme
    prog = bpf_object__find_program_by_name(obj, "trace_execve");
    if (!prog) {
        fprintf(stderr, "Failed to find program\n");
        goto cleanup;
    }

    // 4. Attacher
    link = bpf_program__attach(prog);
    if (libbpf_get_error(link)) {
        fprintf(stderr, "Failed to attach program\n");
        goto cleanup;
    }

    printf("Successfully attached! Press Ctrl-C to stop.\n");

    // 5. Garder actif
    pause();  // ou while(1) sleep(1);

    // 6. Cleanup
    bpf_link__destroy(link);
cleanup:
    bpf_object__close(obj);
    return err != 0;
}
```

### Compilation du loader

```bash
gcc -Wall -O2 loader.c -o loader -lbpf -lelf -lz
```

**BibliothÃ¨ques requises :**
- `-lbpf` : libbpf
- `-lelf` : libelf (parsing ELF)
- `-lz` : zlib (compression)

### Ã‰tapes du chargement en dÃ©tail

#### 1. **bpf_object__open_file()** : Parsing ELF

```c
obj = bpf_object__open_file("program.bpf.o", NULL);
```

**Ce qui se passe :**
- Lecture du fichier ELF
- Parsing des sections
- Extraction du bytecode eBPF
- Lecture des dÃ©finitions de maps
- Lecture des informations BTF
- PrÃ©paration des relocations CO-RE

#### 2. **bpf_object__load()** : Chargement kernel

```c
err = bpf_object__load(obj);
```

**Ce qui se passe :**

**a. Relocation CO-RE**
```
Si BTF prÃ©sent :
  â”œâ”€ Lire le BTF du kernel (/sys/kernel/btf/vmlinux)
  â”œâ”€ Comparer avec le BTF du programme
  â”œâ”€ Calculer les offsets corrects pour le kernel actuel
  â””â”€ Appliquer les relocations au bytecode
```

**b. CrÃ©ation des maps**
```
Pour chaque map dÃ©finie :
  â”œâ”€ syscall bpf(BPF_MAP_CREATE, ...)
  â”œâ”€ Allouer la mÃ©moire kernel
  â””â”€ Retourner un file descriptor
```

**c. Chargement du programme**
```
syscall bpf(BPF_PROG_LOAD, ...)
  â”œâ”€ Passer le bytecode au kernel
  â”œâ”€ SpÃ©cifier le type de programme
  â”œâ”€ Lier avec les maps crÃ©Ã©es
  â””â”€ Retourner un file descriptor
```

**d. VÃ©rification par le verifier**
```
Le verifier analyse le programme :
  â”œâ”€ Pas de boucles infinies ?
  â”œâ”€ AccÃ¨s mÃ©moire valides ?
  â”œâ”€ Utilisation correcte des helpers ?
  â”œâ”€ Terminaison garantie ?
  â””â”€ Si OK â†’ JIT compilation
     Si KO â†’ Rejet avec log
```

#### 3. **bpf_program__attach()** : Attachement

```c
link = bpf_program__attach(prog);
```

**Ce qui se passe :**
- Lecture de la section SEC() pour dÃ©terminer le type
- Attachement automatique selon le type :
  - `kprobe/...` â†’ Attacher au kprobe
  - `tracepoint/...` â†’ Attacher au tracepoint
  - `xdp` â†’ Attacher Ã  une interface (nÃ©cessite params)
- CrÃ©ation d'un bpf_link
- Le programme est maintenant actif

---

## Ã‰tape 5 : Le verifier eBPF

Le **verifier** est le gardien qui s'assure qu'un programme eBPF est sÃ»r.

### Les vÃ©rifications principales

#### 1. **Pas de boucles infinies**

```c
// âŒ REJETÃ‰ : Boucle potentiellement infinie
SEC("kprobe/...")
int bad_program(struct pt_regs *ctx) {
    while (1) {  // Boucle infinie !
        // ...
    }
    return 0;
}
```

**Solution :** Utiliser des boucles bornÃ©es avec `#pragma unroll` :

```c
// âœ… ACCEPTÃ‰ : Boucle dÃ©roulÃ©e
SEC("kprobe/...")
int good_program(struct pt_regs *ctx) {
    #pragma unroll
    for (int i = 0; i < 10; i++) {  // Maximum 10 itÃ©rations
        // ...
    }
    return 0;
}
```

#### 2. **Limite de complexitÃ©**

**Le verifier limite le nombre d'instructions analysÃ©es.**

```bash
# Kernel ancien (< 5.2) : 4096 instructions
# Kernel 5.2+ : 1 million d'instructions

# Si dÃ©passÃ© :
BPF program is too large. Processed 1000001 insn
```

**Solutions :**
- Simplifier le code
- Utiliser `-O2` ou `-Os`
- DÃ©couper en plusieurs programmes

#### 3. **AccÃ¨s mÃ©moire sÃ»rs**

```c
// âŒ REJETÃ‰ : AccÃ¨s potentiellement hors limites
SEC("kprobe/...")
int bad_memory_access(struct pt_regs *ctx) {
    char buffer[10];
    int index = get_user_input();  // Valeur non contrÃ´lÃ©e
    buffer[index] = 'A';  // Peut Ã©crire n'importe oÃ¹ !
    return 0;
}
```

**Solution :** VÃ©rifier les bornes :

```c
// âœ… ACCEPTÃ‰ : VÃ©rification des bornes
SEC("kprobe/...")
int good_memory_access(struct pt_regs *ctx) {
    char buffer[10];
    int index = get_user_input();
    if (index >= 0 && index < 10) {  // VÃ©rification explicite
        buffer[index] = 'A';
    }
    return 0;
}
```

#### 4. **Pointeurs valides**

```c
// âŒ REJETÃ‰ : DÃ©rÃ©fÃ©rencement de pointeur non vÃ©rifiÃ©
SEC("kprobe/...")
int bad_pointer(struct pt_regs *ctx) {
    struct task_struct *task = bpf_get_current_task();
    int pid = task->pid;  // Si task est NULL â†’ crash !
    return 0;
}
```

**Solution :** Utiliser les helpers de lecture sÃ©curisÃ©e :

```c
// âœ… ACCEPTÃ‰ : Lecture sÃ©curisÃ©e
SEC("kprobe/...")
int good_pointer(struct pt_regs *ctx) {
    struct task_struct *task = bpf_get_current_task();
    int pid;
    bpf_probe_read_kernel(&pid, sizeof(pid), &task->pid);
    return 0;
}
```

### InterprÃ©ter les erreurs du verifier

#### Exemple 1 : Variable non initialisÃ©e

```
Error log:
0: (bf) r1 = r10
1: (07) r1 += -8
2: (7a) *(u64 *)(r1 +0) = 0
3: (85) call bpf_map_lookup_elem#1
4: (15) if r0 == 0x0 goto pc+2
 R0_w=map_value(id=1,off=0,ks=4,vs=8,imm=0)
6: (79) r1 = *(u64 *)(r0 +0)
 R0_w=map_value(id=1,off=0,ks=4,vs=8,imm=0)
7: (bf) r2 = r1
invalid read from stack off -8+8 size 8
```

**Traduction :** Lecture d'une variable non initialisÃ©e sur la pile.

#### Exemple 2 : AccÃ¨s hors limites

```
Error log:
invalid access to packet, off=14 size=4, R1(id=0,off=14,r=14)
R1 offset is outside of the packet
```

**Traduction :** Tentative d'accÃ¨s au-delÃ  de la fin d'un paquet rÃ©seau.

### Activer les logs dÃ©taillÃ©s

```c
// Dans le code C
libbpf_set_print(libbpf_print_fn);

static int libbpf_print_fn(enum libbpf_print_level level,
                           const char *format, va_list args) {
    if (level >= LIBBPF_DEBUG) {
        return vfprintf(stderr, format, args);
    }
    return 0;
}
```

**Ou avec bpftool :**

```bash
sudo bpftool --debug prog load program.bpf.o /sys/fs/bpf/test
```

---

## Ã‰tape 6 : JIT Compilation

Une fois le verifier satisfait, le bytecode eBPF est **JIT compilÃ©** en code machine natif.

### VÃ©rifier le JIT

```bash
# Voir si le JIT est activÃ©
$ cat /proc/sys/net/core/bpf_jit_enable
1  # 1 = activÃ©, 0 = dÃ©sactivÃ©

# Activer si nÃ©cessaire
$ sudo sysctl -w net.core.bpf_jit_enable=1
```

### Comparaison : InterprÃ©tÃ© vs JIT

| Aspect | InterprÃ©tÃ© (JIT off) | JIT compilÃ© (JIT on) |
|--------|---------------------|----------------------|
| **Performance** | 3-5x plus lent | Proche du code C natif |
| **DÃ©marrage** | InstantanÃ© | Compilation (< 1ms) |
| **PortabilitÃ©** | Fonctionne partout | DÃ©pend de l'architecture |
| **Usage** | Debugging | Production |

### Voir le code JIT gÃ©nÃ©rÃ©

```bash
# Dumper le code assembleur natif
$ sudo bpftool prog dump jited id 23

int trace_execve(struct pt_regs * ctx):
bpf_prog_a3f21b4c5d6e7f89_trace_execve:
; int trace_execve(struct pt_regs *ctx) {
   0:   push   %rbp
   1:   mov    %rsp,%rbp
   4:   sub    $0x10,%rsp
   8:   callq  0xffffffffa0001234
  13:   xor    %eax,%eax
  15:   leaveq
  16:   retq
```

**C'est ce code qui s'exÃ©cute rÃ©ellement sur le CPU !**

---

## Workflow complet de dÃ©veloppement

### Makefile moderne

```makefile
# Makefile pour projet eBPF

# Outils
CLANG := clang
BPFTOOL := bpftool
CC := gcc

# Flags
BPF_CFLAGS := -O2 -g -target bpf -Wall -Wextra
BPF_INCLUDES := -I./include -I.

USER_CFLAGS := -Wall -O2
USER_LIBS := -lbpf -lelf -lz

# Fichiers
BPF_SRC := program.bpf.c
BPF_OBJ := $(BPF_SRC:.bpf.c=.bpf.o)
SKEL := $(BPF_SRC:.bpf.c=.skel.h)

USER_SRC := loader.c
USER_BIN := loader

# Cible par dÃ©faut
all: $(USER_BIN)

# GÃ©nÃ©rer vmlinux.h (une fois)
vmlinux.h:
	$(BPFTOOL) btf dump file /sys/kernel/btf/vmlinux format c > $@

# Compiler le programme eBPF
$(BPF_OBJ): $(BPF_SRC) vmlinux.h
	$(CLANG) $(BPF_CFLAGS) $(BPF_INCLUDES) -c $< -o $@

# GÃ©nÃ©rer le skeleton
$(SKEL): $(BPF_OBJ)
	$(BPFTOOL) gen skeleton $< > $@

# Compiler le loader userspace
$(USER_BIN): $(USER_SRC) $(SKEL)
	$(CC) $(USER_CFLAGS) $< -o $@ $(USER_LIBS)

# Tester le chargement
test: $(BPF_OBJ)
	sudo $(BPFTOOL) prog load $< /sys/fs/bpf/test
	@echo "Success! Cleaning up..."
	sudo rm /sys/fs/bpf/test

# Cleanup
clean:
	rm -f $(BPF_OBJ) $(SKEL) $(USER_BIN)

# Nettoyer tout (y compris vmlinux.h)
distclean: clean
	rm -f vmlinux.h

.PHONY: all test clean distclean
```

### Utilisation

```bash
# Compilation complÃ¨te
make

# Tester juste le chargement
make test

# ExÃ©cuter
sudo ./loader

# Nettoyer
make clean
```

---

## Optimisations de compilation

### 1. **Utiliser -Os pour des programmes complexes**

Si le verifier rejette votre programme pour cause de complexitÃ© :

```bash
# Au lieu de -O2
clang -Os -target bpf -c program.bpf.c -o program.bpf.o
```

`-Os` optimise pour la **taille** plutÃ´t que la vitesse, produisant moins d'instructions.

### 2. **Inlining manuel avec __always_inline**

```c
// Forcer l'inlining d'une fonction
static __always_inline int my_helper(int x) {
    return x * 2;
}

SEC("kprobe/...")
int my_program(struct pt_regs *ctx) {
    int result = my_helper(42);  // Sera inline
    return 0;
}
```

### 3. **Ã‰viter les fonctions non inline**

```c
// âŒ PROBLÃˆME : Fonction externe (peut ne pas Ãªtre inline)
static int external_function(int x) {
    return x * 2;
}

// âœ… SOLUTION : Marquer __always_inline
static __always_inline int inline_function(int x) {
    return x * 2;
}
```

### 4. **Loop unrolling**

```c
// DÃ©rouler les boucles
#pragma unroll
for (int i = 0; i < 10; i++) {
    // Le compilateur gÃ©nÃ¨re 10 copies de ce code
}
```

---

## Debugging de la compilation

### ProblÃ¨me 1 : "clang: error: unknown target triple 'bpf'"

**Cause :** Clang installÃ© sans support eBPF.

**Solution :**
```bash
# VÃ©rifier la version de clang
clang --version
# Doit Ãªtre 10.0+

# VÃ©rifier le support BPF
llc --version | grep bpf

# RÃ©installer si nÃ©cessaire
sudo apt install clang llvm
```

### ProblÃ¨me 2 : "undefined reference to 'bpf_probe_read'"

**Cause :** Fonction helper pas correctement liÃ©e.

**Solution :**
```c
// S'assurer d'inclure les headers
#include <bpf/bpf_helpers.h>

// Utiliser la macro SEC() correctement
SEC("kprobe/...")
```

### ProblÃ¨me 3 : "invalid argument" au chargement

**Cause :** Souvent une section license manquante.

**Solution :**
```c
// Ajouter Ã  la fin du fichier .bpf.c
char LICENSE[] SEC("license") = "GPL";
```

### ProblÃ¨me 4 : Erreurs de relocation CO-RE

**Cause :** BTF non disponible ou incompatible.

**Solution :**
```bash
# VÃ©rifier BTF kernel
ls /sys/kernel/btf/vmlinux

# Si absent, mettre Ã  jour le kernel (5.4+)

# VÃ©rifier BTF dans le .o
llvm-objdump -h program.bpf.o | grep BTF
```

---

## Checklist de dÃ©ploiement

### Avant la production

- [ ] Code compilÃ© avec `-O2` (ou `-Os`)
- [ ] Debug symbols activÃ©s (`-g`)
- [ ] Tous les warnings corrigÃ©s (`-Wall -Wextra`)
- [ ] Licence dÃ©finie (`char LICENSE[] SEC("license") = "GPL"`)
- [ ] Programme passe le verifier
- [ ] TestÃ© sur le kernel cible
- [ ] BTF disponible (pour CO-RE)
- [ ] JIT activÃ© (`bpf_jit_enable=1`)
- [ ] Logging appropriÃ© (pas de bpf_printk en prod)
- [ ] Gestion d'erreurs robuste dans le loader

### Tests de compatibilitÃ©

```bash
# Tester sur diffÃ©rentes versions kernel
docker run -it --privileged ubuntu:20.04  # Kernel 5.4
docker run -it --privileged ubuntu:22.04  # Kernel 5.15
docker run -it --privileged ubuntu:24.04  # Kernel 6.x

# Dans chaque conteneur
./loader  # Doit fonctionner partout (CO-RE)
```

---

## Ressources avancÃ©es

### Documentation officielle

- **LLVM BPF backend** : https://llvm.org/docs/BPFBackend.html
- **BPF verifier** : https://www.kernel.org/doc/html/latest/bpf/verifier.html
- **libbpf API** : https://libbpf.readthedocs.io/

### Outils utiles

```bash
# Analyser un fichier objet eBPF
llvm-objdump -h program.bpf.o     # Sections
llvm-objdump -d program.bpf.o     # Disassemblage
llvm-readelf -a program.bpf.o     # Toutes les infos
```

### Debugging avancÃ©

```bash
# Tracer le processus de chargement
strace -e bpf ./loader

# Voir tous les syscalls eBPF
sudo bpftrace -e 'tracepoint:syscalls:sys_enter_bpf { printf("%s\n", comm); }'
```

---

## Conclusion

La **compilation et le chargement** d'un programme eBPF peuvent sembler complexes, mais en comprenant chaque Ã©tape, le processus devient maÃ®trisable :

- âœ… **Compilation** : Clang avec `-O2 -g -target bpf`
- âœ… **Fichier objet** : ELF contenant bytecode, maps, BTF
- âœ… **Chargement** : libbpf lit l'ELF, applique CO-RE, charge dans le kernel
- âœ… **VÃ©rification** : Le verifier valide la sÃ©curitÃ©
- âœ… **JIT** : Compilation en code natif pour performance maximale
- âœ… **Attachement** : Le programme devient actif sur le hook

La clÃ© du succÃ¨s est de :
- Toujours compiler avec `-O2 -g`
- Comprendre les messages du verifier
- Tester sur diffÃ©rents kernels (CO-RE)
- Utiliser un Makefile moderne
- Activer les logs en cas de problÃ¨me

Avec ces connaissances, vous Ãªtes maintenant capable de compiler, charger, et debugger n'importe quel programme eBPF. Dans la section suivante (21.5), nous crÃ©erons notre premier programme eBPF complet en pratique.

---

**ğŸ’¡ Ã€ retenir :**
- Compilation : `clang -O2 -g -target bpf -c program.bpf.c -o program.bpf.o`
- Le verifier valide la sÃ©curitÃ© (pas de boucles infinies, accÃ¨s mÃ©moire sÃ»rs)
- CO-RE rend les programmes portables entre versions kernel
- JIT compilation pour performances natives
- libbpf simplifie le chargement et la gestion
- Toujours tester le chargement avec `make test` ou bpftool

---

â­ï¸ [Premier programme eBPF](/21-introduction-ebpf/05-premier-programme.md)
