üîù Retour au [Sommaire](/SOMMAIRE.md)

# 15.7.2 lcov - Visualisation Graphique de la Couverture de Code

## Introduction

**lcov** (Linux Test Project Coverage) est un outil graphique qui transforme les donn√©es brutes de **gcov** en magnifiques rapports HTML interactifs et faciles √† naviguer. C'est le compl√©ment id√©al √† gcov pour visualiser et analyser la couverture de code de mani√®re intuitive.

### Pourquoi utiliser lcov ?

Alors que gcov g√©n√®re des fichiers texte annot√©s (`.gcov`), lcov offre :

**Avantages de lcov :**
- üé® **Interface HTML moderne** : Rapports color√©s et interactifs
- üìä **Graphiques visuels** : Barres de progression, diagrammes
- üóÇÔ∏è **Navigation hi√©rarchique** : Vue par r√©pertoire, par fichier, par fonction
- üîç **Code source coloris√©** : Vert (couvert), rouge (non couvert)
- üìà **Statistiques d√©taill√©es** : Pourcentages globaux et par composant
- üíæ **Export multiple** : HTML, JSON, XML
- üîÑ **Comparaison de rapports** : Suivre l'√©volution dans le temps

### lcov vs gcov : Comparaison

| Aspect | gcov | lcov |
|--------|------|------|
| **Sortie** | Fichiers texte `.gcov` | Rapports HTML interactifs |
| **Visualisation** | ‚≠ê Basique | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Excellente |
| **Navigation** | Fichier par fichier | Hi√©rarchique (projet ‚Üí r√©pertoire ‚Üí fichier) |
| **Graphiques** | ‚ùå Non | ‚úÖ Barres, pourcentages |
| **Couleurs** | ‚ùå Non | ‚úÖ Vert/rouge/gris |
| **Filtrage** | ‚ùå Limit√© | ‚úÖ Avanc√© (patterns, chemins) |
| **Export** | Texte | HTML, JSON, XML |
| **Partage** | ‚ùå Difficile | ‚úÖ Facile (site web statique) |

**En r√©sum√© :** lcov = gcov + belle interface graphique !

---

## Installation

### Sur Ubuntu/Debian

```bash
sudo apt update  
sudo apt install lcov  
```

### V√©rification de l'installation

```bash
lcov --version
```

**Sortie typique :**
```
lcov: LCOV version 1.14
```

### Pr√©requis

- **gcov** : Install√© avec GCC (automatique)
- **genhtml** : Install√© avec lcov (automatique)
- **Perl** : N√©cessaire pour lcov (g√©n√©ralement d√©j√† install√©)

---

## Utilisation de base

### Workflow complet : De la compilation au rapport HTML

Voici le processus en 5 √©tapes :

```
1. COMPILATION          2. EX√âCUTION         3. CAPTURE           4. G√âN√âRATION        5. VISUALISATION
   (avec gcov)            (tests)              (lcov)              (genhtml)            (navigateur)
       ‚Üì                      ‚Üì                    ‚Üì                    ‚Üì                     ‚Üì
gcc -fprofile-arcs  ‚Üí  ./programme  ‚Üí  lcov --capture  ‚Üí  genhtml  ‚Üí  firefox report.html
   -ftest-coverage
```

### Exemple simple : Hello World avec lcov

**√âtape 1 : Cr√©er le code source**

Cr√©ons `hello.c` :

```c
#include <stdio.h>

void print_hello() {
    printf("Hello, World!\n");
}

void print_goodbye() {
    printf("Goodbye, World!\n");
}

void print_message(int type) {
    if (type == 0) {
        print_hello();
    } else if (type == 1) {
        print_goodbye();
    } else {
        printf("Unknown message type\n");
    }
}

int main() {
    print_message(0);
    // print_message(1) et print_message(2) non appel√©s
    return 0;
}
```

**√âtape 2 : Compiler avec les options de couverture**

```bash
gcc -fprofile-arcs -ftest-coverage -o hello hello.c
```

**√âtape 3 : Ex√©cuter le programme**

```bash
./hello
```

**Sortie :**
```
Hello, World!
```

Cela g√©n√®re les fichiers `.gcda` (donn√©es de couverture).

**√âtape 4 : Capturer les donn√©es de couverture avec lcov**

```bash
lcov --capture --directory . --output-file coverage.info
```

**Sortie typique :**
```
Capturing coverage data from .  
Found gcov version: 11.4.0  
Using intermediate gcov format  
Scanning . for .gcda files ...  
Found 1 data files in .  
Processing hello.gcda  
Finished .info-file creation  
```

Le fichier `coverage.info` contient toutes les donn√©es de couverture au format LCOV.

**√âtape 5 : G√©n√©rer le rapport HTML**

```bash
genhtml coverage.info --output-directory coverage_html
```

**Sortie typique :**
```
Reading data file coverage.info  
Found 1 entries.  
Found common filename prefix "/home/user/project"  
Writing .css and .png files.  
Generating output.  
Processing file hello.c  
Writing directory view page.  
Overall coverage rate:  
  lines......: 60.0% (6 of 10 lines)
  functions..: 75.0% (3 of 4 functions)
```

**√âtape 6 : Visualiser le rapport**

```bash
# Ouvrir dans le navigateur
xdg-open coverage_html/index.html

# Ou avec Firefox/Chrome
firefox coverage_html/index.html
```

Vous verrez une magnifique page HTML avec :
- üìä Un r√©sum√© global de la couverture
- üìÅ Une liste des fichiers avec leurs pourcentages
- üé® Du code source color√© (vert = couvert, rouge = non couvert)

---

## Structure du rapport HTML

### Page d'accueil (index.html)

La page principale affiche :

**1. R√©sum√© global :**
```
Directory       Line Coverage    Functions    Branches
-------------------------------------------------------
.               60.0% (6/10)    75.0% (3/4)   50.0% (2/4)
```

**2. Barres de progression color√©es :**
- üü¢ **Vert** (> 80%) : Bonne couverture
- üü° **Jaune** (60-80%) : Couverture moyenne
- üî¥ **Rouge** (< 60%) : Faible couverture

**3. Liste des fichiers/r√©pertoires :**
Chaque fichier est cliquable pour voir le d√©tail.

### Page de d√©tail d'un fichier

En cliquant sur un fichier, vous voyez :

**1. Code source coloris√© :**
```c
     1  #include <stdio.h>
     2
   1 3  void print_hello() {
   1 4      printf("Hello, World!\n");
   1 5  }
     6
  #### 7  void print_goodbye() {
  #### 8      printf("Goodbye, World!\n");
  #### 9  }
```

**L√©gende des couleurs :**
- üü¢ **Vert** : Ligne ex√©cut√©e (avec le nombre d'ex√©cutions)
- üî¥ **Rouge** : Ligne non ex√©cut√©e (`####`)
- ‚ö™ **Blanc** : Ligne non ex√©cutable (commentaires, d√©clarations)

**2. Statistiques d√©taill√©es :**
- Couverture de lignes : 60.0% (6/10)
- Couverture de fonctions : 75.0% (3/4)
- Couverture de branches : 50.0% (2/4)

**3. Liste des fonctions :**
```
Function        Line Coverage
-----------------------------
print_hello     100% (2/2)  
print_goodbye   0% (0/2)  
print_message   66.7% (4/6)  
main            100% (2/2)  
```

---

## Commandes principales de lcov

### 1. Capturer la couverture

**Commande de base :**

```bash
lcov --capture --directory . --output-file coverage.info
```

**Options utiles :**

```bash
# Capturer depuis un r√©pertoire sp√©cifique
lcov --capture --directory ./build --output-file coverage.info

# Capturer avec un nom de test
lcov --capture --directory . --test-name "MyTests" --output-file coverage.info

# Mode verbeux pour debugging
lcov --capture --directory . --output-file coverage.info --verbose
```

### 2. R√©initialiser les compteurs

**Avant de lancer de nouveaux tests, r√©initialisez les compteurs :**

```bash
lcov --zerocounters --directory .
```

Cela supprime tous les fichiers `.gcda` pour repartir √† z√©ro.

### 3. Cr√©er un rapport de base (baseline)

**Avant toute ex√©cution, capturez l'√©tat initial :**

```bash
# Baseline (0% couverture)
lcov --capture --initial --directory . --output-file coverage_base.info
```

Utile pour voir **tout** le code, m√™me celui qui n'a jamais √©t√© ex√©cut√©.

### 4. Combiner des rapports

**Fusionner plusieurs fichiers `.info` :**

```bash
# Combiner baseline et r√©sultats de tests
lcov --add-tracefile coverage_base.info \
     --add-tracefile coverage_test.info \
     --output-file coverage_total.info
```

### 5. Filtrer les donn√©es

#### Supprimer des fichiers/r√©pertoires

```bash
# Supprimer les headers syst√®me
lcov --remove coverage.info '/usr/*' --output-file coverage_filtered.info

# Supprimer plusieurs patterns
lcov --remove coverage.info \
     '/usr/*' \
     '*/test/*' \
     '*/vendor/*' \
     --output-file coverage_filtered.info
```

#### Garder uniquement certains fichiers

```bash
# Garder seulement les fichiers du projet
lcov --extract coverage.info '*/src/*' --output-file coverage_src.info
```

### 6. Afficher un r√©sum√©

```bash
# R√©sum√© dans le terminal
lcov --list coverage.info
```

**Sortie :**
```
Reading tracefile coverage.info
                        |Lines      |Functions |Branches
Filename                |Rate    Num|Rate   Num|Rate   Num
=========================================================
[src/]
hello.c                 |60.0%    10|75.0%   4|50.0%  4
=========================================================
                  Total:|60.0%    10|75.0%   4|50.0%  4
```

---

## G√©n√©ration de rapports HTML avec genhtml

### Commande de base

```bash
genhtml coverage.info --output-directory coverage_html
```

### Options de personnalisation

#### Titre personnalis√©

```bash
genhtml coverage.info \
    --output-directory coverage_html \
    --title "My Project Coverage Report" \
    --legend
```

#### Options de style

```bash
genhtml coverage.info \
    --output-directory coverage_html \
    --title "Coverage Report" \
    --legend \
    --show-details \
    --branch-coverage
```

**Explication des options :**
- `--title` : Titre du rapport
- `--legend` : Afficher la l√©gende des couleurs
- `--show-details` : Afficher les d√©tails des branches
- `--branch-coverage` : Inclure la couverture de branches

#### Seuils de couleur personnalis√©s

```bash
genhtml coverage.info \
    --output-directory coverage_html \
    --rc genhtml_hi_limit=90 \
    --rc genhtml_med_limit=75
```

**Seuils :**
- **Vert** : ‚â• 90%
- **Jaune** : 75-89%
- **Rouge** : < 75%

#### Pr√©fixe de chemin

```bash
genhtml coverage.info \
    --output-directory coverage_html \
    --prefix /home/user/project
```

Retire le pr√©fixe des chemins dans le rapport (plus lisible).

---

## Exemple complet : Projet multi-fichiers

### Structure du projet

```
myproject/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.c
‚îÇ   ‚îú‚îÄ‚îÄ math_utils.c
‚îÇ   ‚îî‚îÄ‚îÄ string_utils.c
‚îú‚îÄ‚îÄ include/
‚îÇ   ‚îú‚îÄ‚îÄ math_utils.h
‚îÇ   ‚îî‚îÄ‚îÄ string_utils.h
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îî‚îÄ‚îÄ test_runner.c
‚îú‚îÄ‚îÄ Makefile
‚îî‚îÄ‚îÄ run_coverage.sh
```

### Fichiers sources

**src/math_utils.c :**

```c
#include "math_utils.h"

int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

int multiply(int a, int b) {
    return a * b;
}

int divide(int a, int b) {
    if (b == 0) {
        return 0;
    }
    return a / b;
}
```

**src/string_utils.c :**

```c
#include "string_utils.h"
#include <string.h>

int string_length(const char *str) {
    return strlen(str);
}

void string_copy(char *dest, const char *src) {
    strcpy(dest, src);
}
```

**src/main.c :**

```c
#include <stdio.h>
#include "math_utils.h"
#include "string_utils.h"

int main() {
    printf("Addition: %d\n", add(5, 3));
    printf("Subtraction: %d\n", subtract(10, 4));

    char buffer[50];
    string_copy(buffer, "Hello");
    printf("String: %s (length: %d)\n", buffer, string_length(buffer));

    return 0;
}
```

### Makefile avec support lcov

```makefile
CC = gcc  
CFLAGS = -Wall -Wextra -std=c11 -I./include  
COVERAGE_FLAGS = -fprofile-arcs -ftest-coverage  
LDFLAGS = -lgcov  

SRC_DIR = src  
SRC = $(wildcard $(SRC_DIR)/*.c)  
OBJ = $(SRC:.c=.o)  
EXEC = myapp  

# Build normal
all: $(EXEC)

$(EXEC): $(OBJ)
	$(CC) $(OBJ) -o $@

%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@

# Build avec couverture
coverage: CFLAGS += $(COVERAGE_FLAGS)  
coverage: LDFLAGS += $(COVERAGE_FLAGS)  
coverage: clean $(EXEC)  

# G√©n√©rer le rapport de couverture
coverage-report: coverage
	@echo "üß™ Running tests..."
	./$(EXEC)

	@echo "üìä Generating coverage report..."
	# R√©initialiser d'abord (si besoin)
	lcov --zerocounters --directory .

	# Capturer la baseline
	lcov --capture --initial --directory . \
	     --output-file coverage_base.info

	# Re-ex√©cuter pour capturer les donn√©es
	./$(EXEC)
	lcov --capture --directory . --output-file coverage_test.info

	# Combiner baseline et test
	lcov --add-tracefile coverage_base.info \
	     --add-tracefile coverage_test.info \
	     --output-file coverage_total.info

	# Filtrer les fichiers syst√®me
	lcov --remove coverage_total.info '/usr/*' \
	     --output-file coverage_filtered.info

	# G√©n√©rer le HTML
	genhtml coverage_filtered.info \
	        --output-directory coverage_html \
	        --title "MyProject Coverage" \
	        --legend \
	        --show-details

	@echo "‚úÖ Coverage report generated in coverage_html/"
	@echo "üìÇ Open: coverage_html/index.html"

# Nettoyer
clean:
	rm -f $(OBJ) $(EXEC)
	rm -f *.gcno *.gcda *.gcov *.info
	rm -rf coverage_html

# Ouvrir le rapport
view-coverage:
	xdg-open coverage_html/index.html

.PHONY: all coverage coverage-report clean view-coverage
```

### Script automatis√© : run_coverage.sh

```bash
#!/bin/bash

set -e

# Couleurs
GREEN='\033[0;32m'  
YELLOW='\033[1;33m'  
RED='\033[0;31m'  
NC='\033[0m' # No Color  

echo "üßπ Cleaning old coverage data..."  
make clean  

echo ""  
echo "üî® Building with coverage..."  
make coverage  

echo ""  
echo "üß™ Running program..."  
./myapp

echo ""  
echo "üìä Capturing coverage data..."  

# Baseline
lcov --capture --initial --directory . \
     --output-file coverage_base.info --quiet

# Test data
lcov --capture --directory . \
     --output-file coverage_test.info --quiet

# Combine
lcov --add-tracefile coverage_base.info \
     --add-tracefile coverage_test.info \
     --output-file coverage_total.info --quiet

# Filter
lcov --remove coverage_total.info \
     '/usr/*' \
     '*/test/*' \
     --output-file coverage_filtered.info --quiet

echo ""  
echo "üé® Generating HTML report..."  
genhtml coverage_filtered.info \  
        --output-directory coverage_html \
        --title "MyProject Coverage Report" \
        --legend \
        --show-details \
        --branch-coverage \
        --quiet

echo ""  
echo -e "${GREEN}‚úÖ Coverage report generated!${NC}"  
echo ""  
echo "üìÇ Report location: coverage_html/index.html"  

# Afficher le r√©sum√©
echo ""  
echo "üìà Coverage Summary:"  
lcov --list coverage_filtered.info | tail -n 3  

# V√©rifier le seuil
COVERAGE=$(lcov --summary coverage_filtered.info 2>&1 | grep lines | awk '{print $2}' | tr -d '%')  
THRESHOLD=80  

echo ""  
if (( $(echo "$COVERAGE < $THRESHOLD" | bc -l) )); then  
    echo -e "${RED}‚ùå Coverage ($COVERAGE%) is below threshold ($THRESHOLD%)${NC}"
    exit 1
else
    echo -e "${GREEN}‚úÖ Coverage ($COVERAGE%) meets threshold ($THRESHOLD%)${NC}"
fi

# Ouvrir automatiquement le rapport
if [ -n "$DISPLAY" ]; then
    echo ""
    echo "üåê Opening report in browser..."
    xdg-open coverage_html/index.html &
fi
```

**Utilisation :**

```bash
chmod +x run_coverage.sh
./run_coverage.sh
```

---

## Filtrage avanc√©

### Patterns courants √† exclure

```bash
lcov --remove coverage.info \
    '/usr/*' \                      # Headers syst√®me
    '/usr/include/*' \              # Headers syst√®me explicites
    '**/test/*' \                   # Dossier tests
    '**/tests/*' \                  # Dossier tests (variante)
    '**/vendor/*' \                 # Biblioth√®ques tierces
    '**/third_party/*' \            # Biblioth√®ques tierces (variante)
    '**/*_test.c' \                 # Fichiers de test
    '**/mock_*.c' \                 # Fichiers de mock
    --output-file coverage_clean.info
```

### Patterns courants √† inclure

```bash
lcov --extract coverage.info \
    '*/src/*' \                     # Code source principal
    '*/include/*' \                 # Headers du projet
    --output-file coverage_src.info
```

### Combiner inclusion et exclusion

```bash
# 1. Extraire uniquement le code source
lcov --extract coverage.info '*/src/*' --output-file temp.info

# 2. Supprimer les fichiers de test
lcov --remove temp.info '*_test.c' --output-file coverage_final.info

# 3. Nettoyer
rm temp.info
```

---

## Int√©gration avec CMake

### CMakeLists.txt avec support lcov

```cmake
cmake_minimum_required(VERSION 3.15)  
project(MyProject C)  

set(CMAKE_C_STANDARD 11)

# Option pour activer la couverture
option(ENABLE_COVERAGE "Enable code coverage" OFF)

if(ENABLE_COVERAGE)
    message(STATUS "Code coverage enabled")

    # V√©rifier la disponibilit√© de lcov
    find_program(LCOV_PATH lcov)
    find_program(GENHTML_PATH genhtml)

    if(NOT LCOV_PATH OR NOT GENHTML_PATH)
        message(FATAL_ERROR "lcov and genhtml are required for coverage")
    endif()

    # Flags de couverture
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -fprofile-arcs -ftest-coverage")
    set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -lgcov")

    # Target pour g√©n√©rer le rapport
    add_custom_target(coverage
        # R√©initialiser
        COMMAND ${LCOV_PATH} --zerocounters --directory .

        # Capturer baseline
        COMMAND ${LCOV_PATH} --capture --initial --directory .
                --output-file coverage_base.info

        # Ex√©cuter les tests
        COMMAND ${CMAKE_CTEST_COMMAND} --output-on-failure

        # Capturer les r√©sultats
        COMMAND ${LCOV_PATH} --capture --directory .
                --output-file coverage_test.info

        # Combiner
        COMMAND ${LCOV_PATH} --add-tracefile coverage_base.info
                --add-tracefile coverage_test.info
                --output-file coverage_total.info

        # Filtrer
        COMMAND ${LCOV_PATH} --remove coverage_total.info
                '/usr/*' '*/test/*'
                --output-file coverage_filtered.info

        # G√©n√©rer HTML
        COMMAND ${GENHTML_PATH} coverage_filtered.info
                --output-directory coverage_html
                --title "${PROJECT_NAME} Coverage"
                --legend --show-details

        WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
        COMMENT "Generating code coverage report"
    )

    # Target pour ouvrir le rapport
    add_custom_target(coverage-view
        COMMAND xdg-open coverage_html/index.html
        DEPENDS coverage
        WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
        COMMENT "Opening coverage report"
    )
endif()

# Sources
add_executable(myapp src/main.c src/utils.c)

# Tests
enable_testing()  
add_test(NAME test_myapp COMMAND myapp)  
```

**Utilisation :**

```bash
# Build avec couverture
cmake -B build -DENABLE_COVERAGE=ON  
cmake --build build  

# G√©n√©rer le rapport
cd build  
make coverage  

# Ouvrir le rapport
make coverage-view
```

---

## Int√©gration CI/CD

### GitHub Actions

**`.github/workflows/coverage.yml` :**

```yaml
name: Code Coverage

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  coverage:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y gcc lcov

      - name: Build with coverage
        run: |
          gcc -fprofile-arcs -ftest-coverage \
              -o myapp src/*.c -I./include

      - name: Run tests
        run: ./myapp

      - name: Generate coverage report
        run: |
          # Capture coverage
          lcov --capture --directory . \
               --output-file coverage.info

          # Filter system files
          lcov --remove coverage.info '/usr/*' \
               --output-file coverage_filtered.info

          # Generate HTML
          genhtml coverage_filtered.info \
                  --output-directory coverage_html

      - name: Check coverage threshold
        run: |
          COVERAGE=$(lcov --summary coverage_filtered.info 2>&1 | \
                     grep lines | awk '{print $2}' | tr -d '%')
          echo "Coverage: $COVERAGE%"

          if (( $(echo "$COVERAGE < 80" | bc -l) )); then
            echo "‚ùå Coverage below 80%"
            exit 1
          fi

      - name: Upload coverage report
        uses: actions/upload-artifact@v3
        with:
          name: coverage-report
          path: coverage_html/

      - name: Comment PR with coverage
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const coverage = fs.readFileSync('coverage_filtered.info', 'utf8');
            // Parser et commenter...
```

### GitLab CI

**`.gitlab-ci.yml` :**

```yaml
image: ubuntu:22.04

stages:
  - build
  - test
  - report

variables:
  GIT_SUBMODULE_STRATEGY: recursive

before_script:
  - apt-get update -qq
  - apt-get install -y -qq gcc lcov

build:
  stage: build
  script:
    - gcc -fprofile-arcs -ftest-coverage -o myapp src/*.c -I./include
  artifacts:
    paths:
      - myapp
      - "*.gcno"
    expire_in: 1 hour

test:
  stage: test
  dependencies:
    - build
  script:
    - ./myapp
  artifacts:
    paths:
      - "*.gcda"
    expire_in: 1 hour

coverage-report:
  stage: report
  dependencies:
    - build
    - test
  script:
    # Capture coverage
    - lcov --capture --directory . --output-file coverage.info

    # Filter
    - lcov --remove coverage.info '/usr/*' --output-file coverage_filtered.info

    # Generate HTML
    - genhtml coverage_filtered.info --output-directory coverage_html

    # Display summary
    - lcov --list coverage_filtered.info

  coverage: '/lines\.*: (\d+\.\d+)%/'

  artifacts:
    paths:
      - coverage_html/
    expire_in: 30 days

  # Publier en GitLab Pages
  pages:
    paths:
      - coverage_html
```

---

## Configuration avanc√©e : fichier .lcovrc

Pour personnaliser le comportement de lcov, cr√©ez un fichier `.lcovrc` :

**Exemple de `.lcovrc` :**

```ini
# Configuration globale de lcov

# Seuils de couleur pour genhtml
genhtml_hi_limit = 90  
genhtml_med_limit = 75  

# Pr√©fixe √† retirer des chemins
genhtml_prefix = /home/user/project

# Options par d√©faut
lcov_branch_coverage = 1  
genhtml_branch_coverage = 1  

# Fonction pour extraire le nom des tests
genhtml_function_hi_limit = 90  
genhtml_function_med_limit = 75  

# Ignorer les erreurs sur les fichiers manquants
lcov_excl_line = LCOV_EXCL_LINE  
lcov_excl_br_line = LCOV_EXCL_BR_LINE  
```

**Utilisation :**

```bash
# lcov utilisera automatiquement le fichier .lcovrc s'il existe
lcov --capture --directory . --output-file coverage.info
```

---

## Marqueurs d'exclusion

### Exclure du code de la couverture

Parfois, certaines parties du code ne doivent pas √™tre comptabilis√©es :

#### LCOV_EXCL_LINE : Exclure une ligne

```c
int debug_mode = 1;  // LCOV_EXCL_LINE
```

#### LCOV_EXCL_START / LCOV_EXCL_STOP : Exclure un bloc

```c
// LCOV_EXCL_START
void debug_function() {
    printf("Debug info\n");
    // Ce code ne sera pas compt√© dans la couverture
}
// LCOV_EXCL_STOP
```

#### LCOV_EXCL_BR_LINE : Exclure une branche

```c
if (debug_enabled) {  // LCOV_EXCL_BR_LINE
    log_debug("Debug message");
}
```

### Exemple complet

```c
#include <stdio.h>
#include <assert.h>

int process_data(int x) {
    // LCOV_EXCL_START
    #ifdef DEBUG
    printf("Debug: x = %d\n", x);
    #endif
    // LCOV_EXCL_STOP

    if (x < 0) {
        return -1;
    }

    assert(x >= 0);  // LCOV_EXCL_LINE (assert non test√©)

    return x * 2;
}
```

---

## Comparaison de rapports

### Comparer deux versions

Pour suivre l'√©volution de la couverture entre deux versions :

```bash
# Version 1
./run_tests_v1
lcov --capture --directory . --output-file coverage_v1.info

# Version 2
./run_tests_v2
lcov --capture --directory . --output-file coverage_v2.info

# Comparer
lcov --diff coverage_v1.info coverage_v2.info \
     --output-file coverage_diff.info

# G√©n√©rer le rapport de diff√©rence
genhtml coverage_diff.info --output-directory coverage_diff_html
```

### Suivre l'√©volution dans le temps

**Script `track_coverage.sh` :**

```bash
#!/bin/bash

DATE=$(date +%Y%m%d)  
REPORT_DIR="coverage_history/$DATE"  

mkdir -p "$REPORT_DIR"

# G√©n√©rer la couverture
./run_coverage.sh

# Copier le rapport
cp -r coverage_html "$REPORT_DIR/"  
cp coverage_filtered.info "$REPORT_DIR/coverage.info"  

# Extraire le pourcentage
COVERAGE=$(lcov --summary coverage_filtered.info 2>&1 | \
           grep lines | awk '{print $2}' | tr -d '%')

# Logger
echo "$DATE,$COVERAGE" >> coverage_history.csv

echo "Coverage: $COVERAGE% (saved to $REPORT_DIR)"
```

### Visualiser les tendances

**Script Python `plot_coverage.py` :**

```python
#!/usr/bin/env python3

import pandas as pd  
import matplotlib.pyplot as plt  

# Lire l'historique
df = pd.read_csv('coverage_history.csv', names=['date', 'coverage'])  
df['date'] = pd.to_datetime(df['date'], format='%Y%m%d')  

# Tracer
plt.figure(figsize=(12, 6))  
plt.plot(df['date'], df['coverage'], marker='o')  
plt.axhline(y=80, color='r', linestyle='--', label='Target: 80%')  
plt.xlabel('Date')  
plt.ylabel('Coverage (%)')  
plt.title('Code Coverage Evolution')  
plt.legend()  
plt.grid(True)  
plt.savefig('coverage_trend.png')  
print("Graph saved to coverage_trend.png")  
```

---

## Bonnes pratiques

### 1. Automatiser compl√®tement

Ne comptez pas sur les d√©veloppeurs pour lancer manuellement les rapports.

**Cr√©ez un script tout-en-un :**

```bash
#!/bin/bash
make clean  
make coverage  
./run_tests
./generate_coverage_report.sh
```

### 2. Int√©grer dans le CI/CD

G√©n√©rez et archivez les rapports √† chaque build :

```yaml
- name: Archive coverage report
  uses: actions/upload-artifact@v3
  with:
    name: coverage-report-${{ github.sha }}
    path: coverage_html/
    retention-days: 30
```

### 3. D√©finir des seuils clairs

```bash
# √âchec si couverture < 80%
COVERAGE=$(lcov --summary coverage.info 2>&1 | grep lines | awk '{print $2}' | tr -d '%')  
if (( $(echo "$COVERAGE < 80" | bc -l) )); then  
    exit 1
fi
```

### 4. Exclure intelligemment

N'incluez pas dans la couverture :
- ‚ùå Code de test lui-m√™me
- ‚ùå Biblioth√®ques tierces
- ‚ùå Code g√©n√©r√© automatiquement
- ‚ùå Code de debugging

Incluez :
- ‚úÖ Code m√©tier
- ‚úÖ Gestion d'erreurs
- ‚úÖ Fonctions utilitaires

### 5. Publier les rapports

**GitHub Pages :**

```bash
# Branche gh-pages pour h√©berger les rapports
git checkout --orphan gh-pages  
cp -r coverage_html/* .  
git add .  
git commit -m "Coverage report"  
git push origin gh-pages  
```

Accessible √† : `https://username.github.io/repo/`

### 6. Commenter les PRs avec la couverture

Utilisez des bots pour commenter automatiquement :
- Coverage bot pour GitHub
- Danger pour automatiser les reviews

---

## D√©pannage

### Probl√®me : "cannot open notes file"

**Solution :**

```bash
# S'assurer que lcov est ex√©cut√© dans le bon r√©pertoire
cd build  
lcov --capture --directory . --output-file coverage.info  
```

### Probl√®me : Rapport vide ou incomplet

**Causes possibles :**
1. Programme non ex√©cut√©
2. Fichiers `.gcda` non g√©n√©r√©s
3. Mauvais r√©pertoire de capture

**Solution :**

```bash
# V√©rifier la pr√©sence des fichiers .gcda
find . -name "*.gcda"

# Capturer avec le bon r√©pertoire
lcov --capture --directory $(pwd) --output-file coverage.info
```

### Probl√®me : Erreurs de parsing

**Erreur :**
```
geninfo: ERROR: cannot read file.gcov!
```

**Solution :**

```bash
# Utiliser la bonne version de gcov
lcov --capture --directory . --gcov-tool /usr/bin/gcov-11 \
     --output-file coverage.info
```

### Probl√®me : Chemins absolus dans le rapport

**Solution :**

```bash
# Utiliser --prefix pour nettoyer les chemins
genhtml coverage.info \
        --output-directory coverage_html \
        --prefix $(pwd)
```

---

## Outils compl√©mentaires

### gcovr : Alternative √† lcov

**Installation :**

```bash
pip install gcovr
```

**Utilisation :**

```bash
# Rapport HTML
gcovr --html-details coverage.html

# Rapport XML (Cobertura)
gcovr --xml coverage.xml

# Rapport texte
gcovr
```

### Codecov / Coveralls

Services cloud pour h√©berger et visualiser les rapports :

```bash
# Upload vers Codecov
bash <(curl -s https://codecov.io/bash)

# Upload vers Coveralls
coveralls --gcov-options '\-lp'
```

---

## R√©sum√©

**lcov** transforme les donn√©es brutes de gcov en rapports HTML professionnels :

- ‚úÖ **Interface graphique** : Navigation intuitive
- ‚úÖ **Visualisation color√©e** : Vert (couvert) / Rouge (non couvert)
- ‚úÖ **Statistiques compl√®tes** : Lignes, fonctions, branches
- ‚úÖ **Filtrage avanc√©** : Exclure fichiers syst√®me, tests
- ‚úÖ **Int√©gration facile** : CI/CD, CMake, Makefile
- ‚úÖ **Gratuit et open-source** : Pas de co√ªt, code accessible

**Workflow minimal :**

```bash
# 1. Compiler avec couverture
gcc -fprofile-arcs -ftest-coverage -o prog prog.c

# 2. Ex√©cuter
./prog

# 3. Capturer
lcov --capture --directory . --output-file coverage.info

# 4. G√©n√©rer HTML
genhtml coverage.info --output-directory coverage_html

# 5. Visualiser
xdg-open coverage_html/index.html
```

**Commande tout-en-un recommand√©e :**

```bash
lcov --capture --directory . --output-file coverage.info && \  
lcov --remove coverage.info '/usr/*' --output-file coverage_filtered.info && \  
genhtml coverage_filtered.info --output-directory coverage_html --legend && \  
xdg-open coverage_html/index.html  
```

**üí° Conseil final :** Utilisez lcov pour **visualiser et communiquer** la couverture de code. Un beau rapport HTML est beaucoup plus efficace qu'un fichier texte pour convaincre l'√©quipe d'am√©liorer les tests ! Int√©grez-le dans votre CI/CD et affichez les rapports publiquement pour maintenir la pression sur la qualit√©.

---

**üéØ Prochaine √©tape :** Dans la section suivante (15.7.3), nous verrons comment **int√©grer la couverture dans le CI** de mani√®re robuste et automatis√©e pour garantir une qualit√© constante du code.

‚è≠Ô∏è [Int√©gration dans le CI](/15-debogage-et-qualite/07.3-integration-ci.md)
