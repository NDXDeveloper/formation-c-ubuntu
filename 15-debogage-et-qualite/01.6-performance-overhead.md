üîù Retour au [Sommaire](/SOMMAIRE.md)

# 15.1.6 Performance et overhead

## Introduction

Les sanitizers sont des outils extr√™mement puissants pour d√©tecter les bugs, mais ils ont un **co√ªt en performance**. Cette section vous aide √† comprendre l'impact des sanitizers sur la vitesse d'ex√©cution et la consommation m√©moire de vos programmes, et comment optimiser leur utilisation.

### Qu'est-ce que l'overhead ?

**L'overhead** (surcharge) est le co√ªt suppl√©mentaire introduit par les sanitizers :
- üêå **Temps d'ex√©cution** : Le programme est plus lent
- üíæ **M√©moire** : Le programme consomme plus de RAM
- üì¶ **Taille du binaire** : L'ex√©cutable est plus gros

**Question importante :** Cet overhead est-il acceptable ?

**R√©ponse :** Oui, car :
- ‚úÖ Les sanitizers sont **uniquement pour le d√©veloppement et les tests**
- ‚úÖ Les bugs d√©tect√©s valent largement le ralentissement
- ‚úÖ En production, on compile **sans sanitizers** (overhead = 0%)

### Pourquoi comprendre l'overhead ?

1. **Choisir le bon sanitizer** pour chaque situation
2. **Optimiser votre workflow** de d√©veloppement
3. **Planifier le temps de tests** en CI/CD
4. **√âviter les frustrations** li√©es aux ralentissements

---

## Vue d'ensemble des performances

### Tableau r√©capitulatif

| Sanitizer | Ralentissement | M√©moire suppl√©mentaire | Taille binaire | Usage recommand√© |
|-----------|----------------|------------------------|----------------|------------------|
| **ASan** | ~2√ó (100%) | ~3√ó (200%) | +50-100% | D√©veloppement quotidien |
| **UBSan** | ~1.2√ó (20%) | +5-10% | +10-20% | D√©veloppement quotidien |
| **TSan** | ~5-15√ó (400-1400%) | ~5-10√ó (400-900%) | +50-100% | Tests sp√©cifiques |
| **LSan** | ~1.05√ó (5%) | +5-10% | +10% | D√©veloppement / Tests |
| **ASan+UBSan** | ~2.5√ó (150%) | ~3√ó (200%) | +100% | D√©veloppement / CI/CD |

**L√©gende :**
- Ralentissement : Combien de fois plus lent que sans sanitizer
- M√©moire suppl√©mentaire : Multiplication de la consommation RAM
- Taille binaire : Augmentation de la taille de l'ex√©cutable

### Visualisation de l'impact

```
Temps d'ex√©cution (√©chelle logarithmique)

Sans sanitizer    : ‚ñà‚ñà‚ñà‚ñà (1√ó)         [R√©f√©rence]
LSan seul         : ‚ñà‚ñà‚ñà‚ñà‚ñà (1.05√ó)     [Tr√®s l√©ger]
UBSan             : ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà (1.2√ó)     [L√©ger]
ASan              : ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà (2√ó)     [Acceptable]
ASan + UBSan      : ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà (2.5√ó) [Acceptable]
TSan              : ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà (10√ó) [Lourd]
```

---

## Performance par sanitizer

### AddressSanitizer (ASan)

#### Impact sur les performances

**Ralentissement :** ~2√ó (le programme prend 2 fois plus de temps)

**Consommation m√©moire :** ~3√ó (le programme utilise 3 fois plus de RAM)

**Taille du binaire :** +50-100%

#### Pourquoi cet overhead ?

ASan doit :
1. **Instrumenter** chaque acc√®s m√©moire pour v√©rifier qu'il est valide
2. Maintenir une **shadow memory** (m√©moire fant√¥me) qui garde trace de l'√©tat de chaque byte
3. Intercepter les appels √† `malloc`, `free`, etc.
4. Cr√©er des **zones de quarantaine** pour les blocs lib√©r√©s

#### Exemple de mesure

**Programme de test :**
```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    clock_t start = clock();

    // Allocation et traitement
    for (int i = 0; i < 1000000; i++) {
        int *ptr = malloc(100 * sizeof(int));
        for (int j = 0; j < 100; j++) {
            ptr[j] = i + j;
        }
        free(ptr);
    }

    clock_t end = clock();
    double time_spent = (double)(end - start) / CLOCKS_PER_SEC;
    printf("Temps d'ex√©cution : %.2f secondes\n", time_spent);

    return 0;
}
```

**R√©sultats typiques :**
```bash
# Sans sanitizer
gcc -O1 -o bench bench.c
./bench
# Temps : 0.50 secondes

# Avec ASan
gcc -fsanitize=address -O1 -o bench bench.c
./bench
# Temps : 1.05 secondes (~2√ó)
```

#### Quand l'overhead est-il acceptable ?

**‚úÖ Acceptable pour :**
- D√©veloppement quotidien (compilation debug)
- Tests unitaires
- Tests d'int√©gration
- CI/CD avec timeout g√©n√©reux

**‚ùå Trop lourd pour :**
- Benchmarks de performance
- Tests de charge
- Profiling
- Production

### UndefinedBehaviorSanitizer (UBSan)

#### Impact sur les performances

**Ralentissement :** ~1.2√ó (20% plus lent)

**Consommation m√©moire :** +5-10%

**Taille du binaire :** +10-20%

#### Pourquoi l'overhead est faible ?

UBSan ajoute uniquement des **v√©rifications ponctuelles** :
- Avant chaque division : v√©rifier que le diviseur n'est pas z√©ro
- Avant chaque op√©ration arithm√©tique : v√©rifier les d√©bordements
- Avant chaque shift : v√©rifier la validit√©

Ces v√©rifications sont **locales** et n'ont pas besoin de structures de donn√©es globales comme ASan.

#### Exemple de mesure

**Programme de test :**
```c
#include <stdio.h>
#include <time.h>

int main() {
    clock_t start = clock();

    volatile int sum = 0;
    for (int i = 1; i < 10000000; i++) {
        sum += i;
        sum = sum / i;
        sum = sum << 1;
    }

    clock_t end = clock();
    double time_spent = (double)(end - start) / CLOCKS_PER_SEC;
    printf("Temps : %.2f secondes, Somme : %d\n", time_spent, sum);

    return 0;
}
```

**R√©sultats typiques :**
```bash
# Sans sanitizer
gcc -O1 -o bench bench.c
./bench
# Temps : 0.15 secondes

# Avec UBSan
gcc -fsanitize=undefined -O1 -o bench bench.c
./bench
# Temps : 0.18 secondes (~1.2√ó)
```

#### Quand l'overhead est-il acceptable ?

**‚úÖ Acceptable pour :**
- D√©veloppement quotidien (overhead minimal)
- Tous les tests
- CI/CD
- Peut m√™me √™tre laiss√© activ√© lors de benchmarks non critiques

**‚ùå √Ä d√©sactiver pour :**
- Benchmarks de performance critiques
- Production

### ThreadSanitizer (TSan)

#### Impact sur les performances

**Ralentissement :** ~5-15√ó (programme 5 √† 15 fois plus lent)

**Consommation m√©moire :** ~5-10√ó (5 √† 10 fois plus de RAM)

**Taille du binaire :** +50-100%

**‚ö†Ô∏è TSan est le sanitizer le plus lourd !**

#### Pourquoi cet overhead important ?

TSan doit :
1. **Intercepter tous les acc√®s m√©moire** de tous les threads
2. Maintenir un **historique** des acc√®s r√©cents (pour d√©tecter les races)
3. Traquer les **synchronisations** (mutex, atomiques, etc.)
4. Analyser les **relations happens-before**
5. G√©rer une **√©norme shadow memory** pour chaque thread

#### Exemple de mesure

**Programme de test :**
```c
#include <stdio.h>
#include <pthread.h>
#include <time.h>

#define NUM_THREADS 4
#define ITERATIONS 1000000

int compteur = 0;
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

void* worker(void* arg) {
    for (int i = 0; i < ITERATIONS; i++) {
        pthread_mutex_lock(&mutex);
        compteur++;
        pthread_mutex_unlock(&mutex);
    }
    return NULL;
}

int main() {
    clock_t start = clock();

    pthread_t threads[NUM_THREADS];
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_create(&threads[i], NULL, worker, NULL);
    }

    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }

    clock_t end = clock();
    double time_spent = (double)(end - start) / CLOCKS_PER_SEC;
    printf("Temps : %.2f secondes, Compteur : %d\n", time_spent, compteur);

    return 0;
}
```

**R√©sultats typiques :**
```bash
# Sans sanitizer
gcc -O1 -pthread -o bench bench.c
./bench
# Temps : 1.2 secondes

# Avec TSan
gcc -fsanitize=thread -O1 -pthread -o bench bench.c
./bench
# Temps : 12.5 secondes (~10√ó)
```

#### Quand l'overhead est-il acceptable ?

**‚úÖ Acceptable pour :**
- Tests sp√©cifiques de concurrence
- Validation avant release (tests nightly)
- Debugging de race conditions

**‚ùå Trop lourd pour :**
- D√©veloppement quotidien
- Tests unitaires fr√©quents
- CI/CD sur chaque commit (sauf tests cibl√©s)
- Toute situation o√π le temps est critique

### LeakSanitizer (LSan)

#### Impact sur les performances

**Ralentissement :** ~1.05√ó (5% plus lent, presque n√©gligeable)

**Consommation m√©moire :** +5-10%

**Taille du binaire :** +10%

**‚ö†Ô∏è LSan seul est le sanitizer le plus l√©ger !**

#### Pourquoi l'overhead est minimal ?

LSan fonctionne diff√©remment des autres :
1. **Pas d'instrumentation** des acc√®s m√©moire pendant l'ex√©cution
2. **Analyse unique** √† la fin du programme seulement
3. Enregistre simplement les allocations/lib√©rations

**Le co√ªt principal** est pay√© **√† la fin** du programme, pas pendant son ex√©cution.

#### Exemple de mesure

**Programme de test :**
```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    clock_t start = clock();

    for (int i = 0; i < 1000000; i++) {
        int *ptr = malloc(100 * sizeof(int));
        ptr[0] = i;
        free(ptr);
    }

    clock_t end = clock();
    double time_spent = (double)(end - start) / CLOCKS_PER_SEC;
    printf("Temps : %.2f secondes\n", time_spent);

    return 0;
}
```

**R√©sultats typiques :**
```bash
# Sans sanitizer
gcc -O1 -o bench bench.c
./bench
# Temps : 0.42 secondes

# Avec LSan seul
gcc -fsanitize=leak -O1 -o bench bench.c
./bench
# Temps : 0.44 secondes (~1.05√ó)
```

#### Quand l'overhead est-il acceptable ?

**‚úÖ Acceptable pour :**
- Tout le temps ! (overhead n√©gligeable)
- D√©veloppement quotidien
- Tous les tests
- CI/CD
- Peut m√™me rester activ√© lors de benchmarks

**‚ùå √Ä d√©sactiver uniquement pour :**
- Production
- Benchmarks ultra-pr√©cis

### Combinaison ASan + UBSan

#### Impact sur les performances

**Ralentissement :** ~2.5√ó (150% plus lent)

**Consommation m√©moire :** ~3√ó (m√™me qu'ASan seul)

**Taille du binaire :** +100%

#### Pourquoi cette combinaison ?

**ASan + UBSan** est la combinaison **la plus utilis√©e** car :
- ‚úÖ D√©tecte erreurs m√©moire **et** comportements ind√©finis
- ‚úÖ Overhead additionnel de UBSan est faible (~20% sur les 100% d'ASan)
- ‚úÖ Couverture maximale pour un co√ªt raisonnable

#### Exemple de mesure

**R√©sultats typiques :**
```bash
# Sans sanitizer
./bench
# Temps : 1.0 seconde

# Avec ASan seul
gcc -fsanitize=address -O1 -o bench bench.c
./bench
# Temps : 2.0 secondes

# Avec UBSan seul
gcc -fsanitize=undefined -O1 -o bench bench.c
./bench
# Temps : 1.2 secondes

# Avec ASan + UBSan
gcc -fsanitize=address,undefined -O1 -o bench bench.c
./bench
# Temps : 2.4 secondes (~2.5√ó)
```

---

## Facteurs influen√ßant l'overhead

### 1. Type d'op√©rations effectu√©es

Certaines op√©rations sont plus impact√©es que d'autres :

**Tr√®s impact√©es par ASan :**
- ‚ùå Allocations/lib√©rations fr√©quentes (`malloc`/`free`)
- ‚ùå Acc√®s m√©moire intensifs
- ‚ùå Manipulation de tableaux

**Peu impact√©es par ASan :**
- ‚úÖ Calculs arithm√©tiques purs (pas d'acc√®s m√©moire)
- ‚úÖ I/O (lecture/√©criture fichiers, r√©seau)
- ‚úÖ Appels syst√®me

**Tr√®s impact√©es par TSan :**
- ‚ùå Synchronisation fr√©quente (locks/unlocks)
- ‚ùå Acc√®s √† des variables partag√©es
- ‚ùå Cr√©ations de threads

**Exemple :**
```c
// Code tr√®s impact√© par ASan (~5√ó plus lent)
for (int i = 0; i < 1000000; i++) {
    int *p = malloc(100);
    p[50] = i;
    free(p);
}

// Code peu impact√© par ASan (~1.2√ó plus lent)
for (int i = 0; i < 1000000; i++) {
    int x = i * i + i / 2;
}
```

### 2. Niveau d'optimisation

**Impact du niveau d'optimisation :**

| Niveau | Effet sur overhead | Recommandation |
|--------|-------------------|----------------|
| `-O0` | Overhead relatif plus faible | ‚ùå Peut masquer bugs |
| `-O1` | Bon √©quilibre | ‚úÖ **Recommand√©** |
| `-O2` | Overhead relatif plus √©lev√© | ‚ö†Ô∏è Peut compliquer debug |
| `-O3` | Peut perturber sanitizers | ‚ùå D√©conseill√© |

**Exemple :**
```bash
# Sans optimisation : Lent m√™me sans sanitizer
gcc -fsanitize=address -O0 -o prog prog.c
# Overhead relatif : ~1.5√ó (car le code de base est d√©j√† lent)

# Avec optimisation : Plus rapide mais overhead relatif plus visible
gcc -fsanitize=address -O2 -o prog prog.c
# Overhead relatif : ~2.5√ó (car le code de base est optimis√©)
```

**Recommandation :** Utilisez `-O1` avec les sanitizers.

### 3. Taille et complexit√© du programme

**Programmes petits :**
- Overhead startup plus visible
- Temps de d√©tection des fuites (LSan) n√©gligeable

**Programmes larges :**
- Overhead startup dilu√©
- Temps de d√©tection des fuites (LSan) peut √™tre significatif

### 4. Architecture et CPU

**Impact du CPU :**
- Processeurs modernes (AVX2, etc.) : Overhead l√©g√®rement r√©duit
- Vieux processeurs : Overhead peut √™tre plus √©lev√©

**Impact de la RAM :**
- RAM abondante : Pas de swapping, overhead nominal
- RAM limit√©e : Swapping possible avec ASan/TSan, ralentissement dramatique

---

## Strat√©gies d'optimisation

### 1. Utiliser le bon sanitizer pour la situation

**D√©veloppement quotidien :**
```bash
# L√©ger : UBSan seul si vous ne manipulez pas beaucoup la m√©moire
gcc -fsanitize=undefined -O1 -o prog prog.c

# Standard : ASan + UBSan pour couverture compl√®te
gcc -fsanitize=address,undefined -O1 -o prog prog.c
```

**Tests automatis√©s (CI/CD) :**
```bash
# Tests rapides : UBSan + LSan
gcc -fsanitize=undefined,leak -O1 -o prog prog.c

# Tests complets : ASan + UBSan
gcc -fsanitize=address,undefined -O1 -o prog prog.c
```

**Tests de concurrence (occasionnels) :**
```bash
# TSan uniquement quand n√©cessaire
gcc -fsanitize=thread -O1 -pthread -o prog_tsan prog.c
```

### 2. Tests cibl√©s plut√¥t qu'exhaustifs

Au lieu de tester **tout le programme** avec TSan (tr√®s lent), testez uniquement les **parties multi-thread√©es**.

**Exemple de strat√©gie :**
```bash
# Tests unitaires normaux : ASan + UBSan
./tests_unitaires  # 2√ó plus lent, acceptable

# Tests de concurrence : TSan (1-2 fois par jour)
./tests_concurrence_tsan  # 10√ó plus lent, mais cibl√©
```

### 3. Parall√©liser les tests en CI/CD

Au lieu d'ex√©cuter tous les tests s√©quentiellement, ex√©cutez-les en parall√®le :

```yaml
# GitHub Actions : Tests en parall√®le
jobs:
  test-asan:
    runs-on: ubuntu-latest
    steps:
      - run: gcc -fsanitize=address,undefined -o tests tests.c
      - run: ./tests

  test-tsan:
    runs-on: ubuntu-latest
    steps:
      - run: gcc -fsanitize=thread -o tests tests.c
      - run: ./tests
```

**Gain :** Les deux tests s'ex√©cutent **simultan√©ment** au lieu de l'un apr√®s l'autre.

### 4. Builds conditionnels

Ne compilez avec sanitizers que quand c'est n√©cessaire :

**Makefile avec targets conditionnels :**
```makefile
# Build rapide (d√©veloppement)
fast:
	gcc -O1 -o prog prog.c

# Build avec sanitizers (tests)
test:
	gcc -fsanitize=address,undefined -O1 -o prog_san prog.c
	./prog_san

# Build TSan (tests concurrence)
test-tsan:
	gcc -fsanitize=thread -O1 -pthread -o prog_tsan prog.c
	./prog_tsan
```

### 5. D√©sactiver les sanitizers pour certaines fonctions

Si une fonction sp√©cifique est **tr√®s lente** avec les sanitizers et **prouv√©e correcte**, vous pouvez la d√©sactiver :

```c
// D√©sactiver ASan pour cette fonction
__attribute__((no_sanitize("address")))
void fonction_critique_performance() {
    // Code v√©rifi√© manuellement
    // Pas d'instrumentation ASan ici
}

// D√©sactiver tous les sanitizers
__attribute__((no_sanitize("address", "undefined", "thread")))
void fonction_hotpath() {
    // Section critique de performance
}
```

**‚ö†Ô∏è Attention :** Utilisez ceci avec **extr√™me prudence**. Vous perdez la protection des sanitizers.

### 6. Optimiser l'allocation m√©moire

R√©duire les allocations/lib√©rations diminue l'overhead d'ASan :

**Avant (lent avec ASan) :**
```c
for (int i = 0; i < 1000000; i++) {
    char *buffer = malloc(100);
    process(buffer);
    free(buffer);
}
```

**Apr√®s (plus rapide avec ASan) :**
```c
char *buffer = malloc(100);
for (int i = 0; i < 1000000; i++) {
    process(buffer);
}
free(buffer);
```

### 7. Utiliser LSan pour une d√©tection rapide des fuites

Si vous voulez **uniquement** v√©rifier les fuites sans tout l'overhead d'ASan :

```bash
# Tr√®s l√©ger : ~5% overhead
gcc -fsanitize=leak -O1 -o prog prog.c
./prog
```

---

## Mesures pratiques et benchmarks

### Benchmark complet : Programme r√©el

**Programme de test : Serveur HTTP simple (1000 requ√™tes)**

| Configuration | Temps d'ex√©cution | M√©moire utilis√©e | Overhead relatif |
|---------------|-------------------|------------------|------------------|
| **Sans sanitizer** | 1.0s | 10 MB | 1√ó (r√©f√©rence) |
| **LSan seul** | 1.05s | 11 MB | 1.05√ó |
| **UBSan** | 1.2s | 11 MB | 1.2√ó |
| **ASan** | 2.1s | 32 MB | 2.1√ó |
| **ASan + UBSan** | 2.5s | 33 MB | 2.5√ó |
| **TSan** | 10.5s | 68 MB | 10.5√ó |

**Conclusion :** ASan + UBSan offre le meilleur compromis d√©tection/performance.

### Benchmark : Traitement de donn√©es

**Programme de test : Parsing et analyse de 100 MB de logs**

| Configuration | Temps | RAM | Taille binaire |
|---------------|-------|-----|----------------|
| **Sans sanitizer** | 3.2s | 50 MB | 45 KB |
| **LSan** | 3.3s | 53 MB | 50 KB |
| **UBSan** | 3.8s | 54 MB | 52 KB |
| **ASan** | 6.5s | 165 MB | 89 KB |
| **ASan + UBSan** | 7.8s | 167 MB | 94 KB |
| **TSan** | N/A | N/A | N/A |

*TSan N/A : Ce programme n'est pas multi-thread√©*

---

## Comparaison avec d'autres outils

### Sanitizers vs Valgrind

**Valgrind Memcheck** est l'alternative la plus connue √† ASan.

| Aspect | ASan | Valgrind Memcheck |
|--------|------|-------------------|
| **Ralentissement** | ~2√ó | ~10-50√ó |
| **M√©moire** | +200% | +100% |
| **Recompilation** | Oui | Non |
| **D√©tection** | Excellent | Excellent |
| **Facilit√©** | Tr√®s simple | Simple |

**Recommandation :**
- üöÄ **ASan** : D√©veloppement quotidien, CI/CD
- üîç **Valgrind** : Analyse approfondie, validation finale

### Sanitizers vs Analyse statique

**Analyse statique** (cppcheck, clang-tidy) ne n√©cessite pas d'ex√©cution.

| Aspect | Sanitizers | Analyse statique |
|--------|-----------|------------------|
| **Overhead runtime** | Oui (2-10√ó) | Non (0%) |
| **D√©tection** | Bugs r√©els | Bugs potentiels |
| **Faux positifs** | Tr√®s peu | Plus nombreux |
| **Co√ªt** | √Ä l'ex√©cution | √Ä la compilation |

**Recommandation :** Utilisez **les deux** pour une couverture maximale.

---

## Cas d'usage et recommandations

### D√©veloppement quotidien

**Objectif :** D√©tection rapide sans trop ralentir.

**Configuration recommand√©e :**
```bash
gcc -fsanitize=address,undefined -g -O1 -o prog prog.c
```

**Overhead acceptable :** ~2.5√ó

**D√©tection :** Erreurs m√©moire + comportements ind√©finis

### Tests unitaires (locaux)

**Objectif :** Couverture compl√®te avant commit.

**Configuration recommand√©e :**
```bash
# Build 1 : ASan + UBSan
gcc -fsanitize=address,undefined -fno-sanitize-recover=all -g -O1 -o tests_asan tests.c

# Build 2 : TSan (si multi-thread√©)
gcc -fsanitize=thread -g -O1 -pthread -o tests_tsan tests.c
```

**Temps d'ex√©cution :** Quelques minutes acceptable

### CI/CD (sur chaque commit)

**Objectif :** Validation automatique rapide.

**Configuration recommand√©e :**
```bash
# Tests principaux : ASan + UBSan
gcc -fsanitize=address,undefined -fno-sanitize-recover=all -g -O1 -Werror -o tests tests.c

# Tests de concurrence : TSan (uniquement nightly ou sur PR)
gcc -fsanitize=thread -g -O1 -pthread -o tests_tsan tests.c
```

**Strat√©gie :**
- ‚úÖ ASan + UBSan sur **chaque commit** (~2-5 min)
- ‚úÖ TSan sur **PR importantes** et **nightly builds** (~10-30 min)

### Tests nightly (toutes les nuits)

**Objectif :** Validation exhaustive.

**Configuration recommand√©e :**
```bash
# Tous les sanitizers, toutes les configurations
./run_all_sanitizer_tests.sh
```

**Temps d'ex√©cution :** 1-2 heures acceptable (ex√©cution nocturne)

### Debugging de bugs sp√©cifiques

**Objectif :** Reproduire et corriger un bug.

**Strat√©gie :**
```bash
# Si crash al√©atoire : ASan
gcc -fsanitize=address -g -O1 -o prog prog.c

# Si comportement bizarre : UBSan
gcc -fsanitize=undefined -g -O1 -o prog prog.c

# Si race condition suspect√©e : TSan
gcc -fsanitize=thread -g -O1 -pthread -o prog prog.c

# Si fuite m√©moire : LSan (ou ASan)
gcc -fsanitize=leak -g -O1 -o prog prog.c
```

### Production

**Objectif :** Performance maximale, pas de sanitizers.

**Configuration :**
```bash
gcc -O2 -DNDEBUG -o prog prog.c
```

**Overhead :** 0% (pas de sanitizers)

---

## Optimisations sp√©cifiques par plateforme

### Linux

**Meilleur support des sanitizers :**
- Tous les sanitizers fonctionnent bien
- Performance optimale

**Tips :**
```bash
# Utiliser Gold linker pour linkage plus rapide
gcc -fsanitize=address -fuse-ld=gold -o prog prog.c
```

### macOS

**Support excellent mais quelques limitations :**
- LSan inclus dans ASan (comme Linux)
- TSan peut n√©cessiter des droits suppl√©mentaires

**Tips :**
```bash
# Utiliser Clang (pr√©install√© et optimis√© pour macOS)
clang -fsanitize=address,undefined -g -O1 -o prog prog.c
```

### Windows (MinGW / WSL)

**Support limit√© :**
- ASan et UBSan fonctionnent
- TSan support partiel
- Pr√©f√©rez WSL ou Linux pour tests complets

---

## Monitoring et m√©triques

### Mesurer l'overhead dans vos projets

**Script de benchmark :**
```bash
#!/bin/bash

echo "Benchmarking sanitizers..."

# Build sans sanitizer
gcc -O1 -o prog_base prog.c
time_base=$(./prog_base | grep "Time:" | awk '{print $2}')

# Build avec ASan
gcc -fsanitize=address -O1 -o prog_asan prog.c
time_asan=$(./prog_asan | grep "Time:" | awk '{print $2}')

# Build avec TSan
gcc -fsanitize=thread -O1 -pthread -o prog_tsan prog.c
time_tsan=$(./prog_tsan | grep "Time:" | awk '{print $2}')

# Calcul des overheads
overhead_asan=$(echo "scale=2; $time_asan / $time_base" | bc)
overhead_tsan=$(echo "scale=2; $time_tsan / $time_base" | bc)

echo "Base : ${time_base}s"
echo "ASan : ${time_asan}s (${overhead_asan}√ó)"
echo "TSan : ${time_tsan}s (${overhead_tsan}√ó)"
```

### Suivre l'√©volution dans le temps

**Int√©gration dans CI/CD :**
```yaml
- name: Benchmark sanitizers
  run: |
    ./benchmark_sanitizers.sh > benchmark_results.txt
    # Comparer avec les r√©sultats pr√©c√©dents
    # Alerter si d√©gradation > 20%
```

---

## R√©sum√©

### Points cl√©s √† retenir

1. **ASan + UBSan** (~2.5√ó) = Meilleur compromis pour d√©veloppement
2. **TSan** (~10√ó) = Uniquement pour tests de concurrence cibl√©s
3. **LSan seul** (~1.05√ó) = Tr√®s l√©ger, peut rester activ√© souvent
4. **Overhead acceptable** car sanitizers = d√©veloppement/tests uniquement
5. **Production** = Toujours compiler **sans sanitizers** (0% overhead)

### Tableau d√©cisionnel

| Situation | Sanitizer recommand√© | Overhead | Fr√©quence |
|-----------|---------------------|----------|-----------|
| **Dev quotidien** | ASan + UBSan | ~2.5√ó | Toujours |
| **Tests rapides** | UBSan ou LSan | ~1.2√ó | Souvent |
| **Tests complets** | ASan + UBSan | ~2.5√ó | Avant commit |
| **Tests concurrence** | TSan | ~10√ó | 1√ó/jour ou PR |
| **CI/CD commit** | ASan + UBSan | ~2.5√ó | Chaque commit |
| **CI/CD nightly** | Tous | Variable | 1√ó/jour |
| **Production** | Aucun | 0% | Toujours |

### R√®gles d'or

1. **Ne pas utiliser de sanitizers en production**
2. **Toujours tester avec ASan + UBSan avant de commit**
3. **Utiliser TSan uniquement pour code multi-thread√©**
4. **Accepter l'overhead en d√©veloppement** (les bugs d√©tect√©s valent le co√ªt)
5. **Parall√©liser les tests** pour r√©duire le temps total

### Commandes m√©mo

**D√©veloppement standard :**
```bash
gcc -fsanitize=address,undefined -g -O1 -Wall -Wextra -o prog prog.c
```

**Tests l√©gers :**
```bash
gcc -fsanitize=leak -g -O1 -o prog prog.c
```

**Tests concurrence :**
```bash
gcc -fsanitize=thread -g -O1 -pthread -o prog prog.c
```

**Production :**
```bash
gcc -O2 -DNDEBUG -o prog prog.c
```

### Prochaines √©tapes

Dans les sections suivantes, vous d√©couvrirez :
- **Int√©gration dans le workflow** : Du d√©veloppement √† la production
- **GDB et debugging** : Combiner sanitizers et debugger
- **Cas pratiques avanc√©s** : R√©solution de bugs r√©els

---

**üéØ Comprendre l'overhead des sanitizers vous permet de les utiliser efficacement sans compromettre votre productivit√©. L'investissement en temps vaut largement les bugs √©vit√©s !**

‚è≠Ô∏è [Int√©gration dans le workflow](/15-debogage-et-qualite/01.7-integration-workflow.md)
