üîù Retour au [Sommaire](/SOMMAIRE.md)

# 15.1.4 LeakSanitizer (LSan)

## Introduction

**LeakSanitizer** (abr√©g√© **LSan**) est un d√©tecteur automatique de **fuites m√©moire** (memory leaks) dans les programmes C. C'est un sanitizer qui identifie la m√©moire allou√©e dynamiquement (avec `malloc`, `calloc`, etc.) qui n'a jamais √©t√© lib√©r√©e (avec `free`).

### Qu'est-ce qu'une fuite m√©moire ?

Une **fuite m√©moire** se produit lorsque vous allouez de la m√©moire dynamiquement mais que vous oubliez de la lib√©rer avant la fin du programme. Cette m√©moire reste alors "perdue" et ne peut plus √™tre utilis√©e.

```c
#include <stdlib.h>

int main() {
    int *tableau = malloc(100 * sizeof(int));

    // On utilise le tableau...
    tableau[0] = 42;

    // ‚ùå OUBLI : On n'appelle jamais free(tableau)

    return 0;  // Fuite m√©moire : 400 octets perdus
}
```

**Cons√©quences des fuites m√©moire :**
- üíæ **Gaspillage de RAM** : La m√©moire n'est jamais r√©cup√©r√©e
- üìà **Croissance progressive** : Le programme consomme de plus en plus de m√©moire
- üí• **Crash possible** : Si le programme tourne longtemps (serveur, daemon)
- üêå **Ralentissements** : Moins de m√©moire disponible pour le syst√®me
- ‚ö†Ô∏è **Probl√®mes en production** : Particuli√®rement grave pour les applications long-running

### Pourquoi LeakSanitizer est important ?

Les fuites m√©moire sont :
- üïµÔ∏è **Difficiles √† d√©tecter** : Le programme peut fonctionner normalement
- üéØ **Insidieuses** : Elles s'accumulent au fil du temps
- üî• **Critiques en production** : Peuvent causer des crashs impr√©visibles
- üìä **Co√ªteuses** : Gaspillent des ressources serveur

**LSan d√©tecte automatiquement** toutes les fuites m√©moire √† la fin de l'ex√©cution de votre programme.

---

## Relation avec AddressSanitizer

### LSan est int√©gr√© dans ASan

**Information importante :** LeakSanitizer est **automatiquement inclus** dans AddressSanitizer sur Linux et macOS.

Quand vous compilez avec `-fsanitize=address`, vous obtenez :
- ‚úÖ D√©tection des erreurs m√©moire (use-after-free, buffer overflow, etc.)
- ‚úÖ **D√©tection des fuites m√©moire** (LSan)

```bash
# Compile avec ASan (inclut automatiquement LSan)
gcc -fsanitize=address -g -o prog prog.c
```

### Utiliser LSan seul

Vous pouvez aussi utiliser LSan **sans** ASan pour avoir uniquement la d√©tection de fuites :

```bash
# LSan uniquement (plus l√©ger qu'ASan)
gcc -fsanitize=leak -g -o prog prog.c
```

**Avantages de LSan seul :**
- üöÄ **Plus rapide** : Overhead minimal (< 5%)
- üíæ **Moins de m√©moire** : Pas le co√ªt d'ASan
- üéØ **Focus fuites** : Rapports plus simples

**Recommandation :** Utilisez ASan en d√©veloppement (qui inclut LSan), et LSan seul pour des v√©rifications cibl√©es.

---

## Comment fonctionne LeakSanitizer ?

### Principe de d√©tection

LSan fonctionne en analysant la m√©moire **√† la fin du programme** :

1. üìù **Enregistre** toutes les allocations (`malloc`, `calloc`, `realloc`)
2. üîç **Scanne** la m√©moire pour trouver les pointeurs encore valides
3. üóëÔ∏è **Identifie** les blocs m√©moire qui ne sont plus accessibles
4. üìä **Rapporte** les fuites d√©tect√©es avec leur origine

**Moment de d√©tection :** LSan s'ex√©cute **automatiquement** quand le programme se termine normalement.

### Types de fuites d√©tect√©es

LSan cat√©gorise les fuites en plusieurs types :

#### 1. **Direct leak (Fuite directe)**

La m√©moire allou√©e n'est plus r√©f√©renc√©e par aucun pointeur.

```c
void fonction() {
    int *ptr = malloc(100 * sizeof(int));
    // ‚ùå Pointeur perdu : ptr sort de la port√©e sans free()
}
```

#### 2. **Indirect leak (Fuite indirecte)**

Une structure est perdue, entra√Ænant la perte de la m√©moire qu'elle contenait.

```c
typedef struct Noeud {
    int valeur;
    struct Noeud *suivant;
} Noeud;

void fonction() {
    Noeud *tete = malloc(sizeof(Noeud));
    tete->suivant = malloc(sizeof(Noeud));

    // ‚ùå On perd tete, donc aussi tete->suivant
}
```

#### 3. **Definitely lost (D√©finitivement perdu)**

M√©moire qui ne peut absolument plus √™tre lib√©r√©e.

```c
int main() {
    char *str = malloc(100);
    str = NULL;  // ‚ùå Perte du pointeur, fuite d√©finitive
    return 0;
}
```

---

## Utilisation de LeakSanitizer

### Activation

**Avec AddressSanitizer (recommand√©) :**
```bash
gcc -fsanitize=address -g -o mon_programme mon_programme.c
./mon_programme
```

**LSan seul :**
```bash
gcc -fsanitize=leak -g -o mon_programme mon_programme.c
./mon_programme
```

**Options importantes :**
- `-fsanitize=address` : Active ASan + LSan
- `-fsanitize=leak` : Active uniquement LSan
- `-g` : Ajoute les informations de d√©bogage (pour voir les num√©ros de lignes)

### Exemple simple

**fichier : `leak.c`**
```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    // Allocation 1 : OK, sera lib√©r√©e
    int *tableau1 = malloc(10 * sizeof(int));

    // Allocation 2 : FUITE, jamais lib√©r√©e
    int *tableau2 = malloc(20 * sizeof(int));

    // Utilisation
    tableau1[0] = 42;
    tableau2[0] = 100;

    printf("Valeurs : %d, %d\n", tableau1[0], tableau2[0]);

    // On lib√®re seulement tableau1
    free(tableau1);

    // ‚ùå Oubli de free(tableau2) ‚Üí Fuite m√©moire

    return 0;
}
```

**Compilation et ex√©cution :**
```bash
gcc -fsanitize=address -g -o leak leak.c
./leak
```

---

## Interpr√©ter les rapports de LeakSanitizer

### Exemple de rapport basique

Pour le programme ci-dessus, LSan produit ce rapport :

```
Valeurs : 42, 100

=================================================================
==12345==ERROR: LeakSanitizer: detected memory leaks

Direct leak of 80 byte(s) in 1 object(s) allocated from:
    #0 0x7f8a12345678 in malloc (/usr/lib/x86_64-linux-gnu/libasan.so.5+0x10c678)
    #1 0x4011a3 in main leak.c:9
    #2 0x7f8a12000b96 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21b96)

SUMMARY: AddressSanitizer: 80 byte(s) leaked in 1 allocation(s).
```

### D√©crypter le rapport

#### 1. **Message d'en-t√™te**
```
ERROR: LeakSanitizer: detected memory leaks
```
‚Üí Des fuites m√©moire ont √©t√© d√©tect√©es.

#### 2. **Type et taille de la fuite**
```
Direct leak of 80 byte(s) in 1 object(s) allocated from:
```
‚Üí **Fuite directe** de **80 octets** (20 entiers √ó 4 octets) dans **1 allocation**.

#### 3. **Stack trace (origine de l'allocation)**
```
#1 0x4011a3 in main leak.c:9
```
‚Üí La m√©moire a √©t√© allou√©e √† la **ligne 9** du fichier `leak.c`, dans la fonction `main`.

#### 4. **R√©sum√©**
```
SUMMARY: AddressSanitizer: 80 byte(s) leaked in 1 allocation(s).
```
‚Üí Total : **80 octets perdus** en **1 allocation**.

---

## Exemples d√©taill√©s avec correction

### Exemple 1 : Fuite simple

**Code probl√©matique :**
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char* creer_message(const char* nom) {
    char *message = malloc(100);
    sprintf(message, "Bonjour %s!", nom);
    return message;  // Le pointeur sort de la fonction
}

int main() {
    // ‚ùå FUITE : On n'enregistre pas le pointeur retourn√©
    creer_message("Alice");
    creer_message("Bob");

    printf("Messages cr√©√©s\n");
    return 0;
}
```

**Rapport LSan :**
```
Direct leak of 200 byte(s) in 2 object(s) allocated from:
    #1 creer_message leak.c:6
    #2 main leak.c:13
```

**Correction :**
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char* creer_message(const char* nom) {
    char *message = malloc(100);
    if (message == NULL) {
        return NULL;
    }
    sprintf(message, "Bonjour %s!", nom);
    return message;
}

int main() {
    // ‚úÖ On enregistre les pointeurs
    char *msg1 = creer_message("Alice");
    char *msg2 = creer_message("Bob");

    if (msg1 && msg2) {
        printf("Message 1 : %s\n", msg1);
        printf("Message 2 : %s\n", msg2);
    }

    // ‚úÖ On lib√®re la m√©moire
    free(msg1);
    free(msg2);

    return 0;
}
```

### Exemple 2 : Fuite dans une boucle

**Code probl√©matique :**
```c
#include <stdio.h>
#include <stdlib.h>

void traiter_donnees() {
    for (int i = 0; i < 10; i++) {
        int *buffer = malloc(1000 * sizeof(int));

        // Traitement des donn√©es...
        buffer[0] = i;
        printf("Traitement %d : %d\n", i, buffer[0]);

        // ‚ùå FUITE : buffer n'est jamais lib√©r√©
    }
}

int main() {
    traiter_donnees();
    return 0;
}
```

**Rapport LSan :**
```
Direct leak of 40000 byte(s) in 10 object(s) allocated from:
    #1 traiter_donnees leak.c:6
```
‚Üí 10 allocations de 4000 octets chacune = 40 000 octets perdus.

**Correction :**
```c
#include <stdio.h>
#include <stdlib.h>

void traiter_donnees() {
    for (int i = 0; i < 10; i++) {
        int *buffer = malloc(1000 * sizeof(int));
        if (buffer == NULL) {
            fprintf(stderr, "Erreur d'allocation\n");
            continue;
        }

        // Traitement des donn√©es...
        buffer[0] = i;
        printf("Traitement %d : %d\n", i, buffer[0]);

        // ‚úÖ Lib√©ration √† chaque it√©ration
        free(buffer);
    }
}

int main() {
    traiter_donnees();
    return 0;
}
```

### Exemple 3 : Fuite avec structure dynamique

**Code probl√©matique :**
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    char *nom;
    char *email;
    int age;
} Personne;

Personne* creer_personne(const char *nom, const char *email, int age) {
    Personne *p = malloc(sizeof(Personne));

    p->nom = malloc(strlen(nom) + 1);
    strcpy(p->nom, nom);

    p->email = malloc(strlen(email) + 1);
    strcpy(p->email, email);

    p->age = age;

    return p;
}

int main() {
    Personne *alice = creer_personne("Alice", "alice@example.com", 30);

    printf("Nom : %s\n", alice->nom);

    // ‚ùå FUITE : On lib√®re la structure mais pas les cha√Ænes
    free(alice);

    return 0;
}
```

**Rapport LSan :**
```
Direct leak of 16 byte(s) in 1 object(s) allocated from:
    #1 creer_personne leak.c:15  (email)

Direct leak of 6 byte(s) in 1 object(s) allocated from:
    #1 creer_personne leak.c:12  (nom)
```

**Correction :**
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    char *nom;
    char *email;
    int age;
} Personne;

Personne* creer_personne(const char *nom, const char *email, int age) {
    Personne *p = malloc(sizeof(Personne));
    if (p == NULL) return NULL;

    p->nom = malloc(strlen(nom) + 1);
    p->email = malloc(strlen(email) + 1);

    if (p->nom == NULL || p->email == NULL) {
        free(p->nom);
        free(p->email);
        free(p);
        return NULL;
    }

    strcpy(p->nom, nom);
    strcpy(p->email, email);
    p->age = age;

    return p;
}

void liberer_personne(Personne *p) {
    if (p != NULL) {
        free(p->nom);    // ‚úÖ Lib√©rer d'abord les membres
        free(p->email);
        free(p);         // ‚úÖ Puis la structure
    }
}

int main() {
    Personne *alice = creer_personne("Alice", "alice@example.com", 30);

    if (alice != NULL) {
        printf("Nom : %s\n", alice->nom);
        liberer_personne(alice);  // ‚úÖ Lib√©ration compl√®te
    }

    return 0;
}
```

### Exemple 4 : Fuite avec liste cha√Æn√©e

**Code probl√©matique :**
```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Noeud {
    int valeur;
    struct Noeud *suivant;
} Noeud;

Noeud* creer_liste() {
    Noeud *tete = malloc(sizeof(Noeud));
    tete->valeur = 1;

    tete->suivant = malloc(sizeof(Noeud));
    tete->suivant->valeur = 2;
    tete->suivant->suivant = NULL;

    return tete;
}

int main() {
    Noeud *liste = creer_liste();

    printf("Premier √©l√©ment : %d\n", liste->valeur);

    // ‚ùå FUITE : On lib√®re seulement le premier noeud
    free(liste);

    return 0;
}
```

**Rapport LSan :**
```
Indirect leak of 16 byte(s) in 1 object(s) allocated from:
    #1 creer_liste leak.c:13
```
‚Üí Fuite **indirecte** : le deuxi√®me n≈ìud est perdu avec le premier.

**Correction :**
```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Noeud {
    int valeur;
    struct Noeud *suivant;
} Noeud;

Noeud* creer_liste() {
    Noeud *tete = malloc(sizeof(Noeud));
    if (tete == NULL) return NULL;

    tete->valeur = 1;

    tete->suivant = malloc(sizeof(Noeud));
    if (tete->suivant == NULL) {
        free(tete);
        return NULL;
    }

    tete->suivant->valeur = 2;
    tete->suivant->suivant = NULL;

    return tete;
}

void liberer_liste(Noeud *tete) {
    Noeud *courant = tete;

    // ‚úÖ Lib√©rer tous les noeuds un par un
    while (courant != NULL) {
        Noeud *suivant = courant->suivant;
        free(courant);
        courant = suivant;
    }
}

int main() {
    Noeud *liste = creer_liste();

    if (liste != NULL) {
        printf("Premier √©l√©ment : %d\n", liste->valeur);
        liberer_liste(liste);  // ‚úÖ Lib√©ration compl√®te
    }

    return 0;
}
```

---

## Configuration via variables d'environnement

LSan peut √™tre configur√© avec la variable `LSAN_OPTIONS` :

### D√©sactiver LSan (quand inclus dans ASan)

```bash
ASAN_OPTIONS=detect_leaks=0 ./mon_programme
```

### Activer uniquement en cas d'erreur m√©moire

```bash
ASAN_OPTIONS=detect_leaks=1:halt_on_error=1 ./mon_programme
```

### Changer le niveau de rapport

```bash
LSAN_OPTIONS=verbosity=1 ./mon_programme
```

### Sauvegarder le rapport dans un fichier

```bash
LSAN_OPTIONS=log_path=leak_report.txt ./mon_programme
```

### Ignorer certaines fuites (avec suppressions)

```bash
LSAN_OPTIONS=suppressions=lsan_suppressions.txt ./mon_programme
```

### Exemples combin√©s

```bash
# ASan + LSan avec arr√™t √† la premi√®re erreur
ASAN_OPTIONS=detect_leaks=1:halt_on_error=1 ./mon_programme

# LSan seul avec rapport d√©taill√©
LSAN_OPTIONS=verbosity=1:report_objects=1 ./mon_programme
```

---

## Fichiers de suppression (Suppression Files)

Parfois, vous devez **ignorer intentionnellement** certaines fuites (ex: biblioth√®ques tierces, code legacy).

### Cr√©er un fichier de suppression

**fichier : `lsan_suppressions.txt`**
```
# Ignorer les fuites dans une fonction sp√©cifique
leak:nom_de_la_fonction

# Ignorer les fuites dans une biblioth√®que
leak:libnom_bibliotheque.so

# Exemple concret : ignorer fuites dans libpthread
leak:libpthread.so
```

### Format des suppressions

```
# Ignorer par nom de fonction
leak:fonction_avec_fuite

# Ignorer par fichier source
leak:fichier.c

# Ignorer par biblioth√®que
leak:libc.so
```

### Utiliser le fichier de suppression

```bash
LSAN_OPTIONS=suppressions=lsan_suppressions.txt ./mon_programme
```

### Exemple pratique

**Sc√©nario :** Vous utilisez une biblioth√®que tierce qui a une petite fuite connue que vous ne pouvez pas corriger.

**lsan_suppressions.txt :**
```
# Ignorer fuite connue dans libexterne
leak:libexterne.so.1
```

**Utilisation :**
```bash
gcc -fsanitize=address -g -o prog prog.c -lexterne  
LSAN_OPTIONS=suppressions=lsan_suppressions.txt ./prog  
```

---

## Cas particuliers et pi√®ges

### 1. **Still reachable (Encore accessible)**

Certaines allocations sont intentionnellement non lib√©r√©es (caches globaux, singletons).

```c
#include <stdlib.h>

static char *cache_global = NULL;

void initialiser_cache() {
    if (cache_global == NULL) {
        cache_global = malloc(1000);
        // ‚ÑπÔ∏è Cache global, lib√©r√© automatiquement √† la fin
    }
}

int main() {
    initialiser_cache();
    // Pas de free(cache_global) ‚Üí Still reachable, pas une vraie fuite
    return 0;
}
```

**LSan ne rapporte pas** ce type d'allocation comme fuite si le pointeur est encore accessible.

### 2. **Fuites conditionnelles**

```c
#include <stdlib.h>

int main(int argc, char *argv[]) {
    if (argc > 1) {
        char *buffer = malloc(100);
        // ‚ùå FUITE uniquement si argc > 1
        return 0;
    }

    return 0;
}
```

**Solution :** Testez tous les chemins d'ex√©cution.

### 3. **Realloc qui √©choue**

```c
#include <stdlib.h>

int main() {
    int *ptr = malloc(100 * sizeof(int));

    // ‚ùå FUITE si realloc √©choue
    ptr = realloc(ptr, 200 * sizeof(int));

    // Si realloc retourne NULL, l'ancien ptr est perdu

    free(ptr);
    return 0;
}
```

**Correction :**
```c
#include <stdlib.h>

int main() {
    int *ptr = malloc(100 * sizeof(int));

    // ‚úÖ Conserver l'ancien pointeur
    int *nouveau_ptr = realloc(ptr, 200 * sizeof(int));

    if (nouveau_ptr != NULL) {
        ptr = nouveau_ptr;
    } else {
        // En cas d'erreur, ptr est toujours valide
        free(ptr);
        return 1;
    }

    free(ptr);
    return 0;
}
```

### 4. **Fuites dans les appels syst√®me**

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    // ‚ùå FUITE : execl() remplace le processus, pas de free
    char *args = malloc(100);
    execl("/bin/ls", "ls", "-l", NULL);

    // Cette ligne n'est jamais ex√©cut√©e
    free(args);

    return 0;
}
```

**C'est OK :** Quand le processus est remplac√©, l'OS lib√®re toute sa m√©moire.

---

## Comparaison avec Valgrind

### LSan vs Valgrind Memcheck

| Aspect | LSan | Valgrind Memcheck |
|--------|------|-------------------|
| **Recompilation** | Oui | Non |
| **Vitesse** | ~5% overhead | ~10-50√ó plus lent |
| **D√©tection fuites** | Excellent | Excellent |
| **Types de fuites** | Direct/Indirect | Direct/Indirect/Still reachable/Possibly lost |
| **Facilit√©** | Tr√®s simple | Simple |
| **D√©tails** | Stack trace complet | Stack trace complet |
| **False positives** | Tr√®s peu | Peu |

**Recommandations :**
- üöÄ **LSan** : Utilisation quotidienne, CI/CD, d√©veloppement
- üîç **Valgrind** : Analyse approfondie, debugging complexe, v√©rification finale

### Quand utiliser l'un ou l'autre ?

**Utilisez LSan pour :**
- ‚úÖ D√©veloppement quotidien (tr√®s rapide)
- ‚úÖ Tests automatis√©s en CI/CD
- ‚úÖ D√©tection rapide de nouvelles fuites
- ‚úÖ Projets o√π la recompilation est acceptable

**Utilisez Valgrind pour :**
- ‚úÖ Analyse de binaires existants (pas de recompilation)
- ‚úÖ D√©tection d'autres erreurs m√©moire (uninit values, etc.)
- ‚úÖ Analyse tr√®s d√©taill√©e de fuites complexes
- ‚úÖ Quand vous ne pouvez pas modifier le build

**Meilleure approche :** Utilisez les deux !
1. LSan pendant le d√©veloppement
2. Valgrind pour la validation finale

---

## Bonnes pratiques

### 1. **Toujours activer LSan en d√©veloppement**

Ajoutez LSan √† votre compilation de debug :

**Makefile :**
```makefile
CFLAGS_DEBUG = -fsanitize=address -g -O1 -Wall -Wextra

debug: CFLAGS += $(CFLAGS_DEBUG)  
debug: mon_programme  

test: debug
	@echo "Ex√©cution avec sanitizers..."
	ASAN_OPTIONS=detect_leaks=1 ./mon_programme
```

**CMake :**
```cmake
option(ENABLE_SANITIZERS "Enable sanitizers" ON)

if(ENABLE_SANITIZERS)
    add_compile_options(-fsanitize=address -g)
    add_link_options(-fsanitize=address)
endif()
```

### 2. **Adopter des patterns de gestion m√©moire coh√©rents**

**Pattern constructor/destructor :**
```c
typedef struct {
    char *nom;
    int *donnees;
    size_t taille;
} Structure;

// Constructeur
Structure* structure_creer(const char *nom, size_t taille) {
    Structure *s = malloc(sizeof(Structure));
    if (s == NULL) return NULL;

    s->nom = strdup(nom);  // Allocation
    s->donnees = malloc(taille * sizeof(int));
    s->taille = taille;

    // V√©rifier les allocations
    if (s->nom == NULL || s->donnees == NULL) {
        structure_detruire(s);
        return NULL;
    }

    return s;
}

// Destructeur (lib√®re TOUT)
void structure_detruire(Structure *s) {
    if (s != NULL) {
        free(s->nom);
        free(s->donnees);
        free(s);
    }
}
```

### 3. **Utiliser des outils automatiques pour les structures complexes**

Pour les structures avec allocation profonde, cr√©ez toujours des fonctions d√©di√©es :

```c
// ‚úÖ Bonne pratique
void liste_detruire(Liste *liste);  
void arbre_detruire(Arbre *arbre);  
void graphe_detruire(Graphe *graphe);  
```

### 4. **V√©rifier syst√©matiquement les retours de malloc**

```c
// ‚ùå Mauvais
int *ptr = malloc(size);  
ptr[0] = 42;  // Crash si malloc a √©chou√©  

// ‚úÖ Bon
int *ptr = malloc(size);  
if (ptr == NULL) {  
    return ERREUR_ALLOCATION;
}
ptr[0] = 42;
```

### 5. **Mettre NULL apr√®s free (optionnel mais recommand√©)**

```c
free(ptr);  
ptr = NULL;  // √âvite les double-free et use-after-free  
```

### 6. **Tests automatis√©s avec LSan**

```bash
#!/bin/bash
# Script de test avec v√©rification des fuites

gcc -fsanitize=address -g -o tests tests.c

export ASAN_OPTIONS=detect_leaks=1:halt_on_error=1

if ./tests; then
    echo "‚úÖ Tests r√©ussis, aucune fuite d√©tect√©e"
    exit 0
else
    echo "‚ùå Tests √©chou√©s ou fuites d√©tect√©es"
    exit 1
fi
```

---

## Int√©gration dans le CI/CD

### GitHub Actions

```yaml
name: Tests avec LeakSanitizer

on: [push, pull_request]

jobs:
  test-lsan:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Install dependencies
        run: sudo apt-get update && sudo apt-get install -y build-essential

      - name: Build avec ASan (inclut LSan)
        run: |
          gcc -fsanitize=address -g -O1 -Wall -Wextra \
              -o tests tests.c

      - name: Run tests
        run: |
          export ASAN_OPTIONS=detect_leaks=1:halt_on_error=1
          ./tests

      - name: V√©rification r√©ussie
        run: echo "‚úÖ Aucune fuite m√©moire d√©tect√©e"
```

### GitLab CI

```yaml
stages:
  - test

test_leaks:
  stage: test
  script:
    - gcc -fsanitize=address -g -O1 -o tests tests.c
    - export ASAN_OPTIONS=detect_leaks=1:halt_on_error=1
    - ./tests
  only:
    - branches
```

### Script de validation pre-commit

**`.git/hooks/pre-commit` :**
```bash
#!/bin/bash

echo "V√©rification des fuites m√©moire..."

# Compilation avec LSan
gcc -fsanitize=address -g -o test_build src/*.c

# Ex√©cution des tests
export ASAN_OPTIONS=detect_leaks=1  
if ./test_build --run-tests; then  
    echo "‚úÖ Aucune fuite d√©tect√©e"
    rm test_build
    exit 0
else
    echo "‚ùå Fuites d√©tect√©es ! Commit bloqu√©."
    rm test_build
    exit 1
fi
```

---

## Debugging de fuites complexes

### Strat√©gie de debugging

1. **Identifier la source** : Regardez le stack trace du rapport LSan
2. **Remonter le flux** : Suivez le chemin d'allocation
3. **Chercher le free manquant** : O√π aurait d√ª √™tre le `free()` ?
4. **V√©rifier les chemins d'erreur** : Les `return` pr√©matur√©s sont dangereux

### Exemple de debugging

**Rapport LSan :**
```
Direct leak of 100 byte(s) in 1 object(s) allocated from:
    #0 malloc
    #1 traiter_fichier fichier.c:45
    #2 main main.c:20
```

**Strat√©gie :**
1. Aller √† `fichier.c:45` ‚Üí `char *buffer = malloc(100);`
2. Chercher tous les chemins de sortie de `traiter_fichier()`
3. V√©rifier que chaque chemin lib√®re `buffer`
4. Trouver le chemin oubli√© (souvent un `return` d'erreur)

**Code probl√©matique trouv√© :**
```c
char* traiter_fichier(const char *nom) {
    char *buffer = malloc(100);

    FILE *f = fopen(nom, "r");
    if (f == NULL) {
        return NULL;  // ‚ùå FUITE : buffer n'est pas lib√©r√©
    }

    fread(buffer, 1, 100, f);
    fclose(f);

    return buffer;
}
```

**Correction :**
```c
char* traiter_fichier(const char *nom) {
    char *buffer = malloc(100);
    if (buffer == NULL) {
        return NULL;
    }

    FILE *f = fopen(nom, "r");
    if (f == NULL) {
        free(buffer);  // ‚úÖ Lib√©ration sur erreur
        return NULL;
    }

    fread(buffer, 1, 100, f);
    fclose(f);

    return buffer;
}
```

---

## Performance et Overhead

### Impact de LSan

| Configuration | Overhead |
|---------------|----------|
| **LSan seul** | < 5% |
| **ASan (inclut LSan)** | ~100% (2√ó plus lent) |
| **M√©moire (LSan seul)** | +5-10% |
| **M√©moire (ASan)** | +200-300% |

**Conclusion :** LSan seul est tr√®s l√©ger, mais vous b√©n√©ficiez g√©n√©ralement d'ASan complet.

### Quand utiliser LSan seul ?

```bash
# Pour des tests de performance o√π ASan est trop lourd
gcc -fsanitize=leak -g -O2 -o prog prog.c
```

**Utilisez LSan seul si :**
- Vous voulez tester uniquement les fuites
- ASan est trop lent pour votre cas d'usage
- Vous faites du profiling de performance

---

## R√©sum√©

### Points cl√©s √† retenir

1. **LSan d√©tecte les fuites m√©moire** automatiquement
2. **Inclus dans ASan** sur Linux/macOS (`-fsanitize=address`)
3. **Peut s'utiliser seul** avec `-fsanitize=leak` (plus l√©ger)
4. **D√©tection √† la fin** du programme (exit normal requis)
5. **Overhead faible** : < 5% seul, ~100% avec ASan

### Commandes √† retenir

**Avec ASan (recommand√©) :**
```bash
gcc -fsanitize=address -g -o programme programme.c  
ASAN_OPTIONS=detect_leaks=1 ./programme  
```

**LSan seul :**
```bash
gcc -fsanitize=leak -g -o programme programme.c
./programme
```

**Avec fichier de suppression :**
```bash
LSAN_OPTIONS=suppressions=suppressions.txt ./programme
```

### Checklist anti-fuites

- ‚úÖ Toujours appeler `free()` pour chaque `malloc()`
- ‚úÖ Cr√©er des fonctions de destruction pour structures complexes
- ‚úÖ V√©rifier tous les chemins de sortie (surtout les erreurs)
- ‚úÖ Utiliser `strdup()` avec pr√©caution (n'oubliez pas le `free`)
- ‚úÖ Lib√©rer dans l'ordre inverse de l'allocation pour structures imbriqu√©es
- ‚úÖ Tester avec LSan activ√© r√©guli√®rement
- ‚úÖ Int√©grer LSan dans votre CI/CD

### Pattern de gestion m√©moire s√ªre

```c
// 1. Allouer
Object *obj = object_create();  
if (obj == NULL) {  
    return ERROR;
}

// 2. Utiliser
int result = object_use(obj);

// 3. Lib√©rer (m√™me en cas d'erreur)
if (result != SUCCESS) {
    object_destroy(obj);  // Nettoyage
    return ERROR;
}

object_destroy(obj);  // Nettoyage normal  
return SUCCESS;  
```

### Prochaines √©tapes

Dans la section suivante, vous d√©couvrirez :
- **Compilation avec sanitizers** : Options et combinaisons
- **Performance et overhead** : Comparatifs d√©taill√©s
- **Int√©gration dans le workflow** : De dev √† production

---

**üéØ LeakSanitizer est votre assurance contre les fuites m√©moire. Utilisez-le syst√©matiquement pour √©crire du code fiable qui ne gaspille pas de ressources !**

‚è≠Ô∏è [Compilation avec sanitizers](/15-debogage-et-qualite/01.5-compilation-sanitizers.md)
