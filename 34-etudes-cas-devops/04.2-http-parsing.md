ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 34.4.2 HTTP Parsing

## Introduction

Maintenant que nous avons une architecture event-driven capable de gÃ©rer des milliers de connexions (section 34.4.1), nous devons comprendre et parser le **protocole HTTP** pour construire un serveur web fonctionnel.

HTTP (HyperText Transfer Protocol) est le protocole qui permet aux navigateurs web et aux serveurs de communiquer. Notre objectif : crÃ©er un parser HTTP simple mais robuste en C, capable d'interprÃ©ter les requÃªtes des clients et de gÃ©nÃ©rer des rÃ©ponses valides.

---

## Le Protocole HTTP en Bref

### HTTP : Un protocole texte

HTTP est un protocole **textuel** (contrairement Ã  des protocoles binaires), ce qui le rend facile Ã  lire et Ã  debugger.

**Exemple de requÃªte HTTP complÃ¨te :**
```http
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0
Accept: text/html
Connection: keep-alive

```

**Exemple de rÃ©ponse HTTP complÃ¨te :**
```http
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 13
Connection: close

Hello, World!
```

### Les versions HTTP

| Version | AnnÃ©e | CaractÃ©ristiques |
|---------|-------|------------------|
| HTTP/0.9 | 1991 | Une seule ligne : `GET /page` |
| HTTP/1.0 | 1996 | Headers, codes de status |
| HTTP/1.1 | 1997 | Keep-alive, chunked encoding |
| HTTP/2 | 2015 | Binaire, multiplexage |
| HTTP/3 | 2022 | QUIC (UDP) |

**Notre serveur :** Nous implÃ©menterons **HTTP/1.1** (la version la plus utilisÃ©e pour les serveurs simples).

---

## Structure d'une RequÃªte HTTP

Une requÃªte HTTP se compose de **trois parties** :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. REQUEST LINE (ligne de requÃªte)                      â”‚
â”‚    GET /path/to/file.html HTTP/1.1                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 2. HEADERS (en-tÃªtes)                                   â”‚
â”‚    Host: www.example.com                                â”‚
â”‚    User-Agent: Mozilla/5.0                              â”‚
â”‚    Accept: text/html                                    â”‚
â”‚    Connection: keep-alive                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 3. EMPTY LINE (ligne vide)                              â”‚
â”‚    \r\n                                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 4. BODY (corps - optionnel)                             â”‚
â”‚    {donnÃ©es pour POST/PUT}                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1. Request Line

Format : `METHODE URI VERSION`

```
GET /index.html HTTP/1.1
â”‚   â”‚           â”‚
â”‚   â”‚           â””â”€ Version HTTP
â”‚   â””â”€ Chemin de la ressource
â””â”€ MÃ©thode HTTP
```

**MÃ©thodes HTTP courantes :**

| MÃ©thode | Usage | Exemple |
|---------|-------|---------|
| GET | RÃ©cupÃ©rer une ressource | `GET /page.html` |
| POST | Envoyer des donnÃ©es | `POST /form` |
| HEAD | Comme GET mais sans body | `HEAD /page.html` |
| PUT | Mettre Ã  jour une ressource | `PUT /file.txt` |
| DELETE | Supprimer une ressource | `DELETE /file.txt` |

**Pour notre serveur simple :** Nous implÃ©menterons **GET** et **HEAD**.

### 2. Headers

Format : `Nom: Valeur`

```
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
Accept: text/html,application/xml
Accept-Encoding: gzip, deflate
Connection: keep-alive
```

**Headers importants :**

| Header | Description | Exemple |
|--------|-------------|---------|
| `Host` | Domaine cible (obligatoire en HTTP/1.1) | `Host: example.com` |
| `User-Agent` | Client (navigateur) | `User-Agent: curl/7.68.0` |
| `Accept` | Types MIME acceptÃ©s | `Accept: text/html` |
| `Content-Length` | Taille du body (pour POST/PUT) | `Content-Length: 42` |
| `Connection` | Persistance de la connexion | `Connection: close` |

### 3. Ligne vide

**Cruciale :** Une ligne vide (`\r\n\r\n`) sÃ©pare les headers du body.

```
GET /index.html HTTP/1.1\r\n
Host: example.com\r\n
\r\n  â† Cette ligne vide marque la fin des headers
```

### 4. Body (optionnel)

Le body contient des donnÃ©es pour les mÃ©thodes POST, PUT, etc.

```http
POST /api/users HTTP/1.1
Host: example.com
Content-Type: application/json
Content-Length: 27

{"name":"Alice","age":30}
```

**Pour notre serveur GET/HEAD :** Pas de body dans les requÃªtes.

---

## Structure d'une RÃ©ponse HTTP

Une rÃ©ponse HTTP se compose Ã©galement de **trois parties** :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. STATUS LINE (ligne de statut)                        â”‚
â”‚    HTTP/1.1 200 OK                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 2. HEADERS (en-tÃªtes)                                   â”‚
â”‚    Content-Type: text/html                              â”‚
â”‚    Content-Length: 1234                                 â”‚
â”‚    Connection: close                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 3. EMPTY LINE (ligne vide)                              â”‚
â”‚    \r\n                                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 4. BODY (corps)                                         â”‚
â”‚    <!DOCTYPE html>                                      â”‚
â”‚    <html>...</html>                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1. Status Line

Format : `VERSION CODE MESSAGE`

```
HTTP/1.1 200 OK
â”‚        â”‚   â”‚
â”‚        â”‚   â””â”€ Phrase explicative (optionnelle)
â”‚        â””â”€ Code de statut
â””â”€ Version HTTP
```

**Codes de statut courants :**

| Code | Message | Signification |
|------|---------|---------------|
| 200 | OK | SuccÃ¨s |
| 301 | Moved Permanently | Redirection permanente |
| 302 | Found | Redirection temporaire |
| 304 | Not Modified | Ressource non modifiÃ©e (cache) |
| 400 | Bad Request | RequÃªte malformÃ©e |
| 403 | Forbidden | AccÃ¨s interdit |
| 404 | Not Found | Ressource introuvable |
| 500 | Internal Server Error | Erreur serveur |
| 501 | Not Implemented | MÃ©thode non supportÃ©e |

### 2. Response Headers

```
Content-Type: text/html; charset=utf-8
Content-Length: 1234
Server: MonServeur/1.0
Date: Mon, 27 Jul 2025 12:34:56 GMT
Connection: close
```

**Headers importants :**

| Header | Description | Exemple |
|--------|-------------|---------|
| `Content-Type` | Type MIME de la ressource | `text/html`, `image/png` |
| `Content-Length` | Taille du body en bytes | `Content-Length: 1234` |
| `Connection` | Gestion de la connexion | `close` ou `keep-alive` |
| `Server` | Identification du serveur | `Server: nginx/1.18.0` |
| `Date` | Date de la rÃ©ponse | Format RFC 7231 |

---

## Parsing de la Request Line

### Objectif

Extraire les trois composants de la premiÃ¨re ligne :

```
GET /index.html HTTP/1.1
â”‚   â”‚           â”‚
â”‚   â”‚           â””â”€ version (doit Ãªtre HTTP/1.0 ou HTTP/1.1)
â”‚   â””â”€ uri (chemin de la ressource)
â””â”€ method (GET, POST, HEAD, etc.)
```

### Structure de donnÃ©es

```c
#define MAX_METHOD_LEN 16
#define MAX_URI_LEN 2048
#define MAX_VERSION_LEN 16

typedef struct {
    char method[MAX_METHOD_LEN];
    char uri[MAX_URI_LEN];
    char version[MAX_VERSION_LEN];
} http_request_line_t;
```

### Fonction de parsing

```c
#include <string.h>
#include <ctype.h>

int parse_request_line(const char *line, http_request_line_t *req_line) {
    // Exemple de ligne: "GET /index.html HTTP/1.1\r\n"

    // VÃ©rifier que la ligne n'est pas vide
    if (line == NULL || line[0] == '\0') {
        return -1;
    }

    // Parser avec sscanf
    int parsed = sscanf(line, "%15s %2047s %15s",
                       req_line->method,
                       req_line->uri,
                       req_line->version);

    if (parsed != 3) {
        return -1;  // Ligne malformÃ©e
    }

    // Valider la mÃ©thode (optionnel mais recommandÃ©)
    if (strcmp(req_line->method, "GET") != 0 &&
        strcmp(req_line->method, "HEAD") != 0 &&
        strcmp(req_line->method, "POST") != 0) {
        return -1;  // MÃ©thode non supportÃ©e
    }

    // Valider la version
    if (strcmp(req_line->version, "HTTP/1.0") != 0 &&
        strcmp(req_line->version, "HTTP/1.1") != 0) {
        return -1;  // Version non supportÃ©e
    }

    // Valider l'URI (doit commencer par /)
    if (req_line->uri[0] != '/') {
        return -1;
    }

    return 0;  // SuccÃ¨s
}
```

**Explication :**
- `sscanf()` parse la ligne en 3 tokens sÃ©parÃ©s par des espaces
- Les limites (`%15s`, `%2047s`) prÃ©viennent les buffer overflows
- Validation pour rejeter les requÃªtes invalides

### Alternative : Parsing manuel

Pour plus de contrÃ´le, on peut parser manuellement :

```c
int parse_request_line_manual(const char *line, http_request_line_t *req_line) {
    const char *p = line;

    // 1. Extraire la mÃ©thode (jusqu'au premier espace)
    size_t method_len = 0;
    while (*p != ' ' && *p != '\0' && method_len < MAX_METHOD_LEN - 1) {
        req_line->method[method_len++] = *p++;
    }
    req_line->method[method_len] = '\0';

    if (*p != ' ') {
        return -1;  // Pas d'espace aprÃ¨s la mÃ©thode
    }
    p++;  // Sauter l'espace

    // 2. Extraire l'URI (jusqu'au deuxiÃ¨me espace)
    size_t uri_len = 0;
    while (*p != ' ' && *p != '\0' && uri_len < MAX_URI_LEN - 1) {
        req_line->uri[uri_len++] = *p++;
    }
    req_line->uri[uri_len] = '\0';

    if (*p != ' ') {
        return -1;  // Pas d'espace aprÃ¨s l'URI
    }
    p++;  // Sauter l'espace

    // 3. Extraire la version (jusqu'Ã  \r ou \n ou fin)
    size_t version_len = 0;
    while (*p != '\r' && *p != '\n' && *p != '\0' &&
           version_len < MAX_VERSION_LEN - 1) {
        req_line->version[version_len++] = *p++;
    }
    req_line->version[version_len] = '\0';

    return 0;
}
```

**Avantages du parsing manuel :**
- ContrÃ´le total sur le comportement
- Meilleure gestion des cas limites
- Plus facile Ã  sÃ©curiser

---

## Parsing des Headers

### Objectif

Extraire tous les headers sous forme de paires `Nom: Valeur`.

### Structure de donnÃ©es

```c
#define MAX_HEADER_NAME_LEN 64
#define MAX_HEADER_VALUE_LEN 512
#define MAX_HEADERS 32

typedef struct {
    char name[MAX_HEADER_NAME_LEN];
    char value[MAX_HEADER_VALUE_LEN];
} http_header_t;

typedef struct {
    http_header_t headers[MAX_HEADERS];
    int num_headers;
} http_headers_t;
```

### Fonction de parsing

```c
int parse_header(const char *line, http_header_t *header) {
    // Exemple: "Host: www.example.com\r\n"

    const char *colon = strchr(line, ':');
    if (colon == NULL) {
        return -1;  // Pas de ':' trouvÃ©
    }

    // Extraire le nom (avant le ':')
    size_t name_len = colon - line;
    if (name_len >= MAX_HEADER_NAME_LEN) {
        return -1;  // Nom trop long
    }

    strncpy(header->name, line, name_len);
    header->name[name_len] = '\0';

    // Sauter le ':' et les espaces qui suivent
    const char *value_start = colon + 1;
    while (*value_start == ' ' || *value_start == '\t') {
        value_start++;
    }

    // Extraire la valeur (jusqu'Ã  \r ou \n)
    const char *value_end = value_start;
    while (*value_end != '\r' && *value_end != '\n' && *value_end != '\0') {
        value_end++;
    }

    size_t value_len = value_end - value_start;
    if (value_len >= MAX_HEADER_VALUE_LEN) {
        return -1;  // Valeur trop longue
    }

    strncpy(header->value, value_start, value_len);
    header->value[value_len] = '\0';

    return 0;
}

int parse_headers(const char *buffer, http_headers_t *headers) {
    const char *line_start = buffer;
    headers->num_headers = 0;

    while (*line_start != '\0' && headers->num_headers < MAX_HEADERS) {
        // Trouver la fin de la ligne
        const char *line_end = strstr(line_start, "\r\n");
        if (line_end == NULL) {
            break;  // Pas de fin de ligne trouvÃ©e
        }

        // Ligne vide ? C'est la fin des headers
        if (line_end == line_start) {
            break;
        }

        // CrÃ©er une copie temporaire de la ligne
        size_t line_len = line_end - line_start;
        char line[1024];
        if (line_len >= sizeof(line)) {
            line_len = sizeof(line) - 1;
        }
        strncpy(line, line_start, line_len);
        line[line_len] = '\0';

        // Parser le header
        http_header_t *header = &headers->headers[headers->num_headers];
        if (parse_header(line, header) == 0) {
            headers->num_headers++;
        }

        // Passer Ã  la ligne suivante
        line_start = line_end + 2;  // +2 pour sauter \r\n
    }

    return headers->num_headers;
}
```

### Recherche d'un header spÃ©cifique

```c
const char *get_header_value(const http_headers_t *headers, const char *name) {
    for (int i = 0; i < headers->num_headers; i++) {
        // Comparaison insensible Ã  la casse (HTTP headers sont case-insensitive)
        if (strcasecmp(headers->headers[i].name, name) == 0) {
            return headers->headers[i].value;
        }
    }
    return NULL;  // Header non trouvÃ©
}

// Exemple d'utilisation
const char *host = get_header_value(&headers, "Host");
if (host != NULL) {
    printf("Host: %s\n", host);
}
```

---

## Parser HTTP Complet

### Structure globale de la requÃªte

```c
typedef struct {
    http_request_line_t request_line;
    http_headers_t headers;
    char *body;           // Pointeur vers le body (si prÃ©sent)
    size_t body_length;   // Taille du body
} http_request_t;
```

### Fonction de parsing complÃ¨te

```c
#include <string.h>
#include <stdlib.h>

int parse_http_request(const char *raw_request, http_request_t *request) {
    // Initialiser la structure
    memset(request, 0, sizeof(http_request_t));

    // 1. Parser la request line (premiÃ¨re ligne)
    const char *line_end = strstr(raw_request, "\r\n");
    if (line_end == NULL) {
        return -1;  // RequÃªte incomplÃ¨te
    }

    // Copier la premiÃ¨re ligne
    size_t line_len = line_end - raw_request;
    char first_line[2048];
    if (line_len >= sizeof(first_line)) {
        return -1;  // Ligne trop longue
    }
    strncpy(first_line, raw_request, line_len);
    first_line[line_len] = '\0';

    // Parser la request line
    if (parse_request_line(first_line, &request->request_line) != 0) {
        return -1;
    }

    // 2. Parser les headers
    const char *headers_start = line_end + 2;  // Sauter \r\n
    if (parse_headers(headers_start, &request->headers) < 0) {
        return -1;
    }

    // 3. Trouver le body (aprÃ¨s la ligne vide)
    const char *body_start = strstr(headers_start, "\r\n\r\n");
    if (body_start != NULL) {
        body_start += 4;  // Sauter \r\n\r\n

        // VÃ©rifier si un body est prÃ©sent
        const char *content_length_str = get_header_value(&request->headers,
                                                          "Content-Length");
        if (content_length_str != NULL) {
            request->body_length = atoi(content_length_str);
            request->body = (char *)body_start;
        }
    }

    return 0;  // SuccÃ¨s
}
```

### Exemple d'utilisation

```c
void handle_client_request(int client_fd) {
    char buffer[8192];
    ssize_t bytes_read = read(client_fd, buffer, sizeof(buffer) - 1);

    if (bytes_read <= 0) {
        return;
    }

    buffer[bytes_read] = '\0';

    // Parser la requÃªte
    http_request_t request;
    if (parse_http_request(buffer, &request) != 0) {
        // Envoyer 400 Bad Request
        send_error_response(client_fd, 400, "Bad Request");
        return;
    }

    // Afficher les infos
    printf("MÃ©thode: %s\n", request.request_line.method);
    printf("URI: %s\n", request.request_line.uri);
    printf("Version: %s\n", request.request_line.version);

    for (int i = 0; i < request.headers.num_headers; i++) {
        printf("Header: %s = %s\n",
               request.headers.headers[i].name,
               request.headers.headers[i].value);
    }

    // Traiter la requÃªte...
}
```

---

## GÃ©nÃ©ration de RÃ©ponses HTTP

### Fonction gÃ©nÃ©rique de rÃ©ponse

```c
#define MAX_RESPONSE_SIZE 8192

int send_http_response(int client_fd,
                      int status_code,
                      const char *status_message,
                      const char *content_type,
                      const char *body,
                      size_t body_length) {
    char response[MAX_RESPONSE_SIZE];
    int offset = 0;

    // 1. Status line
    offset += snprintf(response + offset, MAX_RESPONSE_SIZE - offset,
                      "HTTP/1.1 %d %s\r\n",
                      status_code, status_message);

    // 2. Headers
    offset += snprintf(response + offset, MAX_RESPONSE_SIZE - offset,
                      "Content-Type: %s\r\n", content_type);

    offset += snprintf(response + offset, MAX_RESPONSE_SIZE - offset,
                      "Content-Length: %zu\r\n", body_length);

    offset += snprintf(response + offset, MAX_RESPONSE_SIZE - offset,
                      "Connection: close\r\n");

    offset += snprintf(response + offset, MAX_RESPONSE_SIZE - offset,
                      "Server: MonServeur/1.0\r\n");

    // 3. Ligne vide
    offset += snprintf(response + offset, MAX_RESPONSE_SIZE - offset,
                      "\r\n");

    // Envoyer les headers
    ssize_t sent = write(client_fd, response, offset);
    if (sent < 0) {
        return -1;
    }

    // 4. Envoyer le body (si prÃ©sent)
    if (body != NULL && body_length > 0) {
        sent = write(client_fd, body, body_length);
        if (sent < 0) {
            return -1;
        }
    }

    return 0;
}
```

### RÃ©ponses d'erreur courantes

```c
void send_error_response(int client_fd, int status_code, const char *message) {
    char body[256];
    snprintf(body, sizeof(body),
             "<html><body><h1>%d %s</h1></body></html>",
             status_code, message);

    send_http_response(client_fd, status_code, message,
                      "text/html", body, strlen(body));
}

// Exemples d'utilisation
void send_404(int client_fd) {
    send_error_response(client_fd, 404, "Not Found");
}

void send_400(int client_fd) {
    send_error_response(client_fd, 400, "Bad Request");
}

void send_500(int client_fd) {
    send_error_response(client_fd, 500, "Internal Server Error");
}

void send_501(int client_fd) {
    send_error_response(client_fd, 501, "Not Implemented");
}
```

### RÃ©ponse 200 OK avec contenu

```c
void send_file_response(int client_fd, const char *file_content,
                       size_t file_size, const char *content_type) {
    send_http_response(client_fd, 200, "OK",
                      content_type, file_content, file_size);
}

// Exemple
void serve_html(int client_fd) {
    const char *html =
        "<!DOCTYPE html>\n"
        "<html>\n"
        "<body>\n"
        "<h1>Hello, World!</h1>\n"
        "</body>\n"
        "</html>";

    send_file_response(client_fd, html, strlen(html), "text/html");
}
```

---

## Gestion des Types MIME

### Qu'est-ce qu'un type MIME ?

Le type MIME (Multipurpose Internet Mail Extensions) indique au client le type de contenu qu'il reÃ§oit.

**Format :** `type/sous-type`

### Types MIME courants

```c
typedef struct {
    const char *extension;
    const char *mime_type;
} mime_mapping_t;

static const mime_mapping_t mime_types[] = {
    {".html", "text/html"},
    {".htm", "text/html"},
    {".css", "text/css"},
    {".js", "application/javascript"},
    {".json", "application/json"},
    {".txt", "text/plain"},
    {".xml", "application/xml"},

    {".jpg", "image/jpeg"},
    {".jpeg", "image/jpeg"},
    {".png", "image/png"},
    {".gif", "image/gif"},
    {".svg", "image/svg+xml"},
    {".ico", "image/x-icon"},

    {".pdf", "application/pdf"},
    {".zip", "application/zip"},

    {".mp3", "audio/mpeg"},
    {".mp4", "video/mp4"},

    {NULL, NULL}  // Sentinelle
};
```

### Fonction de dÃ©tection du type MIME

```c
#include <string.h>
#include <strings.h>

const char *get_mime_type(const char *filename) {
    // Trouver l'extension
    const char *ext = strrchr(filename, '.');
    if (ext == NULL) {
        return "application/octet-stream";  // Type par dÃ©faut
    }

    // Chercher dans la table
    for (int i = 0; mime_types[i].extension != NULL; i++) {
        if (strcasecmp(ext, mime_types[i].extension) == 0) {
            return mime_types[i].mime_type;
        }
    }

    return "application/octet-stream";  // Type par dÃ©faut si inconnu
}

// Exemple d'utilisation
const char *mime = get_mime_type("/path/to/image.png");
// mime == "image/png"
```

---

## SÃ©curitÃ© : Validation et Sanitization

### 1. Validation de l'URI

**ProblÃ¨me :** Un attaquant peut essayer d'accÃ©der Ã  des fichiers hors du rÃ©pertoire web.

```
GET /../../../etc/passwd HTTP/1.1
```

**Solution :** Normaliser et valider l'URI.

```c
#include <limits.h>
#include <stdlib.h>

int is_safe_path(const char *uri, const char *document_root) {
    char full_path[PATH_MAX];
    char real_path[PATH_MAX];

    // Construire le chemin complet
    snprintf(full_path, sizeof(full_path), "%s%s", document_root, uri);

    // RÃ©soudre le chemin rÃ©el (supprime .., ., liens symboliques)
    if (realpath(full_path, real_path) == NULL) {
        return 0;  // Chemin invalide
    }

    // VÃ©rifier que le chemin rÃ©el est bien dans document_root
    if (strncmp(real_path, document_root, strlen(document_root)) != 0) {
        return 0;  // Tentative de sortir du document root
    }

    return 1;  // Chemin sÃ»r
}

// Utilisation
if (!is_safe_path(request.request_line.uri, "/var/www/html")) {
    send_error_response(client_fd, 403, "Forbidden");
    return;
}
```

### 2. Limitation de la taille des requÃªtes

```c
#define MAX_REQUEST_SIZE 16384  // 16 KB

ssize_t read_request(int client_fd, char *buffer, size_t buffer_size) {
    size_t total_read = 0;

    while (total_read < buffer_size - 1) {
        ssize_t n = read(client_fd, buffer + total_read,
                        buffer_size - total_read - 1);

        if (n <= 0) {
            break;
        }

        total_read += n;

        // VÃ©rifier si on a reÃ§u la fin des headers
        if (strstr(buffer, "\r\n\r\n") != NULL) {
            break;
        }

        // Protection contre les requÃªtes trop grandes
        if (total_read >= MAX_REQUEST_SIZE) {
            return -1;  // RequÃªte trop grande
        }
    }

    buffer[total_read] = '\0';
    return total_read;
}
```

### 3. Timeout de lecture

```c
#include <sys/select.h>

int read_with_timeout(int client_fd, char *buffer, size_t size, int timeout_sec) {
    fd_set read_fds;
    struct timeval timeout;

    FD_ZERO(&read_fds);
    FD_SET(client_fd, &read_fds);

    timeout.tv_sec = timeout_sec;
    timeout.tv_usec = 0;

    int ready = select(client_fd + 1, &read_fds, NULL, NULL, &timeout);

    if (ready <= 0) {
        return -1;  // Timeout ou erreur
    }

    return read(client_fd, buffer, size);
}
```

### 4. Validation des headers

```c
int validate_headers(const http_headers_t *headers) {
    // VÃ©rifier que Host est prÃ©sent (requis en HTTP/1.1)
    const char *host = get_header_value(headers, "Host");
    if (host == NULL) {
        return -1;
    }

    // VÃ©rifier Content-Length si prÃ©sent
    const char *content_length = get_header_value(headers, "Content-Length");
    if (content_length != NULL) {
        int len = atoi(content_length);
        if (len < 0 || len > MAX_BODY_SIZE) {
            return -1;
        }
    }

    return 0;
}
```

---

## Gestion du Keep-Alive

HTTP/1.1 supporte les connexions persistantes (keep-alive).

### Sans Keep-Alive (simple)

```c
// Une requÃªte = une connexion
void handle_client(int client_fd) {
    parse_and_handle_request(client_fd);
    close(client_fd);  // Fermer aprÃ¨s chaque requÃªte
}
```

### Avec Keep-Alive

```c
void handle_client_keepalive(int client_fd) {
    while (1) {
        // Lire une requÃªte
        http_request_t request;
        if (read_and_parse_request(client_fd, &request) != 0) {
            break;  // Erreur ou connexion fermÃ©e
        }

        // Traiter la requÃªte
        handle_request(client_fd, &request);

        // VÃ©rifier si le client veut garder la connexion
        const char *connection = get_header_value(&request.headers, "Connection");
        if (connection != NULL && strcasecmp(connection, "close") == 0) {
            break;  // Client demande la fermeture
        }

        // En HTTP/1.0, keep-alive doit Ãªtre explicite
        if (strcmp(request.request_line.version, "HTTP/1.0") == 0) {
            if (connection == NULL || strcasecmp(connection, "keep-alive") != 0) {
                break;
            }
        }

        // Continuer Ã  lire la prochaine requÃªte...
    }

    close(client_fd);
}
```

**Note :** Pour un serveur simple, il est plus facile de fermer la connexion aprÃ¨s chaque requÃªte (`Connection: close`).

---

## Exemple Complet : Serveur HTTP Minimal

Voici un serveur HTTP complet mais simple :

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>

#define PORT 8080
#define BUFFER_SIZE 8192

// Structures (dÃ©finies prÃ©cÃ©demment)
// ... http_request_line_t, http_headers_t, http_request_t ...

// Fonctions de parsing (dÃ©finies prÃ©cÃ©demment)
// ... parse_request_line, parse_headers, parse_http_request ...

void handle_get_request(int client_fd, const http_request_t *request) {
    // Pour simplifier, on sert toujours la mÃªme page
    const char *html =
        "<!DOCTYPE html>\n"
        "<html>\n"
        "<head><title>Test Server</title></head>\n"
        "<body>\n"
        "<h1>Hello from C HTTP Server!</h1>\n"
        "<p>You requested: %s</p>\n"
        "</body>\n"
        "</html>";

    char body[2048];
    snprintf(body, sizeof(body), html, request->request_line.uri);

    // Construire la rÃ©ponse
    char response[4096];
    int offset = 0;

    offset += snprintf(response + offset, sizeof(response) - offset,
                      "HTTP/1.1 200 OK\r\n");
    offset += snprintf(response + offset, sizeof(response) - offset,
                      "Content-Type: text/html\r\n");
    offset += snprintf(response + offset, sizeof(response) - offset,
                      "Content-Length: %zu\r\n", strlen(body));
    offset += snprintf(response + offset, sizeof(response) - offset,
                      "Connection: close\r\n");
    offset += snprintf(response + offset, sizeof(response) - offset,
                      "\r\n");

    // Envoyer headers
    write(client_fd, response, offset);

    // Envoyer body
    write(client_fd, body, strlen(body));
}

void handle_client(int client_fd) {
    char buffer[BUFFER_SIZE];

    // Lire la requÃªte
    ssize_t bytes_read = read(client_fd, buffer, sizeof(buffer) - 1);
    if (bytes_read <= 0) {
        close(client_fd);
        return;
    }

    buffer[bytes_read] = '\0';

    // Parser la requÃªte
    http_request_t request;
    if (parse_http_request(buffer, &request) != 0) {
        // Erreur de parsing
        const char *error_response =
            "HTTP/1.1 400 Bad Request\r\n"
            "Content-Length: 11\r\n"
            "Connection: close\r\n"
            "\r\n"
            "Bad Request";
        write(client_fd, error_response, strlen(error_response));
        close(client_fd);
        return;
    }

    // Afficher la requÃªte
    printf("RequÃªte reÃ§ue: %s %s %s\n",
           request.request_line.method,
           request.request_line.uri,
           request.request_line.version);

    // Traiter selon la mÃ©thode
    if (strcmp(request.request_line.method, "GET") == 0) {
        handle_get_request(client_fd, &request);
    } else if (strcmp(request.request_line.method, "HEAD") == 0) {
        // HEAD = GET sans body
        // TODO: implÃ©menter
    } else {
        // MÃ©thode non supportÃ©e
        const char *error_response =
            "HTTP/1.1 501 Not Implemented\r\n"
            "Content-Length: 15\r\n"
            "Connection: close\r\n"
            "\r\n"
            "Not Implemented";
        write(client_fd, error_response, strlen(error_response));
    }

    close(client_fd);
}

int main(void) {
    int server_fd;
    struct sockaddr_in address;
    int opt = 1;

    // CrÃ©er le socket
    server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd < 0) {
        perror("socket");
        return EXIT_FAILURE;
    }

    // Options du socket
    setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    // Configuration de l'adresse
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);

    // Bind
    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {
        perror("bind");
        close(server_fd);
        return EXIT_FAILURE;
    }

    // Listen
    if (listen(server_fd, 10) < 0) {
        perror("listen");
        close(server_fd);
        return EXIT_FAILURE;
    }

    printf("Serveur HTTP dÃ©marrÃ© sur le port %d\n", PORT);
    printf("Ouvrez http://localhost:%d dans votre navigateur\n", PORT);

    // Boucle principale
    while (1) {
        struct sockaddr_in client_addr;
        socklen_t client_len = sizeof(client_addr);

        int client_fd = accept(server_fd,
                              (struct sockaddr *)&client_addr,
                              &client_len);

        if (client_fd < 0) {
            perror("accept");
            continue;
        }

        // Traiter le client
        handle_client(client_fd);
    }

    close(server_fd);
    return EXIT_SUCCESS;
}
```

### Test du serveur

```bash
# Compiler
gcc -Wall -Wextra -o http_server http_server.c

# Lancer
./http_server

# Dans un autre terminal, tester avec curl
curl -v http://localhost:8080/test

# Ou ouvrir dans un navigateur
firefox http://localhost:8080/
```

---

## DÃ©bogage HTTP

### 1. Afficher les requÃªtes brutes

```c
void debug_print_request(const char *buffer, size_t len) {
    printf("=== REQUÃŠTE BRUTE ===\n");
    for (size_t i = 0; i < len; i++) {
        char c = buffer[i];
        if (c == '\r') {
            printf("\\r");
        } else if (c == '\n') {
            printf("\\n\n");
        } else if (isprint(c)) {
            printf("%c", c);
        } else {
            printf("\\x%02x", (unsigned char)c);
        }
    }
    printf("\n=== FIN ===\n");
}
```

### 2. Utiliser des outils de test

```bash
# curl avec verbose
curl -v http://localhost:8080/test

# Voir tous les headers
curl -I http://localhost:8080/

# telnet pour envoyer manuellement
telnet localhost 8080
GET / HTTP/1.1
Host: localhost

# (appuyer sur EntrÃ©e deux fois)
```

### 3. Wireshark/tcpdump

```bash
# Capturer le trafic HTTP
sudo tcpdump -i lo -A port 8080

# Avec wireshark (GUI)
sudo wireshark
# Filtrer: tcp.port == 8080
```

---

## Optimisations

### 1. Buffer statique vs dynamique

```c
// âœ… Bon pour requÃªtes courtes : buffer sur la pile
void handle_client(int client_fd) {
    char buffer[8192];  // Rapide
    // ...
}

// âœ… Bon pour requÃªtes longues : allocation dynamique
void handle_client(int client_fd) {
    char *buffer = malloc(65536);
    // ...
    free(buffer);
}
```

### 2. Parsing lazy

Ne parser que ce qui est nÃ©cessaire :

```c
// Au lieu de tout parser d'avance
if (strcmp(method, "GET") == 0) {
    // Parser seulement si GET
    parse_headers(...);
}
```

### 3. String interning

Pour les noms de headers (rÃ©pÃ©tÃ©s) :

```c
// Utiliser des constantes pour les headers courants
const char *HEADER_HOST = "Host";
const char *HEADER_USER_AGENT = "User-Agent";

// Comparaison de pointeurs au lieu de strcmp
if (header_name == HEADER_HOST) {
    // ...
}
```

---

## RÃ©sumÃ©

Le parsing HTTP en C nÃ©cessite :

1. **Comprendre le protocole** : Format texte, request line, headers, body
2. **Parser la request line** : Extraire mÃ©thode, URI, version
3. **Parser les headers** : Extraire paires nom:valeur
4. **Valider les donnÃ©es** : SÃ©curitÃ© contre injections, path traversal
5. **GÃ©nÃ©rer des rÃ©ponses** : Status line, headers, body
6. **GÃ©rer les types MIME** : Content-Type appropriÃ©
7. **GÃ©rer les erreurs** : 400, 404, 500, 501

**Points clÃ©s :**
- HTTP est **textuel** et **simple Ã  parser**
- Toujours **valider et limiter** les entrÃ©es
- GÃ©rer les **cas d'erreur** proprement
- Utiliser `\r\n` (CRLF) pour les fins de ligne

**Prochaine Ã©tape :** Nous allons maintenant implÃ©menter le **serving de fichiers statiques** pour servir HTML, CSS, images, etc. depuis le disque.

---

## Pour Aller Plus Loin

### RFC HTTP

- **RFC 7230** : HTTP/1.1 - Message Syntax and Routing
- **RFC 7231** : HTTP/1.1 - Semantics and Content
- **RFC 7232** : HTTP/1.1 - Conditional Requests

### Parsers HTTP Robustes

- **http-parser** (utilisÃ© par Node.js) : https://github.com/nodejs/http-parser
- **picohttpparser** : Parser minimaliste et ultra-rapide
- **llhttp** : Successeur de http-parser

### Concepts AvancÃ©s

- **Chunked Transfer Encoding** : Envoyer des donnÃ©es par morceaux
- **Range Requests** : TÃ©lÃ©chargement partiel (vidÃ©os)
- **Compression** : gzip, deflate
- **HTTP/2** : Protocole binaire, multiplexage
- **WebSockets** : Connexion bidirectionnelle

Le parsing HTTP est la base de tout serveur web. Avec une comprÃ©hension solide de ces concepts, vous pouvez construire des serveurs robustes et performants !

â­ï¸ [Static file serving](/34-etudes-cas-devops/04.3-static-file-serving.md)
