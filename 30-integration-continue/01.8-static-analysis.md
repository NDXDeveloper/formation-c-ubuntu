üîù Retour au [Sommaire](/SOMMAIRE.md)

# 30.1.8 Static analysis

## Introduction

L'**analyse statique** (static analysis) est l'examen automatique de votre code source **sans l'ex√©cuter**. C'est comme avoir un expert qui relit votre code et signale les bugs potentiels, les probl√®mes de style, les vuln√©rabilit√©s de s√©curit√© et les mauvaises pratiques avant m√™me la compilation.

Contrairement aux tests dynamiques (sanitizers, Valgrind) qui d√©tectent les probl√®mes pendant l'ex√©cution, l'analyse statique trouve des bugs **avant** que le code ne soit compil√© ou test√©. C'est votre **premier filet de s√©curit√©**.

---

## Pourquoi l'analyse statique est essentielle ?

### Les avantages

1. **D√©tection pr√©coce** : Trouve les bugs avant la compilation et l'ex√©cution
2. **Couverture compl√®te** : Analyse tout le code, m√™me les chemins rarement ex√©cut√©s
3. **Aucun runtime** : Pas besoin d'ex√©cuter le programme
4. **Qualit√© du code** : D√©tecte les mauvaises pratiques et am√©liore la lisibilit√©
5. **S√©curit√©** : Identifie les vuln√©rabilit√©s potentielles
6. **√âconomie de temps** : D√©tecte les probl√®mes avant qu'ils ne deviennent co√ªteux

### Ce que l'analyse statique d√©tecte

| Cat√©gorie | Exemples |
|-----------|----------|
| **Bugs logiques** | Conditions toujours vraies/fausses, code mort |
| **Probl√®mes m√©moire** | Fuites potentielles, use-after-free |
| **Comportements ind√©finis** | Division par z√©ro, d√©bordements |
| **Mauvaises pratiques** | Variables non initialis√©es, fonctions inutilis√©es |
| **Vuln√©rabilit√©s** | Buffer overflows, format string bugs |
| **Style** | Nommage, formatage, complexit√© |

---

## Les outils d'analyse statique pour C

### 1. clang-tidy üîµ (Recommand√©)

**L'outil moderne et le plus complet.**

- Bas√© sur l'infrastructure Clang/LLVM
- Plus de 400 v√©rifications disponibles
- Peut sugg√©rer des corrections automatiques
- S'int√®gre parfaitement avec CMake

**Installation :**
```bash
sudo apt-get install clang-tidy
```

**Utilisation typique :** CI quotidienne, pre-commit hooks

### 2. cppcheck üü¢

**Outil ind√©pendant du compilateur.**

- Fonctionne sans compilation
- Analyse rapide
- Faux positifs mod√©r√©s
- Gratuit et open-source

**Installation :**
```bash
sudo apt-get install cppcheck
```

**Utilisation typique :** CI rapide, v√©rification locale

### 3. Clang Static Analyzer üü°

**Analyseur en profondeur de Clang.**

- Analyse tr√®s approfondie
- Trouve des bugs complexes
- Plus lent que clang-tidy
- Int√©gr√© √† Clang

**Utilisation :** Analyse hebdomadaire approfondie

### 4. Autres outils (commerciaux)

- **Coverity** : Standard industriel (tr√®s puissant, commercial)
- **PVS-Studio** : Excellent mais commercial
- **SonarQube** : Plateforme compl√®te de qualit√© de code
- **Infer** : Par Facebook, open-source

---

## clang-tidy : L'outil principal

### Installation

```bash
sudo apt-get update  
sudo apt-get install clang-tidy  
```

V√©rifier la version :
```bash
clang-tidy --version
```

Sortie typique :
```
LLVM version 15.0.0
```

### Utilisation de base

```bash
clang-tidy src/main.c -- -Iinclude
```

**Syntaxe :**
- `src/main.c` : Fichier √† analyser
- `--` : S√©parateur
- `-Iinclude` : Options du compilateur (chemins d'inclusion, etc.)

### Avec une base de donn√©es de compilation

Pour les projets complexes, utilisez `compile_commands.json` :

```bash
# G√©n√©rer avec CMake
cmake -B build -DCMAKE_EXPORT_COMPILE_COMMANDS=ON

# Analyser avec la base de donn√©es
clang-tidy -p build src/main.c
```

**Avantage :** clang-tidy conna√Æt automatiquement tous les flags de compilation.

---

## Configuration de clang-tidy

### Fichier .clang-tidy

Cr√©ez un fichier `.clang-tidy` √† la racine de votre projet :

**.clang-tidy**
```yaml
---
# V√©rifications √† activer
Checks: >
  clang-diagnostic-*,
  clang-analyzer-*,
  bugprone-*,
  performance-*,
  readability-*,
  modernize-*,
  -readability-magic-numbers,
  -readability-identifier-length

# Traiter les warnings comme des erreurs
WarningsAsErrors: ''

# Options pour les v√©rifications
CheckOptions:
  - key: readability-identifier-naming.FunctionCase
    value: lower_case
  - key: readability-identifier-naming.VariableCase
    value: lower_case
  - key: readability-identifier-naming.ConstantCase
    value: UPPER_CASE
```

**Explications :**

- `Checks:` : Liste des v√©rifications activ√©es
  - `*` : Toutes les v√©rifications de cette cat√©gorie
  - `-name` : D√©sactive une v√©rification sp√©cifique
- `WarningsAsErrors:` : Transforme certains warnings en erreurs
- `CheckOptions:` : Configure des r√®gles sp√©cifiques

### Cat√©gories de v√©rifications

| Cat√©gorie | Description | Exemples |
|-----------|-------------|----------|
| `bugprone-*` | Bugs courants | Use-after-move, integer overflow |
| `clang-analyzer-*` | Analyseur statique | Null pointer, memory leaks |
| `performance-*` | Optimisations | Copies inutiles, boucles lentes |
| `readability-*` | Lisibilit√© | Nommage, complexit√©, magic numbers |
| `modernize-*` | Modernisation | Suggestions C moderne |
| `cert-*` | S√©curit√© CERT | Bonnes pratiques s√©curit√© |
| `cppcoreguidelines-*` | Core Guidelines | Standards de qualit√© |

### Lister toutes les v√©rifications disponibles

```bash
clang-tidy --list-checks
```

Sortie partielle :
```
Enabled checks:
    bugprone-argument-comment
    bugprone-assert-side-effect
    bugprone-bool-pointer-implicit-conversion
    ...
```

---

## Exemple d'analyse clang-tidy

### Code avec probl√®mes

**bad_code.c**
```c
#include <stdio.h>
#include <stdlib.h>

int calculate(int x) {
    int result;  // Variable non initialis√©e !

    if (x == 0) {
        return 0;
    }

    result = 100 / x;
    return result;
}

int main() {
    int *ptr = malloc(10 * sizeof(int));
    // Oups ! Pas de v√©rification de NULL

    ptr[0] = calculate(5);

    // Oups ! Pas de free()
    return 0;
}
```

### Analyse avec clang-tidy

```bash
clang-tidy bad_code.c --
```

### Rapport

```
bad_code.c:5:9: warning: variable 'result' is used uninitialized [clang-analyzer-core.uninitialized.Assign]
    int result;
        ^
bad_code.c:15:20: note: Assuming 'ptr' is non-null
    int *ptr = malloc(10 * sizeof(int));
               ^
bad_code.c:18:5: warning: Potential leak of memory pointed to by 'ptr' [clang-analyzer-unix.Malloc]
    ptr[0] = calculate(5);
    ^
bad_code.c:21:5: warning: Memory allocated by malloc() should be deallocated [cppcoreguidelines-no-malloc]
    return 0;
    ^
```

**Le rapport indique :**
1. Variable non initialis√©e (ligne 5)
2. Pas de v√©rification du retour de `malloc` (ligne 15)
3. Fuite m√©moire potentielle (ligne 18)
4. Recommandation d'√©viter `malloc` brut (ligne 21)

---

## Workflow GitHub Actions avec clang-tidy

### Workflow de base

```yaml
name: Analyse Statique - clang-tidy

on: [push, pull_request]

jobs:
  clang-tidy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout du code
      uses: actions/checkout@v4

    - name: Installer clang-tidy
      run: |
        sudo apt-get update
        sudo apt-get install -y clang-tidy cmake

    - name: Configurer le projet
      run: |
        cmake -B build \
          -DCMAKE_EXPORT_COMPILE_COMMANDS=ON

    - name: Lancer clang-tidy
      run: |
        clang-tidy -p build src/*.c
```

### Workflow avec rapport d√©taill√©

```yaml
name: clang-tidy Analysis

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  static-analysis:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Installer les outils
      run: |
        sudo apt-get update
        sudo apt-get install -y clang-tidy-15 cmake
        sudo update-alternatives --install /usr/bin/clang-tidy clang-tidy /usr/bin/clang-tidy-15 100

    - name: Configurer avec compile_commands.json
      run: |
        cmake -B build \
          -DCMAKE_C_COMPILER=clang \
          -DCMAKE_EXPORT_COMPILE_COMMANDS=ON

    - name: V√©rifier compile_commands.json
      run: |
        if [ ! -f build/compile_commands.json ]; then
          echo "‚ùå compile_commands.json non g√©n√©r√©"
          exit 1
        fi
        echo "‚úÖ compile_commands.json trouv√©"

    - name: Analyser avec clang-tidy
      run: |
        clang-tidy -p build src/*.c 2>&1 | tee clang-tidy-report.txt

    - name: V√©rifier les erreurs critiques
      run: |
        if grep -q "error:" clang-tidy-report.txt; then
          echo "‚ùå Erreurs critiques d√©tect√©es"
          exit 1
        fi
        echo "‚úÖ Aucune erreur critique"

    - name: Uploader le rapport
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: clang-tidy-report
        path: clang-tidy-report.txt
```

---

## cppcheck : Analyse ind√©pendante

### Installation

```bash
sudo apt-get install cppcheck
```

### Utilisation de base

```bash
cppcheck --enable=all --inconclusive --suppress=missingIncludeSystem src/
```

**Options :**

- `--enable=all` : Active toutes les v√©rifications
- `--inconclusive` : Signale m√™me les probl√®mes incertains
- `--suppress=missingIncludeSystem` : Ignore les headers syst√®me manquants
- `src/` : R√©pertoire √† analyser

### Options avanc√©es

```bash
cppcheck \
  --enable=warning,style,performance,portability \
  --std=c17 \
  --template=gcc \
  --verbose \
  --force \
  src/
```

**Explications :**

- `--enable=` : Cat√©gories de v√©rifications
- `--std=c17` : Standard C √† utiliser
- `--template=gcc` : Format de sortie compatible GCC
- `--force` : V√©rifie m√™me les fichiers avec erreurs de pr√©processeur

### Rapport XML pour CI

```bash
cppcheck --enable=all --xml --xml-version=2 src/ 2> cppcheck-report.xml
```

---

## Workflow GitHub Actions avec cppcheck

```yaml
name: Analyse Statique - cppcheck

on: [push, pull_request]

jobs:
  cppcheck:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Installer cppcheck
      run: |
        sudo apt-get update
        sudo apt-get install -y cppcheck

    - name: V√©rifier la version
      run: cppcheck --version

    - name: Analyser le code
      run: |
        cppcheck \
          --enable=all \
          --inconclusive \
          --suppress=missingIncludeSystem \
          --std=c17 \
          --template='[{file}:{line}] ({severity}) {id}: {message}' \
          --error-exitcode=1 \
          src/ 2>&1 | tee cppcheck-report.txt

    - name: Uploader le rapport
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: cppcheck-report
        path: cppcheck-report.txt
```

**Option importante :** `--error-exitcode=1` fait √©chouer le workflow si des erreurs sont d√©tect√©es.

---

## Clang Static Analyzer (scan-build)

### Installation

```bash
sudo apt-get install clang-tools
```

### Utilisation avec Make

```bash
scan-build make
```

### Utilisation avec CMake

```bash
scan-build cmake -B build  
scan-build cmake --build build  
```

### Workflow GitHub Actions

```yaml
name: Clang Static Analyzer

on: [push, pull_request]

jobs:
  scan-build:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4

    - name: Installer scan-build
      run: |
        sudo apt-get update
        sudo apt-get install -y clang-tools cmake

    - name: Analyser avec scan-build
      run: |
        scan-build --status-bugs cmake -B build
        scan-build --status-bugs cmake --build build
```

**Option `--status-bugs`** : Fait √©chouer la commande si des bugs sont d√©tect√©s.

---

## Matrice d'outils : Analyse compl√®te

Pour une analyse exhaustive, combinez plusieurs outils :

```yaml
name: Analyse Statique Compl√®te

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  static-analysis:
    name: ${{ matrix.tool }}
    runs-on: ubuntu-latest

    strategy:
      fail-fast: false
      matrix:
        tool:
          - name: clang-tidy
            command: clang-tidy -p build src/*.c

          - name: cppcheck
            command: cppcheck --enable=all --error-exitcode=1 src/

          - name: scan-build
            command: scan-build --status-bugs cmake --build build

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Installer les outils
      run: |
        sudo apt-get update
        sudo apt-get install -y clang-tidy cppcheck clang-tools cmake

    - name: Configurer le projet
      if: matrix.tool.name != 'cppcheck'
      run: cmake -B build -DCMAKE_EXPORT_COMPILE_COMMANDS=ON

    - name: Lancer ${{ matrix.tool.name }}
      run: ${{ matrix.tool.command }} 2>&1 | tee ${{ matrix.tool.name }}-report.txt

    - name: Uploader le rapport
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.tool.name }}-report
        path: ${{ matrix.tool.name }}-report.txt
```

---

## Configuration CMake pour l'analyse statique

Int√©grez l'analyse statique directement dans votre CMakeLists.txt :

**CMakeLists.txt**

```cmake
cmake_minimum_required(VERSION 3.10)  
project(MonProjet C)  

# Option pour activer clang-tidy
option(ENABLE_CLANG_TIDY "Enable clang-tidy analysis" OFF)

if(ENABLE_CLANG_TIDY)
    find_program(CLANG_TIDY_EXE NAMES clang-tidy)

    if(CLANG_TIDY_EXE)
        message(STATUS "clang-tidy trouv√©: ${CLANG_TIDY_EXE}")
        set(CMAKE_C_CLANG_TIDY ${CLANG_TIDY_EXE})
    else()
        message(WARNING "clang-tidy non trouv√©")
    endif()
endif()

# Option pour activer cppcheck
option(ENABLE_CPPCHECK "Enable cppcheck analysis" OFF)

if(ENABLE_CPPCHECK)
    find_program(CPPCHECK_EXE NAMES cppcheck)

    if(CPPCHECK_EXE)
        message(STATUS "cppcheck trouv√©: ${CPPCHECK_EXE}")
        set(CMAKE_C_CPPCHECK
            ${CPPCHECK_EXE}
            --enable=warning,performance,portability
            --std=c17
            --suppress=missingIncludeSystem
        )
    else()
        message(WARNING "cppcheck non trouv√©")
    endif()
endif()

# Votre projet
add_executable(app src/main.c)
```

**Utilisation dans le workflow :**

```yaml
- name: Configurer avec clang-tidy
  run: cmake -B build -DENABLE_CLANG_TIDY=ON

- name: Compiler (analyse automatique)
  run: cmake --build build
```

L'analyse se fait automatiquement pendant la compilation !

---

## Annotations dans les Pull Requests

Pour annoter directement les fichiers dans les PRs, utilisez des actions sp√©cialis√©es :

### Avec reviewdog

```yaml
name: reviewdog

on: [pull_request]

jobs:
  clang-tidy:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4

    - name: Installer clang-tidy
      run: sudo apt-get install -y clang-tidy cmake

    - name: Configurer
      run: cmake -B build -DCMAKE_EXPORT_COMPILE_COMMANDS=ON

    - name: Analyser avec reviewdog
      uses: reviewdog/action-clang-tidy@v1
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        reporter: github-pr-review
        level: warning
        clang_tidy_flags: -p build
```

**R√©sultat :** Les probl√®mes d√©tect√©s apparaissent comme des commentaires dans la PR !

---

## Suppressions et faux positifs

### Supprimer des warnings sp√©cifiques avec clang-tidy

Dans le code source :

```c
// NOLINT(bugprone-narrowing-conversions)
int x = 3.14;

// Supprimer plusieurs v√©rifications
// NOLINTNEXTLINE(readability-magic-numbers, cert-err34-c)
int magic = 42;
```

### Supprimer avec cppcheck

```c
// cppcheck-suppress uninitvar
int x;  
use(x);  
```

### Fichier de suppressions cppcheck

**cppcheck-suppressions.txt**
```
uninitvar:src/legacy.c  
memleak:src/external.c:42  
```

**Utilisation :**
```bash
cppcheck --suppressions-list=cppcheck-suppressions.txt src/
```

---

## V√©rifications de s√©curit√© sp√©cifiques

### Avec clang-tidy CERT

Activez les v√©rifications CERT (Computer Emergency Response Team) :

**.clang-tidy**
```yaml
Checks: cert-*
```

**V√©rifications CERT importantes :**

- `cert-err33-c` : V√©rifier les valeurs de retour
- `cert-str31-c` : Ne pas modifier les string literals
- `cert-mem33-c` : Allocations/d√©sallocations correctes
- `cert-env33-c` : Ne pas appeler `system()` avec des entr√©es utilisateur

### Avec cppcheck

```bash
cppcheck --enable=warning,style,performance,portability --addon=cert src/
```

---

## Int√©gration avec SonarCloud

Pour une analyse plus compl√®te incluant la qualit√© de code :

```yaml
name: SonarCloud Analysis

on:
  push:
    branches: [ main ]
  pull_request:

jobs:
  sonarcloud:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0  # N√©cessaire pour SonarCloud

    - name: Installer les outils
      run: |
        sudo apt-get update
        sudo apt-get install -y gcc cmake gcov

    - name: Configurer
      run: |
        cmake -B build \
          -DCMAKE_BUILD_TYPE=Debug \
          -DCMAKE_C_FLAGS="--coverage"

    - name: Compiler
      run: cmake --build build

    - name: Lancer les tests
      run: |
        cd build
        ctest

    - name: G√©n√©rer la couverture
      run: |
        cd build
        gcov CMakeFiles/app.dir/src/*.gcno

    - name: SonarCloud Scan
      uses: SonarSource/sonarcloud-github-action@master
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
```

**Note :** N√©cessite une configuration `sonar-project.properties` et un compte SonarCloud.

---

## M√©triques de complexit√©

### Avec lizard (outil de m√©triques)

```yaml
- name: Installer lizard
  run: pip install lizard

- name: Analyser la complexit√©
  run: |
    lizard src/ -l c --CCN 15 --arguments 5 --length 1000
```

**M√©triques :**
- **CCN** : Complexit√© cyclomatique (‚â§ 15 recommand√©)
- **arguments** : Nombre de param√®tres (‚â§ 5 recommand√©)
- **length** : Longueur de fonction (‚â§ 100 lignes recommand√©)

### Avec clang-tidy

```yaml
Checks: readability-function-cognitive-complexity  
CheckOptions:  
  - key: readability-function-cognitive-complexity.Threshold
    value: 25
```

---

## Workflow complet : Qualit√© de code

Voici un workflow production-ready combinant tous les outils :

```yaml
name: Analyse de Qualit√© de Code

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  static-analysis:
    name: Analyse Statique
    runs-on: ubuntu-latest

    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Installer les outils
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          clang-tidy-15 \
          cppcheck \
          clang-tools \
          cmake \
          gcc
        pip install lizard

    - name: Configurer le projet
      run: |
        cmake -B build \
          -DCMAKE_C_COMPILER=clang \
          -DCMAKE_EXPORT_COMPILE_COMMANDS=ON

    # 1. clang-tidy
    - name: Analyse clang-tidy
      continue-on-error: true
      run: |
        echo "=== clang-tidy Analysis ==="
        clang-tidy-15 -p build src/*.c 2>&1 | tee clang-tidy-report.txt

    # 2. cppcheck
    - name: Analyse cppcheck
      continue-on-error: true
      run: |
        echo "=== cppcheck Analysis ==="
        cppcheck \
          --enable=all \
          --inconclusive \
          --std=c17 \
          --suppress=missingIncludeSystem \
          --template='[{file}:{line}] ({severity}) {id}: {message}' \
          src/ 2>&1 | tee cppcheck-report.txt

    # 3. scan-build
    - name: Analyse scan-build
      continue-on-error: true
      run: |
        echo "=== Clang Static Analyzer ==="
        scan-build --status-bugs cmake --build build 2>&1 | tee scan-build-report.txt

    # 4. Complexit√©
    - name: Analyse de complexit√©
      run: |
        echo "=== Code Complexity Analysis ==="
        lizard src/ -l c --CCN 15 --arguments 5 | tee complexity-report.txt

    # 5. R√©sum√©
    - name: G√©n√©rer le r√©sum√©
      if: always()
      run: |
        echo "# üìä R√©sum√© de l'analyse statique" > summary.md
        echo "" >> summary.md

        echo "## clang-tidy" >> summary.md
        if [ -f clang-tidy-report.txt ]; then
          WARNINGS=$(grep -c "warning:" clang-tidy-report.txt || echo "0")
          ERRORS=$(grep -c "error:" clang-tidy-report.txt || echo "0")
          echo "- Warnings: $WARNINGS" >> summary.md
          echo "- Errors: $ERRORS" >> summary.md
        fi
        echo "" >> summary.md

        echo "## cppcheck" >> summary.md
        if [ -f cppcheck-report.txt ]; then
          ISSUES=$(grep -c "(" cppcheck-report.txt || echo "0")
          echo "- Issues trouv√©s: $ISSUES" >> summary.md
        fi
        echo "" >> summary.md

        echo "## Complexit√©" >> summary.md
        cat complexity-report.txt | tail -5 >> summary.md

        cat summary.md

    # 6. V√©rifier les erreurs critiques
    - name: V√©rifier les erreurs
      run: |
        CRITICAL=0

        if grep -q "error:" clang-tidy-report.txt; then
          echo "‚ùå Erreurs critiques dans clang-tidy"
          CRITICAL=1
        fi

        if grep -q "\[error\]" cppcheck-report.txt; then
          echo "‚ùå Erreurs critiques dans cppcheck"
          CRITICAL=1
        fi

        if [ $CRITICAL -eq 1 ]; then
          echo ""
          echo "‚ö†Ô∏è  Des erreurs critiques ont √©t√© d√©tect√©es."
          echo "    Consultez les rapports pour plus de d√©tails."
          exit 1
        else
          echo "‚úÖ Aucune erreur critique d√©tect√©e"
        fi

    # 7. Upload des rapports
    - name: Uploader tous les rapports
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: static-analysis-reports
        path: |
          clang-tidy-report.txt
          cppcheck-report.txt
          scan-build-report.txt
          complexity-report.txt
          summary.md
        retention-days: 30

    # 8. Commenter la PR
    - name: Commenter la PR avec le r√©sum√©
      if: github.event_name == 'pull_request' && always()
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const summary = fs.readFileSync('summary.md', 'utf8');
          github.rest.issues.createComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
            body: summary
          })
```

---

## Bonnes pratiques

### 1. Commencer progressivement

```yaml
# Premi√®re √©tape : mode informatif seulement
- name: clang-tidy (info only)
  continue-on-error: true
  run: clang-tidy -p build src/*.c

# Apr√®s quelques semaines : mode strict
- name: clang-tidy (strict)
  run: clang-tidy -p build src/*.c
```

### 2. Configurer les r√®gles selon le projet

Adaptez `.clang-tidy` √† votre contexte :

```yaml
# Projet embarqu√© : focus performance
Checks: performance-*, bugprone-*

# Projet s√©curit√© : focus CERT
Checks: cert-*, clang-analyzer-security-*

# Projet legacy : v√©rifications minimales
Checks: bugprone-*, clang-analyzer-*
```

### 3. Utiliser compile_commands.json

```cmake
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
```

√âvite les faux positifs li√©s aux includes manquants.

### 4. Ex√©cuter localement avant le push

```bash
# Pre-commit check
clang-tidy -p build src/*.c && git commit
```

### 5. Ne pas viser la perfection imm√©diatement

Commencez avec quelques v√©rifications, augmentez progressivement.

### 6. Documenter les suppressions

```c
// NOLINT: Legacy code, refactoring planifi√© pour v2.0
int old_function(void) { ... }
```

### 7. Automatiser compl√®tement

L'analyse statique doit tourner **√† chaque push**, pas manuellement.

---

## Erreurs courantes et solutions

### Erreur : "compile_commands.json not found"

**Solution :**
```yaml
- name: G√©n√©rer compile_commands.json
  run: cmake -B build -DCMAKE_EXPORT_COMPILE_COMMANDS=ON
```

### Erreur : Trop de faux positifs

**Solutions :**
1. Affiner les r√®gles dans `.clang-tidy`
2. Utiliser des suppressions cibl√©es
3. V√©rifier que compile_commands.json est correct

### Erreur : "clang-tidy: command not found"

**Solution :**
```yaml
- name: Installer clang-tidy
  run: sudo apt-get install -y clang-tidy
```

### Analyse trop lente

**Solutions :**
1. Limiter aux fichiers modifi√©s :
   ```bash
   git diff --name-only origin/main | grep '\.c$' | xargs clang-tidy -p build
   ```
2. Ex√©cuter en nocturne pour analyse compl√®te
3. Parall√©liser avec `run-clang-tidy`

---

## Comparaison des outils

| Crit√®re | clang-tidy | cppcheck | scan-build |
|---------|------------|----------|------------|
| **Vitesse** | Moyenne | Rapide | Lente |
| **Pr√©cision** | Excellente | Bonne | Excellente |
| **Faux positifs** | Peu | Mod√©r√©s | Peu |
| **Configuration** | Flexible | Simple | Limit√©e |
| **Fixes automatiques** | ‚úÖ Oui | ‚ùå Non | ‚ùå Non |
| **CI quotidienne** | ‚úÖ | ‚úÖ | ‚ö†Ô∏è |
| **Analyse profonde** | ‚ö†Ô∏è | ‚ùå | ‚úÖ |

**Recommandation :**
- **CI quotidienne** : clang-tidy + cppcheck
- **Analyse hebdomadaire** : scan-build
- **Analyse de s√©curit√©** : clang-tidy (cert-*)

---

## M√©triques de qualit√©

### Objectifs raisonnables

| M√©trique | Objectif | Excellent |
|----------|----------|-----------|
| Warnings clang-tidy | < 10 | 0 |
| Erreurs cppcheck | 0 | 0 |
| Complexit√© cyclomatique | < 15 | < 10 |
| Longueur de fonction | < 100 lignes | < 50 lignes |
| Param√®tres de fonction | ‚â§ 5 | ‚â§ 3 |

### Suivre l'√©volution

```yaml
- name: Comparer avec la branche main
  run: |
    git checkout main
    clang-tidy -p build src/*.c 2>&1 | grep -c "warning:" > main_warnings.txt

    git checkout ${{ github.sha }}
    clang-tidy -p build src/*.c 2>&1 | grep -c "warning:" > pr_warnings.txt

    MAIN=$(cat main_warnings.txt)
    PR=$(cat pr_warnings.txt)

    if [ $PR -gt $MAIN ]; then
      echo "‚ö†Ô∏è Nouvelles warnings introduites : $((PR - MAIN))"
    else
      echo "‚úÖ Pas de nouvelles warnings"
    fi
```

---

## R√©sum√©

**L'analyse statique trouve des bugs avant l'ex√©cution du code.**

**Outils essentiels :**
- **clang-tidy** : Analyse compl√®te, moderne, recommand√©
- **cppcheck** : Rapide, ind√©pendant du compilateur
- **scan-build** : Analyse profonde pour investigations

**Configuration minimale :**

1. Cr√©er `.clang-tidy` avec les r√®gles
2. G√©n√©rer `compile_commands.json` avec CMake
3. Lancer `clang-tidy -p build src/*.c`
4. Int√©grer dans le workflow CI

**Workflow typique :**

```yaml
- cmake -B build -DCMAKE_EXPORT_COMPILE_COMMANDS=ON
- cmake --build build
- clang-tidy -p build src/*.c
```

**Bonnes pratiques :**
- Commencer progressivement
- Configurer selon votre contexte
- Automatiser compl√®tement
- Documenter les suppressions

---

## Prochaines √©tapes

Maintenant que vous avez l'analyse statique, vous pouvez :

- Publier des **artifacts de build**
- Configurer des **releases automatiques**
- Cr√©er des **rapports de tests** consolid√©s
- Mettre en place des **notifications**

Ces sujets sont couverts dans les sections suivantes.

---

## Ressources compl√©mentaires

- [clang-tidy Documentation](https://clang.llvm.org/extra/clang-tidy/)
- [cppcheck Manual](https://cppcheck.sourceforge.io/manual.html)
- [Clang Static Analyzer](https://clang-analyzer.llvm.org/)
- [CERT C Coding Standard](https://wiki.sei.cmu.edu/confluence/display/c/SEI+CERT+C+Coding+Standard)

---

**üéØ Points cl√©s √† retenir :**

- ‚úÖ L'analyse statique d√©tecte les bugs sans ex√©cuter le code
- ‚úÖ clang-tidy est l'outil le plus complet et moderne
- ‚úÖ G√©n√©rer compile_commands.json avec CMake
- ‚úÖ Configurer les r√®gles dans `.clang-tidy`
- ‚úÖ Commencer avec peu de r√®gles, augmenter progressivement
- ‚úÖ Combiner plusieurs outils pour une couverture maximale
- ‚úÖ Automatiser dans le CI √† chaque commit
- ‚úÖ L'analyse statique compl√®te les tests dynamiques (sanitizers, Valgrind)

‚è≠Ô∏è [Publication d'artifacts](/30-integration-continue/01.9-publication-artifacts.md)
