üîù Retour au [Sommaire](/SOMMAIRE.md)

# 18.10.4 Compare-and-swap (CAS)

## Introduction

**Compare-and-swap** (CAS), √©galement appel√© **compare-and-exchange**, est l'une des op√©rations atomiques les plus puissantes et fondamentales de la programmation concurrente. C'est la pierre angulaire de nombreux algorithmes lock-free sophistiqu√©s.

Dans cette section, nous allons comprendre ce qu'est CAS, comment il fonctionne, et surtout comment l'utiliser efficacement.

---

## Qu'est-ce que Compare-and-Swap ?

### D√©finition simple

Compare-and-swap est une op√©ration atomique qui fait trois choses en **une seule instruction indivisible** :

1. **Compare** : Compare la valeur actuelle d'une variable avec une valeur attendue
2. **Swap** : Si elles sont √©gales, remplace la valeur par une nouvelle valeur
3. **Retourne** : Indique si l'op√©ration a r√©ussi ou non

### Pseudo-code non-atomique

Voici ce que CAS ferait s'il n'√©tait PAS atomique (ne faites JAMAIS √ßa dans du code r√©el multi-thread√© !) :

```c
bool compare_and_swap(int* variable, int attendu, int nouveau) {
    if (*variable == attendu) {
        *variable = nouveau;
        return true;  // Succ√®s
    }
    return false;  // √âchec
}
```

**Probl√®me** : Ce code n'est PAS thread-safe ! Un autre thread pourrait modifier `*variable` entre la comparaison et l'assignation.

**Solution** : La version atomique garantit que ces trois √©tapes sont **indivisibles**.

---

## CAS en C11 : atomic_compare_exchange

C11 fournit deux fonctions CAS :

### 1. atomic_compare_exchange_strong

La version "forte" qui ne fait jamais d'√©checs parasites (spurious failures).

```c
bool atomic_compare_exchange_strong(
    atomic_type* obj,           // Variable atomique
    type* expected,             // Valeur attendue (sera mise √† jour en cas d'√©chec)
    type desired                // Nouvelle valeur souhait√©e
);
```

### 2. atomic_compare_exchange_weak

La version "faible" qui peut √©chouer m√™me si la valeur correspond (utile dans les boucles).

```c
bool atomic_compare_exchange_weak(
    atomic_type* obj,
    type* expected,
    type desired
);
```

### Comportement d√©taill√©

```c
#include <stdatomic.h>

atomic_int variable = 10;
int attendu = 10;
int nouveau = 42;

// Appel CAS
bool succes = atomic_compare_exchange_strong(&variable, &attendu, nouveau);

// Cas 1 : variable == attendu (10 == 10)
// ‚Üí variable devient 42
// ‚Üí attendu reste 10
// ‚Üí retourne true

// Cas 2 : variable != attendu (ex: variable vaut 20)
// ‚Üí variable reste inchang√©e (20)
// ‚Üí attendu est MIS √Ä JOUR avec la valeur actuelle (20)
// ‚Üí retourne false
```

**Point crucial** : En cas d'√©chec, `expected` est mis √† jour avec la valeur r√©elle actuelle !

---

## Premier exemple simple : Incr√©ment atomique

### Impl√©mentation na√Øve (√† des fins p√©dagogiques)

Voici comment on pourrait impl√©menter un incr√©ment avec CAS :

```c
#include <stdio.h>
#include <stdatomic.h>

void incrementer_cas(atomic_int* variable) {
    int ancienne_valeur = atomic_load(variable);
    int nouvelle_valeur;

    do {
        nouvelle_valeur = ancienne_valeur + 1;
    } while (!atomic_compare_exchange_weak(
        variable,
        &ancienne_valeur,  // Mis √† jour en cas d'√©chec
        nouvelle_valeur
    ));
}

int main(void) {
    atomic_int compteur = 0;

    incrementer_cas(&compteur);
    printf("Compteur : %d\n", atomic_load(&compteur));  // Affiche 1

    incrementer_cas(&compteur);
    printf("Compteur : %d\n", atomic_load(&compteur));  // Affiche 2

    return 0;
}
```

### Explication du m√©canisme

1. **Premier essai** :
   - `ancienne_valeur = 0`
   - `nouvelle_valeur = 1`
   - CAS v√©rifie si `compteur == 0` ‚Üí OUI
   - `compteur` devient `1`
   - Retourne `true`, on sort de la boucle

2. **Si un autre thread modifie entre-temps** :
   - `ancienne_valeur = 0`
   - Avant le CAS, un autre thread change `compteur` √† `5`
   - CAS v√©rifie si `compteur == 0` ‚Üí NON (c'est 5)
   - `ancienne_valeur` est mis √† jour √† `5`
   - Retourne `false`, on reboucle
   - `nouvelle_valeur = 5 + 1 = 6`
   - CAS r√©ussit cette fois

**Note** : En pratique, utilisez simplement `atomic_fetch_add` qui est optimis√©, mais cet exemple montre le principe de CAS.

---

## Strong vs Weak : Quand utiliser quoi ?

### atomic_compare_exchange_strong

```c
atomic_int x = 5;
int attendu = 5;

// Essai unique, pas de boucle
if (atomic_compare_exchange_strong(&x, &attendu, 10)) {
    printf("Succ√®s : x est maintenant 10\n");
} else {
    printf("√âchec : x vaut toujours %d, attendu √©tait %d\n", x, attendu);
}
```

**Caract√©ristiques** :
- ‚úÖ Ne peut √©chouer QUE si les valeurs diff√®rent r√©ellement
- ‚úÖ Id√©al pour un seul essai (sans boucle)
- ‚ö†Ô∏è L√©g√®rement plus lent sur certaines architectures (ARM)

### atomic_compare_exchange_weak

```c
atomic_int x = 5;
int attendu = 5;

// Dans une boucle
do {
    int nouveau = attendu + 1;
} while (!atomic_compare_exchange_weak(&x, &attendu, nouveau));
```

**Caract√©ristiques** :
- ‚ö†Ô∏è Peut √©chouer m√™me si les valeurs correspondent (spurious failure)
- ‚úÖ Plus rapide dans les boucles
- ‚úÖ Recommand√© pour les algorithmes en boucle

### R√®gle de choix

```
Utilisez-vous CAS dans une boucle ?
‚îÇ
‚îú‚îÄ OUI ‚Üí atomic_compare_exchange_weak
‚îÇ        (plus performant, les √©checs parasites ne posent pas de probl√®me)
‚îÇ
‚îî‚îÄ NON ‚Üí atomic_compare_exchange_strong
         (garantit qu'un √©chec signifie vraiment que les valeurs diff√®rent)
```

---

## Exemple concret : Stack lock-free

### Structure de donn√©es

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdatomic.h>
#include <pthread.h>

typedef struct node {
    int data;
    struct node* next;
} node_t;

typedef struct {
    _Atomic(node_t*) head;
} stack_t;

void stack_init(stack_t* stack) {
    atomic_store(&stack->head, NULL);
}
```

### Push : Ajouter un √©l√©ment

```c
void stack_push(stack_t* stack, int value) {
    // Cr√©er un nouveau n≈ìud
    node_t* new_node = malloc(sizeof(node_t));
    new_node->data = value;

    // Obtenir la t√™te actuelle
    node_t* old_head = atomic_load(&stack->head);

    do {
        // Le nouveau n≈ìud pointe vers l'ancienne t√™te
        new_node->next = old_head;

        // Essayer de remplacer la t√™te
        // Si un autre thread l'a modifi√©e, old_head sera mis √† jour
    } while (!atomic_compare_exchange_weak(&stack->head, &old_head, new_node));

    printf("Pushed %d\n", value);
}
```

**Comment √ßa marche** :

1. On cr√©e un nouveau n≈ìud avec la valeur
2. On lit la t√™te actuelle de la stack
3. On fait pointer le nouveau n≈ìud vers cette t√™te
4. On essaie de remplacer la t√™te par le nouveau n≈ìud avec CAS
5. Si un autre thread a modifi√© la t√™te entre-temps :
   - CAS √©choue
   - `old_head` est mis √† jour avec la nouvelle t√™te
   - On reboucle avec cette nouvelle valeur

### Pop : Retirer un √©l√©ment

```c
bool stack_pop(stack_t* stack, int* result) {
    node_t* old_head = atomic_load(&stack->head);
    node_t* new_head;

    do {
        // Stack vide ?
        if (old_head == NULL) {
            return false;
        }

        // La nouvelle t√™te sera le deuxi√®me √©l√©ment
        new_head = old_head->next;

        // Essayer de remplacer la t√™te
    } while (!atomic_compare_exchange_weak(&stack->head, &old_head, new_head));

    // Succ√®s : r√©cup√©rer la valeur et lib√©rer le n≈ìud
    *result = old_head->data;
    printf("Popped %d\n", *result);
    free(old_head);

    return true;
}
```

### Utilisation multi-thread√©e

```c
void* producer(void* arg) {
    stack_t* stack = (stack_t*)arg;

    for (int i = 0; i < 5; i++) {
        stack_push(stack, i * 10);
    }

    return NULL;
}

void* consumer(void* arg) {
    stack_t* stack = (stack_t*)arg;
    int value;

    for (int i = 0; i < 5; i++) {
        while (!stack_pop(stack, &value)) {
            // Attendre qu'il y ait des √©l√©ments
        }
    }

    return NULL;
}

int main(void) {
    stack_t stack;
    stack_init(&stack);

    pthread_t prod, cons;

    pthread_create(&prod, NULL, producer, &stack);
    pthread_create(&cons, NULL, consumer, &stack);

    pthread_join(prod, NULL);
    pthread_join(cons, NULL);

    return 0;
}
```

**Avantage** : Aucun mutex ! Plusieurs threads peuvent push/pop en m√™me temps sans se bloquer.

---

## Patterns courants avec CAS

### Pattern 1 : Modification conditionnelle

```c
// Incr√©menter seulement si < 100
atomic_int compteur = 0;

void incrementer_si_possible(void) {
    int ancienne_valeur = atomic_load(&compteur);
    int nouvelle_valeur;

    do {
        // Condition : ne pas d√©passer 100
        if (ancienne_valeur >= 100) {
            printf("Limite atteinte, pas d'incr√©mentation\n");
            return;
        }

        nouvelle_valeur = ancienne_valeur + 1;
    } while (!atomic_compare_exchange_weak(&compteur, &ancienne_valeur, nouvelle_valeur));

    printf("Incr√©ment√© √† %d\n", nouvelle_valeur);
}
```

### Pattern 2 : Retry avec backoff

Pour √©viter la contention excessive :

```c
#include <unistd.h>

void operation_avec_backoff(atomic_int* variable, int nouvelle_valeur) {
    int ancienne_valeur = atomic_load(variable);
    int tentatives = 0;

    while (!atomic_compare_exchange_weak(variable, &ancienne_valeur, nouvelle_valeur)) {
        tentatives++;

        // Backoff exponentiel
        if (tentatives > 10) {
            usleep(1 << (tentatives - 10));  // 1¬µs, 2¬µs, 4¬µs...
        }

        if (tentatives > 1000) {
            printf("Trop de contention, abandon\n");
            break;
        }
    }
}
```

### Pattern 3 : ABA Problem - Solution partielle

Le probl√®me ABA survient quand :
1. Thread 1 lit la valeur A
2. Thread 2 change A en B puis remet B en A
3. Thread 1 pense que rien n'a chang√© !

**Solution avec compteur de version** :

```c
typedef struct {
    int value;
    unsigned int version;
} versioned_int_t;

_Atomic(versioned_int_t) data = { .value = 0, .version = 0 };

void set_value_safe(int nouveau) {
    versioned_int_t ancien = atomic_load(&data);
    versioned_int_t nouv;

    do {
        nouv.value = nouveau;
        nouv.version = ancien.version + 1;  // Incr√©menter la version
    } while (!atomic_compare_exchange_weak(&data, &ancien, nouv));
}
```

**Note** : Cette solution n√©cessite que la structure soit petite (g√©n√©ralement ‚â§ 16 octets).

---

## CAS avec memory ordering

CAS supporte aussi les memory orders pour contr√¥ler la synchronisation :

```c
bool atomic_compare_exchange_strong_explicit(
    atomic_type* obj,
    type* expected,
    type desired,
    memory_order success,  // Memory order si succ√®s
    memory_order failure   // Memory order si √©chec
);
```

### Exemple avec acquire/release

```c
atomic_int flag = 0;
int data = 0;

// Thread producteur
void publier_donnee(void) {
    data = 42;

    int attendu = 0;
    // Release si succ√®s : publie data
    atomic_compare_exchange_strong_explicit(
        &flag,
        &attendu,
        1,
        memory_order_release,  // Succ√®s
        memory_order_relaxed   // √âchec
    );
}

// Thread consommateur
void lire_donnee(void) {
    int attendu = 1;

    // Acquire si succ√®s : acquiert data
    if (atomic_compare_exchange_strong_explicit(
            &flag,
            &attendu,
            2,
            memory_order_acquire,  // Succ√®s
            memory_order_relaxed   // √âchec
        )) {
        printf("Donn√©e : %d\n", data);  // Garanti de voir 42
    }
}
```

### R√®gles pour les memory orders

- Le `success` order doit √™tre au moins aussi fort que `failure`
- `failure` ne peut PAS √™tre `release` ou `acq_rel` (car on ne modifie rien)
- Par d√©faut : `seq_cst` pour les deux

**Combinaisons courantes** :

```c
// Dans une boucle avec donn√©es partag√©es
atomic_compare_exchange_weak_explicit(
    &var, &expected, desired,
    memory_order_acq_rel,    // Succ√®s : acquire + release
    memory_order_acquire     // √âchec : juste acquire pour relire
);

// Compteur simple sans autres donn√©es
atomic_compare_exchange_weak_explicit(
    &compteur, &old, new,
    memory_order_relaxed,    // Succ√®s : pas de synchronisation
    memory_order_relaxed     // √âchec : pas de synchronisation
);
```

---

## Avantages et limitations de CAS

### ‚úÖ Avantages

1. **Lock-free** : Pas de deadlock possible
2. **Scalabilit√©** : Plusieurs threads peuvent progresser simultan√©ment
3. **Performance** : Souvent plus rapide que les mutex pour les op√©rations simples
4. **Atomicit√© garantie** : Op√©ration indivisible au niveau mat√©riel
5. **Flexibilit√©** : Permet d'impl√©menter des algorithmes complexes

### ‚ùå Limitations

1. **ABA problem** : N√©cessite des solutions (version counter, hazard pointers)
2. **Contention** : Performance d√©grad√©e sous forte contention
3. **Complexit√©** : Difficile √† impl√©menter correctement
4. **Taille limit√©e** : G√©n√©ralement limit√© √† 8-16 octets (d√©pend du CPU)
5. **Spurious failures** : La version weak peut √©chouer sans raison (dans les boucles)
6. **Debugging difficile** : Les bugs sont non-d√©terministes

---

## Cas d'usage r√©els

### 1. Compteur de r√©f√©rences

```c
typedef struct {
    void* data;
    atomic_int refcount;
} shared_ptr_t;

void increment_ref(shared_ptr_t* ptr) {
    // Simple fetch_add, mais montrons avec CAS pour l'exemple
    int old_count = atomic_load(&ptr->refcount);

    do {
        // Ne pas incr√©menter si d√©j√† √† 0 (objet en cours de destruction)
        if (old_count == 0) {
            return;
        }
    } while (!atomic_compare_exchange_weak(&ptr->refcount, &old_count, old_count + 1));
}
```

### 2. Lock-free queue (simplifi√©)

```c
typedef struct qnode {
    int data;
    _Atomic(struct qnode*) next;
} qnode_t;

typedef struct {
    _Atomic(qnode_t*) head;
    _Atomic(qnode_t*) tail;
} queue_t;

void enqueue(queue_t* q, int value) {
    qnode_t* node = malloc(sizeof(qnode_t));
    node->data = value;
    atomic_store(&node->next, NULL);

    qnode_t* tail;
    qnode_t* next;

    while (1) {
        tail = atomic_load(&q->tail);
        next = atomic_load(&tail->next);

        // V√©rifier que tail n'a pas chang√©
        if (tail == atomic_load(&q->tail)) {
            if (next == NULL) {
                // Essayer d'ajouter le n≈ìud
                if (atomic_compare_exchange_weak(&tail->next, &next, node)) {
                    // Succ√®s, maintenant d√©placer tail
                    atomic_compare_exchange_weak(&q->tail, &tail, node);
                    return;
                }
            } else {
                // Aider √† d√©placer tail
                atomic_compare_exchange_weak(&q->tail, &tail, next);
            }
        }
    }
}
```

### 3. Spinlock avec CAS

```c
typedef struct {
    atomic_int locked;
} spinlock_t;

void spinlock_init(spinlock_t* lock) {
    atomic_store(&lock->locked, 0);
}

void spinlock_lock(spinlock_t* lock) {
    int expected;

    do {
        expected = 0;  // On attend que le lock soit libre

        // Essayer de passer de 0 (libre) √† 1 (verrouill√©)
    } while (!atomic_compare_exchange_weak(&lock->locked, &expected, 1));
}

void spinlock_unlock(spinlock_t* lock) {
    atomic_store(&lock->locked, 0);
}
```

---

## Comparaison : CAS vs Autres m√©thodes

| M√©thode | Overhead | Scalabilit√© | Complexit√© | Lock-free |
|---------|----------|-------------|------------|-----------|
| **CAS** | Faible | Excellente | √âlev√©e | ‚úÖ Oui |
| **fetch_add** | Tr√®s faible | Excellente | Faible | ‚úÖ Oui |
| **Mutex** | Moyen | Moyenne | Faible | ‚ùå Non |
| **Spinlock** | Faible-Moyen | Variable | Faible | ‚ö†Ô∏è Busy-wait |

### Quand utiliser CAS ?

**‚úÖ Utilisez CAS quand** :
- Vous devez modifier une valeur conditionnellement
- Vous construisez une structure de donn√©es lock-free
- La contention est faible √† mod√©r√©e
- Vous avez besoin de garanties lock-free

**‚ùå N'utilisez PAS CAS quand** :
- Une simple op√©ration atomique (`fetch_add`, etc.) suffit
- Vous prot√©gez une section critique complexe (utilisez un mutex)
- La contention est tr√®s √©lev√©e
- Le code devient incompr√©hensible

---

## Debugging et tests

### D√©tecter les probl√®mes

```bash
# Compiler avec ThreadSanitizer
gcc -fsanitize=thread -g -O1 mon_code.c -lpthread -o mon_code

# Ex√©cuter
./mon_code
```

ThreadSanitizer d√©tecte :
- Data races
- Probl√®mes d'ordre m√©moire
- Acc√®s apr√®s lib√©ration

### Tests de stress

```c
#include <time.h>

void test_contention(void) {
    atomic_int counter = 0;
    pthread_t threads[100];

    clock_t start = clock();

    // Cr√©er 100 threads qui incr√©mentent 10000 fois
    for (int i = 0; i < 100; i++) {
        pthread_create(&threads[i], NULL, incrementer_thread, &counter);
    }

    for (int i = 0; i < 100; i++) {
        pthread_join(threads[i], NULL);
    }

    clock_t end = clock();

    printf("Valeur finale : %d (attendu : 1000000)\n", atomic_load(&counter));
    printf("Temps : %.3f secondes\n", (double)(end - start) / CLOCKS_PER_SEC);
}
```

---

## Pi√®ges courants

### ‚ùå Pi√®ge 1 : Oublier la boucle

```c
// ‚ö†Ô∏è FAUX : CAS peut √©chouer !
atomic_int x = 10;
int expected = 10;
atomic_compare_exchange_strong(&x, &expected, 20);
// Que se passe-t-il si un autre thread a modifi√© x ?
```

**Correct** :
```c
do {
    expected = atomic_load(&x);
    // ... calculer nouvelle valeur ...
} while (!atomic_compare_exchange_weak(&x, &expected, nouvelle_valeur));
```

### ‚ùå Pi√®ge 2 : Ne pas v√©rifier la valeur retourn√©e

```c
// ‚ö†Ô∏è FAUX : on ignore le r√©sultat
atomic_compare_exchange_strong(&x, &expected, desired);
// A-t-on r√©ussi ? On ne sait pas !
```

**Correct** :
```c
if (atomic_compare_exchange_strong(&x, &expected, desired)) {
    printf("Succ√®s !\n");
} else {
    printf("√âchec, valeur actuelle : %d\n", expected);
}
```

### ‚ùå Pi√®ge 3 : Assumer que `expected` reste inchang√©

```c
// ‚ö†Ô∏è FAUX : expected est modifi√© en cas d'√©chec !
int expected = 10;
atomic_compare_exchange_strong(&x, &expected, 20);
printf("Expected vaut toujours 10\n");  // ‚ùå FAUX si √©chec !
```

### ‚ùå Pi√®ge 4 : ABA problem non g√©r√©

```c
// Sc√©nario ABA probl√©matique
node_t* head = atomic_load(&list->head);
// ... Un autre thread enl√®ve head et le remet ...
atomic_compare_exchange_strong(&list->head, &head, head->next);
// CAS r√©ussit mais head a √©t√© r√©utilis√© entre-temps !
```

---

## Performance : CAS vs Mutex

### Benchmark simple

```c
#include <time.h>

// Avec CAS
void bench_cas(void) {
    atomic_int counter = 0;
    clock_t start = clock();

    for (int i = 0; i < 1000000; i++) {
        int expected = atomic_load(&counter);
        while (!atomic_compare_exchange_weak(&counter, &expected, expected + 1));
    }

    printf("CAS: %.3f secondes\n", (double)(clock() - start) / CLOCKS_PER_SEC);
}

// Avec mutex
void bench_mutex(void) {
    int counter = 0;
    pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
    clock_t start = clock();

    for (int i = 0; i < 1000000; i++) {
        pthread_mutex_lock(&lock);
        counter++;
        pthread_mutex_unlock(&lock);
    }

    printf("Mutex: %.3f secondes\n", (double)(clock() - start) / CLOCKS_PER_SEC);
}
```

**R√©sultats typiques (1 thread)** :
- CAS : 0.02-0.05 secondes
- Mutex : 0.1-0.3 secondes

**Avec contention (4 threads)** :
- CAS : Performance d√©grad√©e mais toujours meilleure
- Mutex : Performance stable mais plus lente

---

## R√©sum√©

### Points cl√©s

1. **CAS = Compare-and-Swap** : Op√©ration atomique qui compare et modifie conditionnellement
2. **Deux versions** : `strong` (garantie) et `weak` (peut √©chouer dans les boucles)
3. **Base des algorithmes lock-free** : Stack, queue, compteurs, etc.
4. **N√©cessite des boucles** : Car CAS peut √©chouer si la valeur a chang√©
5. **Plus performant que mutex** : Pour les op√©rations simples
6. **Complexe √† utiliser correctement** : ABA problem, contention, debugging difficile

### Quand utiliser CAS ?

```
Besoin de modification conditionnelle ?
‚îÇ
‚îú‚îÄ Simple incr√©ment/d√©cr√©ment ?
‚îÇ  ‚îî‚îÄ Utilisez atomic_fetch_add/sub (plus simple que CAS)
‚îÇ
‚îú‚îÄ Condition sur la valeur ?
‚îÇ  ‚îî‚îÄ CAS est appropri√©
‚îÇ
‚îú‚îÄ Structure de donn√©es complexe ?
‚îÇ  ‚îî‚îÄ CAS pour lock-free OU mutex pour simplicit√©
‚îÇ
‚îî‚îÄ Section critique multi-variables ?
   ‚îî‚îÄ Utilisez un mutex (pas CAS)
```

### Hi√©rarchie de difficult√©

```
Facile              Moyen                Difficile
  |                   |                      |
fetch_add/sub      CAS simple         Structures lock-free
(recommand√©)    (parfois utile)      (experts uniquement)
```

### Dans la section suivante

**18.10.5 Atomics vs mutex** : Nous comparerons en d√©tail les atomiques et les mutex, pour savoir quand utiliser l'un ou l'autre.

---

## Ressources compl√©mentaires

### Lectures essentielles

- **"The Art of Multiprocessor Programming"** - Herlihy & Shavit (chapitre sur CAS)
- **"Lock-Free Programming"** - Jeff Preshing's blog
- **"CppReference - atomic_compare_exchange"** - Documentation compl√®te

### Impl√©mentations r√©elles √† √©tudier

- **Linux Kernel** : CAS utilis√© partout (spinlocks, RCU)
- **jemalloc** : Allocateur m√©moire avec structures lock-free
- **Folly (Facebook)** : Biblioth√®que C++ avec structures atomiques

### Outils

- **ThreadSanitizer** : Indispensable pour d√©tecter les races
- **Helgrind (Valgrind)** : Alternative √† TSan
- **rr** : Record and Replay debugger

---

**üí° Conseil pratique** : CAS est puissant mais complexe. Commencez par ma√Ætriser les op√©rations atomiques simples (`fetch_add`, `load`, `store`) avant d'utiliser CAS. Utilisez CAS uniquement quand vous avez une condition sp√©cifique √† v√©rifier avant la modification.

**‚ö†Ô∏è Avertissement** : Les structures de donn√©es lock-free avec CAS sont extr√™mement difficiles √† impl√©menter correctement. M√™me les experts font des erreurs. Privil√©giez les biblioth√®ques √©prouv√©es ou des mutex avant de r√©inventer la roue.

**üéØ R√®gle d'or** : Si vous pouvez utiliser `atomic_fetch_add` au lieu de CAS, faites-le. CAS n'est n√©cessaire que pour des modifications **conditionnelles** bas√©es sur la valeur actuelle.

‚è≠Ô∏è [Atomics vs mutex](/18-threads-et-concurrence/10.5-atomics-vs-mutex.md)
