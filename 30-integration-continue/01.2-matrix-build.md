üîù Retour au [Sommaire](/SOMMAIRE.md)

# 30.1.2 Matrix build

## Introduction

Les **matrix builds** (ou builds matriciels) sont une fonctionnalit√© puissante de GitHub Actions qui permet de tester automatiquement votre code C sur **plusieurs configurations diff√©rentes** en une seule fois. C'est comme lancer plusieurs builds en parall√®le avec des param√®tres diff√©rents.

Imaginez que vous voulez tester votre programme C sur :
- Plusieurs versions de GCC (gcc 9, 10, 11, 12)
- Plusieurs syst√®mes d'exploitation (Ubuntu, macOS, Windows)
- Plusieurs niveaux d'optimisation (-O0, -O2, -O3)

Sans matrix builds, vous devriez cr√©er un job s√©par√© pour chaque combinaison. Avec les matrices, GitHub Actions g√©n√®re automatiquement tous les jobs n√©cessaires !

---

## Pourquoi utiliser les matrix builds en C ?

### Avantages pour les projets C

1. **Compatibilit√© multi-compilateurs** : V√©rifier que votre code compile avec diff√©rentes versions de GCC ou Clang

2. **Portabilit√© multi-plateformes** : S'assurer que votre code fonctionne sur Linux, macOS et Windows

3. **D√©tection pr√©coce de bugs** : Certains bugs n'apparaissent qu'avec des versions sp√©cifiques du compilateur ou des flags d'optimisation

4. **Validation des standards** : Tester avec diff√©rentes versions du standard C (C99, C11, C17, C23)

5. **Gain de temps** : Tous les tests s'ex√©cutent en parall√®le au lieu de s√©quentiellement

---

## Syntaxe de base d'une matrice

Voici la structure minimale d'un matrix build :

```yaml
jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        gcc-version: [9, 10, 11, 12]

    steps:
    - uses: actions/checkout@v4

    - name: Installer GCC ${{ matrix.gcc-version }}
      run: |
        sudo apt-get update
        sudo apt-get install -y gcc-${{ matrix.gcc-version }}

    - name: Compiler
      run: gcc-${{ matrix.gcc-version }} -o app main.c
```

### Explications

- `strategy:` : Section qui d√©finit la strat√©gie d'ex√©cution
- `matrix:` : D√©claration de la matrice
- `gcc-version: [9, 10, 11, 12]` : Variable de matrice avec 4 valeurs
- `${{ matrix.gcc-version }}` : R√©f√©rence √† la valeur actuelle de la matrice

**R√©sultat** : GitHub Actions va cr√©er **4 jobs** automatiquement, un pour chaque version de GCC !

---

## Exemple 1 : Tester plusieurs versions de compilateur

```yaml
name: CI Multi-compilateurs

on: [push, pull_request]

jobs:
  build:
    name: Build avec GCC ${{ matrix.gcc }}
    runs-on: ubuntu-latest

    strategy:
      matrix:
        gcc: [9, 10, 11, 12, 13]

    steps:
    - name: Checkout du code
      uses: actions/checkout@v4

    - name: Installer GCC ${{ matrix.gcc }}
      run: |
        sudo apt-get update
        sudo apt-get install -y gcc-${{ matrix.gcc }}

    - name: V√©rifier la version
      run: gcc-${{ matrix.gcc }} --version

    - name: Compiler le projet
      run: gcc-${{ matrix.gcc }} -Wall -Wextra -o app src/main.c

    - name: Ex√©cuter le programme
      run: ./app
```

**Ce que fait ce workflow :**
- Cr√©e 5 jobs en parall√®le (un par version de GCC)
- Chaque job compile et ex√©cute le programme avec sa version de GCC
- Vous verrez 5 r√©sultats dans l'interface GitHub Actions

---

## Exemple 2 : Tester sur plusieurs syst√®mes d'exploitation

```yaml
name: CI Multi-plateformes

on: [push, pull_request]

jobs:
  build:
    name: Build sur ${{ matrix.os }}
    runs-on: ${{ matrix.os }}

    strategy:
      matrix:
        os: [ubuntu-latest, ubuntu-22.04, macos-latest, windows-latest]

    steps:
    - uses: actions/checkout@v4

    - name: Compiler (Linux/macOS)
      if: runner.os != 'Windows'
      run: gcc -o app main.c

    - name: Compiler (Windows)
      if: runner.os == 'Windows'
      run: gcc -o app.exe main.c

    - name: Ex√©cuter (Linux/macOS)
      if: runner.os != 'Windows'
      run: ./app

    - name: Ex√©cuter (Windows)
      if: runner.os == 'Windows'
      run: .\app.exe
```

**Points cl√©s :**
- `runs-on: ${{ matrix.os }}` : Le runner change selon la matrice
- `if: runner.os != 'Windows'` : Ex√©cution conditionnelle selon l'OS
- Ce workflow teste votre code sur 4 plateformes diff√©rentes !

---

## Exemple 3 : Matrice multi-dimensionnelle

Vous pouvez combiner plusieurs variables dans une matrice :

```yaml
name: CI Matrice 2D

on: [push, pull_request]

jobs:
  build:
    name: ${{ matrix.os }} - GCC ${{ matrix.gcc }}
    runs-on: ${{ matrix.os }}

    strategy:
      matrix:
        os: [ubuntu-22.04, ubuntu-24.04]
        gcc: [11, 12, 13]

    steps:
    - uses: actions/checkout@v4

    - name: Installer GCC ${{ matrix.gcc }}
      run: |
        sudo apt-get update
        sudo apt-get install -y gcc-${{ matrix.gcc }}

    - name: Compiler
      run: gcc-${{ matrix.gcc }} -o app main.c

    - name: Tester
      run: ./app
```

**R√©sultat** : Cette matrice g√©n√®re **6 jobs** :
- ubuntu-22.04 avec GCC 11
- ubuntu-22.04 avec GCC 12
- ubuntu-22.04 avec GCC 13
- ubuntu-24.04 avec GCC 11
- ubuntu-24.04 avec GCC 12
- ubuntu-24.04 avec GCC 13

---

## Exemple 4 : Tester diff√©rents niveaux d'optimisation

```yaml
name: CI Optimisations

on: [push, pull_request]

jobs:
  build:
    name: Build avec ${{ matrix.optimization }}
    runs-on: ubuntu-latest

    strategy:
      matrix:
        optimization: ['-O0', '-O1', '-O2', '-O3', '-Os']

    steps:
    - uses: actions/checkout@v4

    - name: Compiler avec ${{ matrix.optimization }}
      run: |
        gcc ${{ matrix.optimization }} -o app main.c

    - name: Tester
      run: ./app

    - name: Mesurer la taille du binaire
      run: ls -lh app
```

**Pourquoi tester diff√©rents niveaux d'optimisation ?**
- `-O0` : Pas d'optimisation, utile pour le d√©bogage
- `-O1`, `-O2`, `-O3` : Niveaux croissants d'optimisation
- `-Os` : Optimisation pour la taille (important pour l'embarqu√©)
- Certains bugs n'apparaissent qu'avec certains niveaux d'optimisation !

---

## Exemple 5 : Matrice avec include/exclude

Parfois, vous voulez tester certaines combinaisons sp√©cifiques ou en exclure d'autres :

```yaml
jobs:
  build:
    runs-on: ${{ matrix.os }}

    strategy:
      matrix:
        os: [ubuntu-22.04, macos-latest]
        compiler: [gcc, clang]

        # Ajouter des combinaisons suppl√©mentaires
        include:
          - os: ubuntu-22.04
            compiler: gcc
            gcc-version: 13

          - os: windows-latest
            compiler: msvc

        # Exclure certaines combinaisons
        exclude:
          - os: macos-latest
            compiler: gcc  # GCC n'est pas recommand√© sur macOS moderne

    steps:
    - uses: actions/checkout@v4
    - name: Compiler
      run: ${{ matrix.compiler }} -o app main.c
```

**Explications :**
- `include:` ajoute des configurations sp√©cifiques √† la matrice
- `exclude:` retire des combinaisons de la matrice
- Utile pour g√©rer les incompatibilit√©s ou cas particuliers

---

## Gestion des √©checs avec fail-fast

Par d√©faut, si un job de la matrice √©choue, GitHub Actions continue d'ex√©cuter les autres jobs. Vous pouvez changer ce comportement :

```yaml
strategy:
  fail-fast: false  # Continue m√™me si un job √©choue
  matrix:
    gcc: [9, 10, 11, 12]
```

**Deux options :**

1. `fail-fast: true` (d√©faut) : Si un job √©choue, annule tous les autres jobs de la matrice
2. `fail-fast: false` : Continue tous les jobs m√™me si certains √©chouent

**Recommandation pour le C :** Utilisez `fail-fast: false` pour voir tous les √©checs en une fois.

---

## Exemple complet : Matrice r√©aliste pour projet C

Voici un exemple complet combinant plusieurs dimensions :

```yaml
name: CI Compl√®te avec Matrice

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  build-and-test:
    name: ${{ matrix.os }} - ${{ matrix.compiler }} ${{ matrix.version }}
    runs-on: ${{ matrix.os }}

    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-22.04, ubuntu-24.04]
        compiler: [gcc, clang]
        version: [11, 12, 13]
        build-type: [Debug, Release]

        exclude:
          # Clang 11 n'est plus maintenu sur Ubuntu 24.04
          - os: ubuntu-24.04
            compiler: clang
            version: 11

    steps:
    - name: Checkout du code
      uses: actions/checkout@v4

    - name: Installer le compilateur
      run: |
        sudo apt-get update
        if [ "${{ matrix.compiler }}" = "gcc" ]; then
          sudo apt-get install -y gcc-${{ matrix.version }}
          echo "CC=gcc-${{ matrix.version }}" >> $GITHUB_ENV
        else
          sudo apt-get install -y clang-${{ matrix.version }}
          echo "CC=clang-${{ matrix.version }}" >> $GITHUB_ENV
        fi

    - name: Afficher la version du compilateur
      run: $CC --version

    - name: Cr√©er le r√©pertoire build
      run: mkdir build

    - name: Configurer CMake
      run: |
        cd build
        cmake -DCMAKE_BUILD_TYPE=${{ matrix.build-type }} \
              -DCMAKE_C_COMPILER=$CC \
              ..

    - name: Compiler
      run: |
        cd build
        make -j$(nproc)

    - name: Lancer les tests
      run: |
        cd build
        ctest --output-on-failure
```

**Cette matrice g√©n√®re** : 2 OS √ó 2 compilateurs √ó 3 versions √ó 2 build types = **24 jobs** (moins les exclusions)

---

## Limites et bonnes pratiques

### Limites de GitHub Actions

- **Maximum 256 jobs** par matrice
- **Temps d'ex√©cution limit√©** : 6h par job (comptes gratuits)
- **Concurrence limit√©e** : 20 jobs simultan√©s (comptes gratuits)

### Bonnes pratiques

1. **Ne pas abuser des matrices** : Plus de jobs = plus de temps d'attente. Commencez petit.

2. **Testez localement d'abord** : Assurez-vous que votre build fonctionne avant d'ajouter une matrice

3. **Utilisez des noms descriptifs** :
   ```yaml
   name: ${{ matrix.os }} - GCC ${{ matrix.gcc }} - ${{ matrix.build-type }}
   ```

4. **Mise en cache des d√©pendances** : Pour acc√©l√©rer les builds (voir section suivante)

5. **Priorisez les configurations importantes** : Testez d'abord les versions de compilateurs les plus utilis√©es

6. **Documentation** : Expliquez dans votre README quelles configurations sont test√©es

---

## Visualisation dans GitHub Actions

Quand vous utilisez une matrice, l'interface GitHub Actions affiche :

```
‚úÖ build (ubuntu-22.04, gcc, 11, Debug)
‚úÖ build (ubuntu-22.04, gcc, 11, Release)
‚úÖ build (ubuntu-22.04, gcc, 12, Debug)
‚ùå build (ubuntu-22.04, gcc, 12, Release)  ‚Üê √âchec ici
‚úÖ build (ubuntu-22.04, clang, 11, Debug)
...
```

Vous pouvez cliquer sur chaque job pour voir ses logs sp√©cifiques.

---

## Cas d'usage avanc√©s

### Tester avec diff√©rents standards C

```yaml
strategy:
  matrix:
    std: ['-std=c99', '-std=c11', '-std=c17', '-std=c2x']

steps:
  - name: Compiler avec ${{ matrix.std }}
    run: gcc ${{ matrix.std }} -o app main.c
```

### Tester avec diff√©rentes architectures

```yaml
strategy:
  matrix:
    arch: [x86_64, aarch64, armv7]
    include:
      - arch: x86_64
        platform: linux/amd64
      - arch: aarch64
        platform: linux/arm64
      - arch: armv7
        platform: linux/arm/v7
```

### Tester avec et sans sanitizers

```yaml
strategy:
  matrix:
    sanitizer: ['none', 'address', 'undefined', 'thread']

steps:
  - name: Compiler
    run: |
      if [ "${{ matrix.sanitizer }}" != "none" ]; then
        gcc -fsanitize=${{ matrix.sanitizer }} -o app main.c
      else
        gcc -o app main.c
      fi
```

---

## Matrice simple vs complexe : Quand utiliser quoi ?

### Matrice simple (recommand√© pour d√©buter)

```yaml
strategy:
  matrix:
    gcc: [11, 12, 13]
```

**Utilisez quand :**
- Vous d√©butez avec GitHub Actions
- Votre projet est petit
- Vous voulez juste tester quelques versions de compilateur

### Matrice complexe

```yaml
strategy:
  matrix:
    os: [ubuntu-22.04, ubuntu-24.04, macos-latest]
    compiler: [gcc, clang]
    version: [11, 12, 13]
    optimization: ['-O0', '-O2', '-O3']
```

**Utilisez quand :**
- Votre projet est mature
- Vous avez besoin de garanties de compatibilit√©
- Vous avez du temps de CI disponible
- Votre projet est open-source avec beaucoup d'utilisateurs

---

## D√©bogage d'une matrice

Si un job sp√©cifique de votre matrice √©choue :

1. **Identifiez la configuration** : Regardez le nom du job qui a √©chou√©
   - Exemple : `build (ubuntu-22.04, gcc, 12, Release)`

2. **Reproduisez localement** : Essayez la m√™me configuration sur votre machine
   ```bash
   gcc-12 -O2 -DNDEBUG -o app main.c
   ```

3. **V√©rifiez les logs** : Cliquez sur le job dans GitHub Actions pour voir les logs d√©taill√©s

4. **Isolez le probl√®me** : Est-ce sp√©cifique √† cette version de GCC ? √Ä ce niveau d'optimisation ?

---

## R√©sum√©

**Structure d'une matrice :**
```yaml
strategy:
  fail-fast: false  # Optionnel
  matrix:
    variable1: [valeur1, valeur2, ...]
    variable2: [valeurA, valeurB, ...]
```

**Utilisation dans les steps :**
```yaml
${{ matrix.variable1 }}
```

**Nombre de jobs g√©n√©r√©s** = Produit cart√©sien de toutes les valeurs

---

## Prochaines √©tapes

Maintenant que vous ma√Ætrisez les matrix builds, vous pouvez :

- Ajouter du **caching** pour acc√©l√©rer vos builds
- Int√©grer des **sanitizers** dans la matrice
- Configurer **Valgrind** pour certaines combinaisons
- Mesurer la **couverture de code** sur diff√©rentes configurations

Ces sujets seront abord√©s dans les sections suivantes.

---

## Ressources compl√©mentaires

- [Documentation officielle des matrices GitHub](https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs)
- [Exemples de matrices pour projets C](https://github.com/actions/starter-workflows/tree/main/ci)

---

**üéØ Points cl√©s √† retenir :**

- ‚úÖ Les matrices g√©n√®rent automatiquement plusieurs jobs en parall√®le
- ‚úÖ Syntaxe : `strategy: matrix: variable: [valeur1, valeur2]`
- ‚úÖ R√©f√©rence avec `${{ matrix.variable }}`
- ‚úÖ Utilisez `fail-fast: false` pour voir tous les √©checs
- ‚úÖ Commencez avec une matrice simple, complexifiez progressivement
- ‚úÖ Nombre de jobs = produit cart√©sien des valeurs
- ‚úÖ Utilisez `include`/`exclude` pour g√©rer les cas particuliers

‚è≠Ô∏è [Build avec CMake en CI](/30-integration-continue/01.3-build-cmake-ci.md)
