üîù Retour au [Sommaire](/SOMMAIRE.md)

# 15.3.3 Scripts GDB

## Introduction

Les **scripts GDB** permettent d'automatiser les t√¢ches de debugging r√©p√©titives et de cr√©er des outils personnalis√©s pour analyser votre code. Au lieu de taper manuellement les m√™mes commandes √† chaque session de debugging, vous pouvez les sauvegarder dans un fichier et les ex√©cuter automatiquement.

### Pourquoi utiliser des scripts GDB ?

Imaginez que chaque fois que vous d√©boguez votre application, vous devez :
- D√©finir 10 breakpoints aux m√™mes endroits
- Afficher l'√©tat de 5 variables sp√©cifiques
- Configurer des options particuli√®res
- Ex√©cuter une s√©rie de commandes pour reproduire le bug

Sans scripts, vous devez retaper tout cela manuellement. Avec des scripts, **une seule commande** suffit !

### Cas d'usage typiques

- ‚úÖ **Automatisation** : Breakpoints et watchpoints r√©currents
- ‚úÖ **Analyse complexe** : Parcourir des structures de donn√©es (listes cha√Æn√©es, arbres)
- ‚úÖ **Production de rapports** : G√©n√©rer des logs d√©taill√©s automatiquement
- ‚úÖ **Tests de r√©gression** : V√©rifier qu'un bug ne r√©appara√Æt pas
- ‚úÖ **Debugging non-interactif** : Ex√©cuter dans un CI/CD

---

## Types de scripts GDB

GDB supporte deux types principaux de scripts :

### 1. Scripts de commandes GDB (simples)

Fichiers texte contenant des commandes GDB natives, ligne par ligne.

**Extension :** `.gdb` ou `.txt`

**Exemple :**
```gdb
# mon_script.gdb
break main
run
print variable
continue
```

### 2. Scripts Python (avanc√©s)

Scripts √©crits en Python qui utilisent l'API Python de GDB pour des fonctionnalit√©s avanc√©es.

**Extension :** `.py`

**Exemple :**
```python
# mon_script.py
import gdb

class HelloCommand(gdb.Command):
    def __init__(self):
        super().__init__("hello", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        print("Hello from GDB Python!")

HelloCommand()
```

---

## Scripts de commandes GDB : Les bases

### Cr√©er votre premier script

Cr√©ons un programme simple √† d√©boguer :

```c
// demo.c
#include <stdio.h>

int calcul(int a, int b) {
    int resultat = a * b;
    return resultat;
}

int main() {
    int x = 10;
    int y = 20;
    int z = calcul(x, y);

    printf("R√©sultat : %d\n", z);

    for (int i = 0; i < 5; i++) {
        printf("i = %d\n", i);
    }

    return 0;
}
```

Compilez-le :

```bash
gcc -g -o demo demo.c
```

### Script basique

Cr√©ez un fichier `debug.gdb` :

```gdb
# debug.gdb - Script de d√©marrage pour demo

# D√©finir des breakpoints
break main
break calcul

# Lancer le programme
run

# Afficher des informations au premier breakpoint
echo \n=== Programme d√©marr√© ===\n
info locals

# Continuer jusqu'au prochain breakpoint
continue

# Dans la fonction calcul
echo \n=== Dans calcul() ===\n
print a
print b
print resultat

# Continuer l'ex√©cution
continue
```

### Ex√©cuter le script

#### M√©thode 1 : Avec l'option `-x`

```bash
gdb -x debug.gdb ./demo
```

GDB charge le script au d√©marrage et ex√©cute toutes les commandes.

#### M√©thode 2 : Depuis GDB

```bash
gdb ./demo
```

Puis dans GDB :

```gdb
(gdb) source debug.gdb
```

#### M√©thode 3 : Automatiquement au d√©marrage

Cr√©ez un fichier `.gdbinit` dans votre r√©pertoire de travail :

```gdb
# .gdbinit
source debug.gdb
```

Maintenant, chaque fois que vous lancez `gdb ./demo` dans ce r√©pertoire, le script est automatiquement charg√©.

---

## Commandes essentielles pour les scripts

### Commentaires

```gdb
# Ceci est un commentaire
```

### Afficher du texte

```gdb
# M√©thode 1 : echo
echo Mon message\n

# M√©thode 2 : printf (plus flexible)
printf "Variable x = %d\n", x
```

### D√©finir des variables GDB

```gdb
# Variables convenience (pr√©fix√©es par $)
set $counter = 0
set $max = 100

# Utiliser la variable
print $counter
```

### Conditions

```gdb
# Syntaxe if/else
if $counter < 10
    print "Petit"
else
    print "Grand"
end
```

### Boucles

```gdb
# Boucle while
set $i = 0
while $i < 5
    print $i
    set $i = $i + 1
end
```

### D√©finir des fonctions personnalis√©es

```gdb
# D√©finir une fonction (commande d√©finie par l'utilisateur)
define affiche_variables
    echo \n=== √âtat des variables ===\n
    print x
    print y
    print z
end

# Utiliser la fonction
affiche_variables
```

### Fonctions avec param√®tres

```gdb
define affiche_n_fois
    set $i = 0
    while $i < $arg0
        print $arg0
        set $i = $i + 1
    end
end

# Appel avec param√®tre
affiche_n_fois 3
```

---

## Exemples pratiques

### Exemple 1 : Script de d√©marrage standard

Un script que vous pouvez utiliser pour tous vos projets :

```gdb
# startup.gdb - Configuration standard

# Ne pas poser de questions de confirmation
set confirm off

# Historique illimit√©
set history save on
set history size unlimited
set history filename ~/.gdb_history

# Affichage am√©lior√©
set print pretty on
set print array on
set print object on

# Breakpoints automatiques sur les erreurs
catch throw
catch signal SIGSEGV

# Message de bienvenue
echo \n=== Session GDB d√©marr√©e ===\n
echo Tapez 'help user-defined' pour voir les commandes custom\n\n
```

### Exemple 2 : Afficher une liste cha√Æn√©e

Programme avec une liste cha√Æn√©e :

```c
// linked_list.c
#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
    int data;
    struct Node* next;
} Node;

Node* create_node(int data) {
    Node* node = malloc(sizeof(Node));
    node->data = data;
    node->next = NULL;
    return node;
}

int main() {
    Node* head = create_node(10);
    head->next = create_node(20);
    head->next->next = create_node(30);
    head->next->next->next = create_node(40);

    printf("Liste cr√©√©e\n");  // Breakpoint ici

    // Lib√©ration m√©moire
    Node* current = head;
    while (current) {
        Node* temp = current;
        current = current->next;
        free(temp);
    }

    return 0;
}
```

Script pour afficher tous les √©l√©ments :

```gdb
# print_list.gdb

define print_list
    set $node = $arg0
    set $count = 0

    echo \n=== Contenu de la liste cha√Æn√©e ===\n

    while $node != 0
        printf "Node %d: data = %d, next = %p\n", $count, $node->data, $node->next
        set $node = $node->next
        set $count = $count + 1
    end

    printf "Total: %d n≈ìuds\n\n", $count
end

# Utilisation
break 22
run
print_list head
```

Ex√©cution :

```bash
gcc -g -o linked_list linked_list.c
gdb -x print_list.gdb ./linked_list
```

### Exemple 3 : Analyse d'un tableau

```gdb
# print_array.gdb

define print_array
    set $arr = $arg0
    set $len = $arg1
    set $i = 0

    echo \n=== Contenu du tableau ===\n

    while $i < $len
        printf "[%d] = %d\n", $i, $arr[$i]
        set $i = $i + 1
    end

    echo \n
end

# Exemple d'utilisation avec un programme
# (gdb) print_array mon_tableau 10
```

### Exemple 4 : Logging automatique

Script qui log toutes les valeurs d'une variable √† chaque passage :

```gdb
# log_variable.gdb

# Ouvrir un fichier de log
set logging file debug.log
set logging overwrite on
set logging on

# Breakpoint avec actions automatiques
break calcul
commands
    silent
    printf "=== Appel √† calcul() ===\n"
    printf "Timestamp: %s\n", (char*)__DATE__
    print a
    print b
    continue
end

run
```

Le mot-cl√© `silent` √©vite d'afficher le message "Breakpoint hit" √† chaque fois.

---

## Scripts Python : Puissance maximale

GDB int√®gre un interpr√©teur Python qui permet d'√©crire des scripts beaucoup plus puissants.

### V√©rifier le support Python

```bash
gdb
(gdb) python print("Python fonctionne!")
```

Si vous voyez "Python fonctionne!", c'est activ√©.

### Premier script Python

```python
# hello.py
import gdb

# Commande simple
gdb.execute("break main")
gdb.execute("run")

# Afficher un message
print("Script Python ex√©cut√© avec succ√®s!")

# Lire une variable
var_x = gdb.parse_and_eval("x")
print(f"Valeur de x: {var_x}")
```

Utilisation :

```bash
gdb ./demo
(gdb) source hello.py
```

### Cr√©er une commande personnalis√©e en Python

```python
# custom_command.py
import gdb

class PrintStructCommand(gdb.Command):
    """Affiche tous les champs d'une structure de mani√®re format√©e"""

    def __init__(self):
        super().__init__("print-struct", gdb.COMMAND_DATA)

    def invoke(self, arg, from_tty):
        try:
            # √âvaluer l'argument (nom de la variable)
            var = gdb.parse_and_eval(arg)

            print(f"\n=== Structure: {arg} ===")

            # Parcourir tous les champs
            for field in var.type.fields():
                field_name = field.name
                field_value = var[field_name]
                print(f"  {field_name}: {field_value}")

            print()

        except Exception as e:
            print(f"Erreur: {e}")

# Enregistrer la commande
PrintStructCommand()
```

Utilisation :

```gdb
(gdb) source custom_command.py
(gdb) print-struct ma_structure
```

### Cr√©er un Pretty Printer pour structures complexes

Les pretty printers permettent d'afficher vos structures personnalis√©es de mani√®re lisible.

```python
# pretty_printer.py
import gdb

class NodePrinter:
    """Pretty printer pour la structure Node"""

    def __init__(self, val):
        self.val = val

    def to_string(self):
        data = self.val['data']
        next_ptr = self.val['next']

        if int(next_ptr) == 0:
            return f"Node(data={data}, next=NULL)"
        else:
            return f"Node(data={data}, next={next_ptr})"

def lookup_type(val):
    """Fonction de lookup pour le pretty printer"""
    if str(val.type) == 'Node' or str(val.type) == 'struct Node':
        return NodePrinter(val)
    return None

# Enregistrer le pretty printer
gdb.pretty_printers.append(lookup_type)

print("Pretty printer pour Node enregistr√©")
```

Apr√®s avoir charg√© ce script, `print head` affichera automatiquement `Node(data=10, next=0x...)` au lieu d'un bloc de m√©moire brute.

### Exemple avanc√© : Tracer tous les appels √† malloc

```python
# trace_malloc.py
import gdb

class MallocBreakpoint(gdb.Breakpoint):
    """Breakpoint qui trace tous les appels √† malloc"""

    def __init__(self):
        super().__init__("malloc")
        self.count = 0

    def stop(self):
        # R√©cup√©rer l'argument (taille demand√©e)
        frame = gdb.selected_frame()

        # Sur x86_64, le premier argument est dans rdi
        try:
            size = frame.read_register("rdi")
            self.count += 1
            print(f"[{self.count}] malloc({size} bytes)")
        except:
            print(f"[{self.count}] malloc() appel√©")

        # Ne pas s'arr√™ter, continuer l'ex√©cution
        return False

# Cr√©er le breakpoint
MallocBreakpoint()
print("Tracer malloc activ√©")
```

---

## Automatisation compl√®te du debugging

### Script pour debugging non-interactif

Utile dans un CI/CD pour v√©rifier automatiquement qu'un bug est corrig√© :

```gdb
# ci_debug.gdb

# Configuration
set pagination off
set confirm off
set logging file ci_debug.log
set logging overwrite on
set logging on

# Breakpoint sur la fonction √† tester
break fonction_a_tester
commands
    silent
    # V√©rifier l'√©tat attendu
    if variable_x == 42
        printf "‚úì TEST PASSED: variable_x = 42\n"
    else
        printf "‚úó TEST FAILED: variable_x = %d (attendu: 42)\n", variable_x
        quit 1
    end
    continue
end

# Lancer le programme
run

# Si on arrive ici, tout s'est bien pass√©
quit 0
```

Ex√©cution dans un script bash :

```bash
#!/bin/bash
gdb -batch -x ci_debug.gdb ./mon_programme

if [ $? -eq 0 ]; then
    echo "Tests de debug: SUCC√àS"
else
    echo "Tests de debug: √âCHEC"
    exit 1
fi
```

### Script de g√©n√©ration de rapport

```gdb
# report.gdb

set logging file debug_report.txt
set logging overwrite on
set logging redirect on
set logging on

echo ========================================\n
echo RAPPORT DE DEBUG\n
echo ========================================\n
echo \n

# Informations sur le programme
echo [PROGRAMME]\n
info files
echo \n

# Breakpoints d√©finis
echo [BREAKPOINTS]\n
info breakpoints
echo \n

# Variables globales
echo [VARIABLES GLOBALES]\n
info variables
echo \n

# Ex√©cution
echo [EX√âCUTION]\n
run

# Backtrace au premier crash
echo [BACKTRACE]\n
backtrace full
echo \n

echo [VARIABLES LOCALES]\n
info locals
echo \n

echo [REGISTRES]\n
info registers
echo \n

echo ========================================\n
echo FIN DU RAPPORT\n
echo ========================================\n

quit
```

---

## Fichiers de configuration GDB

### Le fichier `.gdbinit` global

GDB charge automatiquement `~/.gdbinit` au d√©marrage (si autoris√©).

**Exemple de configuration :**

```gdb
# ~/.gdbinit

# Historique persistant
set history save on
set history size 10000
set history filename ~/.gdb_history

# Affichage am√©lior√©
set print pretty on
set print array on
set print array-indexes on
set print elements 200

# Couleurs dans GDB (avec GDB >= 8.3)
set style enabled on

# D√©sactiver la pagination
set pagination off

# Charger automatiquement les symboles
set auto-load safe-path /

# Commandes personnalis√©es globales
define hook-quit
    set confirm off
end

# Message de d√©marrage
echo \n=== Configuration GDB charg√©e ===\n
echo Tapez 'help' pour l'aide\n\n
```

### Le fichier `.gdbinit` local

Cr√©ez un `.gdbinit` dans le r√©pertoire de votre projet pour des configurations sp√©cifiques :

```gdb
# .gdbinit (dans le dossier du projet)

# Charger les scripts du projet
source scripts/pretty_printers.py
source scripts/custom_commands.gdb

# Breakpoints courants pour ce projet
break main
break error_handler

# D√©finir des chemins de source si n√©cessaire
directory /chemin/vers/sources/externes

echo \n=== Configuration projet charg√©e ===\n
```

**Note de s√©curit√© :** Par d√©faut, GDB refuse de charger les `.gdbinit` locaux pour des raisons de s√©curit√©. Autorisez-le :

```bash
echo "add-auto-load-safe-path /chemin/vers/projet/.gdbinit" >> ~/.gdbinit
```

Ou de mani√®re globale (moins s√©curis√©) :

```bash
echo "set auto-load safe-path /" >> ~/.gdbinit
```

---

## Cas d'usage avanc√©s

### 1. Debugging de race conditions

Script qui v√©rifie l'ordre d'ex√©cution des threads :

```gdb
# race_condition.gdb

# Tracer l'acc√®s √† une variable partag√©e
break variable_partagee if $thread == 1
commands
    silent
    printf "[Thread 1] Acc√®s √† variable_partagee = %d\n", variable_partagee
    continue
end

break variable_partagee if $thread == 2
commands
    silent
    printf "[Thread 2] Acc√®s √† variable_partagee = %d\n", variable_partagee
    continue
end

run
```

### 2. Watchpoint conditionnel automatique

```gdb
# watchpoint.gdb

# Surveiller une variable et s'arr√™ter seulement si elle d√©passe un seuil
watch variable_critique
commands
    silent
    if variable_critique > 1000
        printf "‚ö†Ô∏è  ALERTE: variable_critique = %d (seuil d√©pass√©!)\n", variable_critique
        backtrace
    else
        continue
    end
end
```

### 3. Collecte de statistiques

Script Python pour compter le nombre d'appels √† chaque fonction :

```python
# function_stats.py
import gdb
from collections import defaultdict

class FunctionStats:
    def __init__(self):
        self.call_counts = defaultdict(int)

    def record_call(self, func_name):
        self.call_counts[func_name] += 1

    def print_stats(self):
        print("\n=== Statistiques d'appels ===")
        for func, count in sorted(self.call_counts.items(),
                                   key=lambda x: x[1],
                                   reverse=True):
            print(f"{func}: {count} appels")

stats = FunctionStats()

# Cr√©er des breakpoints sur les fonctions √† surveiller
functions = ["fonction_a", "fonction_b", "fonction_c"]

class StatsBreakpoint(gdb.Breakpoint):
    def __init__(self, func_name):
        super().__init__(func_name)
        self.func_name = func_name

    def stop(self):
        stats.record_call(self.func_name)
        return False  # Ne pas s'arr√™ter

# Cr√©er les breakpoints
for func in functions:
    try:
        StatsBreakpoint(func)
        print(f"Tra√ßage de {func} activ√©")
    except:
        print(f"Impossible de tracer {func}")

# Commande pour afficher les stats
class PrintStatsCommand(gdb.Command):
    def __init__(self):
        super().__init__("print-stats", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        stats.print_stats()

PrintStatsCommand()
```

---

## Debugging avec GDB Dashboard

**GDB Dashboard** est un script Python tiers qui transforme GDB en un outil moderne avec interface TUI am√©lior√©e.

### Installation

```bash
wget -P ~ https://github.com/cyrus-and/gdb-dashboard/raw/master/.gdbinit
```

Ou ajoutez dans votre `~/.gdbinit` :

```gdb
source /chemin/vers/gdb-dashboard/.gdbinit
```

### Fonctionnalit√©s

- Affichage en temps r√©el du code source
- Visualisation de la pile, registres, variables
- Fen√™tre de commandes interactive

---

## Bonnes pratiques

### 1. Documenter vos scripts

```gdb
# mon_script.gdb
# Description: Script pour d√©boguer les probl√®mes de liste cha√Æn√©e
# Auteur: Votre Nom
# Date: 2025-01-15
# Usage: gdb -x mon_script.gdb ./programme

# Fonction: print_list
#   Affiche tous les √©l√©ments d'une liste cha√Æn√©e
#   Param√®tre: $arg0 = pointeur vers le premier n≈ìud
```

### 2. Utiliser des fonctions r√©utilisables

Cr√©ez une biblioth√®que de fonctions GDB :

```gdb
# lib_gdb.gdb

define safe_print
    if $arg0 != 0
        print *$arg0
    else
        echo Pointeur NULL\n
    end
end
```

### 3. Gestion d'erreurs

```gdb
define fonction_safe
    # Sauvegarder l'√©tat
    set $old_pagination = $pagination

    # Faire le travail
    # ...

    # Restaurer l'√©tat
    set pagination $old_pagination
end
```

### 4. Versioning de vos scripts

Mettez vos scripts dans Git avec votre projet :

```
mon_projet/
‚îú‚îÄ‚îÄ src/
‚îú‚îÄ‚îÄ gdb_scripts/
‚îÇ   ‚îú‚îÄ‚îÄ startup.gdb
‚îÇ   ‚îú‚îÄ‚îÄ pretty_printers.py
‚îÇ   ‚îî‚îÄ‚îÄ debug_helpers.gdb
‚îî‚îÄ‚îÄ .gdbinit  # Charge les scripts
```

---

## Troubleshooting

### Probl√®me 1 : Script non charg√©

**Erreur :**
```
warning: File ".gdbinit" auto-loading has been declined
```

**Solution :**

```bash
echo "add-auto-load-safe-path /chemin/vers/.gdbinit" >> ~/.gdbinit
```

### Probl√®me 2 : Commande Python non reconnue

**Erreur :**
```
Undefined command: "source". Try "help".
```

**Cause :** GDB compil√© sans support Python.

**Solution :**
```bash
# V√©rifier le support Python
gdb --configuration

# R√©installer GDB avec Python (Ubuntu)
sudo apt-get install gdb python3-gdb
```

### Probl√®me 3 : Variables pas accessibles

Si vos variables ne sont pas visibles dans le script :

```gdb
# S'assurer d'√™tre dans la bonne frame
frame 0

# Ou utiliser le nom qualifi√©
print fichier.c::variable
```

---

## Ressources et outils compl√©mentaires

### Scripts GDB populaires

1. **GDB Dashboard** : Interface moderne
   - https://github.com/cyrus-and/gdb-dashboard

2. **GEF (GDB Enhanced Features)** : Pour l'exploitation et la s√©curit√©
   - https://github.com/hugsy/gef

3. **PEDA** : Python Exploit Development Assistance
   - https://github.com/longld/peda

4. **voltron** : UI extensible pour GDB
   - https://github.com/snare/voltron

### Documentation officielle

- GDB Python API : https://sourceware.org/gdb/current/onlinedocs/gdb/Python-API.html
- GDB Commands : https://sourceware.org/gdb/current/onlinedocs/gdb/Commands.html

---

## R√©sum√© des commandes essentielles

### Ex√©cution de scripts

```bash
# Charger un script au d√©marrage
gdb -x script.gdb ./programme

# Charger depuis GDB
(gdb) source script.gdb

# Script Python
(gdb) source script.py

# Ex√©cution non-interactive
gdb -batch -x script.gdb ./programme
```

### Commandes de script

```gdb
# D√©finir une fonction
define ma_fonction
    # commandes
end

# Variable GDB
set $var = valeur

# Condition
if condition
    # commandes
end

# Boucle
while condition
    # commandes
end

# Affichage
echo Message\n
printf "Format: %d\n", variable
```

### Python dans GDB

```python
# Ex√©cuter une commande GDB
gdb.execute("break main")

# √âvaluer une expression
val = gdb.parse_and_eval("variable")

# Cr√©er une commande
class MyCommand(gdb.Command):
    def __init__(self):
        super().__init__("mycommand", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        print("Ma commande")

MyCommand()
```

---

## Conclusion

Les scripts GDB transforment le debugging d'une t√¢che manuelle r√©p√©titive en un processus **automatis√© et reproductible**. Ils sont essentiels pour :

- ‚úÖ **Gagner du temps** : Automatiser les configurations r√©currentes
- ‚úÖ **Am√©liorer la qualit√©** : Tests de r√©gression automatiques
- ‚úÖ **Analyser des structures complexes** : Listes, arbres, graphes
- ‚úÖ **Debugging en production** : Scripts non-interactifs dans le CI/CD
- ‚úÖ **Cr√©er des outils sur mesure** : Adapt√©s √† votre projet

**Points cl√©s √† retenir :**

1. **Scripts de commandes** pour l'automatisation simple
2. **Scripts Python** pour des fonctionnalit√©s avanc√©es
3. **`.gdbinit`** pour les configurations persistantes
4. **Commandes custom** avec `define` ou Python
5. **Logging** pour g√©n√©rer des rapports automatiques
6. **Versionner vos scripts** avec votre code

Avec la ma√Ætrise des scripts GDB, vous pouvez cr√©er votre propre bo√Æte √† outils de debugging adapt√©e √† vos besoins sp√©cifiques ! üîßüêõ

‚è≠Ô∏è [rr (Time Travel Debugging)](/15-debogage-et-qualite/03.4-time-travel-debugging.md)
