üîù Retour au [Sommaire](/SOMMAIRE.md)

# 13.1.2 Installation et premiers pas

## Installation de CMake sur Ubuntu

### M√©thode 1 : Installation via APT (recommand√©e pour d√©buter)

La mani√®re la plus simple d'installer CMake est d'utiliser le gestionnaire de paquets Ubuntu :

```bash
sudo apt update  
sudo apt install cmake  
```

Cette commande installe CMake ainsi que ses d√©pendances n√©cessaires.

**V√©rifier la version install√©e :**
```bash
cmake --version
```

Vous devriez voir quelque chose comme :
```
cmake version 3.22.1  
CMake suite maintained and supported by Kitware (kitware.com/cmake)  
```

> ‚ö†Ô∏è **Note** : La version fournie par Ubuntu peut √™tre l√©g√®rement ancienne. Ubuntu 22.04 LTS fournit CMake 3.22, ce qui est largement suffisant pour d√©buter.

### M√©thode 2 : Installation de la derni√®re version (optionnel)

Si vous souhaitez la toute derni√®re version de CMake (3.28+ en 2025), vous pouvez utiliser le PPA officiel Kitware :

```bash
# Ajouter le d√©p√¥t officiel Kitware
wget -O - https://apt.kitware.com/keys/kitware-archive-latest.asc 2>/dev/null | gpg --dearmor - | sudo tee /usr/share/keyrings/kitware-archive-keyring.gpg >/dev/null

echo 'deb [signed-by=/usr/share/keyrings/kitware-archive-keyring.gpg] https://apt.kitware.com/ubuntu/ jammy main' | sudo tee /etc/apt/sources.list.d/kitware.list >/dev/null

# Installer CMake
sudo apt update  
sudo apt install cmake  
```

> üí° **Conseil d√©butant** : Utilisez la m√©thode 1 (APT standard) pour commencer. Vous pourrez toujours mettre √† jour plus tard si vous avez besoin de fonctionnalit√©s r√©centes.

### M√©thode 3 : Installation manuelle depuis les binaires (avanc√©)

Pour les utilisateurs avanc√©s ou si vous n'avez pas les droits sudo :

```bash
# T√©l√©charger la derni√®re version depuis cmake.org
wget https://github.com/Kitware/CMake/releases/download/v3.28.0/cmake-3.28.0-linux-x86_64.tar.gz

# Extraire
tar -xzvf cmake-3.28.0-linux-x86_64.tar.gz

# Ajouter au PATH (dans ~/.bashrc)
export PATH=$HOME/cmake-3.28.0-linux-x86_64/bin:$PATH
```

### V√©rification de l'installation

Une fois CMake install√©, v√©rifiez qu'il fonctionne correctement :

```bash
# Version
cmake --version

# Aide
cmake --help

# Liste des g√©n√©rateurs disponibles
cmake --help | grep "Generators" -A 20
```

Vous devriez voir des g√©n√©rateurs comme :
- Unix Makefiles (par d√©faut sur Linux)
- Ninja
- CodeBlocks
- Etc.

## Votre premier projet CMake : Hello World

### Structure du projet

Cr√©ons un projet minimal pour comprendre le workflow CMake. Voici la structure :

```
hello_cmake/
‚îú‚îÄ‚îÄ CMakeLists.txt
‚îî‚îÄ‚îÄ main.c
```

### √âtape 1 : Cr√©er le r√©pertoire du projet

```bash
mkdir hello_cmake  
cd hello_cmake  
```

### √âtape 2 : Cr√©er le fichier source (main.c)

```bash
nano main.c
```

Contenu de `main.c` :
```c
#include <stdio.h>

int main(void) {
    printf("Hello, CMake!\n");
    printf("Mon premier projet avec CMake sur Ubuntu.\n");
    return 0;
}
```

Sauvegardez et quittez (Ctrl+O, Entr√©e, Ctrl+X dans nano).

### √âtape 3 : Cr√©er le fichier CMakeLists.txt

C'est le c≈ìur de la configuration CMake. Cr√©ez le fichier :

```bash
nano CMakeLists.txt
```

Contenu du `CMakeLists.txt` :
```cmake
# Version minimale de CMake requise
cmake_minimum_required(VERSION 3.15)

# Nom du projet et langage utilis√©
project(HelloCMake C)

# Cr√©er un ex√©cutable nomm√© "hello" √† partir de main.c
add_executable(hello main.c)
```

Sauvegardez et quittez.

### Explications ligne par ligne

```cmake
cmake_minimum_required(VERSION 3.15)
```
- Sp√©cifie la version minimale de CMake n√©cessaire
- Si l'utilisateur a une version plus ancienne, CMake affichera une erreur claire
- 3.15 est un bon compromis (2019) entre compatibilit√© et fonctionnalit√©s modernes

```cmake
project(HelloCMake C)
```
- D√©clare le nom du projet : `HelloCMake`
- Le `C` indique que c'est un projet C (pas C++, Fortran, etc.)
- CMake va automatiquement d√©tecter le compilateur C disponible (gcc, clang...)

```cmake
add_executable(hello main.c)
```
- Cr√©e un **target** (cible) nomm√© `hello`
- Ce target est un ex√©cutable
- Il sera compil√© √† partir du fichier source `main.c`
- Le fichier binaire g√©n√©r√© s'appellera `hello` (ou `hello.exe` sur Windows)

> üéØ **Concept cl√©** : Un **target** est une unit√© de build dans CMake (un ex√©cutable, une biblioth√®que, etc.).

## Compiler le projet avec CMake

CMake fonctionne en **deux √©tapes** :

### √âtape 1 : Configuration (G√©n√©ration du build system)

```bash
cmake -B build
```

**D√©composition de la commande :**
- `cmake` : Lance CMake
- `-B build` : Cr√©e un r√©pertoire `build/` et g√©n√®re les fichiers de build dedans

**Ce qui se passe :**
1. CMake lit le `CMakeLists.txt`
2. D√©tecte le compilateur C (gcc sur Ubuntu)
3. G√©n√®re un Makefile dans le r√©pertoire `build/`
4. Configure le projet selon les param√®tres par d√©faut

**Sortie attendue :**
```
-- The C compiler identification is GNU 11.4.0
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Check for working C compiler: /usr/bin/cc - skipped
-- Detecting C compile features
-- Detecting C compile features - done
-- Configuring done
-- Generating done
-- Build files have been written to: /home/user/hello_cmake/build
```

‚úÖ Si vous voyez "Configuring done" et "Generating done", tout est OK !

### √âtape 2 : Compilation (Build)

```bash
cmake --build build
```

**D√©composition :**
- `cmake --build` : Lance la compilation
- `build` : Utilise les fichiers g√©n√©r√©s dans le r√©pertoire `build/`

**Ce qui se passe :**
1. CMake invoque le Makefile g√©n√©r√© (ou Ninja, selon le g√©n√©rateur)
2. gcc compile `main.c` en `main.o`
3. gcc lie `main.o` pour cr√©er l'ex√©cutable `hello`

**Sortie attendue :**
```
[ 50%] Building C object CMakeFiles/hello.dir/main.c.o
[100%] Linking C executable hello
[100%] Built target hello
```

### √âtape 3 : Ex√©cution

L'ex√©cutable est maintenant dans `build/` :

```bash
./build/hello
```

**Sortie :**
```
Hello, CMake!  
Mon premier projet avec CMake sur Ubuntu.  
```

üéâ **F√©licitations !** Vous venez de compiler votre premier projet avec CMake.

## Comprendre l'arborescence g√©n√©r√©e

Apr√®s la compilation, votre projet ressemble √† ceci :

```
hello_cmake/
‚îú‚îÄ‚îÄ build/                      # R√©pertoire de build (g√©n√©r√© par CMake)
‚îÇ   ‚îú‚îÄ‚îÄ CMakeCache.txt         # Cache de configuration
‚îÇ   ‚îú‚îÄ‚îÄ CMakeFiles/            # Fichiers internes de CMake
‚îÇ   ‚îú‚îÄ‚îÄ Makefile               # Makefile g√©n√©r√©
‚îÇ   ‚îú‚îÄ‚îÄ cmake_install.cmake    # Script d'installation
‚îÇ   ‚îî‚îÄ‚îÄ hello                  # üéØ Votre ex√©cutable !
‚îú‚îÄ‚îÄ CMakeLists.txt             # Configuration CMake
‚îî‚îÄ‚îÄ main.c                     # Code source
```

### Fichiers importants

| Fichier/Dossier | Description |
|-----------------|-------------|
| `build/` | **Out-of-source build** : Tous les fichiers g√©n√©r√©s sont ici, votre source reste propre |
| `CMakeCache.txt` | Cache des variables de configuration (compilateur d√©tect√©, options, etc.) |
| `Makefile` | G√©n√©r√© par CMake, utilis√© pour la compilation (vous ne le modifiez jamais) |
| `hello` | Votre ex√©cutable compil√© |

> üí° **Bonne pratique** : Le r√©pertoire `build/` est jetable. Si quelque chose ne va pas, supprimez-le (`rm -rf build`) et relancez `cmake -B build`.

## Workflow CMake en r√©sum√©

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  1. √âcrire le code source (main.c, utils.c, ...)                ‚îÇ
‚îÇ  2. √âcrire le CMakeLists.txt (configuration)                    ‚îÇ
‚îÇ  3. cmake -B build           (g√©n√©ration du build system)       ‚îÇ
‚îÇ  4. cmake --build build      (compilation)                      ‚îÇ
‚îÇ  5. ./build/mon_executable   (ex√©cution)                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Modification du code ?**
‚Üí Relancez seulement `cmake --build build` (√©tape 4)

**Modification du CMakeLists.txt ?**
‚Üí CMake d√©tecte le changement automatiquement lors du build, pas besoin de relancer la config

**Projet cass√© / comportement bizarre ?**
‚Üí `rm -rf build && cmake -B build` (repartir de z√©ro)

## Options de configuration courantes

### Choisir le type de build (Debug vs Release)

Par d√©faut, CMake compile sans optimisations. Vous pouvez sp√©cifier le type de build :

```bash
# Build en mode Debug (symboles de debug, pas d'optimisation)
cmake -B build -DCMAKE_BUILD_TYPE=Debug

# Build en mode Release (optimisations activ√©es, pas de symboles)
cmake -B build -DCMAKE_BUILD_TYPE=Release
```

**Diff√©rences :**
| Mode | Optimisation | Symboles debug | Taille binaire | Vitesse |
|------|--------------|----------------|----------------|---------|
| **Debug** | `-O0` | Oui (`-g`) | Grande | Lente |
| **Release** | `-O3` | Non | Petite | Rapide |

> üîß **Pendant le d√©veloppement** : Utilisez Debug
> üöÄ **Pour la production** : Utilisez Release

### Choisir le compilateur

CMake d√©tecte automatiquement le compilateur, mais vous pouvez le forcer :

```bash
# Utiliser clang au lieu de gcc
cmake -B build -DCMAKE_C_COMPILER=clang

# Sp√©cifier un chemin personnalis√©
cmake -B build -DCMAKE_C_COMPILER=/usr/bin/gcc-12
```

### Mode verbeux (voir les commandes exactes)

Pour voir les commandes gcc r√©ellement ex√©cut√©es :

```bash
cmake --build build --verbose
```

Ou avec Make :
```bash
make -C build VERBOSE=1
```

**Sortie :**
```
[ 50%] Building C object CMakeFiles/hello.dir/main.c.o
/usr/bin/cc -o CMakeFiles/hello.dir/main.c.o -c /home/user/hello_cmake/main.c
[100%] Linking C executable hello
/usr/bin/cc CMakeFiles/hello.dir/main.c.o -o hello
```

Utile pour comprendre ce que CMake fait r√©ellement !

## Nettoyer le projet

### Supprimer les fichiers compil√©s

```bash
# Nettoyer les fichiers objets et l'ex√©cutable (garde la config)
cmake --build build --target clean
```

### Recommencer de z√©ro

```bash
# Supprimer tout le r√©pertoire de build
rm -rf build

# Reconfigurer et recompiler
cmake -B build  
cmake --build build  
```

## Bonnes pratiques d√®s le d√©but

### 1. **Toujours utiliser des builds out-of-source**
‚ùå **Mauvais** :
```bash
cmake .    # G√©n√®re les fichiers dans le r√©pertoire source
```

‚úÖ **Bon** :
```bash
cmake -B build    # G√©n√®re dans build/, source reste propre
```

### 2. **Ajouter build/ au .gitignore**
```bash
echo "build/" >> .gitignore  
echo "build-*/" >> .gitignore  # Pour build-debug, build-release, etc.  
```

### 3. **S√©parer les builds Debug et Release**
```bash
cmake -B build-debug -DCMAKE_BUILD_TYPE=Debug  
cmake -B build-release -DCMAKE_BUILD_TYPE=Release  
```

Vous pouvez ainsi passer rapidement de l'un √† l'autre :
```bash
./build-debug/hello     # Version debug
./build-release/hello   # Version optimis√©e
```

### 4. **Utiliser des noms de targets explicites**
```cmake
# Au lieu de "app" ou "prog"
add_executable(my_parser src/main.c)
```

### 5. **Documenter votre CMakeLists.txt**
```cmake
# Configuration minimale requise
cmake_minimum_required(VERSION 3.15)

# Projet : Parser de logs
project(LogParser C)

# Ex√©cutable principal
add_executable(logparser
    src/main.c
    src/parser.c
)
```

## Erreurs courantes et solutions

### Erreur : "CMake version X.Y is too old"
**Cause** : Votre version de CMake est plus ancienne que celle demand√©e dans `cmake_minimum_required`.

**Solution** :
- Soit mettre √† jour CMake (m√©thode 2 vue plus haut)
- Soit r√©duire la version minimale dans CMakeLists.txt (si les fonctionnalit√©s utilis√©es le permettent)

### Erreur : "No CMAKE_C_COMPILER could be found"
**Cause** : gcc (ou le compilateur C) n'est pas install√©.

**Solution** :
```bash
sudo apt install build-essential
```

### Erreur : "CMakeLists.txt not found"
**Cause** : Vous n'√™tes pas dans le bon r√©pertoire ou le fichier est mal nomm√©.

**Solution** :
- V√©rifiez que `CMakeLists.txt` est bien dans le r√©pertoire courant
- Attention √† la casse : `CmakeLists.txt` ne fonctionnera pas !

### Warning : "Manually-specified variables were not used by the project"
**Cause** : Vous avez sp√©cifi√© une option que CMake n'utilise pas (typo, option obsol√®te...).

**Solution** : V√©rifiez l'orthographe de vos options `-D`.

## Prochaines √©tapes

Maintenant que vous savez :
- ‚úÖ Installer CMake
- ‚úÖ Cr√©er un projet simple
- ‚úÖ Compiler avec CMake
- ‚úÖ Comprendre le workflow de base

Vous √™tes pr√™t pour la suite :
- **13.1.3** : Structure avanc√©e d'un CMakeLists.txt
- **13.1.4** : Targets, properties et generators
- **13.1.5** : Gestion des d√©pendances
- **13.1.6** : Build types et configurations

## Ressources suppl√©mentaires

### Aide int√©gr√©e de CMake
```bash
cmake --help                    # Aide g√©n√©rale  
cmake --help-command add_executable  # Aide sur une commande  
cmake --help-variable CMAKE_BUILD_TYPE  # Aide sur une variable  
```

### Documentation officielle
- Site officiel : https://cmake.org/
- Tutoriel officiel : https://cmake.org/cmake/help/latest/guide/tutorial/
- R√©f√©rence des commandes : https://cmake.org/cmake/help/latest/manual/cmake-commands.7.html

### V√©rification de votre installation

Pour v√©rifier que tout fonctionne, cr√©ez ce script de test :

```bash
#!/bin/bash
echo "=== Test de l'environnement CMake ==="  
echo ""  
echo "Version de CMake :"  
cmake --version  
echo ""  
echo "Compilateur C d√©tect√© :"  
gcc --version | head -n1  
echo ""  
echo "‚úÖ Si vous voyez des versions, tout est OK !"  
```

Sauvegardez-le dans `test_cmake.sh`, rendez-le ex√©cutable (`chmod +x test_cmake.sh`) et lancez-le (`./test_cmake.sh`).

---


‚è≠Ô∏è [Structure d'un CMakeLists.txt](/13-build-systems/01.3-structure-cmakelists.md)
